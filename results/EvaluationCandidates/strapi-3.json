{
  "promises": {
    "0": {
      "source": "node_modules/jest-runner/build/runTest.js:372:23:372:23",
      "startTime": "928730079120644",
      "endTime": "928730079404215",
      "elapsedTime": "283571",
      "asyncId": 12,
      "triggerAsyncId": 4,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " runTestInternal",
      "userCode": false,
      "line": "\n\n  try {\n    await environment.setup();\n    let result;\n\n    try ",
      "startLine": 372,
      "startCol": 23,
      "endLine": 372,
      "endCol": 23,
      "file": "node_modules/jest-runner/build/runTest.js",
      "triggers": [
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13
      ],
      "uniqueid": 0
    },
    "1": {
      "source": "node_modules/jest-runner/build/runTest.js:472:40:472:40",
      "startTime": "928730078429428",
      "endTime": "928731854238199",
      "elapsedTime": "1775808771",
      "asyncId": 13,
      "triggerAsyncId": 12,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        28,
        28,
        31,
        28,
        33,
        28,
        28,
        29,
        30,
        31,
        34,
        36,
        29,
        28,
        31,
        33,
        30,
        26,
        30,
        29,
        25,
        28,
        31,
        28,
        29,
        28,
        28,
        30,
        26,
        30,
        29,
        25,
        28,
        26,
        33,
        32,
        25,
        29,
        32,
        34,
        29,
        28,
        31,
        28,
        29,
        30,
        31,
        29,
        30,
        32,
        35,
        37,
        26,
        31,
        30,
        25,
        29,
        30,
        33,
        35,
        26,
        34,
        33,
        25,
        26,
        32,
        31,
        25,
        32,
        29,
        30,
        32,
        32,
        30,
        30,
        32,
        31,
        34,
        34,
        34,
        32,
        32,
        33,
        34,
        33,
        34,
        35,
        36,
        37,
        32,
        40,
        42,
        35,
        33,
        33,
        35,
        36,
        37,
        34,
        40,
        34,
        42,
        35,
        35,
        36,
        37,
        35,
        36,
        37,
        36,
        37,
        38,
        38,
        39,
        40,
        39,
        40,
        42,
        42,
        44,
        35,
        36,
        37,
        40,
        43,
        42,
        45,
        26,
        39,
        38,
        25,
        26,
        39,
        38,
        25,
        26,
        41,
        40,
        25,
        43,
        44,
        47,
        49,
        26,
        46,
        45,
        25,
        26,
        39,
        38,
        25,
        26,
        39,
        38,
        25,
        26,
        42,
        41,
        25
      ],
      "line": "\n  sendMessageToJest\n) {\n  const {leakDetector, result} = await runTestInternal(\n    path,\n    globalConfig,\n    config",
      "startLine": 472,
      "startCol": 40,
      "endLine": 472,
      "endCol": 40,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 1
    },
    "2": {
      "source": "node_modules/jest-runner/build/runTest.js:380:22:380:22",
      "startTime": "928730083533386",
      "endTime": "928733025807021",
      "elapsedTime": "2942273635",
      "asyncId": 25,
      "triggerAsyncId": 13,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        38,
        41,
        38,
        38,
        40,
        38,
        40,
        41,
        43,
        39,
        42,
        39,
        41,
        40,
        42,
        44,
        40,
        42,
        47,
        47,
        47,
        49,
        47,
        50,
        47,
        49,
        47,
        49,
        49,
        51,
        54,
        54,
        56,
        47,
        49,
        47,
        49,
        50,
        52
      ],
      "line": "\n      }\n\n      result = await testFramework(\n        globalConfig,\n        config,\n        environment",
      "startLine": 380,
      "startCol": 22,
      "endLine": 380,
      "endCol": 22,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 2
    },
    "3": {
      "source": "node_modules/jest-jasmine2/build/treeProcessor.js:78:10:78:10",
      "startTime": "928731630901485",
      "endTime": "928732270613899",
      "elapsedTime": "639712414",
      "asyncId": 39,
      "triggerAsyncId": 13,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " treeProcessor",
      "userCode": false,
      "triggers": [
        65,
        40,
        40,
        44,
        44,
        44,
        44,
        44,
        46,
        44,
        46,
        44,
        46,
        44,
        46
      ],
      "line": "\n\n  const treeHandler = getNodeHandler(tree, false);\n  return treeHandler();\n}",
      "startLine": 78,
      "startCol": 10,
      "endLine": 78,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/treeProcessor.js",
      "uniqueid": 3
    },
    "4": {
      "source": "node_modules/jest-jasmine2/build/treeProcessor.js:78:10:78:10",
      "startTime": "928731634135057",
      "endTime": "928733025069268",
      "elapsedTime": "1390934211",
      "asyncId": 42,
      "triggerAsyncId": 13,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " treeProcessor",
      "userCode": false,
      "triggers": [
        43,
        65,
        43,
        292,
        294,
        291,
        289,
        43,
        43,
        47,
        43,
        43,
        43,
        43,
        43,
        43,
        47,
        49
      ],
      "line": "\n\n  const treeHandler = getNodeHandler(tree, false);\n  return treeHandler();\n}",
      "startLine": 78,
      "startCol": 10,
      "endLine": 78,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/treeProcessor.js",
      "uniqueid": 4
    },
    "5": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731634549564",
      "endTime": "928732270044442",
      "elapsedTime": "635494878",
      "asyncId": 43,
      "triggerAsyncId": 42,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        246,
        248,
        245,
        243,
        44,
        56,
        58,
        65,
        56,
        58,
        65,
        56,
        58,
        65,
        56,
        58,
        65,
        54,
        55,
        63,
        83,
        67,
        54,
        55,
        63,
        87,
        67,
        54,
        55,
        63,
        90,
        67,
        54,
        55,
        63,
        117,
        67
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 5
    },
    "6": {
      "source": "node_modules/jest-jasmine2/build/treeProcessor.js:78:10:78:10",
      "startTime": "928731634899199",
      "endTime": "928732270126816",
      "elapsedTime": "635227617",
      "asyncId": 44,
      "triggerAsyncId": 39,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " treeProcessor",
      "userCode": false,
      "triggers": [
        45,
        216,
        218,
        215,
        213,
        45,
        45,
        45,
        45,
        45,
        45
      ],
      "line": "\n\n  const treeHandler = getNodeHandler(tree, false);\n  return treeHandler();\n}",
      "startLine": 78,
      "startCol": 10,
      "endLine": 78,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/treeProcessor.js",
      "uniqueid": 6
    },
    "7": {
      "source": "node_modules/jest-jasmine2/build/treeProcessor.js:78:10:78:10",
      "startTime": "928731635220812",
      "endTime": "928732270642934",
      "elapsedTime": "635422122",
      "asyncId": 45,
      "triggerAsyncId": 44,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " treeProcessor",
      "userCode": false,
      "triggers": [
        56,
        55,
        46,
        58,
        60,
        69,
        46,
        56,
        57,
        67,
        87,
        71,
        46
      ],
      "line": "\n\n  const treeHandler = getNodeHandler(tree, false);\n  return treeHandler();\n}",
      "startLine": 78,
      "startCol": 10,
      "endLine": 78,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/treeProcessor.js",
      "uniqueid": 7
    },
    "8": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731644359734",
      "endTime": "928733024527252",
      "elapsedTime": "1380167518",
      "asyncId": 46,
      "triggerAsyncId": 45,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        53,
        53,
        52,
        52,
        61,
        59,
        61,
        70,
        47,
        51,
        51,
        53,
        57,
        58,
        68,
        94,
        72
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 8
    },
    "9": {
      "source": "node_modules/jest-runner/build/runTest.js:380:22:380:22",
      "startTime": "928731646354754",
      "endTime": "928733025266177",
      "elapsedTime": "1378911423",
      "asyncId": 50,
      "triggerAsyncId": 25,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        62,
        64,
        70,
        61,
        68,
        84,
        51,
        51,
        61,
        63,
        69,
        60,
        67,
        83,
        51,
        51,
        51,
        51,
        58,
        58,
        51,
        51,
        51,
        51,
        63,
        65,
        71,
        61,
        62,
        69,
        91,
        73,
        73,
        51
      ],
      "line": "\n      }\n\n      result = await testFramework(\n        globalConfig,\n        config,\n        environment",
      "startLine": 380,
      "startCol": 22,
      "endLine": 380,
      "endCol": 22,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 9
    },
    "10": {
      "source": "node_modules/jest-runner/build/runTest.js:380:22:380:22",
      "startTime": "928731646755275",
      "endTime": "928733025565769",
      "elapsedTime": "1378810494",
      "asyncId": 51,
      "triggerAsyncId": 50,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        98,
        100,
        106,
        97,
        104,
        117,
        52,
        52,
        107,
        109,
        115,
        106,
        113,
        126,
        71,
        67,
        69,
        75,
        66,
        73,
        89,
        52,
        52,
        52,
        52,
        346,
        348,
        345,
        343,
        52
      ],
      "line": "\n      }\n\n      result = await testFramework(\n        globalConfig,\n        config,\n        environment",
      "startLine": 380,
      "startCol": 22,
      "endLine": 380,
      "endCol": 22,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 10
    },
    "11": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731647356382",
      "endTime": "928733034732673",
      "elapsedTime": "1387376291",
      "asyncId": 52,
      "triggerAsyncId": 25,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        131,
        133,
        139,
        130,
        137,
        150,
        72,
        53,
        53,
        53,
        103,
        105,
        111,
        102,
        109,
        122,
        53,
        53,
        64,
        66,
        72,
        63,
        70,
        86,
        53,
        53,
        53,
        803,
        805,
        802,
        800
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 11
    },
    "12": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731645865126",
      "endTime": "928732269902756",
      "elapsedTime": "624037630",
      "asyncId": 55,
      "triggerAsyncId": 43,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        56,
        202,
        204,
        210,
        201,
        208,
        221,
        56,
        56,
        105,
        107,
        113,
        104,
        111,
        124,
        56,
        56,
        56,
        61,
        61,
        61,
        61,
        61,
        61,
        61,
        61
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 12
    },
    "13": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731854177625",
      "endTime": "928731928796244",
      "elapsedTime": "74618619",
      "asyncId": 56,
      "triggerAsyncId": 25,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        235,
        237,
        243,
        234,
        241,
        254,
        57,
        57,
        138,
        140,
        146,
        137,
        144,
        157,
        57,
        57,
        68,
        198,
        200,
        197,
        195
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 13
    },
    "14": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731650856913",
      "endTime": "928733024417416",
      "elapsedTime": "1373560503",
      "asyncId": 58,
      "triggerAsyncId": 46,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        59,
        59,
        59,
        59,
        66,
        59,
        59,
        59,
        59,
        59,
        59,
        66
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 14
    },
    "15": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731648417250",
      "endTime": "928732218845836",
      "elapsedTime": "570428586",
      "asyncId": 59,
      "triggerAsyncId": 58,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        71,
        73,
        86,
        71,
        73,
        79,
        71,
        73,
        71,
        73,
        83,
        69,
        70,
        77,
        99,
        60,
        113,
        60,
        69,
        70,
        81,
        101,
        60,
        60,
        69,
        70,
        84,
        104,
        60,
        60,
        69,
        70,
        111,
        131,
        60,
        60
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 15
    },
    "16": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731649470465",
      "endTime": "928732269767412",
      "elapsedTime": "620296947",
      "asyncId": 61,
      "triggerAsyncId": 55,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        69,
        75,
        77,
        83,
        62,
        73,
        74,
        81,
        101,
        62,
        62,
        62,
        62,
        70,
        62,
        62,
        62
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 16
    },
    "17": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731653089228",
      "endTime": "928732790819858",
      "elapsedTime": "1137730630",
      "asyncId": 62,
      "triggerAsyncId": 61,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        76,
        78,
        90,
        130,
        132,
        139,
        128,
        129,
        137,
        154,
        63,
        63,
        67,
        67,
        74,
        75,
        88,
        108,
        63,
        63
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 17
    },
    "18": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731653554611",
      "endTime": "928732960592892",
      "elapsedTime": "1307038281",
      "asyncId": 63,
      "triggerAsyncId": 62,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        64,
        64,
        72,
        71,
        220,
        222,
        228,
        218,
        219,
        226,
        243,
        64,
        64,
        421,
        423,
        429,
        419,
        420,
        427,
        444,
        64,
        64
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 18
    },
    "19": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731653987112",
      "endTime": "928732997660027",
      "elapsedTime": "1343672915",
      "asyncId": 64,
      "triggerAsyncId": 63,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        65,
        65,
        69,
        74,
        77,
        75,
        79,
        85,
        69,
        65,
        65,
        268,
        270,
        276,
        266,
        267,
        274,
        291,
        85,
        479,
        481,
        490,
        477,
        478,
        488,
        505,
        65,
        65
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 19
    },
    "20": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731654525401",
      "endTime": "928733024275680",
      "elapsedTime": "1369750279",
      "asyncId": 65,
      "triggerAsyncId": 64,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        75,
        78,
        76,
        80,
        86,
        66,
        66,
        89,
        95,
        88,
        88,
        87,
        86,
        93,
        97,
        103,
        66,
        66,
        66,
        66,
        663,
        665,
        673,
        661,
        662,
        671,
        688,
        92
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 20
    },
    "21": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731654931932",
      "endTime": "928733024332126",
      "elapsedTime": "1369400194",
      "asyncId": 66,
      "triggerAsyncId": 58,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        87,
        90,
        88,
        92,
        96,
        67,
        74,
        74,
        67,
        67,
        77,
        79,
        87,
        75,
        76,
        85,
        105,
        89,
        67
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 21
    },
    "22": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731660570272",
      "endTime": "928732790639180",
      "elapsedTime": "1130068908",
      "asyncId": 74,
      "triggerAsyncId": 62,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        76,
        92,
        94,
        100,
        85,
        87,
        95,
        91,
        98,
        114,
        75,
        79,
        84,
        93,
        109,
        97,
        89,
        75,
        91,
        97,
        119,
        121,
        79,
        127,
        88,
        95,
        111,
        75,
        118,
        125,
        141,
        75,
        75,
        75,
        89
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 22
    },
    "23": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731661104474",
      "endTime": "928732790677672",
      "elapsedTime": "1129573198",
      "asyncId": 75,
      "triggerAsyncId": 62,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        77,
        81,
        138,
        140,
        146,
        86,
        76,
        137,
        144,
        157,
        76,
        125,
        127,
        133,
        76,
        155,
        157,
        124,
        131,
        144,
        163,
        76,
        154,
        161,
        174,
        76,
        76,
        76,
        86,
        86
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 23
    },
    "24": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928731863658678",
      "endTime": "928731863725734",
      "elapsedTime": "67056",
      "asyncId": 79,
      "triggerAsyncId": 66,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        96,
        98,
        104,
        80,
        95,
        102,
        118,
        80,
        310,
        312,
        318,
        309,
        80,
        316,
        329,
        80,
        80,
        287,
        289,
        295,
        286,
        293,
        306,
        80,
        80,
        80,
        80,
        80
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 24
    },
    "25": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731663877812",
      "endTime": "928731914582469",
      "elapsedTime": "250704657",
      "asyncId": 80,
      "triggerAsyncId": 79,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        82,
        82,
        138,
        140,
        146,
        353,
        355,
        361,
        352,
        359,
        372,
        81,
        320,
        81,
        322,
        328,
        319,
        326,
        339,
        81,
        81,
        93,
        95,
        101,
        92,
        99,
        115,
        81,
        81,
        137,
        144,
        157,
        81,
        81
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 25
    },
    "26": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731664354286",
      "endTime": "928732131088598",
      "elapsedTime": "466734312",
      "asyncId": 81,
      "triggerAsyncId": 80,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        82,
        82,
        87,
        87,
        396,
        398,
        404,
        395,
        402,
        415,
        102,
        353,
        355,
        361,
        352,
        359,
        372,
        82,
        82,
        129,
        131,
        137,
        128,
        135,
        148,
        82,
        82,
        185,
        187,
        193,
        184,
        191,
        204,
        82,
        82
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 26
    },
    "27": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731664919004",
      "endTime": "928732305266238",
      "elapsedTime": "640347234",
      "asyncId": 82,
      "triggerAsyncId": 81,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        92,
        95,
        93,
        97,
        103,
        83,
        83,
        83,
        386,
        388,
        394,
        385,
        392,
        405,
        83,
        83,
        162,
        164,
        170,
        161,
        168,
        181,
        103,
        232,
        234,
        240,
        231,
        238,
        251,
        83,
        83
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 27
    },
    "28": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731665538375",
      "endTime": "928732470270903",
      "elapsedTime": "804732528",
      "asyncId": 83,
      "triggerAsyncId": 82,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        104,
        107,
        105,
        109,
        113,
        84,
        419,
        421,
        427,
        418,
        425,
        438,
        84,
        84,
        84,
        279,
        281,
        287,
        278,
        285,
        298,
        84,
        84
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 28
    },
    "29": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731666090100",
      "endTime": "928732630878926",
      "elapsedTime": "964788826",
      "asyncId": 84,
      "triggerAsyncId": 83,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        94,
        452,
        454,
        460,
        451,
        458,
        471,
        85,
        85,
        326,
        328,
        334,
        325,
        332,
        345,
        85,
        85
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 29
    },
    "30": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731666646122",
      "endTime": "928732790351430",
      "elapsedTime": "1123705308",
      "asyncId": 85,
      "triggerAsyncId": 84,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        485,
        487,
        493,
        484,
        491,
        504,
        86,
        86,
        373,
        375,
        381,
        372,
        379,
        392,
        106
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 30
    },
    "31": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731667097989",
      "endTime": "928732790426000",
      "elapsedTime": "1123328011",
      "asyncId": 86,
      "triggerAsyncId": 75,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        94,
        518,
        520,
        526,
        517,
        524,
        537,
        87,
        87,
        87
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 31
    },
    "32": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731667566688",
      "endTime": "928732790708880",
      "elapsedTime": "1123142192",
      "asyncId": 87,
      "triggerAsyncId": 86,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        89,
        92,
        88,
        88,
        551,
        553,
        559,
        550,
        557,
        570,
        88,
        88
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 32
    },
    "33": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731668248365",
      "endTime": "928732790745880",
      "elapsedTime": "1122497515",
      "asyncId": 88,
      "triggerAsyncId": 62,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        94,
        91,
        100,
        103,
        101,
        105,
        111,
        89,
        89,
        96,
        96,
        584,
        586,
        592,
        583,
        590,
        603,
        89,
        89
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 33
    },
    "34": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731667533936",
      "endTime": "928732031682022",
      "elapsedTime": "364148086",
      "asyncId": 90,
      "triggerAsyncId": 89,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        100,
        101,
        133,
        125,
        124,
        123,
        122,
        131,
        135,
        139,
        91,
        91,
        650,
        652,
        658,
        649,
        656,
        669,
        91,
        91
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 34
    },
    "35": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731668139601",
      "endTime": "928732054462045",
      "elapsedTime": "386322444",
      "asyncId": 91,
      "triggerAsyncId": 90,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        92,
        99,
        140,
        143,
        141,
        145,
        149,
        92,
        92,
        92,
        92,
        92,
        683,
        685,
        691,
        682,
        689,
        702,
        92,
        92
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 35
    },
    "36": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731670395871",
      "endTime": "928733024354508",
      "elapsedTime": "1353958637",
      "asyncId": 92,
      "triggerAsyncId": 65,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        94,
        94,
        96,
        94,
        102,
        105,
        103,
        107,
        113,
        102,
        105,
        93,
        103,
        107,
        93,
        113,
        93,
        93,
        100,
        716,
        718,
        724,
        715,
        722,
        735,
        93,
        93
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 36
    },
    "37": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731669150316",
      "endTime": "928732088485364",
      "elapsedTime": "419335048",
      "asyncId": 93,
      "triggerAsyncId": 92,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        99,
        99,
        99,
        95,
        116,
        121,
        115,
        114,
        119,
        123,
        127,
        94,
        114,
        117,
        115,
        119,
        123,
        94,
        749,
        751,
        757,
        748,
        755,
        768,
        94,
        94
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 37
    },
    "38": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731670344124",
      "endTime": "928732105231506",
      "elapsedTime": "434887382",
      "asyncId": 95,
      "triggerAsyncId": 94,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        101,
        96,
        105,
        108,
        106,
        110,
        116,
        96,
        96,
        103,
        96,
        96,
        815,
        817,
        823,
        814,
        821,
        834,
        96,
        96
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 38
    },
    "39": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731671762322",
      "endTime": "928732113212387",
      "elapsedTime": "441450065",
      "asyncId": 96,
      "triggerAsyncId": 95,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        97,
        97,
        120,
        126,
        119,
        118,
        117,
        124,
        128,
        134,
        97,
        106,
        109,
        107,
        111,
        117,
        97,
        97,
        848,
        850,
        856,
        847,
        854,
        867,
        97,
        97
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 39
    },
    "40": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731672448499",
      "endTime": "928732122488175",
      "elapsedTime": "450039676",
      "asyncId": 97,
      "triggerAsyncId": 96,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        105,
        112,
        98,
        118,
        121,
        119,
        123,
        127,
        98,
        881,
        883,
        889,
        880,
        887,
        900,
        98,
        98
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 40
    },
    "41": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731673095712",
      "endTime": "928732131481935",
      "elapsedTime": "458386223",
      "asyncId": 98,
      "triggerAsyncId": 97,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        99,
        99,
        99,
        99,
        914,
        916,
        922,
        913,
        920,
        933,
        99,
        99
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 41
    },
    "42": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731673660220",
      "endTime": "928732140751742",
      "elapsedTime": "467091522",
      "asyncId": 99,
      "triggerAsyncId": 98,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        116,
        118,
        123,
        100,
        109,
        112,
        110,
        114,
        120,
        100,
        100,
        947,
        949,
        955,
        946,
        953,
        966,
        100,
        100
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 42
    },
    "43": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731674229878",
      "endTime": "928732148642444",
      "elapsedTime": "474412566",
      "asyncId": 100,
      "triggerAsyncId": 99,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        101,
        101,
        101,
        109,
        102,
        124,
        130,
        123,
        122,
        121,
        128,
        132,
        136,
        101,
        980,
        982,
        988,
        979,
        986,
        999,
        101,
        101
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 43
    },
    "44": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731674892430",
      "endTime": "928732157529373",
      "elapsedTime": "482636943",
      "asyncId": 101,
      "triggerAsyncId": 100,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        108,
        111,
        109,
        113,
        119,
        102,
        102,
        104,
        107,
        1013,
        1015,
        1021,
        1012,
        1019,
        1032,
        102,
        102
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 44
    },
    "45": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731675502063",
      "endTime": "928732165897730",
      "elapsedTime": "490395667",
      "asyncId": 102,
      "triggerAsyncId": 101,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        120,
        123,
        121,
        125,
        129,
        103,
        110,
        108,
        104,
        104,
        1046,
        1048,
        1054,
        1045,
        1052,
        1065,
        103,
        103
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 45
    },
    "46": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731676067994",
      "endTime": "928732173793772",
      "elapsedTime": "497725778",
      "asyncId": 103,
      "triggerAsyncId": 102,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        109,
        109,
        1079,
        1081,
        1087,
        1078,
        1085,
        1098,
        104,
        104
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 46
    },
    "47": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731676611944",
      "endTime": "928732182645435",
      "elapsedTime": "506033491",
      "asyncId": 104,
      "triggerAsyncId": 103,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        106,
        105,
        112,
        1112,
        1114,
        1120,
        1111,
        1118,
        1131,
        105,
        105
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 47
    },
    "48": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731677062428",
      "endTime": "928732194173395",
      "elapsedTime": "517110967",
      "asyncId": 105,
      "triggerAsyncId": 104,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        111,
        106,
        106,
        107,
        1145,
        1147,
        1153,
        1144,
        1151,
        1164,
        106,
        106
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 48
    },
    "49": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731678642270",
      "endTime": "928732790454754",
      "elapsedTime": "1111812484",
      "asyncId": 106,
      "triggerAsyncId": 85,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        114,
        113,
        116,
        114,
        118,
        124,
        107,
        107,
        112,
        108,
        1178,
        1180,
        1186,
        1177,
        1184,
        1197,
        107,
        107
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 49
    },
    "50": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731677977183",
      "endTime": "928732210349338",
      "elapsedTime": "532372155",
      "asyncId": 107,
      "triggerAsyncId": 106,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        125,
        128,
        126,
        130,
        134,
        108,
        108,
        108,
        113,
        1211,
        1213,
        1219,
        1210,
        1217,
        1230,
        108,
        108
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 50
    },
    "51": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731678897518",
      "endTime": "928732218421701",
      "elapsedTime": "539524183",
      "asyncId": 109,
      "triggerAsyncId": 70,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        115,
        110,
        110,
        127,
        130,
        128,
        132,
        136,
        110,
        111,
        110
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 51
    },
    "52": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731679540353",
      "endTime": "928732218721963",
      "elapsedTime": "539181610",
      "asyncId": 110,
      "triggerAsyncId": 109,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        117,
        120,
        118,
        122,
        128,
        111,
        111,
        116
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 52
    },
    "53": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731680170544",
      "endTime": "928732218753773",
      "elapsedTime": "538583229",
      "asyncId": 111,
      "triggerAsyncId": 59,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        132,
        131,
        137,
        131,
        130,
        129,
        135,
        139,
        144,
        112
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 53
    },
    "54": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731878159341",
      "endTime": "928731879853376",
      "elapsedTime": "1694035",
      "asyncId": 113,
      "triggerAsyncId": 107,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        115,
        114,
        119
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 54
    },
    "55": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731686773612",
      "endTime": "928731688207550",
      "elapsedTime": "1433938",
      "asyncId": 114,
      "triggerAsyncId": 93,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        125,
        120,
        115,
        120,
        116
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 55
    },
    "56": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731682515530",
      "endTime": "928732269804983",
      "elapsedTime": "587289453",
      "asyncId": 115,
      "triggerAsyncId": 60,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        122,
        122,
        117,
        118,
        121
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 56
    },
    "57": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731880485521",
      "endTime": "928731884051446",
      "elapsedTime": "3565925",
      "asyncId": 118,
      "triggerAsyncId": 97,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        119,
        119,
        124,
        120,
        123,
        126,
        120
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 57
    },
    "58": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731884373049",
      "endTime": "928731886082022",
      "elapsedTime": "1708973",
      "asyncId": 119,
      "triggerAsyncId": 97,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        129,
        131,
        137,
        128,
        135,
        151,
        120,
        120,
        122,
        125,
        125
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 58
    },
    "59": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731884980638",
      "endTime": "928731885034429",
      "elapsedTime": "53791",
      "asyncId": 121,
      "triggerAsyncId": 97,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        127,
        206,
        208,
        214,
        205,
        212,
        225,
        139,
        122,
        122,
        131,
        122,
        122,
        129
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 59
    },
    "60": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731687771052",
      "endTime": "928731698736668",
      "elapsedTime": "10965616",
      "asyncId": 122,
      "triggerAsyncId": 100,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        123,
        128,
        130,
        124,
        132,
        132,
        135,
        133,
        137,
        143,
        127,
        123,
        123
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 60
    },
    "61": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731885604778",
      "endTime": "928731886747830",
      "elapsedTime": "1143052",
      "asyncId": 123,
      "triggerAsyncId": 97,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        125,
        130,
        126,
        144,
        147,
        145,
        149,
        153,
        124
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 61
    },
    "62": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731695874473",
      "endTime": "928731721643569",
      "elapsedTime": "25769096",
      "asyncId": 124,
      "triggerAsyncId": 75,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        130,
        129,
        125,
        132
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 62
    },
    "63": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731885974681",
      "endTime": "928731886790190",
      "elapsedTime": "815509",
      "asyncId": 125,
      "triggerAsyncId": 119,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        127,
        126,
        126,
        128
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 63
    },
    "64": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731888357959",
      "endTime": "928731900182956",
      "elapsedTime": "11824997",
      "asyncId": 128,
      "triggerAsyncId": 81,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        136,
        134,
        129,
        134,
        135,
        138,
        136,
        140,
        146,
        129,
        129,
        138,
        136
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 64
    },
    "65": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731690050656",
      "endTime": "928732218457338",
      "elapsedTime": "528406682",
      "asyncId": 129,
      "triggerAsyncId": 108,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        136,
        131,
        135,
        147,
        150,
        148,
        152,
        156,
        130,
        135
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 65
    },
    "66": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731699918033",
      "endTime": "928731721754377",
      "elapsedTime": "21836344",
      "asyncId": 130,
      "triggerAsyncId": 129,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        138,
        134,
        132
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 66
    },
    "67": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731890321600",
      "endTime": "928731895985567",
      "elapsedTime": "5663967",
      "asyncId": 132,
      "triggerAsyncId": 131,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        142,
        145,
        143,
        147,
        153,
        133,
        133,
        142,
        133,
        135,
        134,
        133,
        133,
        139,
        142,
        140,
        144,
        150,
        133,
        133
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 67
    },
    "68": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731890741207",
      "endTime": "928731900014019",
      "elapsedTime": "9272812",
      "asyncId": 133,
      "triggerAsyncId": 132,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        134,
        134,
        156,
        161,
        155,
        154,
        159,
        163,
        167,
        134,
        134,
        139,
        142,
        144,
        150,
        141,
        148,
        164,
        134,
        134,
        151,
        154,
        152,
        156,
        160,
        134
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 68
    },
    "69": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731891073550",
      "endTime": "928731900221298",
      "elapsedTime": "9147748",
      "asyncId": 134,
      "triggerAsyncId": 133,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        141,
        144,
        142,
        146,
        152,
        135,
        135,
        182,
        184,
        190,
        181,
        188,
        201,
        152
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 69
    },
    "70": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731891389542",
      "endTime": "928731900270540",
      "elapsedTime": "8880998",
      "asyncId": 135,
      "triggerAsyncId": 81,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        153,
        156,
        154,
        158,
        162,
        136,
        141,
        143,
        143,
        136,
        137,
        136
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 70
    },
    "71": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731702428599",
      "endTime": "928731914173713",
      "elapsedTime": "211745114",
      "asyncId": 137,
      "triggerAsyncId": 80,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        145,
        145,
        145
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 71
    },
    "72": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731892738851",
      "endTime": "928731892791861",
      "elapsedTime": "53010",
      "asyncId": 139,
      "triggerAsyncId": 132,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        146,
        149,
        147,
        151,
        157,
        140,
        140,
        146,
        149,
        147,
        151,
        157,
        140,
        140,
        141
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 72
    },
    "73": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731893090471",
      "endTime": "928731895269034",
      "elapsedTime": "2178563",
      "asyncId": 140,
      "triggerAsyncId": 132,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        158,
        161,
        159,
        163,
        167,
        141,
        141,
        141,
        160,
        159,
        173,
        163,
        159,
        158,
        171,
        175,
        180,
        141,
        141,
        141,
        142,
        141,
        141,
        146
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 73
    },
    "74": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731707220592",
      "endTime": "928731911175813",
      "elapsedTime": "203955221",
      "asyncId": 142,
      "triggerAsyncId": 141,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        148,
        144,
        165,
        163,
        162,
        160,
        169,
        164,
        167,
        163,
        171,
        162,
        177,
        143,
        163,
        169,
        162,
        161,
        160,
        167,
        171,
        177,
        143,
        168,
        162,
        161,
        160,
        166,
        170,
        174,
        143
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 74
    },
    "75": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731707798986",
      "endTime": "928731914261918",
      "elapsedTime": "206462932",
      "asyncId": 143,
      "triggerAsyncId": 142,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        149
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 75
    },
    "76": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731708336003",
      "endTime": "928731914320498",
      "elapsedTime": "205984495",
      "asyncId": 144,
      "triggerAsyncId": 80,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        145,
        146,
        145
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 76
    },
    "77": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731894646187",
      "endTime": "928731895878317",
      "elapsedTime": "1232130",
      "asyncId": 146,
      "triggerAsyncId": 140,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        161,
        148,
        148,
        169,
        174,
        168,
        167,
        172,
        176,
        180,
        147
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 77
    },
    "78": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731702517546",
      "endTime": "928731724937754",
      "elapsedTime": "22420208",
      "asyncId": 147,
      "triggerAsyncId": 146,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        153,
        153,
        149
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 78
    },
    "79": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731896309585",
      "endTime": "928731897219961",
      "elapsedTime": "910376",
      "asyncId": 151,
      "triggerAsyncId": 133,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        152,
        154,
        156,
        156,
        153
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 79
    },
    "80": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731897489787",
      "endTime": "928731899148557",
      "elapsedTime": "1658770",
      "asyncId": 152,
      "triggerAsyncId": 133,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        157,
        153,
        158
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 80
    },
    "81": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731898062271",
      "endTime": "928731898090974",
      "elapsedTime": "28703",
      "asyncId": 154,
      "triggerAsyncId": 133,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        160,
        160,
        155,
        155,
        155,
        162
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 81
    },
    "82": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731674318234",
      "endTime": "928731724343410",
      "elapsedTime": "50025176",
      "asyncId": 155,
      "triggerAsyncId": 154,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        158,
        163,
        165,
        173,
        157,
        162,
        171,
        187,
        175
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 82
    },
    "83": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731898633030",
      "endTime": "928731899761576",
      "elapsedTime": "1128546",
      "asyncId": 156,
      "triggerAsyncId": 133,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        157,
        162,
        157
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 83
    },
    "84": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731898982656",
      "endTime": "928731899826357",
      "elapsedTime": "843701",
      "asyncId": 158,
      "triggerAsyncId": 152,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        159,
        160,
        172,
        165,
        168,
        166,
        170,
        176,
        159,
        159
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 84
    },
    "85": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731721292471",
      "endTime": "928731741185672",
      "elapsedTime": "19893201",
      "asyncId": 159,
      "triggerAsyncId": 158,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        165,
        160,
        165,
        170,
        177,
        180,
        178,
        182,
        186,
        160
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 85
    },
    "86": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731718768199",
      "endTime": "928731910609742",
      "elapsedTime": "191841543",
      "asyncId": 160,
      "triggerAsyncId": 142,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        168,
        161,
        168,
        161,
        161,
        167
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 86
    },
    "87": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731900979519",
      "endTime": "928731914577049",
      "elapsedTime": "13597530",
      "asyncId": 161,
      "triggerAsyncId": 82,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        162,
        166,
        168,
        171,
        169,
        173,
        179,
        162,
        162,
        165,
        169
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 87
    },
    "88": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928731901446584",
      "endTime": "928731901507288",
      "elapsedTime": "60704",
      "asyncId": 162,
      "triggerAsyncId": 82,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        164,
        165,
        172,
        180,
        183,
        181,
        185,
        189,
        163,
        164
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 88
    },
    "89": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731727280466",
      "endTime": "928731743047262",
      "elapsedTime": "15766796",
      "asyncId": 163,
      "triggerAsyncId": 162,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        175,
        165,
        164
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 89
    },
    "90": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928731902279386",
      "endTime": "928731902344899",
      "elapsedTime": "65513",
      "asyncId": 164,
      "triggerAsyncId": 82,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        179,
        174,
        174,
        178,
        177,
        165,
        165
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 90
    },
    "91": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928731721695356",
      "endTime": "928731910684211",
      "elapsedTime": "188988855",
      "asyncId": 165,
      "triggerAsyncId": 161,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        166,
        166,
        166,
        166,
        166,
        167,
        172,
        175,
        173,
        177,
        183,
        166,
        166
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 91
    },
    "92": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731903165807",
      "endTime": "928731914352858",
      "elapsedTime": "11187051",
      "asyncId": 166,
      "triggerAsyncId": 165,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        174,
        181,
        167,
        178,
        181,
        179,
        183,
        189,
        167,
        167,
        172,
        172,
        184,
        187,
        185,
        189,
        193,
        167
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 92
    },
    "93": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731903550980",
      "endTime": "928731914666957",
      "elapsedTime": "11115977",
      "asyncId": 167,
      "triggerAsyncId": 166,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        168,
        173,
        168,
        168,
        173,
        190,
        193,
        191,
        195,
        199,
        168,
        168,
        173
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 93
    },
    "94": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731903835523",
      "endTime": "928731914715739",
      "elapsedTime": "10880216",
      "asyncId": 168,
      "triggerAsyncId": 82,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        176,
        176,
        184,
        187,
        192,
        169,
        209,
        202,
        201,
        200,
        207,
        211,
        215,
        169,
        169,
        171,
        170
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 94
    },
    "95": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731724243743",
      "endTime": "928731910923460",
      "elapsedTime": "186679717",
      "asyncId": 170,
      "triggerAsyncId": 142,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        175,
        171
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 95
    },
    "96": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731732135207",
      "endTime": "928731732249531",
      "elapsedTime": "114324",
      "asyncId": 171,
      "triggerAsyncId": 161,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        172,
        172,
        172,
        172,
        177
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 96
    },
    "97": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731724870678",
      "endTime": "928731910981158",
      "elapsedTime": "186110480",
      "asyncId": 172,
      "triggerAsyncId": 166,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        173,
        179,
        182,
        180,
        184,
        190,
        173,
        173,
        179,
        182,
        180,
        184,
        190,
        173,
        173,
        178,
        174
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 97
    },
    "98": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731905596664",
      "endTime": "928731908114344",
      "elapsedTime": "2517680",
      "asyncId": 173,
      "triggerAsyncId": 165,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        193,
        198,
        192,
        191,
        196,
        200,
        204,
        174,
        191,
        194,
        192,
        196,
        200,
        174,
        179
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 98
    },
    "99": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731906239810",
      "endTime": "928731906297268",
      "elapsedTime": "57458",
      "asyncId": 175,
      "triggerAsyncId": 165,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        176,
        178
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 99
    },
    "100": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731906943248",
      "endTime": "928731908813284",
      "elapsedTime": "1870036",
      "asyncId": 177,
      "triggerAsyncId": 165,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        178,
        179
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 100
    },
    "101": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:40:45:40:45",
      "startTime": "928731825641171",
      "endTime": "928731825724257",
      "elapsedTime": "83086",
      "asyncId": 178,
      "triggerAsyncId": 164,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        186,
        179,
        180,
        184,
        179
      ],
      "line": "\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() ",
      "startLine": 40,
      "startCol": 45,
      "endLine": 40,
      "endCol": 45,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 101
    },
    "102": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731907385718",
      "endTime": "928731908907430",
      "elapsedTime": "1521712",
      "asyncId": 179,
      "triggerAsyncId": 173,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        181,
        181,
        185,
        181
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 102
    },
    "103": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731737191114",
      "endTime": "928731737603006",
      "elapsedTime": "411892",
      "asyncId": 180,
      "triggerAsyncId": 162,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        186,
        186,
        188,
        182
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 103
    },
    "104": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731916133486",
      "endTime": "928732130845201",
      "elapsedTime": "214711715",
      "asyncId": 184,
      "triggerAsyncId": 81,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        185,
        191,
        194,
        192,
        196,
        202,
        185,
        185,
        185,
        185,
        186,
        192
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 104
    },
    "105": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928731916859888",
      "endTime": "928731916934408",
      "elapsedTime": "74520",
      "asyncId": 185,
      "triggerAsyncId": 81,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        186,
        206,
        212,
        205,
        204,
        203,
        210,
        214,
        220,
        186,
        192,
        195,
        193,
        197,
        203,
        186,
        186,
        191
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 105
    },
    "106": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928731919601848",
      "endTime": "928731919654447",
      "elapsedTime": "52599",
      "asyncId": 187,
      "triggerAsyncId": 81,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        189,
        195,
        188,
        188
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 106
    },
    "107": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731920564874",
      "endTime": "928731931937182",
      "elapsedTime": "11372308",
      "asyncId": 188,
      "triggerAsyncId": 187,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        195,
        198,
        196,
        200,
        206,
        189,
        189
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 107
    },
    "108": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731921624289",
      "endTime": "928732128022840",
      "elapsedTime": "206398551",
      "asyncId": 189,
      "triggerAsyncId": 188,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        191,
        190,
        190,
        215,
        209,
        208,
        207,
        213,
        217,
        221,
        190
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 108
    },
    "109": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731922313592",
      "endTime": "928732130892119",
      "elapsedTime": "208578527",
      "asyncId": 190,
      "triggerAsyncId": 189,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        196,
        196,
        198,
        202,
        191,
        192,
        191,
        191,
        198
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 109
    },
    "110": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731922795996",
      "endTime": "928732130928558",
      "elapsedTime": "208132562",
      "asyncId": 191,
      "triggerAsyncId": 81,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        197,
        193,
        193,
        193,
        197,
        198,
        201,
        199,
        203,
        209,
        192,
        192
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 110
    },
    "111": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731924670931",
      "endTime": "928731924749608",
      "elapsedTime": "78677",
      "asyncId": 193,
      "triggerAsyncId": 81,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        194,
        199,
        194,
        194
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 111
    },
    "112": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731918354089",
      "endTime": "928731918727679",
      "elapsedTime": "373590",
      "asyncId": 194,
      "triggerAsyncId": 26,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        195,
        201,
        204,
        202,
        206,
        212,
        195,
        195
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 112
    },
    "113": {
      "source": "node_modules/jest-runner/build/runTest.js:442:12:442:12",
      "startTime": "928731919416651",
      "endTime": "928731936331239",
      "elapsedTime": "16914588",
      "asyncId": 195,
      "triggerAsyncId": 56,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        213,
        216,
        214,
        218,
        222,
        196,
        197,
        210
      ],
      "line": "\n    } // Delay the resolution to allow log messages to be output.\n\n    return new Promise(resolve => {\n      setImmediate(() =>\n        resolve({\n          leakDetector",
      "startLine": 442,
      "startCol": 12,
      "endLine": 442,
      "endCol": 12,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 113
    },
    "114": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731926433585",
      "endTime": "928731930250029",
      "elapsedTime": "3816444",
      "asyncId": 196,
      "triggerAsyncId": 188,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        202,
        197,
        202
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 114
    },
    "115": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731927125271",
      "endTime": "928731927162121",
      "elapsedTime": "36850",
      "asyncId": 198,
      "triggerAsyncId": 188,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        199,
        200,
        199
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 115
    },
    "116": {
      "source": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js:132:21:132:21",
      "startTime": "928731925496659",
      "endTime": "928731928903455",
      "elapsedTime": "3406796",
      "asyncId": 199,
      "triggerAsyncId": 198,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueMutationObserverMicrotask",
      "userCode": false,
      "triggers": [
        201,
        205
      ],
      "line": "\n  mutationObserverMicrotaskQueueFlag = true;\n\n  Promise.resolve().then(() => {\n    notifyMutationObservers();\n  });\n",
      "startLine": 132,
      "startCol": 21,
      "endLine": 132,
      "endCol": 21,
      "file": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js",
      "uniqueid": 116
    },
    "117": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731928552437",
      "endTime": "928731931524298",
      "elapsedTime": "2971861",
      "asyncId": 200,
      "triggerAsyncId": 188,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        203,
        208,
        201,
        203
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 117
    },
    "118": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:116:8:116:8",
      "startTime": "928731927180004",
      "endTime": "928731933802458",
      "elapsedTime": "6622454",
      "asyncId": 201,
      "triggerAsyncId": 200,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " ResourceQueue.push",
      "userCode": false,
      "triggers": [
        209,
        204,
        204,
        206,
        203,
        206,
        202
      ],
      "line": "\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check()",
      "startLine": 116,
      "startCol": 8,
      "endLine": 116,
      "endCol": 8,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "uniqueid": 118
    },
    "119": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:116:8:116:8",
      "startTime": "928731927898521",
      "endTime": "928731933924146",
      "elapsedTime": "6025625",
      "asyncId": 203,
      "triggerAsyncId": 200,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " ResourceQueue.push",
      "userCode": false,
      "triggers": [
        209,
        211,
        204,
        204
      ],
      "line": "\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check()",
      "startLine": 116,
      "startCol": 8,
      "endLine": 116,
      "endCol": 8,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "uniqueid": 119
    },
    "120": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928731930208171",
      "endTime": "928732131139483",
      "elapsedTime": "200931312",
      "asyncId": 204,
      "triggerAsyncId": 81,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        205,
        205,
        209,
        210
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 120
    },
    "121": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731928737484",
      "endTime": "928731934337161",
      "elapsedTime": "5599677",
      "asyncId": 205,
      "triggerAsyncId": 197,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        213,
        212,
        215,
        213,
        217,
        223,
        206,
        206,
        206,
        208,
        208
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 121
    },
    "122": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928731931414973",
      "endTime": "928731931987696",
      "elapsedTime": "572723",
      "asyncId": 206,
      "triggerAsyncId": 188,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        224,
        227,
        225,
        229,
        233,
        207,
        207,
        207,
        207
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 122
    },
    "123": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731932292808",
      "endTime": "928732127734119",
      "elapsedTime": "195441311",
      "asyncId": 207,
      "triggerAsyncId": 189,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        215,
        217,
        213,
        208,
        214
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 123
    },
    "124": {
      "source": "node_modules/jest-each/build/bind.js:76:13:76:13",
      "startTime": "928731933259250",
      "endTime": "928732127669528",
      "elapsedTime": "194410278",
      "asyncId": 208,
      "triggerAsyncId": 189,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        209,
        209,
        209,
        212
      ],
      "line": "\n  supportsDone && params.length < test.length\n    ? done => test(...params, done)\n    : () => test(...params);",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-each/build/bind.js",
      "uniqueid": 124
    },
    "125": {
      "source": "node_modules/bcryptjs/dist/bcrypt.js:222:20:222:20",
      "startTime": "928731933979731",
      "endTime": "928732028158246",
      "elapsedTime": "94178515",
      "asyncId": 209,
      "triggerAsyncId": 189,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.bcrypt.hash",
      "userCode": false,
      "triggers": [
        216,
        219,
        217,
        221,
        227,
        210,
        210,
        215,
        211
      ],
      "line": "\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);",
      "startLine": 222,
      "startCol": 20,
      "endLine": 222,
      "endCol": 20,
      "file": "node_modules/bcryptjs/dist/bcrypt.js",
      "uniqueid": 125
    },
    "126": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731935722808",
      "endTime": "928731936451935",
      "elapsedTime": "729127",
      "asyncId": 210,
      "triggerAsyncId": 195,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        230,
        235,
        229,
        228,
        233,
        237,
        241,
        211,
        211,
        211,
        216,
        212
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 126
    },
    "127": {
      "source": "node_modules/jest-each/build/bind.js:76:13:76:13",
      "startTime": "928731934646431",
      "endTime": "928732039508633",
      "elapsedTime": "104862202",
      "asyncId": 211,
      "triggerAsyncId": 209,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        218,
        221,
        219,
        223,
        229,
        212,
        212,
        217,
        225,
        224
      ],
      "line": "\n  supportsDone && params.length < test.length\n    ? done => test(...params, done)\n    : () => test(...params);",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-each/build/bind.js",
      "uniqueid": 127
    },
    "128": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928731935320113",
      "endTime": "928732127765929",
      "elapsedTime": "192445816",
      "asyncId": 212,
      "triggerAsyncId": 208,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        214,
        232,
        231,
        245,
        235,
        231,
        230,
        243,
        247,
        252,
        213
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 128
    },
    "129": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731935939254",
      "endTime": "928732127801465",
      "elapsedTime": "191862211",
      "asyncId": 213,
      "triggerAsyncId": 189,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        219,
        228,
        215,
        219
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 129
    },
    "130": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731937554943",
      "endTime": "928731937610156",
      "elapsedTime": "55213",
      "asyncId": 215,
      "triggerAsyncId": 189,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        223
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 130
    },
    "131": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731758198234",
      "endTime": "928731758293883",
      "elapsedTime": "95649",
      "asyncId": 216,
      "triggerAsyncId": 195,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        218,
        217,
        218
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 131
    },
    "132": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731938970526",
      "endTime": "928732127922031",
      "elapsedTime": "188951505",
      "asyncId": 217,
      "triggerAsyncId": 189,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        223,
        218,
        223
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 132
    },
    "133": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731755226182",
      "endTime": "928731784136327",
      "elapsedTime": "28910145",
      "asyncId": 218,
      "triggerAsyncId": 63,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        219,
        221,
        220,
        221,
        227
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 133
    },
    "134": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731939871736",
      "endTime": "928732127957698",
      "elapsedTime": "188085962",
      "asyncId": 219,
      "triggerAsyncId": 213,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        224,
        220,
        225,
        224,
        224
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 134
    },
    "135": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731769076937",
      "endTime": "928731787313904",
      "elapsedTime": "18236967",
      "asyncId": 220,
      "triggerAsyncId": 77,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        228
      ],
      "uniqueid": 135
    },
    "136": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928731940797201",
      "endTime": "928732128067615",
      "elapsedTime": "187270414",
      "asyncId": 221,
      "triggerAsyncId": 189,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        222,
        222
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 136
    },
    "137": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731758246254",
      "endTime": "928731783425204",
      "elapsedTime": "25178950",
      "asyncId": 223,
      "triggerAsyncId": 222,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        231,
        231,
        233,
        239,
        224,
        224,
        230,
        237,
        231,
        253,
        241
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 137
    },
    "138": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:74:25:74:25",
      "startTime": "928732028619501",
      "endTime": "928732120795031",
      "elapsedTime": "92175530",
      "asyncId": 224,
      "triggerAsyncId": 211,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        226,
        225,
        231,
        234,
        232,
        236,
        242,
        225,
        225,
        225
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }])",
      "startLine": 74,
      "startCol": 25,
      "endLine": 74,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 138
    },
    "139": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:65:45:65:45",
      "startTime": "928732035811553",
      "endTime": "928732035889780",
      "elapsedTime": "78227",
      "asyncId": 225,
      "triggerAsyncId": 211,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        231,
        226,
        243,
        246,
        244,
        248,
        252,
        226,
        226
      ],
      "line": "\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() ",
      "startLine": 65,
      "startCol": 45,
      "endLine": 65,
      "endCol": 45,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 139
    },
    "140": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:74:25:74:25",
      "startTime": "928732036187107",
      "endTime": "928732119966007",
      "elapsedTime": "83778900",
      "asyncId": 226,
      "triggerAsyncId": 225,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        227,
        227,
        227,
        227,
        227,
        228
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }])",
      "startLine": 74,
      "startCol": 25,
      "endLine": 74,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 140
    },
    "141": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731772876189",
      "endTime": "928731787530519",
      "elapsedTime": "14654330",
      "asyncId": 227,
      "triggerAsyncId": 77,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        234,
        237,
        235,
        239,
        245,
        228,
        228,
        242,
        234,
        237,
        235,
        239,
        245,
        228,
        228
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 141
    },
    "142": {
      "source": "node_modules/bcryptjs/dist/bcrypt.js:306:20:306:20",
      "startTime": "928732041309239",
      "endTime": "928732120697258",
      "elapsedTime": "79388019",
      "asyncId": 228,
      "triggerAsyncId": 226,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.bcrypt.compare",
      "userCode": false,
      "triggers": [
        234,
        249,
        255,
        248,
        247,
        246,
        253,
        257,
        263,
        229,
        246,
        249,
        247,
        251,
        255,
        229,
        230
      ],
      "line": "\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);",
      "startLine": 306,
      "startCol": 20,
      "endLine": 306,
      "endCol": 20,
      "file": "node_modules/bcryptjs/dist/bcrypt.js",
      "uniqueid": 142
    },
    "143": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731767246155",
      "endTime": "928731783180224",
      "elapsedTime": "15934069",
      "asyncId": 229,
      "triggerAsyncId": 228,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        232,
        237
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 143
    },
    "144": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:74:19:74:19",
      "startTime": "928732119925451",
      "endTime": "928732120843212",
      "elapsedTime": "917761",
      "asyncId": 230,
      "triggerAsyncId": 228,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        231,
        244,
        231,
        238
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }])",
      "startLine": 74,
      "startCol": 19,
      "endLine": 74,
      "endCol": 19,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 144
    },
    "145": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732132058946",
      "endTime": "928732305082203",
      "elapsedTime": "173023257",
      "asyncId": 231,
      "triggerAsyncId": 82,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        242,
        233,
        239
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 145
    },
    "146": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732136821104",
      "endTime": "928732136848244",
      "elapsedTime": "27140",
      "asyncId": 232,
      "triggerAsyncId": 82,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        233,
        233,
        235,
        238
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 146
    },
    "147": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732137494456",
      "endTime": "928732137522108",
      "elapsedTime": "27652",
      "asyncId": 234,
      "triggerAsyncId": 82,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        242,
        236,
        236,
        244,
        247,
        236,
        245,
        249,
        255,
        235,
        235,
        235,
        235
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 147
    },
    "148": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732137839743",
      "endTime": "928732141640197",
      "elapsedTime": "3800454",
      "asyncId": 235,
      "triggerAsyncId": 234,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        237,
        241,
        236,
        241,
        256,
        259,
        257,
        261,
        265,
        236,
        242,
        245,
        243,
        247,
        253,
        236,
        236
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 148
    },
    "149": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732138127112",
      "endTime": "928732304921121",
      "elapsedTime": "166794009",
      "asyncId": 236,
      "triggerAsyncId": 235,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        262,
        256,
        255,
        254,
        260,
        264,
        268,
        237
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 149
    },
    "150": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732138372542",
      "endTime": "928732305120996",
      "elapsedTime": "166748454",
      "asyncId": 237,
      "triggerAsyncId": 236,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        238,
        238,
        238,
        238
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 150
    },
    "151": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732138559773",
      "endTime": "928732305155851",
      "elapsedTime": "166596078",
      "asyncId": 238,
      "triggerAsyncId": 82,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        245,
        248,
        246,
        250,
        256,
        239,
        239,
        253,
        239,
        239
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 151
    },
    "152": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732138947650",
      "endTime": "928732138970362",
      "elapsedTime": "22712",
      "asyncId": 240,
      "triggerAsyncId": 82,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        256,
        263,
        259,
        266,
        272,
        241,
        241
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 152
    },
    "153": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731768724917",
      "endTime": "928731784026451",
      "elapsedTime": "15301534",
      "asyncId": 241,
      "triggerAsyncId": 223,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        250
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 153
    },
    "154": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732139417731",
      "endTime": "928732139457696",
      "elapsedTime": "39965",
      "asyncId": 242,
      "triggerAsyncId": 235,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        244
      ],
      "uniqueid": 154
    },
    "155": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732139631241",
      "endTime": "928732141125933",
      "elapsedTime": "1494692",
      "asyncId": 243,
      "triggerAsyncId": 235,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        258,
        249,
        245,
        249
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 155
    },
    "156": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732139994012",
      "endTime": "928732140023697",
      "elapsedTime": "29685",
      "asyncId": 245,
      "triggerAsyncId": 235,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        253,
        247,
        251
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 156
    },
    "157": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731784132510",
      "endTime": "928731784247365",
      "elapsedTime": "114855",
      "asyncId": 246,
      "triggerAsyncId": 225,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        247,
        252,
        254,
        248
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 157
    },
    "158": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732140405824",
      "endTime": "928732141546672",
      "elapsedTime": "1140848",
      "asyncId": 247,
      "triggerAsyncId": 235,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        252,
        253
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 158
    },
    "159": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731785048657",
      "endTime": "928731786705703",
      "elapsedTime": "1657046",
      "asyncId": 248,
      "triggerAsyncId": 225,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        249,
        251,
        251
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 159
    },
    "160": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732140699604",
      "endTime": "928732141588290",
      "elapsedTime": "888686",
      "asyncId": 249,
      "triggerAsyncId": 243,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        254,
        250,
        250
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 160
    },
    "161": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731785571748",
      "endTime": "928731786798507",
      "elapsedTime": "1226759",
      "asyncId": 250,
      "triggerAsyncId": 244,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        260
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 161
    },
    "162": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732141107579",
      "endTime": "928732305309209",
      "elapsedTime": "164201630",
      "asyncId": 251,
      "triggerAsyncId": 82,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        252
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 162
    },
    "163": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732141502299",
      "endTime": "928732141678048",
      "elapsedTime": "175749",
      "asyncId": 253,
      "triggerAsyncId": 235,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        254,
        259,
        261
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 163
    },
    "164": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732141889635",
      "endTime": "928732304600370",
      "elapsedTime": "162710735",
      "asyncId": 254,
      "triggerAsyncId": 236,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        255,
        255,
        261
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 164
    },
    "165": {
      "source": "node_modules/jest-each/build/bind.js:76:13:76:13",
      "startTime": "928732142147709",
      "endTime": "928732304529226",
      "elapsedTime": "162381517",
      "asyncId": 255,
      "triggerAsyncId": 236,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        256,
        259
      ],
      "line": "\n  supportsDone && params.length < test.length\n    ? done => test(...params, done)\n    : () => test(...params);",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-each/build/bind.js",
      "uniqueid": 165
    },
    "166": {
      "source": "node_modules/bcryptjs/dist/bcrypt.js:222:20:222:20",
      "startTime": "928732142442622",
      "endTime": "928732223034608",
      "elapsedTime": "80591986",
      "asyncId": 256,
      "triggerAsyncId": 236,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.bcrypt.hash",
      "userCode": false,
      "triggers": [
        257,
        257,
        258,
        257,
        257,
        265,
        258
      ],
      "line": "\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);",
      "startLine": 222,
      "startCol": 20,
      "endLine": 222,
      "endCol": 20,
      "file": "node_modules/bcryptjs/dist/bcrypt.js",
      "uniqueid": 166
    },
    "167": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731786363752",
      "endTime": "928731809352106",
      "elapsedTime": "22988354",
      "asyncId": 257,
      "triggerAsyncId": 60,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        259,
        258,
        263,
        262,
        264,
        267,
        265,
        269,
        275,
        258,
        258,
        262
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 167
    },
    "168": {
      "source": "node_modules/jest-each/build/bind.js:76:13:76:13",
      "startTime": "928732142681900",
      "endTime": "928732224203920",
      "elapsedTime": "81522020",
      "asyncId": 258,
      "triggerAsyncId": 256,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        264,
        260,
        276,
        279,
        277,
        281,
        285,
        259,
        272,
        271
      ],
      "line": "\n  supportsDone && params.length < test.length\n    ? done => test(...params, done)\n    : () => test(...params);",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-each/build/bind.js",
      "uniqueid": 168
    },
    "169": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928732142877918",
      "endTime": "928732304640836",
      "elapsedTime": "161762918",
      "asyncId": 259,
      "triggerAsyncId": 255,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        261
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 169
    },
    "170": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732143052174",
      "endTime": "928732304677104",
      "elapsedTime": "161624930",
      "asyncId": 260,
      "triggerAsyncId": 236,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        261,
        261,
        261,
        266
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 170
    },
    "171": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732143390869",
      "endTime": "928732143425354",
      "elapsedTime": "34485",
      "asyncId": 262,
      "triggerAsyncId": 236,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        277,
        279,
        283,
        270,
        263
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 171
    },
    "172": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731789252848",
      "endTime": "928731809450430",
      "elapsedTime": "20197582",
      "asyncId": 263,
      "triggerAsyncId": 262,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        264
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 172
    },
    "173": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732143814864",
      "endTime": "928732304812668",
      "elapsedTime": "160997804",
      "asyncId": 264,
      "triggerAsyncId": 236,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        265,
        265,
        266
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 173
    },
    "174": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732144063670",
      "endTime": "928732304860187",
      "elapsedTime": "160796517",
      "asyncId": 266,
      "triggerAsyncId": 260,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        268,
        274,
        275
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 174
    },
    "175": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731785930911",
      "endTime": "928731827928900",
      "elapsedTime": "41997989",
      "asyncId": 267,
      "triggerAsyncId": 64,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        275,
        272,
        272
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 175
    },
    "176": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732144399219",
      "endTime": "928732304955506",
      "elapsedTime": "160556287",
      "asyncId": 268,
      "triggerAsyncId": 236,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        269,
        276
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 176
    },
    "177": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731796114100",
      "endTime": "928731798712842",
      "elapsedTime": "2598742",
      "asyncId": 269,
      "triggerAsyncId": 257,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        271,
        270,
        270
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 177
    },
    "178": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928731787518637",
      "endTime": "928731787619877",
      "elapsedTime": "101240",
      "asyncId": 270,
      "triggerAsyncId": 64,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        271,
        271,
        273,
        277,
        280,
        278,
        282,
        288,
        271,
        271,
        271,
        271
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 178
    },
    "179": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:74:25:74:25",
      "startTime": "928732223539865",
      "endTime": "928732304050359",
      "elapsedTime": "80510494",
      "asyncId": 271,
      "triggerAsyncId": 258,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        278,
        281,
        279,
        283,
        289,
        272,
        272,
        274,
        292,
        298,
        291,
        290,
        289,
        296,
        300,
        306,
        272,
        279,
        281,
        287,
        272,
        272,
        278,
        285,
        301,
        289
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }])",
      "startLine": 74,
      "startCol": 25,
      "endLine": 74,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 179
    },
    "180": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:65:45:65:45",
      "startTime": "928732223814810",
      "endTime": "928732223845909",
      "elapsedTime": "31099",
      "asyncId": 272,
      "triggerAsyncId": 258,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        290,
        293,
        291,
        295,
        299,
        273,
        275,
        282,
        285,
        283,
        287,
        293,
        273,
        273,
        273,
        273
      ],
      "line": "\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() ",
      "startLine": 65,
      "startCol": 45,
      "endLine": 65,
      "endCol": 45,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 180
    },
    "181": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:74:25:74:25",
      "startTime": "928732224034382",
      "endTime": "928732302753047",
      "elapsedTime": "78718665",
      "asyncId": 273,
      "triggerAsyncId": 272,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        294,
        297,
        295,
        299,
        303,
        274,
        275
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }])",
      "startLine": 74,
      "startCol": 25,
      "endLine": 74,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 181
    },
    "182": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731789378153",
      "endTime": "928731828152188",
      "elapsedTime": "38774035",
      "asyncId": 274,
      "triggerAsyncId": 64,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 182
    },
    "183": {
      "source": "node_modules/bcryptjs/dist/bcrypt.js:306:20:306:20",
      "startTime": "928732224458136",
      "endTime": "928732303971471",
      "elapsedTime": "79513335",
      "asyncId": 275,
      "triggerAsyncId": 273,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.bcrypt.compare",
      "userCode": false,
      "triggers": [
        276,
        277
      ],
      "line": "\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);",
      "startLine": 306,
      "startCol": 20,
      "endLine": 306,
      "endCol": 20,
      "file": "node_modules/bcryptjs/dist/bcrypt.js",
      "uniqueid": 183
    },
    "184": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:74:19:74:19",
      "startTime": "928732302731637",
      "endTime": "928732304089562",
      "elapsedTime": "1357925",
      "asyncId": 277,
      "triggerAsyncId": 275,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        278,
        279,
        283
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }])",
      "startLine": 74,
      "startCol": 19,
      "endLine": 74,
      "endCol": 19,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 184
    },
    "185": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732305582390",
      "endTime": "928732470126933",
      "elapsedTime": "164544543",
      "asyncId": 278,
      "triggerAsyncId": 83,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        280,
        281,
        284,
        286,
        286
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 185
    },
    "186": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732305935532",
      "endTime": "928732305960710",
      "elapsedTime": "25178",
      "asyncId": 279,
      "triggerAsyncId": 83,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        285,
        280
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 186
    },
    "187": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731744397343",
      "endTime": "928731744489786",
      "elapsedTime": "92443",
      "asyncId": 280,
      "triggerAsyncId": 270,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        282
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 187
    },
    "188": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732306526380",
      "endTime": "928732306554443",
      "elapsedTime": "28063",
      "asyncId": 281,
      "triggerAsyncId": 83,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        284,
        282,
        282,
        282,
        282
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 188
    },
    "189": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732306869774",
      "endTime": "928732311995552",
      "elapsedTime": "5125778",
      "asyncId": 282,
      "triggerAsyncId": 281,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        285,
        292,
        295,
        293,
        284,
        297,
        303,
        283,
        283,
        289,
        292,
        290,
        294,
        300,
        283,
        283
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 189
    },
    "190": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732307174575",
      "endTime": "928732470030292",
      "elapsedTime": "162855717",
      "asyncId": 283,
      "triggerAsyncId": 282,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        286,
        289,
        307,
        313,
        306,
        305,
        304,
        311,
        315,
        332,
        284,
        309,
        303,
        302,
        301,
        307,
        311,
        315,
        284
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 190
    },
    "191": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732307406801",
      "endTime": "928732470161267",
      "elapsedTime": "162754466",
      "asyncId": 284,
      "triggerAsyncId": 283,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 191
    },
    "192": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732307585736",
      "endTime": "928732470191544",
      "elapsedTime": "162605808",
      "asyncId": 285,
      "triggerAsyncId": 83,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 192
    },
    "193": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732307929340",
      "endTime": "928732307946963",
      "elapsedTime": "17623",
      "asyncId": 287,
      "triggerAsyncId": 83,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 193
    },
    "194": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732308405422",
      "endTime": "928732308436982",
      "elapsedTime": "31560",
      "asyncId": 289,
      "triggerAsyncId": 282,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        304,
        297,
        290,
        290,
        291
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 194
    },
    "195": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732308609796",
      "endTime": "928732311489514",
      "elapsedTime": "2879718",
      "asyncId": 290,
      "triggerAsyncId": 282,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        292,
        295,
        297,
        300,
        298,
        302,
        308,
        291,
        291,
        296
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 195
    },
    "196": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732308922432",
      "endTime": "928732308939423",
      "elapsedTime": "16991",
      "asyncId": 292,
      "triggerAsyncId": 282,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        293,
        293,
        294
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 196
    },
    "197": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731813124197",
      "endTime": "928731826783953",
      "elapsedTime": "13659756",
      "asyncId": 293,
      "triggerAsyncId": 79,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        303,
        299
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 197
    },
    "198": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732309310930",
      "endTime": "928732311878313",
      "elapsedTime": "2567383",
      "asyncId": 294,
      "triggerAsyncId": 282,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        295,
        297,
        296
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 198
    },
    "199": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731813826183",
      "endTime": "928731813917324",
      "elapsedTime": "91141",
      "asyncId": 295,
      "triggerAsyncId": 79,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        300,
        296,
        301
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 199
    },
    "200": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732309564646",
      "endTime": "928732311918668",
      "elapsedTime": "2354022",
      "asyncId": 296,
      "triggerAsyncId": 290,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        302
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 200
    },
    "201": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731814663012",
      "endTime": "928731814727272",
      "elapsedTime": "64260",
      "asyncId": 297,
      "triggerAsyncId": 290,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        298,
        299
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 201
    },
    "202": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732311460920",
      "endTime": "928732470306690",
      "elapsedTime": "158845770",
      "asyncId": 298,
      "triggerAsyncId": 83,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        304
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 202
    },
    "203": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732311842957",
      "endTime": "928732312046719",
      "elapsedTime": "203762",
      "asyncId": 300,
      "triggerAsyncId": 282,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        301
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 203
    },
    "204": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732312218481",
      "endTime": "928732469782728",
      "elapsedTime": "157564247",
      "asyncId": 301,
      "triggerAsyncId": 283,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        316,
        302,
        308
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 204
    },
    "205": {
      "source": "node_modules/jest-each/build/bind.js:76:13:76:13",
      "startTime": "928732312438623",
      "endTime": "928732469730560",
      "elapsedTime": "157291937",
      "asyncId": 302,
      "triggerAsyncId": 283,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        303,
        306
      ],
      "line": "\n  supportsDone && params.length < test.length\n    ? done => test(...params, done)\n    : () => test(...params);",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-each/build/bind.js",
      "uniqueid": 205
    },
    "206": {
      "source": "node_modules/bcryptjs/dist/bcrypt.js:222:20:222:20",
      "startTime": "928732312716384",
      "endTime": "928732390957684",
      "elapsedTime": "78241300",
      "asyncId": 303,
      "triggerAsyncId": 283,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.bcrypt.hash",
      "userCode": false,
      "triggers": [
        311,
        304,
        305
      ],
      "line": "\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);",
      "startLine": 222,
      "startCol": 20,
      "endLine": 222,
      "endCol": 20,
      "file": "node_modules/bcryptjs/dist/bcrypt.js",
      "uniqueid": 206
    },
    "207": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731803322914",
      "endTime": "928731825745977",
      "elapsedTime": "22423063",
      "asyncId": 304,
      "triggerAsyncId": 283,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        305,
        307,
        312
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 207
    },
    "208": {
      "source": "node_modules/jest-each/build/bind.js:76:13:76:13",
      "startTime": "928732312956514",
      "endTime": "928732391728950",
      "elapsedTime": "78772436",
      "asyncId": 305,
      "triggerAsyncId": 303,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        310,
        320,
        319,
        318
      ],
      "line": "\n  supportsDone && params.length < test.length\n    ? done => test(...params, done)\n    : () => test(...params);",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-each/build/bind.js",
      "uniqueid": 208
    },
    "209": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928732313158803",
      "endTime": "928732469816381",
      "elapsedTime": "156657578",
      "asyncId": 306,
      "triggerAsyncId": 302,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        307,
        309,
        309
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 209
    },
    "210": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732313324824",
      "endTime": "928732469847770",
      "elapsedTime": "156522946",
      "asyncId": 307,
      "triggerAsyncId": 283,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        312,
        308,
        308,
        308,
        315,
        313
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 210
    },
    "211": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732313627121",
      "endTime": "928732313644564",
      "elapsedTime": "17443",
      "asyncId": 309,
      "triggerAsyncId": 283,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        310,
        317,
        311
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 211
    },
    "212": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928731806844986",
      "endTime": "928731825859420",
      "elapsedTime": "19014434",
      "asyncId": 310,
      "triggerAsyncId": 305,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [
        316,
        311,
        313
      ],
      "uniqueid": 212
    },
    "213": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732314121418",
      "endTime": "928732469931967",
      "elapsedTime": "155810549",
      "asyncId": 311,
      "triggerAsyncId": 283,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        317,
        316,
        312
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 213
    },
    "214": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732314406302",
      "endTime": "928732469970269",
      "elapsedTime": "155563967",
      "asyncId": 313,
      "triggerAsyncId": 307,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        314,
        320,
        323,
        321,
        325,
        331,
        314,
        314,
        314
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 214
    },
    "215": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732314751338",
      "endTime": "928732470060989",
      "elapsedTime": "155309651",
      "asyncId": 315,
      "triggerAsyncId": 283,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 215
    },
    "216": {
      "source": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js:456:14:456:14",
      "startTime": "928731828411674",
      "endTime": "928731828707219",
      "elapsedTime": "295545",
      "asyncId": 316,
      "triggerAsyncId": 311,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " onDOMContentLoad",
      "userCode": false,
      "line": "\n      }\n\n      return new Promise(resolve => {\n        if (!this._deferQueue.tail) {\n          dispatchEvent();\n          return resolve()",
      "startLine": 456,
      "startCol": 14,
      "endLine": 456,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js",
      "triggers": [
        317
      ],
      "uniqueid": 216
    },
    "217": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:80:14:80:14",
      "startTime": "928731829109833",
      "endTime": "928731830444656",
      "elapsedTime": "1334823",
      "asyncId": 317,
      "triggerAsyncId": 316,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.check",
      "userCode": false,
      "triggers": [
        318
      ],
      "line": "\n\n          Promise.resolve(promise)\n            .then(() => {\n              if (this.next) {\n                this.next.prev = null;\n                this.next.check()",
      "startLine": 80,
      "startCol": 14,
      "endLine": 80,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "uniqueid": 217
    },
    "218": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:74:25:74:25",
      "startTime": "928732391192033",
      "endTime": "928732469275146",
      "elapsedTime": "78083113",
      "asyncId": 318,
      "triggerAsyncId": 305,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        328,
        319
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }])",
      "startLine": 74,
      "startCol": 25,
      "endLine": 74,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 218
    },
    "219": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:65:45:65:45",
      "startTime": "928732391409320",
      "endTime": "928732391423747",
      "elapsedTime": "14427",
      "asyncId": 319,
      "triggerAsyncId": 305,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        329,
        327,
        320
      ],
      "line": "\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() ",
      "startLine": 65,
      "startCol": 45,
      "endLine": 65,
      "endCol": 45,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 219
    },
    "220": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:74:25:74:25",
      "startTime": "928732391582805",
      "endTime": "928732469147076",
      "elapsedTime": "77564271",
      "asyncId": 320,
      "triggerAsyncId": 319,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        322,
        339,
        322
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }])",
      "startLine": 74,
      "startCol": 25,
      "endLine": 74,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 220
    },
    "221": {
      "source": "packages/strapi-admin/node_modules/p-map/index.js:70:6:70:6",
      "startTime": "928731811955356",
      "endTime": "928731823344406",
      "elapsedTime": "11389050",
      "asyncId": 321,
      "triggerAsyncId": 308,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " next",
      "userCode": false,
      "triggers": [
        327,
        322
      ],
      "line": "\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\tfor (let i = 0; i < concurrency; i++) ",
      "startLine": 70,
      "startCol": 6,
      "endLine": 70,
      "endCol": 6,
      "file": "packages/strapi-admin/node_modules/p-map/index.js",
      "uniqueid": 221
    },
    "222": {
      "source": "node_modules/bcryptjs/dist/bcrypt.js:306:20:306:20",
      "startTime": "928732391922813",
      "endTime": "928732469228919",
      "elapsedTime": "77306106",
      "asyncId": 322,
      "triggerAsyncId": 320,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.bcrypt.compare",
      "userCode": false,
      "triggers": [
        323,
        323,
        323,
        324
      ],
      "line": "\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);",
      "startLine": 306,
      "startCol": 20,
      "endLine": 306,
      "endCol": 20,
      "file": "node_modules/bcryptjs/dist/bcrypt.js",
      "uniqueid": 222
    },
    "223": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731829559897",
      "endTime": "928731836077244",
      "elapsedTime": "6517347",
      "asyncId": 323,
      "triggerAsyncId": 322,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        334,
        333,
        333,
        330,
        333,
        331,
        335,
        341,
        324,
        324
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 223
    },
    "224": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:74:19:74:19",
      "startTime": "928732469130565",
      "endTime": "928732469307437",
      "elapsedTime": "176872",
      "asyncId": 324,
      "triggerAsyncId": 322,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        325,
        342,
        345,
        343,
        347,
        351,
        325
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }])",
      "startLine": 74,
      "startCol": 19,
      "endLine": 74,
      "endCol": 19,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 224
    },
    "225": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732470529958",
      "endTime": "928732630743041",
      "elapsedTime": "160213083",
      "asyncId": 325,
      "triggerAsyncId": 84,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        326,
        333
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 225
    },
    "226": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732470925530",
      "endTime": "928732470944676",
      "elapsedTime": "19146",
      "asyncId": 326,
      "triggerAsyncId": 84,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        337,
        336,
        336
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 226
    },
    "227": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732471550943",
      "endTime": "928732471565319",
      "elapsedTime": "14376",
      "asyncId": 328,
      "triggerAsyncId": 84,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        329,
        329
      ],
      "uniqueid": 227
    },
    "228": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732471893394",
      "endTime": "928732475124331",
      "elapsedTime": "3230937",
      "asyncId": 329,
      "triggerAsyncId": 328,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        336,
        339,
        337,
        341,
        347,
        330,
        330
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 228
    },
    "229": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732472192475",
      "endTime": "928732630653634",
      "elapsedTime": "158461159",
      "asyncId": 330,
      "triggerAsyncId": 329,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        332,
        356,
        350,
        349,
        348,
        354,
        358,
        362,
        331
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 229
    },
    "230": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732472439308",
      "endTime": "928732630774951",
      "elapsedTime": "158335643",
      "asyncId": 331,
      "triggerAsyncId": 330,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        337
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 230
    },
    "231": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732472623563",
      "endTime": "928732630804045",
      "elapsedTime": "158180482",
      "asyncId": 332,
      "triggerAsyncId": 84,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        340
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 231
    },
    "232": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732472977216",
      "endTime": "928732472992465",
      "elapsedTime": "15249",
      "asyncId": 334,
      "triggerAsyncId": 84,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        337,
        340
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 232
    },
    "233": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731833946580",
      "endTime": "928731835842194",
      "elapsedTime": "1895614",
      "asyncId": 335,
      "triggerAsyncId": 323,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        336
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 233
    },
    "234": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732473428792",
      "endTime": "928732473456855",
      "elapsedTime": "28063",
      "asyncId": 336,
      "triggerAsyncId": 329,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        346,
        338,
        338
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 234
    },
    "235": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732473628277",
      "endTime": "928732474719823",
      "elapsedTime": "1091546",
      "asyncId": 337,
      "triggerAsyncId": 329,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        341,
        343
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 235
    },
    "236": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732473920654",
      "endTime": "928732473935422",
      "elapsedTime": "14768",
      "asyncId": 339,
      "triggerAsyncId": 329,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        345
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 236
    },
    "237": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731822264962",
      "endTime": "928731822908559",
      "elapsedTime": "643597",
      "asyncId": 340,
      "triggerAsyncId": 334,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 237
    },
    "238": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732474231688",
      "endTime": "928732475036917",
      "elapsedTime": "805229",
      "asyncId": 341,
      "triggerAsyncId": 329,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 238
    },
    "239": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731836424315",
      "endTime": "928731838868467",
      "elapsedTime": "2444152",
      "asyncId": 342,
      "triggerAsyncId": 324,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        344
      ],
      "uniqueid": 239
    },
    "240": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732474435410",
      "endTime": "928732475071352",
      "elapsedTime": "635942",
      "asyncId": 343,
      "triggerAsyncId": 337,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        349,
        358
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 240
    },
    "241": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732474704544",
      "endTime": "928732630911116",
      "elapsedTime": "156206572",
      "asyncId": 345,
      "triggerAsyncId": 84,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        353
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 241
    },
    "242": {
      "source": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js:132:11:132:11",
      "startTime": "928731837273397",
      "endTime": "928731837338339",
      "elapsedTime": "64942",
      "asyncId": 346,
      "triggerAsyncId": 51,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueMutationObserverMicrotask",
      "userCode": false,
      "triggers": [
        347,
        347
      ],
      "line": "\n  mutationObserverMicrotaskQueueFlag = true;\n\n  Promise.resolve().then(() => {\n    notifyMutationObservers();\n  });\n",
      "startLine": 132,
      "startCol": 11,
      "endLine": 132,
      "endCol": 11,
      "file": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js",
      "uniqueid": 242
    },
    "243": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732475000269",
      "endTime": "928732475157132",
      "elapsedTime": "156863",
      "asyncId": 347,
      "triggerAsyncId": 329,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        350
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 243
    },
    "244": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732475302655",
      "endTime": "928732630449932",
      "elapsedTime": "155147277",
      "asyncId": 348,
      "triggerAsyncId": 330,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        349,
        351,
        355
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 244
    },
    "245": {
      "source": "node_modules/jest-each/build/bind.js:76:13:76:13",
      "startTime": "928732475491960",
      "endTime": "928732630403695",
      "elapsedTime": "154911735",
      "asyncId": 349,
      "triggerAsyncId": 330,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        354,
        350,
        353
      ],
      "line": "\n  supportsDone && params.length < test.length\n    ? done => test(...params, done)\n    : () => test(...params);",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-each/build/bind.js",
      "uniqueid": 245
    },
    "246": {
      "source": "node_modules/bcryptjs/dist/bcrypt.js:222:20:222:20",
      "startTime": "928732475751156",
      "endTime": "928732553277836",
      "elapsedTime": "77526680",
      "asyncId": 350,
      "triggerAsyncId": 330,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.bcrypt.hash",
      "userCode": false,
      "triggers": [
        351,
        352
      ],
      "line": "\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);",
      "startLine": 222,
      "startCol": 20,
      "endLine": 222,
      "endCol": 20,
      "file": "node_modules/bcryptjs/dist/bcrypt.js",
      "uniqueid": 246
    },
    "247": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:116:8:116:8",
      "startTime": "928731840893974",
      "endTime": "928731846352246",
      "elapsedTime": "5458272",
      "asyncId": 351,
      "triggerAsyncId": 348,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " ResourceQueue.push",
      "userCode": false,
      "line": "\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check()",
      "startLine": 116,
      "startCol": 8,
      "endLine": 116,
      "endCol": 8,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "triggers": [
        352
      ],
      "uniqueid": 247
    },
    "248": {
      "source": "node_modules/jest-each/build/bind.js:76:13:76:13",
      "startTime": "928732475950279",
      "endTime": "928732553999549",
      "elapsedTime": "78049270",
      "asyncId": 352,
      "triggerAsyncId": 350,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        360,
        360,
        366,
        365
      ],
      "line": "\n  supportsDone && params.length < test.length\n    ? done => test(...params, done)\n    : () => test(...params);",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-each/build/bind.js",
      "uniqueid": 248
    },
    "249": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928732476117884",
      "endTime": "928732630480058",
      "elapsedTime": "154362174",
      "asyncId": 353,
      "triggerAsyncId": 349,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 249
    },
    "250": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732476245122",
      "endTime": "928732630508502",
      "elapsedTime": "154263380",
      "asyncId": 354,
      "triggerAsyncId": 330,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        355,
        360
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 250
    },
    "251": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732476497786",
      "endTime": "928732476516130",
      "elapsedTime": "18344",
      "asyncId": 356,
      "triggerAsyncId": 330,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        363,
        366,
        364,
        368,
        374,
        357,
        357,
        363,
        357,
        366,
        364,
        368,
        374,
        357,
        357
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 251
    },
    "252": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731845490781",
      "endTime": "928731858874690",
      "elapsedTime": "13383909",
      "asyncId": 357,
      "triggerAsyncId": 356,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        378,
        384,
        377,
        376,
        375,
        382,
        386,
        392,
        358,
        375,
        378,
        376,
        380,
        384,
        358
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 252
    },
    "253": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732476844195",
      "endTime": "928732630577631",
      "elapsedTime": "153733436",
      "asyncId": 358,
      "triggerAsyncId": 330,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 253
    },
    "254": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732477053627",
      "endTime": "928732630607297",
      "elapsedTime": "153553670",
      "asyncId": 360,
      "triggerAsyncId": 354,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 254
    },
    "255": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732477316821",
      "endTime": "928732630684952",
      "elapsedTime": "153368131",
      "asyncId": 362,
      "triggerAsyncId": 330,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 255
    },
    "256": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731847353462",
      "endTime": "928731847434364",
      "elapsedTime": "80902",
      "asyncId": 363,
      "triggerAsyncId": 356,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        365,
        365
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 256
    },
    "257": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731847755456",
      "endTime": "928731852094019",
      "elapsedTime": "4338563",
      "asyncId": 364,
      "triggerAsyncId": 356,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        370,
        370
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 257
    },
    "258": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:74:25:74:25",
      "startTime": "928732553478973",
      "endTime": "928732630087733",
      "elapsedTime": "76608760",
      "asyncId": 365,
      "triggerAsyncId": 352,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }])",
      "startLine": 74,
      "startCol": 25,
      "endLine": 74,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [],
      "uniqueid": 258
    },
    "259": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:65:45:65:45",
      "startTime": "928732553676974",
      "endTime": "928732553691812",
      "elapsedTime": "14838",
      "asyncId": 366,
      "triggerAsyncId": 352,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() ",
      "startLine": 65,
      "startCol": 45,
      "endLine": 65,
      "endCol": 45,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [
        367
      ],
      "uniqueid": 259
    },
    "260": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:74:25:74:25",
      "startTime": "928732553862302",
      "endTime": "928732629956827",
      "elapsedTime": "76094525",
      "asyncId": 367,
      "triggerAsyncId": 366,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }])",
      "startLine": 74,
      "startCol": 25,
      "endLine": 74,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [
        369
      ],
      "uniqueid": 260
    },
    "261": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731850952339",
      "endTime": "928731852865876",
      "elapsedTime": "1913537",
      "asyncId": 368,
      "triggerAsyncId": 356,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 261
    },
    "262": {
      "source": "node_modules/bcryptjs/dist/bcrypt.js:306:20:306:20",
      "startTime": "928732554191238",
      "endTime": "928732630042328",
      "elapsedTime": "75851090",
      "asyncId": 369,
      "triggerAsyncId": 367,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.bcrypt.compare",
      "userCode": false,
      "line": "\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);",
      "startLine": 306,
      "startCol": 20,
      "endLine": 306,
      "endCol": 20,
      "file": "node_modules/bcryptjs/dist/bcrypt.js",
      "triggers": [
        371
      ],
      "uniqueid": 262
    },
    "263": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731851340687",
      "endTime": "928731852944764",
      "elapsedTime": "1604077",
      "asyncId": 370,
      "triggerAsyncId": 364,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 263
    },
    "264": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:74:19:74:19",
      "startTime": "928732629941599",
      "endTime": "928732630118230",
      "elapsedTime": "176631",
      "asyncId": 371,
      "triggerAsyncId": 369,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }])",
      "startLine": 74,
      "startCol": 19,
      "endLine": 74,
      "endCol": 19,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [],
      "uniqueid": 264
    },
    "265": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732631817976",
      "endTime": "928732631832744",
      "elapsedTime": "14768",
      "asyncId": 375,
      "triggerAsyncId": 85,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        383,
        377,
        376,
        376
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 265
    },
    "266": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732632090708",
      "endTime": "928732634832417",
      "elapsedTime": "2741709",
      "asyncId": 376,
      "triggerAsyncId": 375,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        381,
        382,
        383,
        386,
        384,
        388,
        394,
        377,
        377
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 266
    },
    "267": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732632313876",
      "endTime": "928732790123834",
      "elapsedTime": "157809958",
      "asyncId": 377,
      "triggerAsyncId": 376,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        380,
        403,
        397,
        396,
        395,
        401,
        405,
        409,
        378
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 267
    },
    "268": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732632497540",
      "endTime": "928732790242746",
      "elapsedTime": "157745206",
      "asyncId": 378,
      "triggerAsyncId": 377,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        379
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 268
    },
    "269": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732632634196",
      "endTime": "928732790273114",
      "elapsedTime": "157638918",
      "asyncId": 379,
      "triggerAsyncId": 85,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        389
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 269
    },
    "270": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732632914412",
      "endTime": "928732632928608",
      "elapsedTime": "14196",
      "asyncId": 381,
      "triggerAsyncId": 85,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 270
    },
    "271": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731857917145",
      "endTime": "928731858765385",
      "elapsedTime": "848240",
      "asyncId": 382,
      "triggerAsyncId": 376,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        388
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 271
    },
    "272": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732633258707",
      "endTime": "928732633279496",
      "elapsedTime": "20789",
      "asyncId": 383,
      "triggerAsyncId": 376,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        385
      ],
      "uniqueid": 272
    },
    "273": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732633420811",
      "endTime": "928732634449399",
      "elapsedTime": "1028588",
      "asyncId": 384,
      "triggerAsyncId": 376,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        390
      ],
      "uniqueid": 273
    },
    "274": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732633664778",
      "endTime": "928732633678664",
      "elapsedTime": "13886",
      "asyncId": 386,
      "triggerAsyncId": 376,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 274
    },
    "275": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732633966043",
      "endTime": "928732634753379",
      "elapsedTime": "787336",
      "asyncId": 388,
      "triggerAsyncId": 376,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        389,
        389
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 275
    },
    "276": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731861503147",
      "endTime": "928731867631615",
      "elapsedTime": "6128468",
      "asyncId": 389,
      "triggerAsyncId": 388,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        390,
        396,
        399,
        397,
        401,
        407,
        390,
        390
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 276
    },
    "277": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732634169073",
      "endTime": "928732634786601",
      "elapsedTime": "617528",
      "asyncId": 390,
      "triggerAsyncId": 384,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        393,
        408,
        411,
        409,
        413,
        417,
        391
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 277
    },
    "278": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731862298819",
      "endTime": "928731875640849",
      "elapsedTime": "13342030",
      "asyncId": 391,
      "triggerAsyncId": 390,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 278
    },
    "279": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732634434241",
      "endTime": "928732790380936",
      "elapsedTime": "155946695",
      "asyncId": 392,
      "triggerAsyncId": 85,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 279
    },
    "280": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732634725657",
      "endTime": "928732634860169",
      "elapsedTime": "134512",
      "asyncId": 394,
      "triggerAsyncId": 376,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 280
    },
    "281": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732635011823",
      "endTime": "928732789895335",
      "elapsedTime": "154883512",
      "asyncId": 395,
      "triggerAsyncId": 377,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        403,
        402
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 281
    },
    "282": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732635322976",
      "endTime": "928732789847075",
      "elapsedTime": "154524099",
      "asyncId": 396,
      "triggerAsyncId": 377,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        398,
        400
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 282
    },
    "283": {
      "source": "node_modules/bcryptjs/dist/bcrypt.js:222:20:222:20",
      "startTime": "928732635532028",
      "endTime": "928732712930538",
      "elapsedTime": "77398510",
      "asyncId": 397,
      "triggerAsyncId": 377,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.bcrypt.hash",
      "userCode": false,
      "triggers": [
        403,
        399
      ],
      "line": "\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);",
      "startLine": 222,
      "startCol": 20,
      "endLine": 222,
      "endCol": 20,
      "file": "node_modules/bcryptjs/dist/bcrypt.js",
      "uniqueid": 283
    },
    "284": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732635724299",
      "endTime": "928732713668542",
      "elapsedTime": "77944243",
      "asyncId": 399,
      "triggerAsyncId": 397,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        406,
        409,
        407,
        411,
        417,
        400,
        400,
        413,
        412
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 284
    },
    "285": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928732635882415",
      "endTime": "928732789925652",
      "elapsedTime": "154043237",
      "asyncId": 400,
      "triggerAsyncId": 396,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        421,
        427,
        420,
        419,
        418,
        425,
        429,
        435,
        401
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 285
    },
    "286": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732636012619",
      "endTime": "928732789955478",
      "elapsedTime": "153942859",
      "asyncId": 401,
      "triggerAsyncId": 377,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        407
      ],
      "uniqueid": 286
    },
    "287": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732636261836",
      "endTime": "928732636276314",
      "elapsedTime": "14478",
      "asyncId": 403,
      "triggerAsyncId": 377,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 287
    },
    "288": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732636570375",
      "endTime": "928732790044094",
      "elapsedTime": "153473719",
      "asyncId": 405,
      "triggerAsyncId": 377,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 288
    },
    "289": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731814351548",
      "endTime": "928731814406852",
      "elapsedTime": "55304",
      "asyncId": 406,
      "triggerAsyncId": 399,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        408
      ],
      "uniqueid": 289
    },
    "290": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732636762004",
      "endTime": "928732790077166",
      "elapsedTime": "153315162",
      "asyncId": 407,
      "triggerAsyncId": 401,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        413
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 290
    },
    "291": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731868072212",
      "endTime": "928731870899922",
      "elapsedTime": "2827710",
      "asyncId": 408,
      "triggerAsyncId": 390,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        410
      ],
      "uniqueid": 291
    },
    "292": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732637040967",
      "endTime": "928732790152888",
      "elapsedTime": "153111921",
      "asyncId": 409,
      "triggerAsyncId": 377,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        415
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 292
    },
    "293": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731871783950",
      "endTime": "928731871815619",
      "elapsedTime": "31669",
      "asyncId": 411,
      "triggerAsyncId": 390,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 293
    },
    "294": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:99:25:99:25",
      "startTime": "928732713133859",
      "endTime": "928732789543245",
      "elapsedTime": "76409386",
      "asyncId": 412,
      "triggerAsyncId": 399,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, user])",
      "startLine": 99,
      "startCol": 25,
      "endLine": 99,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [],
      "uniqueid": 294
    },
    "295": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:90:45:90:45",
      "startTime": "928732713384279",
      "endTime": "928732713400009",
      "elapsedTime": "15730",
      "asyncId": 413,
      "triggerAsyncId": 399,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() ",
      "startLine": 90,
      "startCol": 45,
      "endLine": 90,
      "endCol": 45,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [
        414
      ],
      "uniqueid": 295
    },
    "296": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:99:25:99:25",
      "startTime": "928732713544399",
      "endTime": "928732789422228",
      "elapsedTime": "75877829",
      "asyncId": 414,
      "triggerAsyncId": 413,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, user])",
      "startLine": 99,
      "startCol": 25,
      "endLine": 99,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [
        416
      ],
      "uniqueid": 296
    },
    "297": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731872678136",
      "endTime": "928731875201897",
      "elapsedTime": "2523761",
      "asyncId": 415,
      "triggerAsyncId": 409,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 297
    },
    "298": {
      "source": "node_modules/bcryptjs/dist/bcrypt.js:306:20:306:20",
      "startTime": "928732713845894",
      "endTime": "928732789498631",
      "elapsedTime": "75652737",
      "asyncId": 416,
      "triggerAsyncId": 414,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.bcrypt.compare",
      "userCode": false,
      "line": "\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);",
      "startLine": 306,
      "startCol": 20,
      "endLine": 306,
      "endCol": 20,
      "file": "node_modules/bcryptjs/dist/bcrypt.js",
      "triggers": [
        418
      ],
      "uniqueid": 298
    },
    "299": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:99:19:99:19",
      "startTime": "928732789404966",
      "endTime": "928732789577389",
      "elapsedTime": "172423",
      "asyncId": 418,
      "triggerAsyncId": 416,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        426,
        426
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, user])",
      "startLine": 99,
      "startCol": 19,
      "endLine": 99,
      "endCol": 19,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 299
    },
    "300": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732791032807",
      "endTime": "928732960436038",
      "elapsedTime": "169403231",
      "asyncId": 419,
      "triggerAsyncId": 63,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        424,
        428
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 300
    },
    "301": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732791205581",
      "endTime": "928732960466785",
      "elapsedTime": "169261204",
      "asyncId": 420,
      "triggerAsyncId": 63,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        423,
        425,
        425
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 301
    },
    "302": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732791437666",
      "endTime": "928732791452885",
      "elapsedTime": "15219",
      "asyncId": 421,
      "triggerAsyncId": 63,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        422,
        422,
        422
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 302
    },
    "303": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731878181552",
      "endTime": "928731884489637",
      "elapsedTime": "6308085",
      "asyncId": 422,
      "triggerAsyncId": 421,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        432,
        429,
        432,
        430,
        434,
        440,
        423,
        423
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 303
    },
    "304": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732791877281",
      "endTime": "928732791891978",
      "elapsedTime": "14697",
      "asyncId": 423,
      "triggerAsyncId": 63,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        441,
        444,
        442,
        446,
        450,
        424,
        424,
        424
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 304
    },
    "305": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732792134072",
      "endTime": "928732960321733",
      "elapsedTime": "168187661",
      "asyncId": 424,
      "triggerAsyncId": 423,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        432,
        434,
        440,
        431,
        438,
        454
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 305
    },
    "306": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732792297288",
      "endTime": "928732960389611",
      "elapsedTime": "168092323",
      "asyncId": 425,
      "triggerAsyncId": 420,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        431,
        426
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 306
    },
    "307": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732792452970",
      "endTime": "928732960493165",
      "elapsedTime": "168040195",
      "asyncId": 426,
      "triggerAsyncId": 425,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 307
    },
    "308": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732792630653",
      "endTime": "928732960520526",
      "elapsedTime": "167889873",
      "asyncId": 427,
      "triggerAsyncId": 63,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 308
    },
    "309": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732792912371",
      "endTime": "928732792926948",
      "elapsedTime": "14577",
      "asyncId": 429,
      "triggerAsyncId": 63,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        431
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 309
    },
    "310": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731881019903",
      "endTime": "928731883575714",
      "elapsedTime": "2555811",
      "asyncId": 430,
      "triggerAsyncId": 422,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        436
      ],
      "uniqueid": 310
    },
    "311": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732793265343",
      "endTime": "928732960189866",
      "elapsedTime": "166924523",
      "asyncId": 431,
      "triggerAsyncId": 424,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        439
      ],
      "uniqueid": 311
    },
    "312": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732793506505",
      "endTime": "928732793522174",
      "elapsedTime": "15669",
      "asyncId": 432,
      "triggerAsyncId": 424,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        433
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 312
    },
    "313": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731825175368",
      "endTime": "928731826815182",
      "elapsedTime": "1639814",
      "asyncId": 433,
      "triggerAsyncId": 432,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        436
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 313
    },
    "314": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732794894567",
      "endTime": "928732794911909",
      "elapsedTime": "17342",
      "asyncId": 434,
      "triggerAsyncId": 424,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        435,
        435
      ],
      "uniqueid": 314
    },
    "315": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732795156738",
      "endTime": "928732798714438",
      "elapsedTime": "3557700",
      "asyncId": 435,
      "triggerAsyncId": 434,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        445,
        448,
        446,
        450,
        456,
        436,
        436
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 315
    },
    "316": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732795374085",
      "endTime": "928732960093746",
      "elapsedTime": "164719661",
      "asyncId": 436,
      "triggerAsyncId": 435,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        437,
        465,
        459,
        458,
        457,
        463,
        467,
        471,
        437
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 316
    },
    "317": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732795545457",
      "endTime": "928732960222598",
      "elapsedTime": "164677141",
      "asyncId": 437,
      "triggerAsyncId": 436,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 317
    },
    "318": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732795672285",
      "endTime": "928732960250901",
      "elapsedTime": "164578616",
      "asyncId": 438,
      "triggerAsyncId": 424,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        454
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 318
    },
    "319": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732795923486",
      "endTime": "928732795937873",
      "elapsedTime": "14387",
      "asyncId": 440,
      "triggerAsyncId": 424,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 319
    },
    "320": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731884854572",
      "endTime": "928731887249020",
      "elapsedTime": "2394448",
      "asyncId": 441,
      "triggerAsyncId": 423,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        443
      ],
      "uniqueid": 320
    },
    "321": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731887515610",
      "endTime": "928731889148290",
      "elapsedTime": "1632680",
      "asyncId": 442,
      "triggerAsyncId": 423,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        443,
        443,
        448
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 321
    },
    "322": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732796837840",
      "endTime": "928732960622517",
      "elapsedTime": "163784677",
      "asyncId": 444,
      "triggerAsyncId": 63,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        508,
        510,
        516,
        507,
        514,
        527,
        445,
        445
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 322
    },
    "323": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732796973895",
      "endTime": "928732796995826",
      "elapsedTime": "21931",
      "asyncId": 445,
      "triggerAsyncId": 435,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        555,
        557,
        563,
        554,
        561,
        574,
        446,
        446,
        447
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 323
    },
    "324": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732797183989",
      "endTime": "928732798343412",
      "elapsedTime": "1159423",
      "asyncId": 446,
      "triggerAsyncId": 435,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        602,
        604,
        610,
        601,
        608,
        621,
        447,
        447,
        452
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 324
    },
    "325": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732797535347",
      "endTime": "928732797549123",
      "elapsedTime": "13776",
      "asyncId": 448,
      "triggerAsyncId": 435,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        696,
        698,
        704,
        695,
        702,
        715,
        449,
        449
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 325
    },
    "326": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731834564388",
      "endTime": "928731960519652",
      "elapsedTime": "125955264",
      "asyncId": 449,
      "triggerAsyncId": 448,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        743,
        745,
        751,
        742,
        749,
        762,
        450,
        450
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 326
    },
    "327": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732797875515",
      "endTime": "928732798637764",
      "elapsedTime": "762249",
      "asyncId": 450,
      "triggerAsyncId": 435,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        790,
        792,
        798,
        789,
        796,
        809,
        468
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 327
    },
    "328": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731837097607",
      "endTime": "928731974253838",
      "elapsedTime": "137156231",
      "asyncId": 451,
      "triggerAsyncId": 439,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        459,
        452
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 328
    },
    "329": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732798074177",
      "endTime": "928732798668702",
      "elapsedTime": "594525",
      "asyncId": 452,
      "triggerAsyncId": 446,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 329
    },
    "330": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732798329706",
      "endTime": "928732960349175",
      "elapsedTime": "162019469",
      "asyncId": 454,
      "triggerAsyncId": 424,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        455,
        455
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 330
    },
    "331": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731892577329",
      "endTime": "928731897335949",
      "elapsedTime": "4758620",
      "asyncId": 455,
      "triggerAsyncId": 454,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        462,
        465,
        463,
        467,
        473,
        456,
        456
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 331
    },
    "332": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732798611955",
      "endTime": "928732798740987",
      "elapsedTime": "129032",
      "asyncId": 456,
      "triggerAsyncId": 435,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        474,
        477,
        475,
        479,
        483,
        457
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 332
    },
    "333": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732798881320",
      "endTime": "928732959869476",
      "elapsedTime": "160988156",
      "asyncId": 457,
      "triggerAsyncId": 436,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        465,
        464
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 333
    },
    "334": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732799111111",
      "endTime": "928732959821907",
      "elapsedTime": "160710796",
      "asyncId": 458,
      "triggerAsyncId": 436,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [
        462
      ],
      "uniqueid": 334
    },
    "335": {
      "source": "node_modules/bcryptjs/dist/bcrypt.js:222:20:222:20",
      "startTime": "928732799351782",
      "endTime": "928732883356135",
      "elapsedTime": "84004353",
      "asyncId": 459,
      "triggerAsyncId": 436,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.bcrypt.hash",
      "userCode": false,
      "line": "\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);",
      "startLine": 222,
      "startCol": 20,
      "endLine": 222,
      "endCol": 20,
      "file": "node_modules/bcryptjs/dist/bcrypt.js",
      "triggers": [
        461
      ],
      "uniqueid": 335
    },
    "336": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731893940404",
      "endTime": "928731893997391",
      "elapsedTime": "56987",
      "asyncId": 460,
      "triggerAsyncId": 84,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        461,
        461
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 336
    },
    "337": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732799529074",
      "endTime": "928732959498360",
      "elapsedTime": "159969286",
      "asyncId": 461,
      "triggerAsyncId": 459,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        471,
        474,
        472,
        476,
        482,
        462,
        462,
        474
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 337
    },
    "338": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928732799680959",
      "endTime": "928732959899081",
      "elapsedTime": "160218122",
      "asyncId": 462,
      "triggerAsyncId": 458,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        494,
        486,
        485,
        484,
        483,
        492,
        496,
        500,
        463,
        464
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 338
    },
    "339": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732799804000",
      "endTime": "928732959926403",
      "elapsedTime": "160122403",
      "asyncId": 463,
      "triggerAsyncId": 436,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        469,
        469
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 339
    },
    "340": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732800052856",
      "endTime": "928732800065851",
      "elapsedTime": "12995",
      "asyncId": 465,
      "triggerAsyncId": 436,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 340
    },
    "341": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731842393084",
      "endTime": "928731842439651",
      "elapsedTime": "46567",
      "asyncId": 466,
      "triggerAsyncId": 443,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 341
    },
    "342": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732800376894",
      "endTime": "928732960009749",
      "elapsedTime": "159632855",
      "asyncId": 467,
      "triggerAsyncId": 436,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 342
    },
    "343": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731843104738",
      "endTime": "928731974286339",
      "elapsedTime": "131181601",
      "asyncId": 468,
      "triggerAsyncId": 450,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 343
    },
    "344": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732800566309",
      "endTime": "928732960042620",
      "elapsedTime": "159476311",
      "asyncId": 469,
      "triggerAsyncId": 463,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 344
    },
    "345": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732800813813",
      "endTime": "928732960122270",
      "elapsedTime": "159308457",
      "asyncId": 471,
      "triggerAsyncId": 436,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        473
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 345
    },
    "346": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731843994416",
      "endTime": "928731846129909",
      "elapsedTime": "2135493",
      "asyncId": 472,
      "triggerAsyncId": 461,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        478
      ],
      "uniqueid": 346
    },
    "347": {
      "source": "node_modules/bcryptjs/dist/bcrypt.js:306:20:306:20",
      "startTime": "928732883554477",
      "endTime": "928732959575044",
      "elapsedTime": "76020567",
      "asyncId": 474,
      "triggerAsyncId": 461,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.bcrypt.compare",
      "userCode": false,
      "triggers": [
        476
      ],
      "line": "\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);",
      "startLine": 306,
      "startCol": 20,
      "endLine": 306,
      "endCol": 20,
      "file": "node_modules/bcryptjs/dist/bcrypt.js",
      "uniqueid": 347
    },
    "348": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731899817922",
      "endTime": "928731901594702",
      "elapsedTime": "1776780",
      "asyncId": 475,
      "triggerAsyncId": 456,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        481
      ],
      "uniqueid": 348
    },
    "349": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732960795692",
      "endTime": "928732997503203",
      "elapsedTime": "36707511",
      "asyncId": 477,
      "triggerAsyncId": 64,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        489
      ],
      "uniqueid": 349
    },
    "350": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732960956904",
      "endTime": "928732997534372",
      "elapsedTime": "36577468",
      "asyncId": 478,
      "triggerAsyncId": 64,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        486,
        486
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 350
    },
    "351": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732961192285",
      "endTime": "928732961206292",
      "elapsedTime": "14007",
      "asyncId": 479,
      "triggerAsyncId": 64,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 351
    },
    "352": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732961626519",
      "endTime": "928732961640145",
      "elapsedTime": "13626",
      "asyncId": 481,
      "triggerAsyncId": 64,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        482,
        482
      ],
      "uniqueid": 352
    },
    "353": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732961886887",
      "endTime": "928732971081053",
      "elapsedTime": "9194166",
      "asyncId": 482,
      "triggerAsyncId": 481,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        493,
        495,
        501,
        492,
        499,
        515,
        483,
        483
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 353
    },
    "354": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732962094948",
      "endTime": "928732979965137",
      "elapsedTime": "17870189",
      "asyncId": 483,
      "triggerAsyncId": 482,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        493,
        535,
        537,
        543,
        534,
        541,
        554,
        484,
        484
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 354
    },
    "355": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732962310151",
      "endTime": "928732989202533",
      "elapsedTime": "26892382",
      "asyncId": 484,
      "triggerAsyncId": 483,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        491,
        492,
        574,
        576,
        582,
        573,
        580,
        593,
        485,
        485
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 355
    },
    "356": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732962545071",
      "endTime": "928732997391835",
      "elapsedTime": "34846764",
      "asyncId": 485,
      "triggerAsyncId": 484,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        490,
        618,
        620,
        626,
        617,
        624,
        637
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 356
    },
    "357": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732962708818",
      "endTime": "928732997451747",
      "elapsedTime": "34742929",
      "asyncId": 486,
      "triggerAsyncId": 478,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        487,
        489,
        487
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 357
    },
    "358": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732962884167",
      "endTime": "928732997562544",
      "elapsedTime": "34678377",
      "asyncId": 487,
      "triggerAsyncId": 486,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        488,
        488,
        488
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 358
    },
    "359": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732963058043",
      "endTime": "928732997591148",
      "elapsedTime": "34533105",
      "asyncId": 488,
      "triggerAsyncId": 64,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        495,
        498,
        496,
        500,
        506,
        489,
        489
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 359
    },
    "360": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732963337657",
      "endTime": "928732963350772",
      "elapsedTime": "13115",
      "asyncId": 490,
      "triggerAsyncId": 64,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 360
    },
    "361": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731905677005",
      "endTime": "928731916084154",
      "elapsedTime": "10407149",
      "asyncId": 491,
      "triggerAsyncId": 85,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 361
    },
    "362": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732963693113",
      "endTime": "928732970941551",
      "elapsedTime": "7248438",
      "asyncId": 492,
      "triggerAsyncId": 482,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        498,
        500
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 362
    },
    "363": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732963936279",
      "endTime": "928732963950596",
      "elapsedTime": "14317",
      "asyncId": 493,
      "triggerAsyncId": 482,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 363
    },
    "364": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731851212066",
      "endTime": "928731851281766",
      "elapsedTime": "69700",
      "asyncId": 494,
      "triggerAsyncId": 462,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 364
    },
    "365": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732964394599",
      "endTime": "928732964408334",
      "elapsedTime": "13735",
      "asyncId": 495,
      "triggerAsyncId": 482,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        497,
        496,
        496
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 365
    },
    "366": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732964635911",
      "endTime": "928732967670349",
      "elapsedTime": "3034438",
      "asyncId": 496,
      "triggerAsyncId": 495,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        502,
        506,
        509,
        507,
        511,
        517,
        497,
        497
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 366
    },
    "367": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732964881852",
      "endTime": "928732970858977",
      "elapsedTime": "5977125",
      "asyncId": 497,
      "triggerAsyncId": 496,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        521,
        527,
        520,
        519,
        518,
        525,
        529,
        533,
        498
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 367
    },
    "368": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732965054085",
      "endTime": "928732970973411",
      "elapsedTime": "5919326",
      "asyncId": 498,
      "triggerAsyncId": 497,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 368
    },
    "369": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732965174962",
      "endTime": "928732971008657",
      "elapsedTime": "5833695",
      "asyncId": 499,
      "triggerAsyncId": 482,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 369
    },
    "370": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732965417947",
      "endTime": "928732965431543",
      "elapsedTime": "13596",
      "asyncId": 501,
      "triggerAsyncId": 482,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        502
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 370
    },
    "371": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731908861484",
      "endTime": "928731910205474",
      "elapsedTime": "1343990",
      "asyncId": 502,
      "triggerAsyncId": 496,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        503
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 371
    },
    "372": {
      "source": "packages/strapi-database/lib/utils/lifecycles.js:15:3:15:3",
      "startTime": "928731854325412",
      "endTime": "928731855242962",
      "elapsedTime": "917550",
      "asyncId": 503,
      "triggerAsyncId": 502,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " executeAfterLifecycle",
      "userCode": false,
      "triggers": [
        504,
        506
      ],
      "line": "\n\nconst executeAfterLifecycle = (lifecycle, model, ...args) =>\n  executeLifecycle(`after${_.upperFirst(lifecycle)}`, model, ...args);\n\nmodule.exports = {\n  executeBeforeLifecycle",
      "startLine": 15,
      "startCol": 3,
      "endLine": 15,
      "endCol": 3,
      "file": "packages/strapi-database/lib/utils/lifecycles.js",
      "uniqueid": 372
    },
    "373": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732965961265",
      "endTime": "928732997683171",
      "elapsedTime": "31721906",
      "asyncId": 505,
      "triggerAsyncId": 64,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 373
    },
    "374": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732966097571",
      "endTime": "928732966117779",
      "elapsedTime": "20208",
      "asyncId": 506,
      "triggerAsyncId": 496,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        508
      ],
      "uniqueid": 374
    },
    "375": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732966259805",
      "endTime": "928732967288433",
      "elapsedTime": "1028628",
      "asyncId": 507,
      "triggerAsyncId": 496,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        515,
        509,
        513
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 375
    },
    "376": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732966531434",
      "endTime": "928732966545020",
      "elapsedTime": "13586",
      "asyncId": 509,
      "triggerAsyncId": 496,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 376
    },
    "377": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731913609926",
      "endTime": "928731913657595",
      "elapsedTime": "47669",
      "asyncId": 510,
      "triggerAsyncId": 489,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        511,
        511
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 377
    },
    "378": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732966819654",
      "endTime": "928732967596280",
      "elapsedTime": "776626",
      "asyncId": 511,
      "triggerAsyncId": 496,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        518,
        521,
        519,
        523,
        529,
        512,
        512
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 378
    },
    "379": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731914291864",
      "endTime": "928731915466697",
      "elapsedTime": "1174833",
      "asyncId": 512,
      "triggerAsyncId": 489,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        541,
        533,
        532,
        531,
        530,
        539,
        543,
        547,
        513
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 379
    },
    "380": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732967019689",
      "endTime": "928732967626898",
      "elapsedTime": "607209",
      "asyncId": 513,
      "triggerAsyncId": 507,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 380
    },
    "381": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731914702444",
      "endTime": "928731915550854",
      "elapsedTime": "848410",
      "asyncId": 514,
      "triggerAsyncId": 508,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 381
    },
    "382": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732967274537",
      "endTime": "928732971109025",
      "elapsedTime": "3834488",
      "asyncId": 515,
      "triggerAsyncId": 482,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 382
    },
    "383": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732967571303",
      "endTime": "928732967699243",
      "elapsedTime": "127940",
      "asyncId": 517,
      "triggerAsyncId": 496,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        525
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 383
    },
    "384": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732967841009",
      "endTime": "928732970663560",
      "elapsedTime": "2822551",
      "asyncId": 518,
      "triggerAsyncId": 497,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        520,
        526
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 384
    },
    "385": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732968074797",
      "endTime": "928732970599240",
      "elapsedTime": "2524443",
      "asyncId": 519,
      "triggerAsyncId": 497,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        525,
        524
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 385
    },
    "386": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:127:13:127:13",
      "startTime": "928732968408603",
      "endTime": "928732970137484",
      "elapsedTime": "1728881",
      "asyncId": 520,
      "triggerAsyncId": 497,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        521,
        521,
        523
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io' };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email, isActive: true });\n    })",
      "startLine": 127,
      "startCol": 13,
      "endLine": 127,
      "endCol": 13,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 386
    },
    "387": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:118:45:118:45",
      "startTime": "928732968710008",
      "endTime": "928732968723614",
      "elapsedTime": "13606",
      "asyncId": 521,
      "triggerAsyncId": 497,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        528,
        531,
        529,
        533,
        539,
        522,
        522,
        522
      ],
      "line": "\n  describe('forgotPassword', () => {\n    test('Only run the process for active users', async () => {\n      const findOne = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query() ",
      "startLine": 118,
      "startCol": 45,
      "endLine": 118,
      "endCol": 45,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 387
    },
    "388": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:127:13:127:13",
      "startTime": "928732968919731",
      "endTime": "928732970164695",
      "elapsedTime": "1244964",
      "asyncId": 522,
      "triggerAsyncId": 521,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        540,
        543,
        541,
        545,
        549,
        523
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io' };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email, isActive: true });\n    })",
      "startLine": 127,
      "startCol": 13,
      "endLine": 127,
      "endCol": 13,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 388
    },
    "389": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732969088848",
      "endTime": "928732970632422",
      "elapsedTime": "1543574",
      "asyncId": 523,
      "triggerAsyncId": 520,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 389
    },
    "390": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928732969240883",
      "endTime": "928732970690341",
      "elapsedTime": "1449458",
      "asyncId": 524,
      "triggerAsyncId": 519,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 390
    },
    "391": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732969359686",
      "endTime": "928732970716510",
      "elapsedTime": "1356824",
      "asyncId": 525,
      "triggerAsyncId": 497,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        531
      ],
      "uniqueid": 391
    },
    "392": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732969603724",
      "endTime": "928732969617890",
      "elapsedTime": "14166",
      "asyncId": 527,
      "triggerAsyncId": 497,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 392
    },
    "393": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731921354794",
      "endTime": "928731921395451",
      "elapsedTime": "40657",
      "asyncId": 528,
      "triggerAsyncId": 521,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        530
      ],
      "uniqueid": 393
    },
    "394": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732969896021",
      "endTime": "928732970780750",
      "elapsedTime": "884729",
      "asyncId": 529,
      "triggerAsyncId": 497,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        535
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 394
    },
    "395": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732970089154",
      "endTime": "928732970810586",
      "elapsedTime": "721432",
      "asyncId": 531,
      "triggerAsyncId": 525,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        538
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 395
    },
    "396": {
      "source": "packages/strapi-database/lib/queries/__tests__/create-query.test.js:57:28:57:28",
      "startTime": "928731866043659",
      "endTime": "928731872750241",
      "elapsedTime": "6706582",
      "asyncId": 532,
      "triggerAsyncId": 512,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n        const query = createQuery({ model, connectorQuery });\n\n        await query[method](arg1, arg2);\n\n        expect(queryMethod).toHaveBeenCalledWith(arg1, arg2);\n        expect(beforeLifecycleMethod).toHaveBeenCalledWith(arg1, arg2)",
      "startLine": 57,
      "startCol": 28,
      "endLine": 57,
      "endCol": 28,
      "file": "packages/strapi-database/lib/queries/__tests__/create-query.test.js",
      "triggers": [
        537
      ],
      "uniqueid": 396
    },
    "397": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732970431325",
      "endTime": "928732970888171",
      "elapsedTime": "456846",
      "asyncId": 533,
      "triggerAsyncId": 497,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        534,
        536
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 397
    },
    "398": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732971299132",
      "endTime": "928732979857916",
      "elapsedTime": "8558784",
      "asyncId": 534,
      "triggerAsyncId": 483,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        535,
        542
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 398
    },
    "399": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732972967008",
      "endTime": "928732972984501",
      "elapsedTime": "17493",
      "asyncId": 535,
      "triggerAsyncId": 483,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 399
    },
    "400": {
      "source": "packages/strapi-database/lib/queries/__tests__/create-query.test.js:57:28:57:28",
      "startTime": "928731867652725",
      "endTime": "928731871358282",
      "elapsedTime": "3705557",
      "asyncId": 536,
      "triggerAsyncId": 533,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        548
      ],
      "line": "\n        const query = createQuery({ model, connectorQuery });\n\n        await query[method](arg1, arg2);\n\n        expect(queryMethod).toHaveBeenCalledWith(arg1, arg2);\n        expect(beforeLifecycleMethod).toHaveBeenCalledWith(arg1, arg2)",
      "startLine": 57,
      "startCol": 28,
      "endLine": 57,
      "endCol": 28,
      "file": "packages/strapi-database/lib/queries/__tests__/create-query.test.js",
      "uniqueid": 400
    },
    "401": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732973482685",
      "endTime": "928732973499226",
      "elapsedTime": "16541",
      "asyncId": 537,
      "triggerAsyncId": 483,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        538,
        538
      ],
      "uniqueid": 401
    },
    "402": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732973767890",
      "endTime": "928732976435300",
      "elapsedTime": "2667410",
      "asyncId": 538,
      "triggerAsyncId": 537,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        545,
        548,
        546,
        550,
        556,
        539,
        539
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 402
    },
    "403": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732973987321",
      "endTime": "928732979787003",
      "elapsedTime": "5799682",
      "asyncId": 539,
      "triggerAsyncId": 538,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        545,
        560,
        566,
        559,
        558,
        557,
        564,
        568,
        572,
        540
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 403
    },
    "404": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732974177447",
      "endTime": "928732979882612",
      "elapsedTime": "5705165",
      "asyncId": 540,
      "triggerAsyncId": 539,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        542
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 404
    },
    "405": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732974310897",
      "endTime": "928732979905756",
      "elapsedTime": "5594859",
      "asyncId": 541,
      "triggerAsyncId": 483,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        547
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 405
    },
    "406": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732974589920",
      "endTime": "928732974603786",
      "elapsedTime": "13866",
      "asyncId": 543,
      "triggerAsyncId": 483,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 406
    },
    "407": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732974916813",
      "endTime": "928732974937662",
      "elapsedTime": "20849",
      "asyncId": 545,
      "triggerAsyncId": 538,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        547
      ],
      "uniqueid": 407
    },
    "408": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732975085489",
      "endTime": "928732976073792",
      "elapsedTime": "988303",
      "asyncId": 546,
      "triggerAsyncId": 538,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        552
      ],
      "uniqueid": 408
    },
    "409": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732975327092",
      "endTime": "928732975340578",
      "elapsedTime": "13486",
      "asyncId": 548,
      "triggerAsyncId": 538,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        549
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 409
    },
    "410": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732975621845",
      "endTime": "928732976361962",
      "elapsedTime": "740117",
      "asyncId": 550,
      "triggerAsyncId": 538,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        551,
        553,
        558
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 410
    },
    "411": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928731932846126",
      "endTime": "928731932912921",
      "elapsedTime": "66795",
      "asyncId": 551,
      "triggerAsyncId": 87,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        552
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 411
    },
    "412": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732975801161",
      "endTime": "928732976392971",
      "elapsedTime": "591810",
      "asyncId": 552,
      "triggerAsyncId": 546,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 412
    },
    "413": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928731933749419",
      "endTime": "928731933802929",
      "elapsedTime": "53510",
      "asyncId": 553,
      "triggerAsyncId": 87,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        554,
        554
      ],
      "uniqueid": 413
    },
    "414": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732976059345",
      "endTime": "928732979988431",
      "elapsedTime": "3929086",
      "asyncId": 554,
      "triggerAsyncId": 483,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        562,
        561,
        564,
        562,
        566,
        572,
        555,
        555
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 414
    },
    "415": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731934607057",
      "endTime": "928731954566282",
      "elapsedTime": "19959225",
      "asyncId": 555,
      "triggerAsyncId": 554,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        573,
        576,
        574,
        578,
        582,
        556
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 415
    },
    "416": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732976336485",
      "endTime": "928732976462370",
      "elapsedTime": "125885",
      "asyncId": 556,
      "triggerAsyncId": 538,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 416
    },
    "417": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732976606311",
      "endTime": "928732979520323",
      "elapsedTime": "2914012",
      "asyncId": 557,
      "triggerAsyncId": 539,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        558,
        558,
        565
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 417
    },
    "418": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732976851330",
      "endTime": "928732979451694",
      "elapsedTime": "2600364",
      "asyncId": 558,
      "triggerAsyncId": 539,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        565,
        568,
        566,
        570,
        576,
        559,
        559,
        563
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 418
    },
    "419": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:150:13:150:13",
      "startTime": "928732977093173",
      "endTime": "928732978814380",
      "elapsedTime": "1721207",
      "asyncId": 559,
      "triggerAsyncId": 539,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        588,
        580,
        579,
        578,
        577,
        586,
        590,
        594,
        560,
        562
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io' };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(send).not.toHaveBeenCalled()",
      "startLine": 150,
      "startCol": 13,
      "endLine": 150,
      "endCol": 13,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 419
    },
    "420": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:133:45:133:45",
      "startTime": "928732977386383",
      "endTime": "928732977400579",
      "elapsedTime": "14196",
      "asyncId": 560,
      "triggerAsyncId": 539,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n\n    test('Will return silently in case the user is not found', async () => {\n      const findOne = jest.fn(() => Promise.resolve());\n      const send = jest.fn(() => Promise.resolve());\n\n      global.strapi = ",
      "startLine": 133,
      "startCol": 45,
      "endLine": 133,
      "endCol": 45,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [
        561
      ],
      "uniqueid": 420
    },
    "421": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:150:13:150:13",
      "startTime": "928732977601686",
      "endTime": "928732978842693",
      "elapsedTime": "1241007",
      "asyncId": 561,
      "triggerAsyncId": 560,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        563
      ],
      "line": "\n\n      const input = { email: 'test@strapi.io' };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(send).not.toHaveBeenCalled()",
      "startLine": 150,
      "startCol": 13,
      "endLine": 150,
      "endCol": 13,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 421
    },
    "422": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732977761236",
      "endTime": "928732979486410",
      "elapsedTime": "1725174",
      "asyncId": 562,
      "triggerAsyncId": 559,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        568
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 422
    },
    "423": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928732977919402",
      "endTime": "928732979550269",
      "elapsedTime": "1630867",
      "asyncId": 563,
      "triggerAsyncId": 558,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 423
    },
    "424": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732978055327",
      "endTime": "928732979666838",
      "elapsedTime": "1611511",
      "asyncId": 564,
      "triggerAsyncId": 539,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        570
      ],
      "uniqueid": 424
    },
    "425": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732978302049",
      "endTime": "928732978315424",
      "elapsedTime": "13375",
      "asyncId": 566,
      "triggerAsyncId": 539,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        572
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 425
    },
    "426": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732978589989",
      "endTime": "928732979727331",
      "elapsedTime": "1137342",
      "asyncId": 568,
      "triggerAsyncId": 539,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 426
    },
    "427": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732978768133",
      "endTime": "928732979751917",
      "elapsedTime": "983784",
      "asyncId": 570,
      "triggerAsyncId": 564,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 427
    },
    "428": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732979096268",
      "endTime": "928732979812581",
      "elapsedTime": "716313",
      "asyncId": 572,
      "triggerAsyncId": 539,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 428
    },
    "429": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732980157187",
      "endTime": "928732989093579",
      "elapsedTime": "8936392",
      "asyncId": 573,
      "triggerAsyncId": 484,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        575,
        581
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 429
    },
    "430": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732980395393",
      "endTime": "928732980407837",
      "elapsedTime": "12444",
      "asyncId": 574,
      "triggerAsyncId": 484,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        580
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 430
    },
    "431": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732980848082",
      "endTime": "928732980859844",
      "elapsedTime": "11762",
      "asyncId": 576,
      "triggerAsyncId": 484,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        577,
        577
      ],
      "uniqueid": 431
    },
    "432": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732981095346",
      "endTime": "928732983611522",
      "elapsedTime": "2516176",
      "asyncId": 577,
      "triggerAsyncId": 576,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        587,
        584,
        587,
        585,
        589,
        595,
        578,
        578
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 432
    },
    "433": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732981316901",
      "endTime": "928732989027204",
      "elapsedTime": "7710303",
      "asyncId": 578,
      "triggerAsyncId": 577,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        585,
        599,
        605,
        598,
        598,
        597,
        596,
        603,
        607,
        613,
        579
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 433
    },
    "434": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732981485126",
      "endTime": "928732989118235",
      "elapsedTime": "7633109",
      "asyncId": 579,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        584
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 434
    },
    "435": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732981610641",
      "endTime": "928732989144624",
      "elapsedTime": "7533983",
      "asyncId": 580,
      "triggerAsyncId": 484,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        581,
        583
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 435
    },
    "436": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732981874486",
      "endTime": "928732981886418",
      "elapsedTime": "11932",
      "asyncId": 582,
      "triggerAsyncId": 484,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 436
    },
    "437": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731955815854",
      "endTime": "928731980204703",
      "elapsedTime": "24388849",
      "asyncId": 583,
      "triggerAsyncId": 88,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        595,
        591
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 437
    },
    "438": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732982198644",
      "endTime": "928732982220124",
      "elapsedTime": "21480",
      "asyncId": 584,
      "triggerAsyncId": 577,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        586
      ],
      "uniqueid": 438
    },
    "439": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732982350238",
      "endTime": "928732983271224",
      "elapsedTime": "920986",
      "asyncId": 585,
      "triggerAsyncId": 577,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        591
      ],
      "uniqueid": 439
    },
    "440": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732982585539",
      "endTime": "928732982597090",
      "elapsedTime": "11551",
      "asyncId": 587,
      "triggerAsyncId": 577,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        594,
        597,
        595,
        599,
        605,
        588,
        588
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 440
    },
    "441": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731960966439",
      "endTime": "928731980050224",
      "elapsedTime": "19083785",
      "asyncId": 588,
      "triggerAsyncId": 587,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        606,
        609,
        607,
        611,
        615,
        589
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 441
    },
    "442": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732982853081",
      "endTime": "928732983545789",
      "elapsedTime": "692708",
      "asyncId": 589,
      "triggerAsyncId": 577,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 442
    },
    "443": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731961980190",
      "endTime": "928731980316533",
      "elapsedTime": "18336343",
      "asyncId": 590,
      "triggerAsyncId": 88,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 443
    },
    "444": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732983027528",
      "endTime": "928732983574122",
      "elapsedTime": "546594",
      "asyncId": 591,
      "triggerAsyncId": 585,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 444
    },
    "445": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731962825204",
      "endTime": "928731962865590",
      "elapsedTime": "40386",
      "asyncId": 592,
      "triggerAsyncId": 88,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 445
    },
    "446": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732983258721",
      "endTime": "928732989225206",
      "elapsedTime": "5966485",
      "asyncId": 593,
      "triggerAsyncId": 484,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 446
    },
    "447": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731963865163",
      "endTime": "928731963900930",
      "elapsedTime": "35767",
      "asyncId": 594,
      "triggerAsyncId": 587,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        596
      ],
      "uniqueid": 447
    },
    "448": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732983523848",
      "endTime": "928732983634886",
      "elapsedTime": "111038",
      "asyncId": 595,
      "triggerAsyncId": 577,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        596,
        601
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 448
    },
    "449": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732983765130",
      "endTime": "928732988850483",
      "elapsedTime": "5085353",
      "asyncId": 596,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        597,
        604
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 449
    },
    "450": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732984042460",
      "endTime": "928732988793276",
      "elapsedTime": "4750816",
      "asyncId": 597,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        598,
        600,
        602
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 450
    },
    "451": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:190:13:190:13",
      "startTime": "928732984321743",
      "endTime": "928732988443109",
      "elapsedTime": "4121366",
      "asyncId": 598,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        599,
        601
      ],
      "line": "\n\n      const input = { email: user.email };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(createToken).toHaveBeenCalled()",
      "startLine": 190,
      "startCol": 13,
      "endLine": 190,
      "endCol": 13,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 451
    },
    "452": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:163:45:163:45",
      "startTime": "928732984604484",
      "endTime": "928732984616827",
      "elapsedTime": "12343",
      "asyncId": 599,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      const resetPasswordToken = '123';\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const send = jest.fn(() => Promise.resolve());\n      const updateById = jest.fn(() => Promise.resolve());\n      const createToken = jest.fn(() => resetPasswordToken)",
      "startLine": 163,
      "startCol": 45,
      "endLine": 163,
      "endCol": 45,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [
        600
      ],
      "uniqueid": 452
    },
    "453": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:190:13:190:13",
      "startTime": "928732984806202",
      "endTime": "928732986323867",
      "elapsedTime": "1517665",
      "asyncId": 600,
      "triggerAsyncId": 599,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        610
      ],
      "line": "\n\n      const input = { email: user.email };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(createToken).toHaveBeenCalled()",
      "startLine": 190,
      "startCol": 13,
      "endLine": 190,
      "endCol": 13,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 453
    },
    "454": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732984961393",
      "endTime": "928732988824615",
      "elapsedTime": "3863222",
      "asyncId": 601,
      "triggerAsyncId": 598,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        609
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 454
    },
    "455": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928732985124348",
      "endTime": "928732988875971",
      "elapsedTime": "3751623",
      "asyncId": 602,
      "triggerAsyncId": 597,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 455
    },
    "456": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732985235767",
      "endTime": "928732988899816",
      "elapsedTime": "3664049",
      "asyncId": 603,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        609
      ],
      "uniqueid": 456
    },
    "457": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732985461179",
      "endTime": "928732985472461",
      "elapsedTime": "11282",
      "asyncId": 605,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        612,
        615,
        613,
        617,
        623,
        606,
        606
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 457
    },
    "458": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731970951407",
      "endTime": "928731975464928",
      "elapsedTime": "4513521",
      "asyncId": 606,
      "triggerAsyncId": 588,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        635,
        627,
        626,
        625,
        624,
        633,
        637,
        641,
        607,
        608
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 458
    },
    "459": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732985731997",
      "endTime": "928732988959898",
      "elapsedTime": "3227901",
      "asyncId": 607,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        613
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 459
    },
    "460": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732985902096",
      "endTime": "928732988984434",
      "elapsedTime": "3082338",
      "asyncId": 609,
      "triggerAsyncId": 603,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 460
    },
    "461": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:165:48:165:48",
      "startTime": "928732986173655",
      "endTime": "928732986185878",
      "elapsedTime": "12223",
      "asyncId": 610,
      "triggerAsyncId": 600,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const send = jest.fn(() => Promise.resolve());\n      const updateById = jest.fn(() => Promise.resolve());\n      const createToken = jest.fn(() => resetPasswordToken);\n\n      const config = ",
      "startLine": 165,
      "startCol": 48,
      "endLine": 165,
      "endCol": 48,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [
        611
      ],
      "uniqueid": 461
    },
    "462": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:190:7:190:7",
      "startTime": "928732986312586",
      "endTime": "928732988268382",
      "elapsedTime": "1955796",
      "asyncId": 611,
      "triggerAsyncId": 610,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        614
      ],
      "line": "\n\n      const input = { email: user.email };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(createToken).toHaveBeenCalled()",
      "startLine": 190,
      "startCol": 7,
      "endLine": 190,
      "endCol": 7,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 462
    },
    "463": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731894672075",
      "endTime": "928731894727359",
      "elapsedTime": "55284",
      "asyncId": 612,
      "triggerAsyncId": 605,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        614
      ],
      "uniqueid": 463
    },
    "464": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732986545122",
      "endTime": "928732989050949",
      "elapsedTime": "2505827",
      "asyncId": 613,
      "triggerAsyncId": 578,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        619
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 464
    },
    "465": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:164:42:164:42",
      "startTime": "928732988069048",
      "endTime": "928732988082043",
      "elapsedTime": "12995",
      "asyncId": 614,
      "triggerAsyncId": 611,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const send = jest.fn(() => Promise.resolve());\n      const updateById = jest.fn(() => Promise.resolve());\n      const createToken = jest.fn(() => resetPasswordToken);",
      "startLine": 164,
      "startCol": 42,
      "endLine": 164,
      "endCol": 42,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [
        615
      ],
      "uniqueid": 465
    },
    "466": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731981092788",
      "endTime": "928732004119283",
      "elapsedTime": "23026495",
      "asyncId": 616,
      "triggerAsyncId": 89,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        624
      ],
      "uniqueid": 466
    },
    "467": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732989382300",
      "endTime": "928732997273463",
      "elapsedTime": "7891163",
      "asyncId": 617,
      "triggerAsyncId": 485,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        625
      ],
      "uniqueid": 467
    },
    "468": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732989630976",
      "endTime": "928732989643530",
      "elapsedTime": "12554",
      "asyncId": 618,
      "triggerAsyncId": 485,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 468
    },
    "469": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928731984190325",
      "endTime": "928731984232594",
      "elapsedTime": "42269",
      "asyncId": 619,
      "triggerAsyncId": 89,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        620,
        620
      ],
      "uniqueid": 469
    },
    "470": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732990070911",
      "endTime": "928732990082843",
      "elapsedTime": "11932",
      "asyncId": 620,
      "triggerAsyncId": 485,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        627,
        630,
        628,
        632,
        638,
        621,
        621,
        621,
        621
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 470
    },
    "471": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732990320669",
      "endTime": "928732992799065",
      "elapsedTime": "2478396",
      "asyncId": 621,
      "triggerAsyncId": 620,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        639,
        642,
        640,
        644,
        648,
        622,
        628,
        631,
        629,
        633,
        639,
        622,
        622
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 471
    },
    "472": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732990532617",
      "endTime": "928732997208511",
      "elapsedTime": "6675894",
      "asyncId": 622,
      "triggerAsyncId": 621,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        643,
        649,
        642,
        642,
        641,
        640,
        647,
        651,
        657,
        623
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 472
    },
    "473": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732990699479",
      "endTime": "928732997297968",
      "elapsedTime": "6598489",
      "asyncId": 623,
      "triggerAsyncId": 622,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 473
    },
    "474": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732990825375",
      "endTime": "928732997328065",
      "elapsedTime": "6502690",
      "asyncId": 624,
      "triggerAsyncId": 485,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        634
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 474
    },
    "475": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732991099700",
      "endTime": "928732991111381",
      "elapsedTime": "11681",
      "asyncId": 626,
      "triggerAsyncId": 485,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        631
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 475
    },
    "476": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731989760637",
      "endTime": "928731989806062",
      "elapsedTime": "45425",
      "asyncId": 627,
      "triggerAsyncId": 620,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        628,
        630,
        629
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 476
    },
    "477": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732991404291",
      "endTime": "928732991420431",
      "elapsedTime": "16140",
      "asyncId": 628,
      "triggerAsyncId": 621,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        629,
        634,
        630
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 477
    },
    "478": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732991554502",
      "endTime": "928732992463927",
      "elapsedTime": "909425",
      "asyncId": 629,
      "triggerAsyncId": 621,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        635
      ],
      "uniqueid": 478
    },
    "479": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732991780576",
      "endTime": "928732991792118",
      "elapsedTime": "11542",
      "asyncId": 631,
      "triggerAsyncId": 621,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 479
    },
    "480": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731992142772",
      "endTime": "928731994290508",
      "elapsedTime": "2147736",
      "asyncId": 632,
      "triggerAsyncId": 620,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 480
    },
    "481": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732992051053",
      "endTime": "928732992732701",
      "elapsedTime": "681648",
      "asyncId": 633,
      "triggerAsyncId": 621,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        639
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 481
    },
    "482": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731992556958",
      "endTime": "928731994361912",
      "elapsedTime": "1804954",
      "asyncId": 634,
      "triggerAsyncId": 628,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 482
    },
    "483": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732992222093",
      "endTime": "928732992762136",
      "elapsedTime": "540043",
      "asyncId": 635,
      "triggerAsyncId": 629,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 483
    },
    "484": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732992451704",
      "endTime": "928732997414166",
      "elapsedTime": "4962462",
      "asyncId": 637,
      "triggerAsyncId": 485,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 484
    },
    "485": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732992710489",
      "endTime": "928732992823030",
      "elapsedTime": "112541",
      "asyncId": 639,
      "triggerAsyncId": 621,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        641
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 485
    },
    "486": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732992952934",
      "endTime": "928732997048631",
      "elapsedTime": "4095697",
      "asyncId": 640,
      "triggerAsyncId": 622,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        646,
        648
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 486
    },
    "487": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732993223631",
      "endTime": "928732996980694",
      "elapsedTime": "3757063",
      "asyncId": 641,
      "triggerAsyncId": 622,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [
        646
      ],
      "uniqueid": 487
    },
    "488": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:237:13:237:13",
      "startTime": "928732993489529",
      "endTime": "928732996671835",
      "elapsedTime": "3182306",
      "asyncId": 642,
      "triggerAsyncId": 622,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        643,
        645
      ],
      "line": "\n\n      const input = { email: user.email };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(createToken).toHaveBeenCalled()",
      "startLine": 237,
      "startCol": 13,
      "endLine": 237,
      "endCol": 13,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 488
    },
    "489": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:204:45:204:45",
      "startTime": "928732993781427",
      "endTime": "928732993793569",
      "elapsedTime": "12142",
      "asyncId": 643,
      "triggerAsyncId": 622,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        644,
        644
      ],
      "line": "\n      const resetPasswordToken = '123';\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const send = jest.fn(() => Promise.resolve());\n      const sendTemplatedEmail = jest.fn(() => Promise.resolve());\n      const updateById = jest.fn(() => Promise.resolve())",
      "startLine": 204,
      "startCol": 45,
      "endLine": 204,
      "endCol": 45,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 489
    },
    "490": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:237:13:237:13",
      "startTime": "928732993980861",
      "endTime": "928732995681609",
      "elapsedTime": "1700748",
      "asyncId": 644,
      "triggerAsyncId": 643,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        645,
        647,
        654
      ],
      "line": "\n\n      const input = { email: user.email };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(createToken).toHaveBeenCalled()",
      "startLine": 237,
      "startCol": 13,
      "endLine": 237,
      "endCol": 13,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 490
    },
    "491": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732994149126",
      "endTime": "928732997022151",
      "elapsedTime": "2873025",
      "asyncId": 645,
      "triggerAsyncId": 642,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        646
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 491
    },
    "492": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928732994453486",
      "endTime": "928732997071254",
      "elapsedTime": "2617768",
      "asyncId": 646,
      "triggerAsyncId": 641,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 492
    },
    "493": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732994588670",
      "endTime": "928732997094848",
      "elapsedTime": "2506178",
      "asyncId": 647,
      "triggerAsyncId": 622,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        653
      ],
      "uniqueid": 493
    },
    "494": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732994831315",
      "endTime": "928732994843417",
      "elapsedTime": "12102",
      "asyncId": 649,
      "triggerAsyncId": 622,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        657
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 494
    },
    "495": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732005947510",
      "endTime": "928732005976905",
      "elapsedTime": "29395",
      "asyncId": 650,
      "triggerAsyncId": 90,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 495
    },
    "496": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732995106611",
      "endTime": "928732997149721",
      "elapsedTime": "2043110",
      "asyncId": 651,
      "triggerAsyncId": 622,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        652,
        652
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 496
    },
    "497": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732007779875",
      "endTime": "928732007804742",
      "elapsedTime": "24867",
      "asyncId": 652,
      "triggerAsyncId": 90,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        659,
        662,
        660,
        664,
        670,
        653,
        653,
        653,
        653
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 497
    },
    "498": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732995269997",
      "endTime": "928732997173565",
      "elapsedTime": "1903568",
      "asyncId": 653,
      "triggerAsyncId": 647,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        682,
        674,
        673,
        672,
        671,
        680,
        684,
        688,
        654,
        660,
        663,
        661,
        665,
        671,
        654,
        654
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 498
    },
    "499": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:207:48:207:48",
      "startTime": "928732995527881",
      "endTime": "928732995540233",
      "elapsedTime": "12352",
      "asyncId": 654,
      "triggerAsyncId": 644,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        672,
        675,
        673,
        677,
        681,
        655,
        655
      ],
      "line": "\n      const send = jest.fn(() => Promise.resolve());\n      const sendTemplatedEmail = jest.fn(() => Promise.resolve());\n      const updateById = jest.fn(() => Promise.resolve());\n      const createToken = jest.fn(() => resetPasswordToken);\n\n      const config = ",
      "startLine": 207,
      "startCol": 48,
      "endLine": 207,
      "endCol": 48,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 499
    },
    "500": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:237:7:237:7",
      "startTime": "928732995670397",
      "endTime": "928732996502417",
      "elapsedTime": "832020",
      "asyncId": 655,
      "triggerAsyncId": 654,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        658
      ],
      "line": "\n\n      const input = { email: user.email };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(createToken).toHaveBeenCalled()",
      "startLine": 237,
      "startCol": 7,
      "endLine": 237,
      "endCol": 7,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 500
    },
    "501": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732010813562",
      "endTime": "928732031514748",
      "elapsedTime": "20701186",
      "asyncId": 656,
      "triggerAsyncId": 90,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 501
    },
    "502": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928732995894978",
      "endTime": "928732997231274",
      "elapsedTime": "1336296",
      "asyncId": 657,
      "triggerAsyncId": 622,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 502
    },
    "503": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:206:56:206:56",
      "startTime": "928732996305899",
      "endTime": "928732996318512",
      "elapsedTime": "12613",
      "asyncId": 658,
      "triggerAsyncId": 655,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const send = jest.fn(() => Promise.resolve());\n      const sendTemplatedEmail = jest.fn(() => Promise.resolve());\n      const updateById = jest.fn(() => Promise.resolve());\n      const createToken = jest.fn(() => resetPasswordToken);",
      "startLine": 206,
      "startCol": 56,
      "endLine": 206,
      "endCol": 56,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [
        659
      ],
      "uniqueid": 503
    },
    "504": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732013038323",
      "endTime": "928732013114936",
      "elapsedTime": "76613",
      "asyncId": 660,
      "triggerAsyncId": 653,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        666,
        662
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 504
    },
    "505": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732997843571",
      "endTime": "928733024145777",
      "elapsedTime": "26302206",
      "asyncId": 661,
      "triggerAsyncId": 65,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        667,
        672
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 505
    },
    "506": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732997998472",
      "endTime": "928733024172687",
      "elapsedTime": "26174215",
      "asyncId": 662,
      "triggerAsyncId": 65,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        669,
        669
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 506
    },
    "507": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732998236748",
      "endTime": "928732998250013",
      "elapsedTime": "13265",
      "asyncId": 663,
      "triggerAsyncId": 65,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 507
    },
    "508": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731913142259",
      "endTime": "928731914979223",
      "elapsedTime": "1836964",
      "asyncId": 664,
      "triggerAsyncId": 652,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 508
    },
    "509": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732998681983",
      "endTime": "928732998694005",
      "elapsedTime": "12022",
      "asyncId": 665,
      "triggerAsyncId": 65,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        666,
        666
      ],
      "uniqueid": 509
    },
    "510": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732998910802",
      "endTime": "928733008347682",
      "elapsedTime": "9436880",
      "asyncId": 666,
      "triggerAsyncId": 665,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        676,
        678,
        684,
        675,
        682,
        698,
        667,
        667
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 510
    },
    "511": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732999114243",
      "endTime": "928733016916716",
      "elapsedTime": "17802473",
      "asyncId": 667,
      "triggerAsyncId": 666,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        719,
        721,
        727,
        718,
        725,
        738,
        668,
        668
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 511
    },
    "512": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732999309169",
      "endTime": "928733024046882",
      "elapsedTime": "24737713",
      "asyncId": 668,
      "triggerAsyncId": 667,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        759,
        761,
        767,
        758,
        765,
        778
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 512
    },
    "513": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732999459090",
      "endTime": "928733024103277",
      "elapsedTime": "24644187",
      "asyncId": 669,
      "triggerAsyncId": 662,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        670
      ],
      "uniqueid": 513
    },
    "514": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732999608740",
      "endTime": "928733024194649",
      "elapsedTime": "24585909",
      "asyncId": 670,
      "triggerAsyncId": 669,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 514
    },
    "515": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732999767758",
      "endTime": "928733024220367",
      "elapsedTime": "24452609",
      "asyncId": 671,
      "triggerAsyncId": 65,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        681
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 515
    },
    "516": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733000047693",
      "endTime": "928733000059515",
      "elapsedTime": "11822",
      "asyncId": 673,
      "triggerAsyncId": 65,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        678,
        679
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 516
    },
    "517": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928733000358105",
      "endTime": "928733008244940",
      "elapsedTime": "7886835",
      "asyncId": 675,
      "triggerAsyncId": 666,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        676,
        683
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 517
    },
    "518": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928733000590371",
      "endTime": "928733000605429",
      "elapsedTime": "15058",
      "asyncId": 676,
      "triggerAsyncId": 666,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 518
    },
    "519": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732028589855",
      "endTime": "928732031074072",
      "elapsedTime": "2484217",
      "asyncId": 677,
      "triggerAsyncId": 654,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        689
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 519
    },
    "520": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928733000997484",
      "endTime": "928733001015738",
      "elapsedTime": "18254",
      "asyncId": 678,
      "triggerAsyncId": 666,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        679,
        679
      ],
      "uniqueid": 520
    },
    "521": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928733001243024",
      "endTime": "928733004456959",
      "elapsedTime": "3213935",
      "asyncId": 679,
      "triggerAsyncId": 678,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        689,
        692,
        690,
        694,
        700,
        680,
        680
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 521
    },
    "522": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928733001442207",
      "endTime": "928733008177774",
      "elapsedTime": "6735567",
      "asyncId": 680,
      "triggerAsyncId": 679,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        686,
        704,
        702,
        710,
        703,
        702,
        701,
        708,
        712,
        717,
        681
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 522
    },
    "523": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928733001605103",
      "endTime": "928733008269546",
      "elapsedTime": "6664443",
      "asyncId": 681,
      "triggerAsyncId": 680,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 523
    },
    "524": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733001715409",
      "endTime": "928733008292298",
      "elapsedTime": "6576889",
      "asyncId": 682,
      "triggerAsyncId": 666,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        690
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 524
    },
    "525": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733001936775",
      "endTime": "928733001947745",
      "elapsedTime": "10970",
      "asyncId": 684,
      "triggerAsyncId": 666,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 525
    },
    "526": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732035156535",
      "endTime": "928732035229422",
      "elapsedTime": "72887",
      "asyncId": 685,
      "triggerAsyncId": 91,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        686,
        686
      ],
      "uniqueid": 526
    },
    "527": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732035731913",
      "endTime": "928732044425110",
      "elapsedTime": "8693197",
      "asyncId": 686,
      "triggerAsyncId": 685,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        693,
        696,
        694,
        698,
        704,
        687,
        687
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 527
    },
    "528": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732036309476",
      "endTime": "928732054119262",
      "elapsedTime": "17809786",
      "asyncId": 687,
      "triggerAsyncId": 686,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        705,
        708,
        706,
        710,
        714,
        688
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 528
    },
    "529": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928733002428907",
      "endTime": "928733024297852",
      "elapsedTime": "21868945",
      "asyncId": 688,
      "triggerAsyncId": 65,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 529
    },
    "530": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928733002545355",
      "endTime": "928733002562177",
      "elapsedTime": "16822",
      "asyncId": 689,
      "triggerAsyncId": 679,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        690,
        691
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 530
    },
    "531": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733002695056",
      "endTime": "928733004106211",
      "elapsedTime": "1411155",
      "asyncId": 690,
      "triggerAsyncId": 679,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        691,
        696
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 531
    },
    "532": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733002920729",
      "endTime": "928733002931720",
      "elapsedTime": "10991",
      "asyncId": 692,
      "triggerAsyncId": 679,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        693
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 532
    },
    "533": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732038524048",
      "endTime": "928732038568030",
      "elapsedTime": "43982",
      "asyncId": 693,
      "triggerAsyncId": 686,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        695
      ],
      "uniqueid": 533
    },
    "534": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928733003211524",
      "endTime": "928733004391516",
      "elapsedTime": "1179992",
      "asyncId": 694,
      "triggerAsyncId": 679,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        700
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 534
    },
    "535": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928733003375702",
      "endTime": "928733004419879",
      "elapsedTime": "1044177",
      "asyncId": 696,
      "triggerAsyncId": 690,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 535
    },
    "536": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928733004092345",
      "endTime": "928733008370264",
      "elapsedTime": "4277919",
      "asyncId": 698,
      "triggerAsyncId": 666,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        699,
        699
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 536
    },
    "537": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731929329493",
      "endTime": "928731934832920",
      "elapsedTime": "5503427",
      "asyncId": 699,
      "triggerAsyncId": 698,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        706,
        709,
        707,
        711,
        717,
        700,
        700
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 537
    },
    "538": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928733004369064",
      "endTime": "928733004482086",
      "elapsedTime": "113022",
      "asyncId": 700,
      "triggerAsyncId": 679,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        729,
        721,
        720,
        719,
        718,
        727,
        731,
        735,
        701
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 538
    },
    "539": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928733004627659",
      "endTime": "928733007715147",
      "elapsedTime": "3087488",
      "asyncId": 701,
      "triggerAsyncId": 680,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        709
      ],
      "uniqueid": 539
    },
    "540": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928733004863771",
      "endTime": "928733007683677",
      "elapsedTime": "2819906",
      "asyncId": 702,
      "triggerAsyncId": 680,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [
        707
      ],
      "uniqueid": 540
    },
    "541": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:259:14:259:14",
      "startTime": "928733005209490",
      "endTime": "928733007015455",
      "elapsedTime": "1805965",
      "asyncId": 703,
      "triggerAsyncId": 680,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n\n      expect.assertions(2);\n      return resetPassword({ resetPasswordToken, password: 'Test1234' }).catch(() => {\n        expect(findOne).toHaveBeenCalledWith({ resetPasswordToken, isActive: true });\n        expect(badRequest).toHaveBeenCalled();\n      })",
      "startLine": 259,
      "startCol": 14,
      "endLine": 259,
      "endCol": 14,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [
        706
      ],
      "uniqueid": 541
    },
    "542": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:248:45:248:45",
      "startTime": "928733005507328",
      "endTime": "928733005520032",
      "elapsedTime": "12704",
      "asyncId": 704,
      "triggerAsyncId": 680,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n    test('Check user is active', async () => {\n      const resetPasswordToken = '123';\n      const findOne = jest.fn(() => Promise.resolve());\n      const badRequest = jest.fn(() => {});\n\n      global.strapi = ",
      "startLine": 248,
      "startCol": 45,
      "endLine": 248,
      "endCol": 45,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [
        705
      ],
      "uniqueid": 542
    },
    "543": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:259:14:259:14",
      "startTime": "928733005710188",
      "endTime": "928733007041925",
      "elapsedTime": "1331737",
      "asyncId": 705,
      "triggerAsyncId": 704,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        707
      ],
      "line": "\n\n      expect.assertions(2);\n      return resetPassword({ resetPasswordToken, password: 'Test1234' }).catch(() => {\n        expect(findOne).toHaveBeenCalledWith({ resetPasswordToken, isActive: true });\n        expect(badRequest).toHaveBeenCalled();\n      })",
      "startLine": 259,
      "startCol": 14,
      "endLine": 259,
      "endCol": 14,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 543
    },
    "544": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928733006115418",
      "endTime": "928733007737779",
      "elapsedTime": "1622361",
      "asyncId": 707,
      "triggerAsyncId": 702,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        713
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 544
    },
    "545": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733006227538",
      "endTime": "928733007759790",
      "elapsedTime": "1532252",
      "asyncId": 708,
      "triggerAsyncId": 680,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        714
      ],
      "uniqueid": 545
    },
    "546": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733006466205",
      "endTime": "928733006477687",
      "elapsedTime": "11482",
      "asyncId": 710,
      "triggerAsyncId": 680,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 546
    },
    "547": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731933109690",
      "endTime": "928731934576870",
      "elapsedTime": "1467180",
      "asyncId": 711,
      "triggerAsyncId": 699,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 547
    },
    "548": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928733006769273",
      "endTime": "928733008111209",
      "elapsedTime": "1341936",
      "asyncId": 712,
      "triggerAsyncId": 680,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 548
    },
    "549": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731933452132",
      "endTime": "928731934639828",
      "elapsedTime": "1187696",
      "asyncId": 713,
      "triggerAsyncId": 707,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 549
    },
    "550": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928733006933261",
      "endTime": "928733008140464",
      "elapsedTime": "1207203",
      "asyncId": 714,
      "triggerAsyncId": 708,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 550
    },
    "551": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732055022355",
      "endTime": "928732079296960",
      "elapsedTime": "24274605",
      "asyncId": 715,
      "triggerAsyncId": 92,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        723
      ],
      "uniqueid": 551
    },
    "552": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732055962007",
      "endTime": "928732055983537",
      "elapsedTime": "21530",
      "asyncId": 716,
      "triggerAsyncId": 92,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 552
    },
    "553": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928733007351755",
      "endTime": "928733008200666",
      "elapsedTime": "848911",
      "asyncId": 717,
      "triggerAsyncId": 680,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 553
    },
    "554": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928733008528200",
      "endTime": "928733016792984",
      "elapsedTime": "8264784",
      "asyncId": 718,
      "triggerAsyncId": 667,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        728,
        719,
        719,
        726
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 554
    },
    "555": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928733010278271",
      "endTime": "928733010291216",
      "elapsedTime": "12945",
      "asyncId": 719,
      "triggerAsyncId": 667,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        726,
        726,
        729,
        727,
        731,
        737,
        720,
        720
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 555
    },
    "556": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732057928553",
      "endTime": "928732079163850",
      "elapsedTime": "21235297",
      "asyncId": 720,
      "triggerAsyncId": 719,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        725,
        738,
        741,
        739,
        743,
        747,
        721
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 556
    },
    "557": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928733010867005",
      "endTime": "928733010877915",
      "elapsedTime": "10910",
      "asyncId": 721,
      "triggerAsyncId": 667,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        722,
        724,
        722,
        722
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 557
    },
    "558": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928733011118356",
      "endTime": "928733013657426",
      "elapsedTime": "2539070",
      "asyncId": 722,
      "triggerAsyncId": 721,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        723,
        729,
        732,
        730,
        734,
        740,
        723,
        723
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 558
    },
    "559": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928733011340162",
      "endTime": "928733016720718",
      "elapsedTime": "5380556",
      "asyncId": 723,
      "triggerAsyncId": 722,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        744,
        742,
        750,
        743,
        742,
        741,
        748,
        752,
        757,
        724
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 559
    },
    "560": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928733011509489",
      "endTime": "928733016821367",
      "elapsedTime": "5311878",
      "asyncId": 724,
      "triggerAsyncId": 723,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        736
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 560
    },
    "561": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733011639433",
      "endTime": "928733016845763",
      "elapsedTime": "5206330",
      "asyncId": 725,
      "triggerAsyncId": 667,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 561
    },
    "562": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733011893048",
      "endTime": "928733011904480",
      "elapsedTime": "11432",
      "asyncId": 727,
      "triggerAsyncId": 667,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        733,
        733
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 562
    },
    "563": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928733012219210",
      "endTime": "928733012239518",
      "elapsedTime": "20308",
      "asyncId": 729,
      "triggerAsyncId": 722,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        731
      ],
      "uniqueid": 563
    },
    "564": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733012368860",
      "endTime": "928733013278445",
      "elapsedTime": "909585",
      "asyncId": 730,
      "triggerAsyncId": 722,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        736
      ],
      "uniqueid": 564
    },
    "565": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733012596818",
      "endTime": "928733012607939",
      "elapsedTime": "11121",
      "asyncId": 732,
      "triggerAsyncId": 722,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 565
    },
    "566": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732062113668",
      "endTime": "928732063629249",
      "elapsedTime": "1515581",
      "asyncId": 733,
      "triggerAsyncId": 727,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 566
    },
    "567": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928733012868587",
      "endTime": "928733013596131",
      "elapsedTime": "727544",
      "asyncId": 734,
      "triggerAsyncId": 722,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 567
    },
    "568": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928733013037914",
      "endTime": "928733013622721",
      "elapsedTime": "584807",
      "asyncId": 736,
      "triggerAsyncId": 730,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        737
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 568
    },
    "569": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928733013266072",
      "endTime": "928733016941763",
      "elapsedTime": "3675691",
      "asyncId": 738,
      "triggerAsyncId": 667,
      "createdIn": 1626205014925,
      "functionName": "",
      "triggers": [
        739,
        741,
        740
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 569
    },
    "570": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732069041645",
      "endTime": "928732078650418",
      "elapsedTime": "9608773",
      "asyncId": 739,
      "triggerAsyncId": 720,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        740,
        745
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 570
    },
    "571": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928733013574651",
      "endTime": "928733013680449",
      "elapsedTime": "105798",
      "asyncId": 740,
      "triggerAsyncId": 722,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 571
    },
    "572": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928733013808710",
      "endTime": "928733016551030",
      "elapsedTime": "2742320",
      "asyncId": 741,
      "triggerAsyncId": 723,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        749
      ],
      "uniqueid": 572
    },
    "573": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928733014042798",
      "endTime": "928733016519862",
      "elapsedTime": "2477064",
      "asyncId": 742,
      "triggerAsyncId": 723,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        750,
        747
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 573
    },
    "574": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:278:14:278:14",
      "startTime": "928733014279923",
      "endTime": "928733015983787",
      "elapsedTime": "1703864",
      "asyncId": 743,
      "triggerAsyncId": 723,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n\n      expect.assertions(1);\n      return resetPassword({ resetPasswordToken, password: 'Test1234' }).catch(() => {\n        expect(badRequest).toHaveBeenCalled();\n      });\n    })",
      "startLine": 278,
      "startCol": 14,
      "endLine": 278,
      "endCol": 14,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [
        746
      ],
      "uniqueid": 574
    },
    "575": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:267:45:267:45",
      "startTime": "928733014571139",
      "endTime": "928733014585515",
      "elapsedTime": "14376",
      "asyncId": 744,
      "triggerAsyncId": 723,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n    test('Fails if user is not found', async () => {\n      const resetPasswordToken = '123';\n      const findOne = jest.fn(() => Promise.resolve());\n      const badRequest = jest.fn(() => {});\n\n      global.strapi = ",
      "startLine": 267,
      "startCol": 45,
      "endLine": 267,
      "endCol": 45,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [
        745
      ],
      "uniqueid": 575
    },
    "576": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:278:14:278:14",
      "startTime": "928733014775141",
      "endTime": "928733016028601",
      "elapsedTime": "1253460",
      "asyncId": 745,
      "triggerAsyncId": 744,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        746,
        746
      ],
      "line": "\n\n      expect.assertions(1);\n      return resetPassword({ resetPasswordToken, password: 'Test1234' }).catch(() => {\n        expect(badRequest).toHaveBeenCalled();\n      });\n    })",
      "startLine": 278,
      "startCol": 14,
      "endLine": 278,
      "endCol": 14,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 576
    },
    "577": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928733015133252",
      "endTime": "928733016573863",
      "elapsedTime": "1440611",
      "asyncId": 747,
      "triggerAsyncId": 742,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        776,
        768,
        767,
        766,
        765,
        774,
        778,
        782,
        748
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 577
    },
    "578": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733015245803",
      "endTime": "928733016598088",
      "elapsedTime": "1352285",
      "asyncId": 748,
      "triggerAsyncId": 723,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        756,
        754
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 578
    },
    "579": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733015470485",
      "endTime": "928733015481846",
      "elapsedTime": "11361",
      "asyncId": 750,
      "triggerAsyncId": 723,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 579
    },
    "580": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732080666567",
      "endTime": "928732080682377",
      "elapsedTime": "15810",
      "asyncId": 751,
      "triggerAsyncId": 93,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        752,
        752
      ],
      "uniqueid": 580
    },
    "581": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928733015750850",
      "endTime": "928733016655516",
      "elapsedTime": "904666",
      "asyncId": 752,
      "triggerAsyncId": 723,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        759,
        762,
        760,
        764,
        770,
        753,
        753
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 581
    },
    "582": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732081188856",
      "endTime": "928732088219135",
      "elapsedTime": "7030279",
      "asyncId": 753,
      "triggerAsyncId": 752,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        755,
        771,
        774,
        772,
        776,
        780,
        754
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 582
    },
    "583": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928733015914958",
      "endTime": "928733016682306",
      "elapsedTime": "767348",
      "asyncId": 754,
      "triggerAsyncId": 748,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        760
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 583
    },
    "584": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732081609074",
      "endTime": "928732088390216",
      "elapsedTime": "6781142",
      "asyncId": 755,
      "triggerAsyncId": 93,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 584
    },
    "585": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928733016344874",
      "endTime": "928733016745254",
      "elapsedTime": "400380",
      "asyncId": 757,
      "triggerAsyncId": 723,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 585
    },
    "586": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928733017138662",
      "endTime": "928733023932026",
      "elapsedTime": "6793364",
      "asyncId": 758,
      "triggerAsyncId": 668,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        766
      ],
      "uniqueid": 586
    },
    "587": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928733017378551",
      "endTime": "928733017390574",
      "elapsedTime": "12023",
      "asyncId": 759,
      "triggerAsyncId": 668,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        761
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 587
    },
    "588": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732082679992",
      "endTime": "928732083919365",
      "elapsedTime": "1239373",
      "asyncId": 760,
      "triggerAsyncId": 752,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        766
      ],
      "uniqueid": 588
    },
    "589": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928733017821111",
      "endTime": "928733017832813",
      "elapsedTime": "11702",
      "asyncId": 761,
      "triggerAsyncId": 668,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        762,
        762
      ],
      "uniqueid": 589
    },
    "590": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928733018077602",
      "endTime": "928733020648902",
      "elapsedTime": "2571300",
      "asyncId": 762,
      "triggerAsyncId": 761,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        769,
        772,
        770,
        774,
        780,
        763,
        763
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 590
    },
    "591": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928733018294969",
      "endTime": "928733023869028",
      "elapsedTime": "5574059",
      "asyncId": 763,
      "triggerAsyncId": 762,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        784,
        790,
        783,
        783,
        782,
        781,
        788,
        792,
        797,
        764
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 591
    },
    "592": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928733018467202",
      "endTime": "928733023956532",
      "elapsedTime": "5489330",
      "asyncId": 764,
      "triggerAsyncId": 763,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 592
    },
    "593": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733018593439",
      "endTime": "928733023979035",
      "elapsedTime": "5385596",
      "asyncId": 765,
      "triggerAsyncId": 668,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        775
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 593
    },
    "594": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733018852645",
      "endTime": "928733018863786",
      "elapsedTime": "11141",
      "asyncId": 767,
      "triggerAsyncId": 668,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        772
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 594
    },
    "595": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928733019175530",
      "endTime": "928733019191861",
      "elapsedTime": "16331",
      "asyncId": 769,
      "triggerAsyncId": 762,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        770,
        771
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 595
    },
    "596": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733019318388",
      "endTime": "928733020282054",
      "elapsedTime": "963666",
      "asyncId": 770,
      "triggerAsyncId": 762,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        776
      ],
      "uniqueid": 596
    },
    "597": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733019552226",
      "endTime": "928733019562966",
      "elapsedTime": "10740",
      "asyncId": 772,
      "triggerAsyncId": 762,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        778
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 597
    },
    "598": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928733019862528",
      "endTime": "928733020583910",
      "elapsedTime": "721382",
      "asyncId": 774,
      "triggerAsyncId": 762,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        780
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 598
    },
    "599": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928733020040301",
      "endTime": "928733020615098",
      "elapsedTime": "574797",
      "asyncId": 776,
      "triggerAsyncId": 770,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 599
    },
    "600": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928733020270102",
      "endTime": "928733024069654",
      "elapsedTime": "3799552",
      "asyncId": 778,
      "triggerAsyncId": 668,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 600
    },
    "601": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928733020562440",
      "endTime": "928733020674069",
      "elapsedTime": "111629",
      "asyncId": 780,
      "triggerAsyncId": 762,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 601
    },
    "602": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928733020811507",
      "endTime": "928733023711863",
      "elapsedTime": "2900356",
      "asyncId": 781,
      "triggerAsyncId": 763,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        789,
        789
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 602
    },
    "603": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928733021055905",
      "endTime": "928733023661389",
      "elapsedTime": "2605484",
      "asyncId": 782,
      "triggerAsyncId": 763,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [
        787
      ],
      "uniqueid": 603
    },
    "604": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:298:13:298:13",
      "startTime": "928733021281899",
      "endTime": "928733023486471",
      "elapsedTime": "2204572",
      "asyncId": 783,
      "triggerAsyncId": 763,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        784,
        786
      ],
      "line": "\n\n      const input = { resetPasswordToken, password: 'Test1234' };\n      await resetPassword(input);\n\n      expect(updateById).toHaveBeenCalledWith(user.id, {\n        password: input.password",
      "startLine": 298,
      "startCol": 13,
      "endLine": 298,
      "endCol": 13,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 604
    },
    "605": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:287:45:287:45",
      "startTime": "928733021557605",
      "endTime": "928733021568957",
      "elapsedTime": "11352",
      "asyncId": 784,
      "triggerAsyncId": 763,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        785,
        785,
        785,
        785
      ],
      "line": "\n      const user = { id: 1 };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const updateById = jest.fn(() => Promise.resolve());\n\n      global.strapi = ",
      "startLine": 287,
      "startCol": 45,
      "endLine": 287,
      "endCol": 45,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 605
    },
    "606": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:298:13:298:13",
      "startTime": "928733021753312",
      "endTime": "928733023149710",
      "elapsedTime": "1396398",
      "asyncId": 785,
      "triggerAsyncId": 784,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        786,
        788,
        792,
        795,
        793,
        797,
        803,
        786,
        786,
        795
      ],
      "line": "\n\n      const input = { resetPasswordToken, password: 'Test1234' };\n      await resetPassword(input);\n\n      expect(updateById).toHaveBeenCalledWith(user.id, {\n        password: input.password",
      "startLine": 298,
      "startCol": 13,
      "endLine": 298,
      "endCol": 13,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "uniqueid": 606
    },
    "607": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928733021911408",
      "endTime": "928733023688720",
      "elapsedTime": "1777312",
      "asyncId": 786,
      "triggerAsyncId": 783,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        787,
        804,
        807,
        805,
        809,
        813,
        787
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 607
    },
    "608": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928733022062562",
      "endTime": "928733023733374",
      "elapsedTime": "1670812",
      "asyncId": 787,
      "triggerAsyncId": 782,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 608
    },
    "609": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733022175323",
      "endTime": "928733023754874",
      "elapsedTime": "1579551",
      "asyncId": 788,
      "triggerAsyncId": 763,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        794
      ],
      "uniqueid": 609
    },
    "610": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928733022395997",
      "endTime": "928733022407078",
      "elapsedTime": "11081",
      "asyncId": 790,
      "triggerAsyncId": 763,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 610
    },
    "611": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928733022661214",
      "endTime": "928733023812182",
      "elapsedTime": "1150968",
      "asyncId": 792,
      "triggerAsyncId": 763,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        793,
        793,
        794
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 611
    },
    "612": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732091483765",
      "endTime": "928732092734199",
      "elapsedTime": "1250434",
      "asyncId": 793,
      "triggerAsyncId": 785,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        800,
        803,
        801,
        805,
        811,
        794,
        794,
        799
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 612
    },
    "613": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928733022825412",
      "endTime": "928733023835435",
      "elapsedTime": "1010023",
      "asyncId": 794,
      "triggerAsyncId": 788,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        823,
        815,
        814,
        813,
        812,
        821,
        825,
        829,
        795
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 613
    },
    "614": {
      "source": "packages/strapi-admin/services/__tests__/auth.test.js:288:48:288:48",
      "startTime": "928733023087323",
      "endTime": "928733023099776",
      "elapsedTime": "12453",
      "asyncId": 795,
      "triggerAsyncId": 785,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const updateById = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query() ",
      "startLine": 288,
      "startCol": 48,
      "endLine": 288,
      "endCol": 48,
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "triggers": [],
      "uniqueid": 614
    },
    "615": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731963172846",
      "endTime": "928731973923258",
      "elapsedTime": "10750412",
      "asyncId": 796,
      "triggerAsyncId": 450,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 615
    },
    "616": {
      "source": "(undefined:NaN:NaN:NaN:NaN)",
      "startTime": "928733023368961",
      "endTime": "928733023890428",
      "elapsedTime": "521467",
      "asyncId": 797,
      "triggerAsyncId": 763,
      "createdIn": 1626205014925,
      "functionName": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 616
    },
    "617": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731963688492",
      "endTime": "928731963724440",
      "elapsedTime": "35948",
      "asyncId": 798,
      "triggerAsyncId": 450,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 617
    },
    "618": {
      "source": "node_modules/jest-runner/build/runTest.js:380:16:380:16",
      "startTime": "928733025552394",
      "endTime": "928733025838610",
      "elapsedTime": "286216",
      "asyncId": 799,
      "triggerAsyncId": 26,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " runTestInternal",
      "userCode": false,
      "line": "\n      }\n\n      result = await testFramework(\n        globalConfig,\n        config,\n        environment",
      "startLine": 380,
      "startCol": 16,
      "endLine": 380,
      "endCol": 16,
      "file": "node_modules/jest-runner/build/runTest.js",
      "triggers": [],
      "uniqueid": 618
    },
    "619": {
      "source": "node_modules/jest-runner/build/runTest.js:442:12:442:12",
      "startTime": "928733027611514",
      "endTime": "928733036613669",
      "elapsedTime": "9002155",
      "asyncId": 800,
      "triggerAsyncId": 52,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        802
      ],
      "line": "\n    } // Delay the resolution to allow log messages to be output.\n\n    return new Promise(resolve => {\n      setImmediate(() =>\n        resolve({\n          leakDetector",
      "startLine": 442,
      "startCol": 12,
      "endLine": 442,
      "endCol": 12,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 619
    },
    "620": {
      "source": "node_modules/jest-runner/build/runTest.js:453:23:453:23",
      "startTime": "928733027916997",
      "endTime": "928733034527849",
      "elapsedTime": "6610852",
      "asyncId": 802,
      "triggerAsyncId": 52,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " runTestInternal",
      "userCode": false,
      "line": "\n    var _runtime$teardown;\n\n    await environment.teardown(); // TODO: this function might be missing, remove ? in Jest 26\n\n    (_runtime$teardown = runtime.teardown) === null ||\n    _runtime$teardown === void ",
      "startLine": 453,
      "startCol": 23,
      "endLine": 453,
      "endCol": 23,
      "file": "node_modules/jest-runner/build/runTest.js",
      "triggers": [
        810
      ],
      "uniqueid": 620
    },
    "621": {
      "source": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js:132:11:132:11",
      "startTime": "928733031391199",
      "endTime": "928733031411447",
      "elapsedTime": "20248",
      "asyncId": 803,
      "triggerAsyncId": 52,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueMutationObserverMicrotask",
      "userCode": false,
      "line": "\n  mutationObserverMicrotaskQueueFlag = true;\n\n  Promise.resolve().then(() => {\n    notifyMutationObservers();\n  });\n",
      "startLine": 132,
      "startCol": 11,
      "endLine": 132,
      "endCol": 11,
      "file": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js",
      "triggers": [
        804
      ],
      "uniqueid": 621
    },
    "622": {
      "source": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js:132:21:132:21",
      "startTime": "928733032063740",
      "endTime": "928733034771275",
      "elapsedTime": "2707535",
      "asyncId": 804,
      "triggerAsyncId": 803,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueMutationObserverMicrotask",
      "userCode": false,
      "triggers": [
        806
      ],
      "line": "\n  mutationObserverMicrotaskQueueFlag = true;\n\n  Promise.resolve().then(() => {\n    notifyMutationObservers();\n  });\n",
      "startLine": 132,
      "startCol": 21,
      "endLine": 132,
      "endCol": 21,
      "file": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js",
      "uniqueid": 622
    },
    "623": {
      "source": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js:446:34:446:34",
      "startTime": "928733033292563",
      "endTime": "928733033306940",
      "elapsedTime": "14377",
      "asyncId": 805,
      "triggerAsyncId": 52,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " DocumentImpl.close",
      "userCode": false,
      "triggers": [
        811,
        806,
        808
      ],
      "line": "\n    this._queue.resume();\n\n    const dummyPromise = Promise.resolve();\n\n    const onDOMContentLoad = () => {\n      const doc = this",
      "startLine": 446,
      "startCol": 34,
      "endLine": 446,
      "endCol": 34,
      "file": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js",
      "uniqueid": 623
    },
    "624": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:116:8:116:8",
      "startTime": "928733033626600",
      "endTime": "928733035451020",
      "elapsedTime": "1824420",
      "asyncId": 806,
      "triggerAsyncId": 805,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " ResourceQueue.push",
      "userCode": false,
      "triggers": [
        811,
        807
      ],
      "line": "\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check()",
      "startLine": 116,
      "startCol": 8,
      "endLine": 116,
      "endCol": 8,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "uniqueid": 624
    },
    "625": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:116:8:116:8",
      "startTime": "928733034127839",
      "endTime": "928733035484583",
      "elapsedTime": "1356744",
      "asyncId": 808,
      "triggerAsyncId": 805,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " ResourceQueue.push",
      "userCode": false,
      "line": "\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check()",
      "startLine": 116,
      "startCol": 8,
      "endLine": 116,
      "endCol": 8,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "triggers": [
        809
      ],
      "uniqueid": 625
    },
    "626": {
      "source": "node_modules/jest-runner/build/runTest.js:472:34:472:34",
      "startTime": "928733034716913",
      "endTime": "928733035695808",
      "elapsedTime": "978895",
      "asyncId": 810,
      "triggerAsyncId": 802,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " runTest",
      "userCode": false,
      "line": "\n  sendMessageToJest\n) {\n  const {leakDetector, result} = await runTestInternal(\n    path,\n    globalConfig,\n    config",
      "startLine": 472,
      "startCol": 34,
      "endLine": 472,
      "endCol": 34,
      "file": "node_modules/jest-runner/build/runTest.js",
      "triggers": [],
      "uniqueid": 626
    },
    "627": {
      "source": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js:456:14:456:14",
      "startTime": "928733034975088",
      "endTime": "928733035247418",
      "elapsedTime": "272330",
      "asyncId": 811,
      "triggerAsyncId": 806,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " onDOMContentLoad",
      "userCode": false,
      "line": "\n      }\n\n      return new Promise(resolve => {\n        if (!this._deferQueue.tail) {\n          dispatchEvent();\n          return resolve()",
      "startLine": 456,
      "startCol": 14,
      "endLine": 456,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js",
      "triggers": [
        812
      ],
      "uniqueid": 627
    },
    "628": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:80:14:80:14",
      "startTime": "928733035437074",
      "endTime": "928733036229349",
      "elapsedTime": "792275",
      "asyncId": 812,
      "triggerAsyncId": 811,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.check",
      "userCode": false,
      "triggers": [
        822,
        813
      ],
      "line": "\n\n          Promise.resolve(promise)\n            .then(() => {\n              if (this.next) {\n                this.next.prev = null;\n                this.next.check()",
      "startLine": 80,
      "startCol": 14,
      "endLine": 80,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "uniqueid": 628
    },
    "629": {
      "source": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js:478:14:478:14",
      "startTime": "928733035911523",
      "endTime": "928733036021699",
      "elapsedTime": "110176",
      "asyncId": 813,
      "triggerAsyncId": 812,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " onLoad",
      "userCode": false,
      "triggers": [
        820,
        814
      ],
      "line": "\n      }\n\n      return new Promise(resolve => {\n        if (this._asyncQueue.count() === 0) {\n          dispatchEvent();\n          return resolve()",
      "startLine": 478,
      "startCol": 14,
      "endLine": 478,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js",
      "uniqueid": 629
    },
    "630": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:80:14:80:14",
      "startTime": "928733036208069",
      "endTime": "928733036454641",
      "elapsedTime": "246572",
      "asyncId": 814,
      "triggerAsyncId": 813,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.check",
      "userCode": false,
      "triggers": [
        819,
        822
      ],
      "line": "\n\n          Promise.resolve(promise)\n            .then(() => {\n              if (this.next) {\n                this.next.prev = null;\n                this.next.check()",
      "startLine": 80,
      "startCol": 14,
      "endLine": 80,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "uniqueid": 630
    },
    "631": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732097282004",
      "endTime": "928732097293816",
      "elapsedTime": "11812",
      "asyncId": 815,
      "triggerAsyncId": 95,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        816,
        818
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 631
    },
    "632": {
      "source": "packages/strapi-database/lib/utils/lifecycles.js:12:3:12:3",
      "startTime": "928731968232360",
      "endTime": "928731968570023",
      "elapsedTime": "337663",
      "asyncId": 816,
      "triggerAsyncId": 815,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " executeBeforeLifecycle",
      "userCode": false,
      "line": "\n\nconst executeBeforeLifecycle = (lifecycle, model, ...args) =>\n  executeLifecycle(`before${_.upperFirst(lifecycle)}`, model, ...args);\n\nconst executeAfterLifecycle = (lifecycle, model, ...args) =>\n  executeLifecycle(`after${_.upperFirst(lifecycle)}`, model, ...args)",
      "startLine": 12,
      "startCol": 3,
      "endLine": 12,
      "endCol": 3,
      "file": "packages/strapi-database/lib/utils/lifecycles.js",
      "triggers": [
        817
      ],
      "uniqueid": 632
    },
    "633": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732097806878",
      "endTime": "928732097821686",
      "elapsedTime": "14808",
      "asyncId": 817,
      "triggerAsyncId": 95,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        818,
        818
      ],
      "uniqueid": 633
    },
    "634": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732098097503",
      "endTime": "928732101646586",
      "elapsedTime": "3549083",
      "asyncId": 818,
      "triggerAsyncId": 817,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        830,
        825,
        828,
        826,
        830,
        836,
        819,
        819
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 634
    },
    "635": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732098372278",
      "endTime": "928732104927016",
      "elapsedTime": "6554738",
      "asyncId": 819,
      "triggerAsyncId": 818,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        837,
        840,
        838,
        842,
        846,
        820
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 635
    },
    "636": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732098614873",
      "endTime": "928732105094259",
      "elapsedTime": "6479386",
      "asyncId": 820,
      "triggerAsyncId": 819,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 636
    },
    "637": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732098824686",
      "endTime": "928732105127141",
      "elapsedTime": "6302455",
      "asyncId": 821,
      "triggerAsyncId": 95,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        827
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 637
    },
    "638": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732099196603",
      "endTime": "928732099241397",
      "elapsedTime": "44794",
      "asyncId": 823,
      "triggerAsyncId": 95,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 638
    },
    "639": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732099667947",
      "endTime": "928732099688255",
      "elapsedTime": "20308",
      "asyncId": 825,
      "triggerAsyncId": 818,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        827
      ],
      "uniqueid": 639
    },
    "640": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732099864375",
      "endTime": "928732101161767",
      "elapsedTime": "1297392",
      "asyncId": 826,
      "triggerAsyncId": 818,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        832
      ],
      "uniqueid": 640
    },
    "641": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732100198932",
      "endTime": "928732100216666",
      "elapsedTime": "17734",
      "asyncId": 828,
      "triggerAsyncId": 818,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 641
    },
    "642": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732100575679",
      "endTime": "928732101551408",
      "elapsedTime": "975729",
      "asyncId": 830,
      "triggerAsyncId": 818,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        831
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 642
    },
    "643": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731971786513",
      "endTime": "928731972779534",
      "elapsedTime": "993021",
      "asyncId": 831,
      "triggerAsyncId": 830,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        832
      ],
      "uniqueid": 643
    },
    "644": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732100806982",
      "endTime": "928732101585381",
      "elapsedTime": "778399",
      "asyncId": 832,
      "triggerAsyncId": 826,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        833,
        835
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 644
    },
    "645": {
      "source": "packages/strapi-database/lib/utils/lifecycles.js:15:3:15:3",
      "startTime": "928731972288434",
      "endTime": "928731972527241",
      "elapsedTime": "238807",
      "asyncId": 833,
      "triggerAsyncId": 832,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " executeAfterLifecycle",
      "userCode": false,
      "line": "\n\nconst executeAfterLifecycle = (lifecycle, model, ...args) =>\n  executeLifecycle(`after${_.upperFirst(lifecycle)}`, model, ...args);\n\nmodule.exports = {\n  executeBeforeLifecycle",
      "startLine": 15,
      "startCol": 3,
      "endLine": 15,
      "endCol": 3,
      "file": "packages/strapi-database/lib/utils/lifecycles.js",
      "triggers": [
        834
      ],
      "uniqueid": 645
    },
    "646": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731972746883",
      "endTime": "928731972969921",
      "elapsedTime": "223038",
      "asyncId": 835,
      "triggerAsyncId": 832,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 646
    },
    "647": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732101851340",
      "endTime": "928732103329741",
      "elapsedTime": "1478401",
      "asyncId": 837,
      "triggerAsyncId": 819,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        852,
        839
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 647
    },
    "648": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732103529065",
      "endTime": "928732104478014",
      "elapsedTime": "948949",
      "asyncId": 838,
      "triggerAsyncId": 819,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        844
      ],
      "uniqueid": 648
    },
    "649": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732103829207",
      "endTime": "928732103851940",
      "elapsedTime": "22733",
      "asyncId": 840,
      "triggerAsyncId": 819,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        841
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 649
    },
    "650": {
      "source": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js:132:21:132:21",
      "startTime": "928731981535869",
      "endTime": "928731984449440",
      "elapsedTime": "2913571",
      "asyncId": 841,
      "triggerAsyncId": 840,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueMutationObserverMicrotask",
      "userCode": false,
      "line": "\n  mutationObserverMicrotaskQueueFlag = true;\n\n  Promise.resolve().then(() => {\n    notifyMutationObservers();\n  });\n",
      "startLine": 132,
      "startCol": 21,
      "endLine": 132,
      "endCol": 21,
      "file": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js",
      "triggers": [],
      "uniqueid": 650
    },
    "651": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732104204321",
      "endTime": "928732104824273",
      "elapsedTime": "619952",
      "asyncId": 842,
      "triggerAsyncId": 819,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        843,
        845
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 651
    },
    "652": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:116:8:116:8",
      "startTime": "928731982977341",
      "endTime": "928731985079501",
      "elapsedTime": "2102160",
      "asyncId": 843,
      "triggerAsyncId": 842,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " ResourceQueue.push",
      "userCode": false,
      "triggers": [
        848,
        844
      ],
      "line": "\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check()",
      "startLine": 116,
      "startCol": 8,
      "endLine": 116,
      "endCol": 8,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "uniqueid": 652
    },
    "653": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732104416929",
      "endTime": "928732104861102",
      "elapsedTime": "444173",
      "asyncId": 844,
      "triggerAsyncId": 838,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 653
    },
    "654": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:116:8:116:8",
      "startTime": "928731983551076",
      "endTime": "928731985127792",
      "elapsedTime": "1576716",
      "asyncId": 845,
      "triggerAsyncId": 842,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " ResourceQueue.push",
      "userCode": false,
      "line": "\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check()",
      "startLine": 116,
      "startCol": 8,
      "endLine": 116,
      "endCol": 8,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "triggers": [
        846
      ],
      "uniqueid": 654
    },
    "655": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732105487396",
      "endTime": "928732113046677",
      "elapsedTime": "7559281",
      "asyncId": 847,
      "triggerAsyncId": 96,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        855
      ],
      "uniqueid": 655
    },
    "656": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732105773182",
      "endTime": "928732105799411",
      "elapsedTime": "26229",
      "asyncId": 848,
      "triggerAsyncId": 96,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        849
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 656
    },
    "657": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:80:14:80:14",
      "startTime": "928731985063111",
      "endTime": "928731985979969",
      "elapsedTime": "916858",
      "asyncId": 849,
      "triggerAsyncId": 848,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Object.check",
      "userCode": false,
      "triggers": [
        850
      ],
      "line": "\n\n          Promise.resolve(promise)\n            .then(() => {\n              if (this.next) {\n                this.next.prev = null;\n                this.next.check()",
      "startLine": 80,
      "startCol": 14,
      "endLine": 80,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "uniqueid": 657
    },
    "658": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732106290792",
      "endTime": "928732106321119",
      "elapsedTime": "30327",
      "asyncId": 850,
      "triggerAsyncId": 96,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        851,
        851,
        851
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 658
    },
    "659": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732106583681",
      "endTime": "928732109873638",
      "elapsedTime": "3289957",
      "asyncId": 851,
      "triggerAsyncId": 850,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        858,
        861,
        859,
        863,
        869,
        852,
        852
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 659
    },
    "660": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732106824753",
      "endTime": "928732112950646",
      "elapsedTime": "6125893",
      "asyncId": 852,
      "triggerAsyncId": 851,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        870,
        873,
        871,
        875,
        879,
        853
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 660
    },
    "661": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732107059463",
      "endTime": "928732113076061",
      "elapsedTime": "6016598",
      "asyncId": 853,
      "triggerAsyncId": 852,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 661
    },
    "662": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732107223621",
      "endTime": "928732113117219",
      "elapsedTime": "5893598",
      "asyncId": 854,
      "triggerAsyncId": 96,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 662
    },
    "663": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732107535866",
      "endTime": "928732107549541",
      "elapsedTime": "13675",
      "asyncId": 856,
      "triggerAsyncId": 96,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 663
    },
    "664": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732107934273",
      "endTime": "928732107970791",
      "elapsedTime": "36518",
      "asyncId": 858,
      "triggerAsyncId": 851,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        860
      ],
      "uniqueid": 664
    },
    "665": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732108150628",
      "endTime": "928732109437300",
      "elapsedTime": "1286672",
      "asyncId": 859,
      "triggerAsyncId": 851,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        865
      ],
      "uniqueid": 665
    },
    "666": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732108463204",
      "endTime": "928732108488121",
      "elapsedTime": "24917",
      "asyncId": 861,
      "triggerAsyncId": 851,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 666
    },
    "667": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732108868033",
      "endTime": "928732109782828",
      "elapsedTime": "914795",
      "asyncId": 863,
      "triggerAsyncId": 851,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 667
    },
    "668": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732109087965",
      "endTime": "928732109814447",
      "elapsedTime": "726482",
      "asyncId": 865,
      "triggerAsyncId": 859,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 668
    },
    "669": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732110069275",
      "endTime": "928732111418785",
      "elapsedTime": "1349510",
      "asyncId": 870,
      "triggerAsyncId": 852,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        872
      ],
      "uniqueid": 669
    },
    "670": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732111605275",
      "endTime": "928732112549975",
      "elapsedTime": "944700",
      "asyncId": 871,
      "triggerAsyncId": 852,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        877
      ],
      "uniqueid": 670
    },
    "671": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732111935163",
      "endTime": "928732111964919",
      "elapsedTime": "29756",
      "asyncId": 873,
      "triggerAsyncId": 852,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 671
    },
    "672": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732112312961",
      "endTime": "928732112876999",
      "elapsedTime": "564038",
      "asyncId": 875,
      "triggerAsyncId": 852,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 672
    },
    "673": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732112507115",
      "endTime": "928732112908888",
      "elapsedTime": "401773",
      "asyncId": 877,
      "triggerAsyncId": 871,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 673
    },
    "674": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732113423914",
      "endTime": "928732122270047",
      "elapsedTime": "8846133",
      "asyncId": 880,
      "triggerAsyncId": 97,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        888
      ],
      "uniqueid": 674
    },
    "675": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732113693339",
      "endTime": "928732113712865",
      "elapsedTime": "19526",
      "asyncId": 881,
      "triggerAsyncId": 97,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 675
    },
    "676": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732114252527",
      "endTime": "928732114279317",
      "elapsedTime": "26790",
      "asyncId": 883,
      "triggerAsyncId": 97,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        884,
        884
      ],
      "uniqueid": 676
    },
    "677": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732114539946",
      "endTime": "928732118036390",
      "elapsedTime": "3496444",
      "asyncId": 884,
      "triggerAsyncId": 883,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        891,
        894,
        892,
        896,
        902,
        885,
        885
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 677
    },
    "678": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732114771059",
      "endTime": "928732122144321",
      "elapsedTime": "7373262",
      "asyncId": 885,
      "triggerAsyncId": 884,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        903,
        906,
        904,
        908,
        912,
        886
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 678
    },
    "679": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732114961556",
      "endTime": "928732122308208",
      "elapsedTime": "7346652",
      "asyncId": 886,
      "triggerAsyncId": 885,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 679
    },
    "680": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732115117779",
      "endTime": "928732122341481",
      "elapsedTime": "7223702",
      "asyncId": 887,
      "triggerAsyncId": 97,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 680
    },
    "681": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732115468877",
      "endTime": "928732115492682",
      "elapsedTime": "23805",
      "asyncId": 889,
      "triggerAsyncId": 97,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 681
    },
    "682": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732115889305",
      "endTime": "928732115919692",
      "elapsedTime": "30387",
      "asyncId": 891,
      "triggerAsyncId": 884,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        893
      ],
      "uniqueid": 682
    },
    "683": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732116152929",
      "endTime": "928732117408173",
      "elapsedTime": "1255244",
      "asyncId": 892,
      "triggerAsyncId": 884,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        898
      ],
      "uniqueid": 683
    },
    "684": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732116455106",
      "endTime": "928732116469473",
      "elapsedTime": "14367",
      "asyncId": 894,
      "triggerAsyncId": 884,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 684
    },
    "685": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732116800914",
      "endTime": "928732117907669",
      "elapsedTime": "1106755",
      "asyncId": 896,
      "triggerAsyncId": 884,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 685
    },
    "686": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732117055641",
      "endTime": "928732117959937",
      "elapsedTime": "904296",
      "asyncId": 898,
      "triggerAsyncId": 892,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 686
    },
    "687": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732118293512",
      "endTime": "928732120087705",
      "elapsedTime": "1794193",
      "asyncId": 903,
      "triggerAsyncId": 885,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        905
      ],
      "uniqueid": 687
    },
    "688": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732120336562",
      "endTime": "928732121579562",
      "elapsedTime": "1243000",
      "asyncId": 904,
      "triggerAsyncId": 885,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        910
      ],
      "uniqueid": 688
    },
    "689": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732120727064",
      "endTime": "928732120758904",
      "elapsedTime": "31840",
      "asyncId": 906,
      "triggerAsyncId": 885,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 689
    },
    "690": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732121247319",
      "endTime": "928732122018415",
      "elapsedTime": "771096",
      "asyncId": 908,
      "triggerAsyncId": 885,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 690
    },
    "691": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732121510503",
      "endTime": "928732122068719",
      "elapsedTime": "558216",
      "asyncId": 910,
      "triggerAsyncId": 904,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 691
    },
    "692": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732122772478",
      "endTime": "928732131331132",
      "elapsedTime": "8558654",
      "asyncId": 913,
      "triggerAsyncId": 98,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        921
      ],
      "uniqueid": 692
    },
    "693": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732123084683",
      "endTime": "928732123111754",
      "elapsedTime": "27071",
      "asyncId": 914,
      "triggerAsyncId": 98,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 693
    },
    "694": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732123615268",
      "endTime": "928732123635817",
      "elapsedTime": "20549",
      "asyncId": 916,
      "triggerAsyncId": 98,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        917,
        917
      ],
      "uniqueid": 694
    },
    "695": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732123905622",
      "endTime": "928732127117794",
      "elapsedTime": "3212172",
      "asyncId": 917,
      "triggerAsyncId": 916,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        924,
        927,
        925,
        929,
        935,
        918,
        918
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 695
    },
    "696": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732124153357",
      "endTime": "928732131244359",
      "elapsedTime": "7091002",
      "asyncId": 918,
      "triggerAsyncId": 917,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        936,
        939,
        937,
        941,
        945,
        919
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 696
    },
    "697": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732124355987",
      "endTime": "928732131362812",
      "elapsedTime": "7006825",
      "asyncId": 919,
      "triggerAsyncId": 918,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 697
    },
    "698": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732124518411",
      "endTime": "928732131390824",
      "elapsedTime": "6872413",
      "asyncId": 920,
      "triggerAsyncId": 98,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 698
    },
    "699": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732124835055",
      "endTime": "928732124859621",
      "elapsedTime": "24566",
      "asyncId": 922,
      "triggerAsyncId": 98,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 699
    },
    "700": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732125298133",
      "endTime": "928732125331225",
      "elapsedTime": "33092",
      "asyncId": 924,
      "triggerAsyncId": 917,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        926
      ],
      "uniqueid": 700
    },
    "701": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732125497927",
      "endTime": "928732126689240",
      "elapsedTime": "1191313",
      "asyncId": 925,
      "triggerAsyncId": 917,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        931
      ],
      "uniqueid": 701
    },
    "702": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732125810133",
      "endTime": "928732125826734",
      "elapsedTime": "16601",
      "asyncId": 927,
      "triggerAsyncId": 917,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 702
    },
    "703": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732126153005",
      "endTime": "928732127017917",
      "elapsedTime": "864912",
      "asyncId": 929,
      "triggerAsyncId": 917,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 703
    },
    "704": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732126352299",
      "endTime": "928732127057160",
      "elapsedTime": "704861",
      "asyncId": 931,
      "triggerAsyncId": 925,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 704
    },
    "705": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732127321616",
      "endTime": "928732129638740",
      "elapsedTime": "2317124",
      "asyncId": 936,
      "triggerAsyncId": 918,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        938
      ],
      "uniqueid": 705
    },
    "706": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732129813337",
      "endTime": "928732130717562",
      "elapsedTime": "904225",
      "asyncId": 937,
      "triggerAsyncId": 918,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        943
      ],
      "uniqueid": 706
    },
    "707": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732130125212",
      "endTime": "928732130140039",
      "elapsedTime": "14827",
      "asyncId": 939,
      "triggerAsyncId": 918,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 707
    },
    "708": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732130460240",
      "endTime": "928732131103575",
      "elapsedTime": "643335",
      "asyncId": 941,
      "triggerAsyncId": 918,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 708
    },
    "709": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732130667839",
      "endTime": "928732131145745",
      "elapsedTime": "477906",
      "asyncId": 943,
      "triggerAsyncId": 937,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 709
    },
    "710": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732131699403",
      "endTime": "928732140595679",
      "elapsedTime": "8896276",
      "asyncId": 946,
      "triggerAsyncId": 99,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        954
      ],
      "uniqueid": 710
    },
    "711": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732133180369",
      "endTime": "928732133202851",
      "elapsedTime": "22482",
      "asyncId": 947,
      "triggerAsyncId": 99,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 711
    },
    "712": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732133828534",
      "endTime": "928732133849423",
      "elapsedTime": "20889",
      "asyncId": 949,
      "triggerAsyncId": 99,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        950,
        950
      ],
      "uniqueid": 712
    },
    "713": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732134119559",
      "endTime": "928732137354453",
      "elapsedTime": "3234894",
      "asyncId": 950,
      "triggerAsyncId": 949,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        957,
        960,
        958,
        962,
        968,
        951,
        951
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 713
    },
    "714": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732134341896",
      "endTime": "928732140493778",
      "elapsedTime": "6151882",
      "asyncId": 951,
      "triggerAsyncId": 950,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        969,
        972,
        970,
        974,
        978,
        952
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 714
    },
    "715": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732134534838",
      "endTime": "928732140629994",
      "elapsedTime": "6095156",
      "asyncId": 952,
      "triggerAsyncId": 951,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 715
    },
    "716": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732134681513",
      "endTime": "928732140657625",
      "elapsedTime": "5976112",
      "asyncId": 953,
      "triggerAsyncId": 99,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 716
    },
    "717": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732135027932",
      "endTime": "928732135055504",
      "elapsedTime": "27572",
      "asyncId": 955,
      "triggerAsyncId": 99,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 717
    },
    "718": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732135456536",
      "endTime": "928732135481502",
      "elapsedTime": "24966",
      "asyncId": 957,
      "triggerAsyncId": 950,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        959
      ],
      "uniqueid": 718
    },
    "719": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732135652593",
      "endTime": "928732136857752",
      "elapsedTime": "1205159",
      "asyncId": 958,
      "triggerAsyncId": 950,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        964
      ],
      "uniqueid": 719
    },
    "720": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732135950842",
      "endTime": "928732135975468",
      "elapsedTime": "24626",
      "asyncId": 960,
      "triggerAsyncId": 950,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 720
    },
    "721": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732136322258",
      "endTime": "928732137264244",
      "elapsedTime": "941986",
      "asyncId": 962,
      "triggerAsyncId": 950,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 721
    },
    "722": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732136532032",
      "endTime": "928732137295753",
      "elapsedTime": "763721",
      "asyncId": 964,
      "triggerAsyncId": 958,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 722
    },
    "723": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732137552054",
      "endTime": "928732138884953",
      "elapsedTime": "1332899",
      "asyncId": 969,
      "triggerAsyncId": 951,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        971
      ],
      "uniqueid": 723
    },
    "724": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732139068116",
      "endTime": "928732140035339",
      "elapsedTime": "967223",
      "asyncId": 970,
      "triggerAsyncId": 951,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        976
      ],
      "uniqueid": 724
    },
    "725": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732139397774",
      "endTime": "928732139411810",
      "elapsedTime": "14036",
      "asyncId": 972,
      "triggerAsyncId": 951,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 725
    },
    "726": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732139756396",
      "endTime": "928732140371409",
      "elapsedTime": "615013",
      "asyncId": 974,
      "triggerAsyncId": 951,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 726
    },
    "727": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732139963775",
      "endTime": "928732140417866",
      "elapsedTime": "454091",
      "asyncId": 976,
      "triggerAsyncId": 970,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 727
    },
    "728": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732140971694",
      "endTime": "928732148483566",
      "elapsedTime": "7511872",
      "asyncId": 979,
      "triggerAsyncId": 100,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        987
      ],
      "uniqueid": 728
    },
    "729": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732141268701",
      "endTime": "928732141283619",
      "elapsedTime": "14918",
      "asyncId": 980,
      "triggerAsyncId": 100,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 729
    },
    "730": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732141771533",
      "endTime": "928732141792643",
      "elapsedTime": "21110",
      "asyncId": 982,
      "triggerAsyncId": 100,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        983,
        983
      ],
      "uniqueid": 730
    },
    "731": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732142091934",
      "endTime": "928732145283036",
      "elapsedTime": "3191102",
      "asyncId": 983,
      "triggerAsyncId": 982,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        990,
        993,
        991,
        995,
        1001,
        984,
        984
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 731
    },
    "732": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732142338406",
      "endTime": "928732148391353",
      "elapsedTime": "6052947",
      "asyncId": 984,
      "triggerAsyncId": 983,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1002,
        1005,
        1003,
        1007,
        1011,
        985
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 732
    },
    "733": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732142546256",
      "endTime": "928732148514344",
      "elapsedTime": "5968088",
      "asyncId": 985,
      "triggerAsyncId": 984,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 733
    },
    "734": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732142701327",
      "endTime": "928732148550071",
      "elapsedTime": "5848744",
      "asyncId": 986,
      "triggerAsyncId": 100,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 734
    },
    "735": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732143031796",
      "endTime": "928732143056502",
      "elapsedTime": "24706",
      "asyncId": 988,
      "triggerAsyncId": 100,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 735
    },
    "736": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732143444349",
      "endTime": "928732143462333",
      "elapsedTime": "17984",
      "asyncId": 990,
      "triggerAsyncId": 983,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        992
      ],
      "uniqueid": 736
    },
    "737": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732143643853",
      "endTime": "928732144848191",
      "elapsedTime": "1204338",
      "asyncId": 991,
      "triggerAsyncId": 983,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        997
      ],
      "uniqueid": 737
    },
    "738": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732143954966",
      "endTime": "928732143970596",
      "elapsedTime": "15630",
      "asyncId": 993,
      "triggerAsyncId": 983,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 738
    },
    "739": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732144295825",
      "endTime": "928732145178240",
      "elapsedTime": "882415",
      "asyncId": 995,
      "triggerAsyncId": 983,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 739
    },
    "740": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732144491572",
      "endTime": "928732145214748",
      "elapsedTime": "723176",
      "asyncId": 997,
      "triggerAsyncId": 991,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 740
    },
    "741": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732145481067",
      "endTime": "928732146818144",
      "elapsedTime": "1337077",
      "asyncId": 1002,
      "triggerAsyncId": 984,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1004
      ],
      "uniqueid": 741
    },
    "742": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732147026304",
      "endTime": "928732147906464",
      "elapsedTime": "880160",
      "asyncId": 1003,
      "triggerAsyncId": 984,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1009
      ],
      "uniqueid": 742
    },
    "743": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732147310046",
      "endTime": "928732147324914",
      "elapsedTime": "14868",
      "asyncId": 1005,
      "triggerAsyncId": 984,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 743
    },
    "744": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732147632270",
      "endTime": "928732148267310",
      "elapsedTime": "635040",
      "asyncId": 1007,
      "triggerAsyncId": 984,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 744
    },
    "745": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732147848966",
      "endTime": "928732148306674",
      "elapsedTime": "457708",
      "asyncId": 1009,
      "triggerAsyncId": 1003,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 745
    },
    "746": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732148858980",
      "endTime": "928732157365756",
      "elapsedTime": "8506776",
      "asyncId": 1012,
      "triggerAsyncId": 101,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1020
      ],
      "uniqueid": 746
    },
    "747": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732149126531",
      "endTime": "928732149154093",
      "elapsedTime": "27562",
      "asyncId": 1013,
      "triggerAsyncId": 101,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 747
    },
    "748": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732149637619",
      "endTime": "928732149649161",
      "elapsedTime": "11542",
      "asyncId": 1015,
      "triggerAsyncId": 101,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1016,
        1016
      ],
      "uniqueid": 748
    },
    "749": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732149899771",
      "endTime": "928732153116451",
      "elapsedTime": "3216680",
      "asyncId": 1016,
      "triggerAsyncId": 1015,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1023,
        1026,
        1024,
        1028,
        1034,
        1017,
        1017
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 749
    },
    "750": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732150195645",
      "endTime": "928732157286608",
      "elapsedTime": "7090963",
      "asyncId": 1017,
      "triggerAsyncId": 1016,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1035,
        1038,
        1036,
        1040,
        1044,
        1018
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 750
    },
    "751": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732150385391",
      "endTime": "928732157414097",
      "elapsedTime": "7028706",
      "asyncId": 1018,
      "triggerAsyncId": 1017,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 751
    },
    "752": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732150534921",
      "endTime": "928732157452308",
      "elapsedTime": "6917387",
      "asyncId": 1019,
      "triggerAsyncId": 101,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 752
    },
    "753": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732150858949",
      "endTime": "928732150889456",
      "elapsedTime": "30507",
      "asyncId": 1021,
      "triggerAsyncId": 101,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 753
    },
    "754": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732151283294",
      "endTime": "928732151303131",
      "elapsedTime": "19837",
      "asyncId": 1023,
      "triggerAsyncId": 1016,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1025
      ],
      "uniqueid": 754
    },
    "755": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732151475444",
      "endTime": "928732152665736",
      "elapsedTime": "1190292",
      "asyncId": 1024,
      "triggerAsyncId": 1016,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1030
      ],
      "uniqueid": 755
    },
    "756": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732151796326",
      "endTime": "928732151812887",
      "elapsedTime": "16561",
      "asyncId": 1026,
      "triggerAsyncId": 1016,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 756
    },
    "757": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732152161300",
      "endTime": "928732152991056",
      "elapsedTime": "829756",
      "asyncId": 1028,
      "triggerAsyncId": 1016,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 757
    },
    "758": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732152364811",
      "endTime": "928732153051459",
      "elapsedTime": "686648",
      "asyncId": 1030,
      "triggerAsyncId": 1024,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 758
    },
    "759": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732153304343",
      "endTime": "928732155756830",
      "elapsedTime": "2452487",
      "asyncId": 1035,
      "triggerAsyncId": 1017,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1037
      ],
      "uniqueid": 759
    },
    "760": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732155946205",
      "endTime": "928732156837315",
      "elapsedTime": "891110",
      "asyncId": 1036,
      "triggerAsyncId": 1017,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1042
      ],
      "uniqueid": 760
    },
    "761": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732156258641",
      "endTime": "928732156272958",
      "elapsedTime": "14317",
      "asyncId": 1038,
      "triggerAsyncId": 1017,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 761
    },
    "762": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732156583570",
      "endTime": "928732157196459",
      "elapsedTime": "612889",
      "asyncId": 1040,
      "triggerAsyncId": 1017,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 762
    },
    "763": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732156784186",
      "endTime": "928732157226235",
      "elapsedTime": "442049",
      "asyncId": 1042,
      "triggerAsyncId": 1036,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 763
    },
    "764": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732157750487",
      "endTime": "928732165756225",
      "elapsedTime": "8005738",
      "asyncId": 1045,
      "triggerAsyncId": 102,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1053
      ],
      "uniqueid": 764
    },
    "765": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732158025503",
      "endTime": "928732158057563",
      "elapsedTime": "32060",
      "asyncId": 1046,
      "triggerAsyncId": 102,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 765
    },
    "766": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732158559123",
      "endTime": "928732158581175",
      "elapsedTime": "22052",
      "asyncId": 1048,
      "triggerAsyncId": 102,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1049,
        1049
      ],
      "uniqueid": 766
    },
    "767": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732158864055",
      "endTime": "928732162095723",
      "elapsedTime": "3231668",
      "asyncId": 1049,
      "triggerAsyncId": 1048,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1056,
        1059,
        1057,
        1061,
        1067,
        1050,
        1050
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 767
    },
    "768": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732159130795",
      "endTime": "928732165674001",
      "elapsedTime": "6543206",
      "asyncId": 1050,
      "triggerAsyncId": 1049,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1068,
        1071,
        1069,
        1073,
        1077,
        1051
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 768
    },
    "769": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732159338464",
      "endTime": "928732165786922",
      "elapsedTime": "6448458",
      "asyncId": 1051,
      "triggerAsyncId": 1050,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 769
    },
    "770": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732159488746",
      "endTime": "928732165815015",
      "elapsedTime": "6326269",
      "asyncId": 1052,
      "triggerAsyncId": 102,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 770
    },
    "771": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732159801102",
      "endTime": "928732159813785",
      "elapsedTime": "12683",
      "asyncId": 1054,
      "triggerAsyncId": 102,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 771
    },
    "772": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732160307351",
      "endTime": "928732160324843",
      "elapsedTime": "17492",
      "asyncId": 1056,
      "triggerAsyncId": 1049,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1058
      ],
      "uniqueid": 772
    },
    "773": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732160485765",
      "endTime": "928732161641361",
      "elapsedTime": "1155596",
      "asyncId": 1057,
      "triggerAsyncId": 1049,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1063
      ],
      "uniqueid": 773
    },
    "774": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732160769297",
      "endTime": "928732160780848",
      "elapsedTime": "11551",
      "asyncId": 1059,
      "triggerAsyncId": 1049,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 774
    },
    "775": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732161113612",
      "endTime": "928732161977902",
      "elapsedTime": "864290",
      "asyncId": 1061,
      "triggerAsyncId": 1049,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 775
    },
    "776": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732161328745",
      "endTime": "928732162027956",
      "elapsedTime": "699211",
      "asyncId": 1063,
      "triggerAsyncId": 1057,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 776
    },
    "777": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732162291560",
      "endTime": "928732164144584",
      "elapsedTime": "1853024",
      "asyncId": 1068,
      "triggerAsyncId": 1050,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1070
      ],
      "uniqueid": 777
    },
    "778": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732164319572",
      "endTime": "928732165221412",
      "elapsedTime": "901840",
      "asyncId": 1069,
      "triggerAsyncId": 1050,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1075
      ],
      "uniqueid": 778
    },
    "779": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732164590149",
      "endTime": "928732164612932",
      "elapsedTime": "22783",
      "asyncId": 1071,
      "triggerAsyncId": 1050,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 779
    },
    "780": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732164932361",
      "endTime": "928732165563223",
      "elapsedTime": "630862",
      "asyncId": 1073,
      "triggerAsyncId": 1050,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 780
    },
    "781": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732165164526",
      "endTime": "928732165599301",
      "elapsedTime": "434775",
      "asyncId": 1075,
      "triggerAsyncId": 1069,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 781
    },
    "782": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732166120588",
      "endTime": "928732173630856",
      "elapsedTime": "7510268",
      "asyncId": 1078,
      "triggerAsyncId": 103,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1086
      ],
      "uniqueid": 782
    },
    "783": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732166384202",
      "endTime": "928732166403348",
      "elapsedTime": "19146",
      "asyncId": 1079,
      "triggerAsyncId": 103,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 783
    },
    "784": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732167068755",
      "endTime": "928732167086018",
      "elapsedTime": "17263",
      "asyncId": 1081,
      "triggerAsyncId": 103,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1082,
        1082
      ],
      "uniqueid": 784
    },
    "785": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732167418411",
      "endTime": "928732170557155",
      "elapsedTime": "3138744",
      "asyncId": 1082,
      "triggerAsyncId": 1081,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1089,
        1092,
        1090,
        1094,
        1100,
        1083,
        1083
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 785
    },
    "786": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732167654664",
      "endTime": "928732173546569",
      "elapsedTime": "5891905",
      "asyncId": 1083,
      "triggerAsyncId": 1082,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1101,
        1104,
        1102,
        1106,
        1110,
        1084
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 786
    },
    "787": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732167845121",
      "endTime": "928732173667295",
      "elapsedTime": "5822174",
      "asyncId": 1084,
      "triggerAsyncId": 1083,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 787
    },
    "788": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732168012805",
      "endTime": "928732173711407",
      "elapsedTime": "5698602",
      "asyncId": 1085,
      "triggerAsyncId": 103,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 788
    },
    "789": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732168396965",
      "endTime": "928732168421872",
      "elapsedTime": "24907",
      "asyncId": 1087,
      "triggerAsyncId": 103,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 789
    },
    "790": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732168803638",
      "endTime": "928732168836359",
      "elapsedTime": "32721",
      "asyncId": 1089,
      "triggerAsyncId": 1082,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1091
      ],
      "uniqueid": 790
    },
    "791": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732168992091",
      "endTime": "928732170135194",
      "elapsedTime": "1143103",
      "asyncId": 1090,
      "triggerAsyncId": 1082,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1096
      ],
      "uniqueid": 791
    },
    "792": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732169294217",
      "endTime": "928732169310798",
      "elapsedTime": "16581",
      "asyncId": 1092,
      "triggerAsyncId": 1082,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 792
    },
    "793": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732169627652",
      "endTime": "928732170467437",
      "elapsedTime": "839785",
      "asyncId": 1094,
      "triggerAsyncId": 1082,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 793
    },
    "794": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732169829370",
      "endTime": "928732170505658",
      "elapsedTime": "676288",
      "asyncId": 1096,
      "triggerAsyncId": 1090,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 794
    },
    "795": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732170727865",
      "endTime": "928732171969282",
      "elapsedTime": "1241417",
      "asyncId": 1101,
      "triggerAsyncId": 1083,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1103
      ],
      "uniqueid": 795
    },
    "796": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732172151844",
      "endTime": "928732173105652",
      "elapsedTime": "953808",
      "asyncId": 1102,
      "triggerAsyncId": 1083,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1108
      ],
      "uniqueid": 796
    },
    "797": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732172450895",
      "endTime": "928732172472806",
      "elapsedTime": "21911",
      "asyncId": 1104,
      "triggerAsyncId": 1083,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 797
    },
    "798": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732172815248",
      "endTime": "928732173450318",
      "elapsedTime": "635070",
      "asyncId": 1106,
      "triggerAsyncId": 1083,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 798
    },
    "799": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732173039578",
      "endTime": "928732173496184",
      "elapsedTime": "456606",
      "asyncId": 1108,
      "triggerAsyncId": 1102,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 799
    },
    "800": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732174074288",
      "endTime": "928732182476458",
      "elapsedTime": "8402170",
      "asyncId": 1111,
      "triggerAsyncId": 104,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1119
      ],
      "uniqueid": 800
    },
    "801": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732174337722",
      "endTime": "928732174368479",
      "elapsedTime": "30757",
      "asyncId": 1112,
      "triggerAsyncId": 104,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 801
    },
    "802": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732174857366",
      "endTime": "928732174885829",
      "elapsedTime": "28463",
      "asyncId": 1114,
      "triggerAsyncId": 104,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1115,
        1115
      ],
      "uniqueid": 802
    },
    "803": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732175152529",
      "endTime": "928732178416688",
      "elapsedTime": "3264159",
      "asyncId": 1115,
      "triggerAsyncId": 1114,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1122,
        1125,
        1123,
        1127,
        1133,
        1116,
        1116
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 803
    },
    "804": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732175385556",
      "endTime": "928732182399254",
      "elapsedTime": "7013698",
      "asyncId": 1116,
      "triggerAsyncId": 1115,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1134,
        1137,
        1135,
        1139,
        1143,
        1117
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 804
    },
    "805": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732175583186",
      "endTime": "928732182512766",
      "elapsedTime": "6929580",
      "asyncId": 1117,
      "triggerAsyncId": 1116,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 805
    },
    "806": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732175735722",
      "endTime": "928732182561748",
      "elapsedTime": "6826026",
      "asyncId": 1118,
      "triggerAsyncId": 104,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 806
    },
    "807": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732176061733",
      "endTime": "928732176080018",
      "elapsedTime": "18285",
      "asyncId": 1120,
      "triggerAsyncId": 104,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 807
    },
    "808": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732176444461",
      "endTime": "928732176468656",
      "elapsedTime": "24195",
      "asyncId": 1122,
      "triggerAsyncId": 1115,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1124
      ],
      "uniqueid": 808
    },
    "809": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732176632413",
      "endTime": "928732177767611",
      "elapsedTime": "1135198",
      "asyncId": 1123,
      "triggerAsyncId": 1115,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1129
      ],
      "uniqueid": 809
    },
    "810": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732176915273",
      "endTime": "928732176942835",
      "elapsedTime": "27562",
      "asyncId": 1125,
      "triggerAsyncId": 1115,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 810
    },
    "811": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732177270890",
      "endTime": "928732178313485",
      "elapsedTime": "1042595",
      "asyncId": 1127,
      "triggerAsyncId": 1115,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 811
    },
    "812": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732177466567",
      "endTime": "928732178346747",
      "elapsedTime": "880180",
      "asyncId": 1129,
      "triggerAsyncId": 1123,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 812
    },
    "813": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732178646739",
      "endTime": "928732180598738",
      "elapsedTime": "1951999",
      "asyncId": 1134,
      "triggerAsyncId": 1116,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1136
      ],
      "uniqueid": 813
    },
    "814": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732180799004",
      "endTime": "928732181893946",
      "elapsedTime": "1094942",
      "asyncId": 1135,
      "triggerAsyncId": 1116,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1141
      ],
      "uniqueid": 814
    },
    "815": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732181146405",
      "endTime": "928732181174007",
      "elapsedTime": "27602",
      "asyncId": 1137,
      "triggerAsyncId": 1116,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 815
    },
    "816": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732181590818",
      "endTime": "928732182294597",
      "elapsedTime": "703779",
      "asyncId": 1139,
      "triggerAsyncId": 1116,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 816
    },
    "817": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732181836739",
      "endTime": "928732182341135",
      "elapsedTime": "504396",
      "asyncId": 1141,
      "triggerAsyncId": 1135,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 817
    },
    "818": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732182904331",
      "endTime": "928732194017643",
      "elapsedTime": "11113312",
      "asyncId": 1144,
      "triggerAsyncId": 105,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1152
      ],
      "uniqueid": 818
    },
    "819": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732183296886",
      "endTime": "928732183313958",
      "elapsedTime": "17072",
      "asyncId": 1145,
      "triggerAsyncId": 105,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 819
    },
    "820": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732183918802",
      "endTime": "928732183935073",
      "elapsedTime": "16271",
      "asyncId": 1147,
      "triggerAsyncId": 105,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1148,
        1148
      ],
      "uniqueid": 820
    },
    "821": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732184298955",
      "endTime": "928732189916445",
      "elapsedTime": "5617490",
      "asyncId": 1148,
      "triggerAsyncId": 1147,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1155,
        1158,
        1156,
        1160,
        1166,
        1149,
        1149
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 821
    },
    "822": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732185723575",
      "endTime": "928732193916684",
      "elapsedTime": "8193109",
      "asyncId": 1149,
      "triggerAsyncId": 1148,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1167,
        1170,
        1168,
        1172,
        1176,
        1150
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 822
    },
    "823": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732185952474",
      "endTime": "928732194051427",
      "elapsedTime": "8098953",
      "asyncId": 1150,
      "triggerAsyncId": 1149,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 823
    },
    "824": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732186126581",
      "endTime": "928732194079720",
      "elapsedTime": "7953139",
      "asyncId": 1151,
      "triggerAsyncId": 105,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 824
    },
    "825": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732186434889",
      "endTime": "928732186450278",
      "elapsedTime": "15389",
      "asyncId": 1153,
      "triggerAsyncId": 105,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 825
    },
    "826": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732186815212",
      "endTime": "928732186838635",
      "elapsedTime": "23423",
      "asyncId": 1155,
      "triggerAsyncId": 1148,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1157
      ],
      "uniqueid": 826
    },
    "827": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732187044461",
      "endTime": "928732189524180",
      "elapsedTime": "2479719",
      "asyncId": 1156,
      "triggerAsyncId": 1148,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1162
      ],
      "uniqueid": 827
    },
    "828": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732187334345",
      "endTime": "928732187365323",
      "elapsedTime": "30978",
      "asyncId": 1158,
      "triggerAsyncId": 1148,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 828
    },
    "829": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732188991481",
      "endTime": "928732189846494",
      "elapsedTime": "855013",
      "asyncId": 1160,
      "triggerAsyncId": 1148,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 829
    },
    "830": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732189218066",
      "endTime": "928732189878193",
      "elapsedTime": "660127",
      "asyncId": 1162,
      "triggerAsyncId": 1156,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 830
    },
    "831": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732190121670",
      "endTime": "928732192439305",
      "elapsedTime": "2317635",
      "asyncId": 1167,
      "triggerAsyncId": 1149,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1169
      ],
      "uniqueid": 831
    },
    "832": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732192622047",
      "endTime": "928732193489954",
      "elapsedTime": "867907",
      "asyncId": 1168,
      "triggerAsyncId": 1149,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1174
      ],
      "uniqueid": 832
    },
    "833": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732192912812",
      "endTime": "928732192924023",
      "elapsedTime": "11211",
      "asyncId": 1170,
      "triggerAsyncId": 1149,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 833
    },
    "834": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732193246247",
      "endTime": "928732193814843",
      "elapsedTime": "568596",
      "asyncId": 1172,
      "triggerAsyncId": 1149,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 834
    },
    "835": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732193439469",
      "endTime": "928732193850730",
      "elapsedTime": "411261",
      "asyncId": 1174,
      "triggerAsyncId": 1168,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 835
    },
    "836": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732194383970",
      "endTime": "928732202369028",
      "elapsedTime": "7985058",
      "asyncId": 1177,
      "triggerAsyncId": 106,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1185
      ],
      "uniqueid": 836
    },
    "837": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732194672972",
      "endTime": "928732194688641",
      "elapsedTime": "15669",
      "asyncId": 1178,
      "triggerAsyncId": 106,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 837
    },
    "838": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732195177207",
      "endTime": "928732195205460",
      "elapsedTime": "28253",
      "asyncId": 1180,
      "triggerAsyncId": 106,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1181,
        1181
      ],
      "uniqueid": 838
    },
    "839": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732195469124",
      "endTime": "928732198609491",
      "elapsedTime": "3140367",
      "asyncId": 1181,
      "triggerAsyncId": 1180,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1188,
        1191,
        1189,
        1193,
        1199,
        1182,
        1182
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 839
    },
    "840": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732195723090",
      "endTime": "928732202290191",
      "elapsedTime": "6567101",
      "asyncId": 1182,
      "triggerAsyncId": 1181,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1200,
        1203,
        1201,
        1205,
        1209,
        1183
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 840
    },
    "841": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732195920079",
      "endTime": "928732202397773",
      "elapsedTime": "6477694",
      "asyncId": 1183,
      "triggerAsyncId": 1182,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 841
    },
    "842": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732196088736",
      "endTime": "928732202438208",
      "elapsedTime": "6349472",
      "asyncId": 1184,
      "triggerAsyncId": 106,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 842
    },
    "843": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732196409637",
      "endTime": "928732196432791",
      "elapsedTime": "23154",
      "asyncId": 1186,
      "triggerAsyncId": 106,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 843
    },
    "844": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732196787285",
      "endTime": "928732196804407",
      "elapsedTime": "17122",
      "asyncId": 1188,
      "triggerAsyncId": 1181,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1190
      ],
      "uniqueid": 844
    },
    "845": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732196957003",
      "endTime": "928732198223808",
      "elapsedTime": "1266805",
      "asyncId": 1189,
      "triggerAsyncId": 1181,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1195
      ],
      "uniqueid": 845
    },
    "846": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732197236868",
      "endTime": "928732197257817",
      "elapsedTime": "20949",
      "asyncId": 1191,
      "triggerAsyncId": 1181,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 846
    },
    "847": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732197698112",
      "endTime": "928732198531695",
      "elapsedTime": "833583",
      "asyncId": 1193,
      "triggerAsyncId": 1181,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 847
    },
    "848": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732197915590",
      "endTime": "928732198564487",
      "elapsedTime": "648897",
      "asyncId": 1195,
      "triggerAsyncId": 1189,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 848
    },
    "849": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732198788356",
      "endTime": "928732200807882",
      "elapsedTime": "2019526",
      "asyncId": 1200,
      "triggerAsyncId": 1182,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1202
      ],
      "uniqueid": 849
    },
    "850": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732200988020",
      "endTime": "928732201859824",
      "elapsedTime": "871804",
      "asyncId": 1201,
      "triggerAsyncId": 1182,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1207
      ],
      "uniqueid": 850
    },
    "851": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732201287191",
      "endTime": "928732201301407",
      "elapsedTime": "14216",
      "asyncId": 1203,
      "triggerAsyncId": 1182,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 851
    },
    "852": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732201611208",
      "endTime": "928732202192508",
      "elapsedTime": "581300",
      "asyncId": 1205,
      "triggerAsyncId": 1182,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 852
    },
    "853": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732201800012",
      "endTime": "928732202231931",
      "elapsedTime": "431919",
      "asyncId": 1207,
      "triggerAsyncId": 1201,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 853
    },
    "854": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732202731879",
      "endTime": "928732210211039",
      "elapsedTime": "7479160",
      "asyncId": 1210,
      "triggerAsyncId": 107,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1218
      ],
      "uniqueid": 854
    },
    "855": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732202995313",
      "endTime": "928732203022513",
      "elapsedTime": "27200",
      "asyncId": 1211,
      "triggerAsyncId": 107,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 855
    },
    "856": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732203503225",
      "endTime": "928732203526348",
      "elapsedTime": "23123",
      "asyncId": 1213,
      "triggerAsyncId": 107,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1214,
        1214
      ],
      "uniqueid": 856
    },
    "857": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732203787668",
      "endTime": "928732206862101",
      "elapsedTime": "3074433",
      "asyncId": 1214,
      "triggerAsyncId": 1213,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1221,
        1224,
        1222,
        1226,
        1232,
        1215,
        1215
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 857
    },
    "858": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732204027057",
      "endTime": "928732210130889",
      "elapsedTime": "6103832",
      "asyncId": 1215,
      "triggerAsyncId": 1214,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1233,
        1236,
        1234,
        1238,
        1242,
        1216
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 858
    },
    "859": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732204223485",
      "endTime": "928732210240444",
      "elapsedTime": "6016959",
      "asyncId": 1216,
      "triggerAsyncId": 1215,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 859
    },
    "860": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732204387442",
      "endTime": "928732210270631",
      "elapsedTime": "5883189",
      "asyncId": 1217,
      "triggerAsyncId": 107,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 860
    },
    "861": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732204716950",
      "endTime": "928732204735204",
      "elapsedTime": "18254",
      "asyncId": 1219,
      "triggerAsyncId": 107,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 861
    },
    "862": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732205089588",
      "endTime": "928732205115267",
      "elapsedTime": "25679",
      "asyncId": 1221,
      "triggerAsyncId": 1214,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1223
      ],
      "uniqueid": 862
    },
    "863": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732205277631",
      "endTime": "928732206457453",
      "elapsedTime": "1179822",
      "asyncId": 1222,
      "triggerAsyncId": 1214,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1228
      ],
      "uniqueid": 863
    },
    "864": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732205561413",
      "endTime": "928732205573806",
      "elapsedTime": "12393",
      "asyncId": 1224,
      "triggerAsyncId": 1214,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 864
    },
    "865": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732205902893",
      "endTime": "928732206774217",
      "elapsedTime": "871324",
      "asyncId": 1226,
      "triggerAsyncId": 1214,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 865
    },
    "866": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732206126793",
      "endTime": "928732206807319",
      "elapsedTime": "680526",
      "asyncId": 1228,
      "triggerAsyncId": 1222,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 866
    },
    "867": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732207061916",
      "endTime": "928732208660613",
      "elapsedTime": "1598697",
      "asyncId": 1233,
      "triggerAsyncId": 1215,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1235
      ],
      "uniqueid": 867
    },
    "868": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732208828728",
      "endTime": "928732209696915",
      "elapsedTime": "868187",
      "asyncId": 1234,
      "triggerAsyncId": 1215,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1240
      ],
      "uniqueid": 868
    },
    "869": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732209123561",
      "endTime": "928732209139260",
      "elapsedTime": "15699",
      "asyncId": 1236,
      "triggerAsyncId": 1215,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 869
    },
    "870": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732209441807",
      "endTime": "928732210019901",
      "elapsedTime": "578094",
      "asyncId": 1238,
      "triggerAsyncId": 1215,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 870
    },
    "871": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732209637304",
      "endTime": "928732210048504",
      "elapsedTime": "411200",
      "asyncId": 1240,
      "triggerAsyncId": 1234,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 871
    },
    "872": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732210571856",
      "endTime": "928732218210485",
      "elapsedTime": "7638629",
      "asyncId": 1243,
      "triggerAsyncId": 108,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1251
      ],
      "uniqueid": 872
    },
    "873": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732210852832",
      "endTime": "928732210869223",
      "elapsedTime": "16391",
      "asyncId": 1244,
      "triggerAsyncId": 108,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 873
    },
    "874": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732211362798",
      "endTime": "928732211376784",
      "elapsedTime": "13986",
      "asyncId": 1246,
      "triggerAsyncId": 108,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1247,
        1247
      ],
      "uniqueid": 874
    },
    "875": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732211635119",
      "endTime": "928732214678684",
      "elapsedTime": "3043565",
      "asyncId": 1247,
      "triggerAsyncId": 1246,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1254,
        1257,
        1255,
        1259,
        1265,
        1248,
        1248
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 875
    },
    "876": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732211864399",
      "endTime": "928732218139622",
      "elapsedTime": "6275223",
      "asyncId": 1248,
      "triggerAsyncId": 1247,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1266,
        1269,
        1267,
        1271,
        1275,
        1249
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 876
    },
    "877": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732212054485",
      "endTime": "928732218240992",
      "elapsedTime": "6186507",
      "asyncId": 1249,
      "triggerAsyncId": 1248,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 877
    },
    "878": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732212198034",
      "endTime": "928732218269085",
      "elapsedTime": "6071051",
      "asyncId": 1250,
      "triggerAsyncId": 108,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 878
    },
    "879": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732212505240",
      "endTime": "928732212516261",
      "elapsedTime": "11021",
      "asyncId": 1252,
      "triggerAsyncId": 108,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 879
    },
    "880": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732212876716",
      "endTime": "928732212909578",
      "elapsedTime": "32862",
      "asyncId": 1254,
      "triggerAsyncId": 1247,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1256
      ],
      "uniqueid": 880
    },
    "881": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732213074888",
      "endTime": "928732214226015",
      "elapsedTime": "1151127",
      "asyncId": 1255,
      "triggerAsyncId": 1247,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1261
      ],
      "uniqueid": 881
    },
    "882": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732213369129",
      "endTime": "928732213383857",
      "elapsedTime": "14728",
      "asyncId": 1257,
      "triggerAsyncId": 1247,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 882
    },
    "883": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732213725297",
      "endTime": "928732214550354",
      "elapsedTime": "825057",
      "asyncId": 1259,
      "triggerAsyncId": 1247,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 883
    },
    "884": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732213917196",
      "endTime": "928732214588425",
      "elapsedTime": "671229",
      "asyncId": 1261,
      "triggerAsyncId": 1255,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 884
    },
    "885": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732214880593",
      "endTime": "928732216647485",
      "elapsedTime": "1766892",
      "asyncId": 1266,
      "triggerAsyncId": 1248,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1268
      ],
      "uniqueid": 885
    },
    "886": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732216821471",
      "endTime": "928732217719454",
      "elapsedTime": "897983",
      "asyncId": 1267,
      "triggerAsyncId": 1248,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1273
      ],
      "uniqueid": 886
    },
    "887": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732217109050",
      "endTime": "928732217128216",
      "elapsedTime": "19166",
      "asyncId": 1269,
      "triggerAsyncId": 1248,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 887
    },
    "888": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732217462954",
      "endTime": "928732218052278",
      "elapsedTime": "589324",
      "asyncId": 1271,
      "triggerAsyncId": 1248,
      "io": false,
      "createdIn": 1626205014925,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 888
    },
    "889": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732217662488",
      "endTime": "928732218093636",
      "elapsedTime": "431148",
      "asyncId": 1273,
      "triggerAsyncId": 1267,
      "io": "",
      "createdIn": 1626205014925,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 889
    }
  },
  "antipatterns": {
    "0": {
      "patternID": "pattern2",
      "file": "packages/strapi/bin/strapi.js",
      "startLine": "48",
      "startCol": "3",
      "endLine": "51",
      "endCol": "6"
    },
    "1": {
      "patternID": "pattern2",
      "file": "packages/strapi/lib/hooks/index.js",
      "startLine": "36",
      "startCol": "7",
      "endLine": "37",
      "endCol": "40"
    },
    "2": {
      "patternID": "pattern2",
      "file": "packages/strapi/lib/middlewares/index.js",
      "startLine": "52",
      "startCol": "7",
      "endLine": "53",
      "endCol": "40"
    },
    "3": {
      "patternID": "pattern2",
      "file": "packages/strapi-admin/ee/admin/containers/Roles/CreatePage/index.js",
      "startLine": "72",
      "startCol": "5",
      "endLine": "95",
      "endCol": "8"
    },
    "4": {
      "patternID": "pattern2",
      "file": "packages/strapi-admin/services/permission/engine.js",
      "startLine": "108",
      "startCol": "11",
      "endLine": "109",
      "endCol": "30"
    },
    "5": {
      "patternID": "pattern2",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/Roles/CreatePage/index.js",
      "startLine": "63",
      "startCol": "5",
      "endLine": "78",
      "endCol": "8"
    },
    "6": {
      "patternID": "pattern2",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/Roles/EditPage/index.js",
      "startLine": "68",
      "startCol": "5",
      "endLine": "81",
      "endCol": "8"
    },
    "7": {
      "patternID": "pattern2",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/Roles/ListPage/index.js",
      "startLine": "51",
      "startCol": "5",
      "endLine": "62",
      "endCol": "8"
    },
    "8": {
      "patternID": "pattern5",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "41",
      "startCol": "19",
      "endLine": "62",
      "endCol": "1"
    },
    "9": {
      "patternID": "pattern5",
      "file": "packages/strapi/lib/hooks/index.js",
      "startLine": "22",
      "startCol": "22",
      "endLine": "51",
      "endCol": "3"
    },
    "10": {
      "patternID": "pattern5",
      "file": "packages/strapi/lib/load/glob.js",
      "startLine": "8",
      "startCol": "18",
      "endLine": "15",
      "endCol": "1"
    },
    "11": {
      "patternID": "pattern5",
      "file": "packages/strapi/lib/middlewares/index.js",
      "startLine": "39",
      "startCol": "22",
      "endLine": "67",
      "endCol": "3"
    },
    "12": {
      "patternID": "pattern5",
      "file": "packages/strapi-admin/admin/src/hooks/useFetchPluginsFromMarketPlace/tests/useFetchPluginsFromMarketPlace.test.js",
      "startLine": "28",
      "startCol": "28",
      "endLine": "32",
      "endCol": "5"
    },
    "13": {
      "patternID": "pattern5",
      "file": "packages/strapi-admin/index.js",
      "startLine": "39",
      "startCol": "1",
      "endLine": "80",
      "endCol": "1"
    },
    "14": {
      "patternID": "pattern5",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "87",
      "startCol": "18",
      "endLine": "87",
      "endCol": "88"
    },
    "15": {
      "patternID": "pattern5",
      "file": "packages/strapi-admin/services/__tests__/token.test.js",
      "startLine": "5",
      "startCol": "15",
      "endLine": "5",
      "endCol": "71"
    },
    "16": {
      "patternID": "pattern5",
      "file": "packages/strapi-helper-plugin/lib/src/utils/request.js",
      "startLine": "68",
      "startCol": "1",
      "endLine": "91",
      "endCol": "1"
    },
    "17": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/ListView/index.js",
      "startLine": "163",
      "startCol": "16",
      "endLine": "167",
      "endCol": "3"
    },
    "18": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "131",
      "startCol": "21",
      "endLine": "149",
      "endCol": "1"
    },
    "19": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-upload/admin/src/components/EditForm/index.js",
      "startLine": "151",
      "startCol": "30",
      "endLine": "177",
      "endCol": "5"
    },
    "20": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-upload/utils/file.js",
      "startLine": "8",
      "startCol": "24",
      "endLine": "18",
      "endCol": "4"
    },
    "21": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-users-permissions/services/Jwt.js",
      "startLine": "50",
      "startCol": "9",
      "endLine": "64",
      "endCol": "3"
    },
    "22": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "27",
      "startCol": "17",
      "endLine": "105",
      "endCol": "1"
    },
    "23": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "425",
      "startCol": "35",
      "endLine": "438",
      "endCol": "9"
    },
    "24": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "440",
      "startCol": "33",
      "endLine": "453",
      "endCol": "9"
    },
    "25": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "87",
      "startCol": "15",
      "endLine": "100",
      "endCol": "3"
    },
    "26": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "122",
      "startCol": "13",
      "endLine": "142",
      "endCol": "3"
    },
    "27": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-email-amazon-ses/lib/index.js",
      "startLine": "11",
      "startCol": "13",
      "endLine": "37",
      "endCol": "7"
    },
    "28": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-email-mailgun/lib/index.js",
      "startLine": "14",
      "startCol": "13",
      "endLine": "38",
      "endCol": "7"
    },
    "29": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-email-sendgrid/lib/index.js",
      "startLine": "11",
      "startCol": "13",
      "endLine": "35",
      "endCol": "7"
    },
    "30": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-email-sendmail/lib/index.js",
      "startLine": "13",
      "startCol": "13",
      "endLine": "37",
      "endCol": "7"
    },
    "31": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-aws-s3/lib/index.js",
      "startLine": "20",
      "startCol": "13",
      "endLine": "44",
      "endCol": "7"
    },
    "32": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-aws-s3/lib/index.js",
      "startLine": "45",
      "startCol": "13",
      "endLine": "63",
      "endCol": "7"
    },
    "33": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-cloudinary/lib/index.js",
      "startLine": "17",
      "startCol": "13",
      "endLine": "59",
      "endCol": "7"
    },
    "34": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-local/lib/index.js",
      "startLine": "27",
      "startCol": "13",
      "endLine": "46",
      "endCol": "7"
    },
    "35": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-local/lib/index.js",
      "startLine": "47",
      "startCol": "13",
      "endLine": "64",
      "endCol": "7"
    },
    "36": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-rackspace/lib/index.js",
      "startLine": "19",
      "startCol": "23",
      "endLine": "25",
      "endCol": "8"
    },
    "37": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-rackspace/lib/index.js",
      "startLine": "28",
      "startCol": "13",
      "endLine": "52",
      "endCol": "7"
    },
    "38": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-rackspace/lib/index.js",
      "startLine": "53",
      "startCol": "13",
      "endLine": "60",
      "endCol": "7"
    },
    "39": {
      "patternID": "pattern5",
      "file": "test/helpers/test-app-generator.js",
      "startLine": "11",
      "startCol": "22",
      "endLine": "18",
      "endCol": "1"
    },
    "40": {
      "patternID": "pattern3",
      "file": "examples/getstarted/api/homepage/config/policies/test.js",
      "startLine": "4",
      "startCol": "3",
      "endLine": "4",
      "endCol": "14"
    },
    "41": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "208",
      "startCol": "5",
      "endLine": "214",
      "endCol": "5"
    },
    "42": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "217",
      "startCol": "7",
      "endLine": "217",
      "endCol": "32"
    },
    "43": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "223",
      "startCol": "7",
      "endLine": "223",
      "endCol": "29"
    },
    "44": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "254",
      "startCol": "7",
      "endLine": "254",
      "endCol": "80"
    },
    "45": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "312",
      "startCol": "9",
      "endLine": "312",
      "endCol": "20"
    },
    "46": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "325",
      "startCol": "5",
      "endLine": "325",
      "endCol": "25"
    },
    "47": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "339",
      "startCol": "5",
      "endLine": "339",
      "endCol": "30"
    },
    "48": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "373",
      "startCol": "22",
      "endLine": "373",
      "endCol": "59"
    },
    "49": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "432",
      "startCol": "5",
      "endLine": "432",
      "endCol": "38"
    },
    "50": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/__tests__/admin-reset.test.js",
      "startLine": "61",
      "startCol": "7",
      "endLine": "63",
      "endCol": "8"
    },
    "51": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/__tests__/admin-reset.test.js",
      "startLine": "89",
      "startCol": "7",
      "endLine": "91",
      "endCol": "8"
    },
    "52": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/admin-reset.js",
      "startLine": "27",
      "startCol": "21",
      "endLine": "27",
      "endCol": "58"
    },
    "53": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/admin-reset.js",
      "startLine": "47",
      "startCol": "3",
      "endLine": "47",
      "endCol": "69"
    },
    "54": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationDump.js",
      "startLine": "17",
      "startCol": "17",
      "endLine": "17",
      "endCol": "53"
    },
    "55": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationDump.js",
      "startLine": "24",
      "startCol": "21",
      "endLine": "26",
      "endCol": "76"
    },
    "56": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "31",
      "startCol": "5",
      "endLine": "31",
      "endCol": "33"
    },
    "57": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "93",
      "startCol": "24",
      "endLine": "93",
      "endCol": "76"
    },
    "58": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "96",
      "startCol": "9",
      "endLine": "96",
      "endCol": "68"
    },
    "59": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "99",
      "startCol": "9",
      "endLine": "99",
      "endCol": "49"
    },
    "60": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "121",
      "startCol": "28",
      "endLine": "121",
      "endCol": "79"
    },
    "61": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "124",
      "startCol": "9",
      "endLine": "124",
      "endCol": "91"
    },
    "62": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "127",
      "startCol": "9",
      "endLine": "127",
      "endCol": "49"
    },
    "63": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "149",
      "startCol": "24",
      "endLine": "149",
      "endCol": "76"
    },
    "64": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "157",
      "startCol": "7",
      "endLine": "157",
      "endCol": "47"
    },
    "65": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/install.js",
      "startLine": "22",
      "startCol": "7",
      "endLine": "22",
      "endCol": "49"
    },
    "66": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/install.js",
      "startLine": "24",
      "startCol": "7",
      "endLine": "24",
      "endCol": "62"
    },
    "67": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/install.js",
      "startLine": "40",
      "startCol": "7",
      "endLine": "40",
      "endCol": "42"
    },
    "68": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/uninstall.js",
      "startLine": "11",
      "startCol": "19",
      "endLine": "19",
      "endCol": "4"
    },
    "69": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/uninstall.js",
      "startLine": "40",
      "startCol": "7",
      "endLine": "40",
      "endCol": "52"
    },
    "70": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/uninstall.js",
      "startLine": "42",
      "startCol": "7",
      "endLine": "42",
      "endCol": "51"
    },
    "71": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/uninstall.js",
      "startLine": "60",
      "startCol": "7",
      "endLine": "60",
      "endCol": "42"
    },
    "72": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/__tests__/fs.test.js",
      "startLine": "30",
      "startCol": "7",
      "endLine": "30",
      "endCol": "50"
    },
    "73": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/__tests__/fs.test.js",
      "startLine": "41",
      "startCol": "7",
      "endLine": "41",
      "endCol": "56"
    },
    "74": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/__tests__/fs.test.js",
      "startLine": "52",
      "startCol": "7",
      "endLine": "52",
      "endCol": "67"
    },
    "75": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/__tests__/fs.test.js",
      "startLine": "70",
      "startCol": "7",
      "endLine": "70",
      "endCol": "91"
    },
    "76": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-admin.js",
      "startLine": "14",
      "startCol": "27",
      "endLine": "17",
      "endCol": "4"
    },
    "77": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-admin.js",
      "startLine": "29",
      "startCol": "27",
      "endLine": "32",
      "endCol": "6"
    },
    "78": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-components.js",
      "startLine": "11",
      "startCol": "9",
      "endLine": "11",
      "endCol": "35"
    },
    "79": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-hooks.js",
      "startLine": "16",
      "startCol": "3",
      "endLine": "24",
      "endCol": "4"
    },
    "80": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-hooks.js",
      "startLine": "53",
      "startCol": "24",
      "endLine": "53",
      "endCol": "51"
    },
    "81": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-hooks.js",
      "startLine": "57",
      "startCol": "18",
      "endLine": "57",
      "endCol": "68"
    },
    "82": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "20",
      "startCol": "3",
      "endLine": "20",
      "endCol": "77"
    },
    "83": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "22",
      "startCol": "3",
      "endLine": "22",
      "endCol": "52"
    },
    "84": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "24",
      "startCol": "3",
      "endLine": "24",
      "endCol": "58"
    },
    "85": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "26",
      "startCol": "3",
      "endLine": "26",
      "endCol": "69"
    },
    "86": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "28",
      "startCol": "3",
      "endLine": "28",
      "endCol": "65"
    },
    "87": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "30",
      "startCol": "3",
      "endLine": "30",
      "endCol": "49"
    },
    "88": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "68",
      "startCol": "26",
      "endLine": "68",
      "endCol": "53"
    },
    "89": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "72",
      "startCol": "20",
      "endLine": "72",
      "endCol": "72"
    },
    "90": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-modules.js",
      "startLine": "24",
      "startCol": "76",
      "endLine": "32",
      "endCol": "4"
    },
    "91": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-plugins.js",
      "startLine": "36",
      "startCol": "28",
      "endLine": "39",
      "endCol": "4"
    },
    "92": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/__tests__/service.test.js",
      "startLine": "82",
      "startCol": "9",
      "endLine": "82",
      "endCol": "43"
    },
    "93": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/__tests__/service.test.js",
      "startLine": "115",
      "startCol": "9",
      "endLine": "115",
      "endCol": "43"
    },
    "94": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/__tests__/service.test.js",
      "startLine": "150",
      "startCol": "9",
      "endLine": "150",
      "endCol": "30"
    },
    "95": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "36",
      "startCol": "22",
      "endLine": "36",
      "endCol": "46"
    },
    "96": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "49",
      "startCol": "18",
      "endLine": "49",
      "endCol": "62"
    },
    "97": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "51",
      "startCol": "18",
      "endLine": "51",
      "endCol": "63"
    },
    "98": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "58",
      "startCol": "22",
      "endLine": "58",
      "endCol": "43"
    },
    "99": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "80",
      "startCol": "20",
      "endLine": "80",
      "endCol": "50"
    },
    "100": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "82",
      "startCol": "20",
      "endLine": "82",
      "endCol": "48"
    },
    "101": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "95",
      "startCol": "22",
      "endLine": "95",
      "endCol": "71"
    },
    "102": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "121",
      "startCol": "18",
      "endLine": "121",
      "endCol": "54"
    },
    "103": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "123",
      "startCol": "18",
      "endLine": "123",
      "endCol": "55"
    },
    "104": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "138",
      "startCol": "18",
      "endLine": "138",
      "endCol": "77"
    },
    "105": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "140",
      "startCol": "18",
      "endLine": "140",
      "endCol": "78"
    },
    "106": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "152",
      "startCol": "22",
      "endLine": "152",
      "endCol": "64"
    },
    "107": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/service.js",
      "startLine": "98",
      "startCol": "22",
      "endLine": "98",
      "endCol": "38"
    },
    "108": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/service.js",
      "startLine": "123",
      "startCol": "22",
      "endLine": "123",
      "endCol": "38"
    },
    "109": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/hooks/index.js",
      "startLine": "58",
      "startCol": "3",
      "endLine": "65",
      "endCol": "3"
    },
    "110": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/load/load-files.js",
      "startLine": "35",
      "startCol": "13",
      "endLine": "35",
      "endCol": "44"
    },
    "111": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/boom/index.js",
      "startLine": "75",
      "startCol": "11",
      "endLine": "75",
      "endCol": "22"
    },
    "112": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/boom/index.js",
      "startLine": "96",
      "startCol": "9",
      "endLine": "96",
      "endCol": "20"
    },
    "113": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/cors/index.js",
      "startLine": "39",
      "startCol": "28",
      "endLine": "39",
      "endCol": "44"
    },
    "114": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/csp/index.js",
      "startLine": "17",
      "startCol": "39",
      "endLine": "17",
      "endCol": "50"
    },
    "115": {
      "patternID": "pattern1",
      "file": "packages/strapi/lib/middlewares/csp/index.js",
      "startLine": "16",
      "startCol": "22",
      "endLine": "23",
      "endCol": "7"
    },
    "116": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/csp/index.js",
      "startLine": "19",
      "startCol": "16",
      "endLine": "22",
      "endCol": "9"
    },
    "117": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/hsts/index.js",
      "startLine": "23",
      "startCol": "16",
      "endLine": "26",
      "endCol": "9"
    },
    "118": {
      "patternID": "pattern1",
      "file": "packages/strapi/lib/middlewares/hsts/index.js",
      "startLine": "20",
      "startCol": "22",
      "endLine": "27",
      "endCol": "7"
    },
    "119": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/index.js",
      "startLine": "74",
      "startCol": "3",
      "endLine": "81",
      "endCol": "3"
    },
    "120": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/index.js",
      "startLine": "113",
      "startCol": "3",
      "endLine": "116",
      "endCol": "4"
    },
    "121": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/logger/index.js",
      "startLine": "56",
      "startCol": "11",
      "endLine": "56",
      "endCol": "22"
    },
    "122": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/p3p/index.js",
      "startLine": "22",
      "startCol": "16",
      "endLine": "25",
      "endCol": "9"
    },
    "123": {
      "patternID": "pattern1",
      "file": "packages/strapi/lib/middlewares/p3p/index.js",
      "startLine": "19",
      "startCol": "22",
      "endLine": "26",
      "endCol": "7"
    },
    "124": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/parser/index.js",
      "startLine": "48",
      "startCol": "23",
      "endLine": "51",
      "endCol": "23"
    },
    "125": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/poweredBy/index.js",
      "startLine": "7",
      "startCol": "9",
      "endLine": "7",
      "endCol": "20"
    },
    "126": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/public/index.js",
      "startLine": "35",
      "startCol": "11",
      "endLine": "35",
      "endCol": "22"
    },
    "127": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/public/serve-static.js",
      "startLine": "14",
      "startCol": "5",
      "endLine": "18",
      "endCol": "6"
    },
    "128": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/public/serve-static.js",
      "startLine": "16",
      "startCol": "7",
      "endLine": "16",
      "endCol": "18"
    },
    "129": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/responseTime/index.js",
      "startLine": "17",
      "startCol": "9",
      "endLine": "17",
      "endCol": "20"
    },
    "130": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/responses/index.js",
      "startLine": "9",
      "startCol": "9",
      "endLine": "9",
      "endCol": "20"
    },
    "131": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/responses/index.js",
      "startLine": "13",
      "startCol": "11",
      "endLine": "13",
      "endCol": "31"
    },
    "132": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/router/utils/routerChecker.js",
      "startLine": "79",
      "startCol": "22",
      "endLine": "79",
      "endCol": "33"
    },
    "133": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/xframe/index.js",
      "startLine": "21",
      "startCol": "18",
      "endLine": "21",
      "endCol": "66"
    },
    "134": {
      "patternID": "pattern1",
      "file": "packages/strapi/lib/middlewares/xframe/index.js",
      "startLine": "19",
      "startCol": "22",
      "endLine": "30",
      "endCol": "7"
    },
    "135": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/xframe/index.js",
      "startLine": "26",
      "startCol": "18",
      "endLine": "26",
      "endCol": "56"
    },
    "136": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/xframe/index.js",
      "startLine": "29",
      "startCol": "9",
      "endLine": "29",
      "endCol": "20"
    },
    "137": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/xss/index.js",
      "startLine": "13",
      "startCol": "18",
      "endLine": "18",
      "endCol": "22"
    },
    "138": {
      "patternID": "pattern1",
      "file": "packages/strapi/lib/middlewares/xss/index.js",
      "startLine": "11",
      "startCol": "22",
      "endLine": "27",
      "endCol": "7"
    },
    "139": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/xss/index.js",
      "startLine": "23",
      "startCol": "18",
      "endLine": "23",
      "endCol": "67"
    },
    "140": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/xss/index.js",
      "startLine": "26",
      "startCol": "9",
      "endLine": "26",
      "endCol": "20"
    },
    "141": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-service.test.js",
      "startLine": "40",
      "startCol": "22",
      "endLine": "40",
      "endCol": "69"
    },
    "142": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-service.test.js",
      "startLine": "69",
      "startCol": "7",
      "endLine": "71",
      "endCol": "7"
    },
    "143": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-service.test.js",
      "startLine": "130",
      "startCol": "9",
      "endLine": "139",
      "endCol": "10"
    },
    "144": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-service.test.js",
      "startLine": "150",
      "startCol": "9",
      "endLine": "159",
      "endCol": "10"
    },
    "145": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-service.test.js",
      "startLine": "174",
      "startCol": "9",
      "endLine": "176",
      "endCol": "9"
    },
    "146": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "27",
      "startCol": "9",
      "endLine": "32",
      "endCol": "10"
    },
    "147": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "48",
      "startCol": "22",
      "endLine": "48",
      "endCol": "79"
    },
    "148": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "68",
      "startCol": "22",
      "endLine": "68",
      "endCol": "79"
    },
    "149": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "93",
      "startCol": "9",
      "endLine": "97",
      "endCol": "10"
    },
    "150": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "99",
      "startCol": "9",
      "endLine": "103",
      "endCol": "10"
    },
    "151": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "119",
      "startCol": "22",
      "endLine": "119",
      "endCol": "79"
    },
    "152": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "147",
      "startCol": "9",
      "endLine": "151",
      "endCol": "10"
    },
    "153": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "174",
      "startCol": "9",
      "endLine": "178",
      "endCol": "10"
    },
    "154": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "195",
      "startCol": "22",
      "endLine": "195",
      "endCol": "79"
    },
    "155": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "227",
      "startCol": "9",
      "endLine": "235",
      "endCol": "10"
    },
    "156": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "253",
      "startCol": "9",
      "endLine": "261",
      "endCol": "10"
    },
    "157": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "287",
      "startCol": "9",
      "endLine": "292",
      "endCol": "10"
    },
    "158": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "308",
      "startCol": "22",
      "endLine": "308",
      "endCol": "98"
    },
    "159": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "328",
      "startCol": "22",
      "endLine": "328",
      "endCol": "98"
    },
    "160": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "347",
      "startCol": "20",
      "endLine": "347",
      "endCol": "93"
    },
    "161": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "350",
      "startCol": "16",
      "endLine": "354",
      "endCol": "9"
    },
    "162": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "371",
      "startCol": "22",
      "endLine": "371",
      "endCol": "98"
    },
    "163": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "393",
      "startCol": "22",
      "endLine": "393",
      "endCol": "98"
    },
    "164": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "417",
      "startCol": "9",
      "endLine": "421",
      "endCol": "10"
    },
    "165": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "437",
      "startCol": "22",
      "endLine": "437",
      "endCol": "98"
    },
    "166": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "469",
      "startCol": "9",
      "endLine": "479",
      "endCol": "10"
    },
    "167": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "497",
      "startCol": "9",
      "endLine": "509",
      "endCol": "10"
    },
    "168": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/core-store.js",
      "startLine": "49",
      "startCol": "20",
      "endLine": "49",
      "endCol": "62"
    },
    "169": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/core-store.js",
      "startLine": "88",
      "startCol": "20",
      "endLine": "88",
      "endCol": "62"
    },
    "170": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/core-store.js",
      "startLine": "96",
      "startCol": "9",
      "endLine": "96",
      "endCol": "66"
    },
    "171": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/core-store.js",
      "startLine": "104",
      "startCol": "9",
      "endLine": "104",
      "endCol": "49"
    },
    "172": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "29",
      "startCol": "23",
      "endLine": "29",
      "endCol": "84"
    },
    "173": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "75",
      "startCol": "21",
      "endLine": "75",
      "endCol": "49"
    },
    "174": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "83",
      "startCol": "23",
      "endLine": "83",
      "endCol": "95"
    },
    "175": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "85",
      "startCol": "17",
      "endLine": "85",
      "endCol": "55"
    },
    "176": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "89",
      "startCol": "15",
      "endLine": "89",
      "endCol": "73"
    },
    "177": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "108",
      "startCol": "27",
      "endLine": "108",
      "endCol": "63"
    },
    "178": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "112",
      "startCol": "23",
      "endLine": "114",
      "endCol": "6"
    },
    "179": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "116",
      "startCol": "17",
      "endLine": "116",
      "endCol": "63"
    },
    "180": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "120",
      "startCol": "15",
      "endLine": "120",
      "endCol": "73"
    },
    "181": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "138",
      "startCol": "19",
      "endLine": "138",
      "endCol": "54"
    },
    "182": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-validator/index.js",
      "startLine": "177",
      "startCol": "12",
      "endLine": "177",
      "endCol": "64"
    },
    "183": {
      "patternID": "pattern1",
      "file": "packages/strapi/lib/services/entity-validator/index.js",
      "startLine": "174",
      "startCol": "48",
      "endLine": "181",
      "endCol": "1"
    },
    "184": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/metrics/middleware.js",
      "startLine": "29",
      "startCol": "5",
      "endLine": "29",
      "endCol": "16"
    },
    "185": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/metrics/sender.js",
      "startLine": "58",
      "startCol": "19",
      "endLine": "58",
      "endCol": "66"
    },
    "186": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/utils/upload-files.js",
      "startLine": "69",
      "startCol": "3",
      "endLine": "69",
      "endCol": "77"
    },
    "187": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/webhook-runner.js",
      "startLine": "70",
      "startCol": "7",
      "endLine": "73",
      "endCol": "8"
    },
    "188": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/webhook-runner.js",
      "startLine": "104",
      "startCol": "20",
      "endLine": "104",
      "endCol": "35"
    },
    "189": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/webhook-store.js",
      "startLine": "61",
      "startCol": "23",
      "endLine": "61",
      "endCol": "49"
    },
    "190": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/webhook-store.js",
      "startLine": "67",
      "startCol": "22",
      "endLine": "67",
      "endCol": "57"
    },
    "191": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/webhook-store.js",
      "startLine": "76",
      "startCol": "23",
      "endLine": "76",
      "endCol": "75"
    },
    "192": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/webhook-store.js",
      "startLine": "81",
      "startCol": "23",
      "endLine": "81",
      "endCol": "57"
    },
    "193": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/worker-queue.js",
      "startLine": "49",
      "startCol": "7",
      "endLine": "49",
      "endCol": "32"
    },
    "194": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/utils/index.js",
      "startLine": "17",
      "startCol": "38",
      "endLine": "17",
      "endCol": "92"
    },
    "195": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/utils/openBrowser.js",
      "startLine": "106",
      "startCol": "5",
      "endLine": "106",
      "endCol": "66"
    },
    "196": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/utils/update-notifier/index.js",
      "startLine": "56",
      "startCol": "19",
      "endLine": "56",
      "endCol": "45"
    },
    "197": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "54",
      "startCol": "5",
      "endLine": "57",
      "endCol": "14"
    },
    "198": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "60",
      "startCol": "10",
      "endLine": "60",
      "endCol": "44"
    },
    "199": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "65",
      "startCol": "5",
      "endLine": "65",
      "endCol": "27"
    },
    "200": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "83",
      "endCol": "6"
    },
    "201": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "92",
      "startCol": "17",
      "endLine": "95",
      "endCol": "6"
    },
    "202": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "115",
      "startCol": "17",
      "endLine": "119",
      "endCol": "6"
    },
    "203": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "129",
      "startCol": "17",
      "endLine": "132",
      "endCol": "6"
    },
    "204": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "147",
      "startCol": "19",
      "endLine": "151",
      "endCol": "8"
    },
    "205": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "168",
      "startCol": "19",
      "endLine": "172",
      "endCol": "8"
    },
    "206": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "191",
      "startCol": "19",
      "endLine": "195",
      "endCol": "8"
    },
    "207": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "213",
      "startCol": "19",
      "endLine": "217",
      "endCol": "8"
    },
    "208": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "56",
      "endCol": "14"
    },
    "209": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "59",
      "startCol": "10",
      "endLine": "59",
      "endCol": "44"
    },
    "210": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "64",
      "startCol": "5",
      "endLine": "64",
      "endCol": "27"
    },
    "211": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "76",
      "startCol": "17",
      "endLine": "80",
      "endCol": "6"
    },
    "212": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "89",
      "startCol": "17",
      "endLine": "92",
      "endCol": "6"
    },
    "213": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "110",
      "startCol": "17",
      "endLine": "114",
      "endCol": "6"
    },
    "214": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "124",
      "startCol": "17",
      "endLine": "127",
      "endCol": "6"
    },
    "215": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "142",
      "startCol": "19",
      "endLine": "146",
      "endCol": "8"
    },
    "216": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "161",
      "startCol": "19",
      "endLine": "165",
      "endCol": "8"
    },
    "217": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "182",
      "startCol": "19",
      "endLine": "186",
      "endCol": "8"
    },
    "218": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "202",
      "startCol": "19",
      "endLine": "206",
      "endCol": "8"
    },
    "219": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "55",
      "startCol": "5",
      "endLine": "58",
      "endCol": "14"
    },
    "220": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "61",
      "startCol": "10",
      "endLine": "61",
      "endCol": "44"
    },
    "221": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "66",
      "startCol": "5",
      "endLine": "66",
      "endCol": "27"
    },
    "222": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "80",
      "startCol": "17",
      "endLine": "84",
      "endCol": "6"
    },
    "223": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "93",
      "startCol": "17",
      "endLine": "96",
      "endCol": "6"
    },
    "224": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "118",
      "startCol": "17",
      "endLine": "122",
      "endCol": "6"
    },
    "225": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "132",
      "startCol": "17",
      "endLine": "135",
      "endCol": "6"
    },
    "226": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "150",
      "startCol": "19",
      "endLine": "154",
      "endCol": "8"
    },
    "227": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "171",
      "startCol": "19",
      "endLine": "175",
      "endCol": "8"
    },
    "228": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "194",
      "startCol": "19",
      "endLine": "198",
      "endCol": "8"
    },
    "229": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "216",
      "startCol": "19",
      "endLine": "220",
      "endCol": "8"
    },
    "230": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "54",
      "startCol": "5",
      "endLine": "57",
      "endCol": "14"
    },
    "231": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "60",
      "startCol": "10",
      "endLine": "60",
      "endCol": "44"
    },
    "232": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "65",
      "startCol": "5",
      "endLine": "65",
      "endCol": "27"
    },
    "233": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "77",
      "startCol": "17",
      "endLine": "81",
      "endCol": "6"
    },
    "234": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "90",
      "startCol": "17",
      "endLine": "93",
      "endCol": "6"
    },
    "235": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "113",
      "startCol": "17",
      "endLine": "117",
      "endCol": "6"
    },
    "236": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "127",
      "startCol": "17",
      "endLine": "130",
      "endCol": "6"
    },
    "237": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "145",
      "startCol": "19",
      "endLine": "149",
      "endCol": "8"
    },
    "238": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "164",
      "startCol": "19",
      "endLine": "168",
      "endCol": "8"
    },
    "239": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "185",
      "startCol": "19",
      "endLine": "189",
      "endCol": "8"
    },
    "240": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "205",
      "startCol": "19",
      "endLine": "209",
      "endCol": "8"
    },
    "241": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "52",
      "startCol": "5",
      "endLine": "55",
      "endCol": "14"
    },
    "242": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "58",
      "startCol": "10",
      "endLine": "58",
      "endCol": "44"
    },
    "243": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "63",
      "startCol": "5",
      "endLine": "63",
      "endCol": "27"
    },
    "244": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "71",
      "startCol": "17",
      "endLine": "75",
      "endCol": "6"
    },
    "245": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "89",
      "startCol": "17",
      "endLine": "93",
      "endCol": "6"
    },
    "246": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "103",
      "startCol": "17",
      "endLine": "106",
      "endCol": "6"
    },
    "247": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "129",
      "startCol": "17",
      "endLine": "133",
      "endCol": "6"
    },
    "248": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "148",
      "startCol": "17",
      "endLine": "152",
      "endCol": "6"
    },
    "249": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "162",
      "startCol": "17",
      "endLine": "165",
      "endCol": "6"
    },
    "250": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "180",
      "startCol": "19",
      "endLine": "184",
      "endCol": "8"
    },
    "251": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "196",
      "startCol": "19",
      "endLine": "200",
      "endCol": "8"
    },
    "252": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "211",
      "startCol": "19",
      "endLine": "215",
      "endCol": "8"
    },
    "253": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "56",
      "endCol": "14"
    },
    "254": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "59",
      "startCol": "10",
      "endLine": "59",
      "endCol": "44"
    },
    "255": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "64",
      "startCol": "5",
      "endLine": "64",
      "endCol": "27"
    },
    "256": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "83",
      "endCol": "6"
    },
    "257": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "92",
      "startCol": "17",
      "endLine": "95",
      "endCol": "6"
    },
    "258": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "116",
      "startCol": "17",
      "endLine": "120",
      "endCol": "6"
    },
    "259": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "130",
      "startCol": "17",
      "endLine": "133",
      "endCol": "6"
    },
    "260": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "148",
      "startCol": "19",
      "endLine": "152",
      "endCol": "8"
    },
    "261": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "170",
      "startCol": "19",
      "endLine": "174",
      "endCol": "8"
    },
    "262": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "194",
      "startCol": "19",
      "endLine": "198",
      "endCol": "8"
    },
    "263": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "217",
      "startCol": "19",
      "endLine": "221",
      "endCol": "8"
    },
    "264": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "240",
      "startCol": "19",
      "endLine": "244",
      "endCol": "8"
    },
    "265": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "46",
      "startCol": "5",
      "endLine": "49",
      "endCol": "14"
    },
    "266": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "52",
      "startCol": "10",
      "endLine": "52",
      "endCol": "44"
    },
    "267": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "57",
      "startCol": "5",
      "endLine": "57",
      "endCol": "27"
    },
    "268": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "65",
      "startCol": "17",
      "endLine": "69",
      "endCol": "6"
    },
    "269": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "78",
      "startCol": "17",
      "endLine": "81",
      "endCol": "6"
    },
    "270": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "102",
      "startCol": "17",
      "endLine": "106",
      "endCol": "6"
    },
    "271": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "116",
      "startCol": "17",
      "endLine": "119",
      "endCol": "6"
    },
    "272": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "85",
      "startCol": "5",
      "endLine": "89",
      "endCol": "14"
    },
    "273": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "92",
      "startCol": "10",
      "endLine": "92",
      "endCol": "44"
    },
    "274": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "99",
      "startCol": "5",
      "endLine": "99",
      "endCol": "27"
    },
    "275": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "105",
      "startCol": "21",
      "endLine": "111",
      "endCol": "10"
    },
    "276": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "120",
      "startCol": "21",
      "endLine": "126",
      "endCol": "10"
    },
    "277": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "136",
      "startCol": "21",
      "endLine": "142",
      "endCol": "10"
    },
    "278": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "154",
      "startCol": "21",
      "endLine": "161",
      "endCol": "10"
    },
    "279": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "169",
      "startCol": "21",
      "endLine": "176",
      "endCol": "10"
    },
    "280": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "186",
      "startCol": "21",
      "endLine": "193",
      "endCol": "10"
    },
    "281": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "200",
      "startCol": "21",
      "endLine": "207",
      "endCol": "10"
    },
    "282": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "25",
      "startCol": "5",
      "endLine": "29",
      "endCol": "14"
    },
    "283": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "32",
      "startCol": "10",
      "endLine": "32",
      "endCol": "44"
    },
    "284": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "37",
      "startCol": "5",
      "endLine": "37",
      "endCol": "27"
    },
    "285": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "49",
      "startCol": "24",
      "endLine": "55",
      "endCol": "8"
    },
    "286": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "65",
      "startCol": "24",
      "endLine": "71",
      "endCol": "8"
    },
    "287": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "81",
      "startCol": "24",
      "endLine": "87",
      "endCol": "8"
    },
    "288": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "102",
      "startCol": "24",
      "endLine": "106",
      "endCol": "8"
    },
    "289": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "124",
      "startCol": "24",
      "endLine": "128",
      "endCol": "8"
    },
    "290": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "147",
      "startCol": "24",
      "endLine": "151",
      "endCol": "8"
    },
    "291": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "170",
      "startCol": "24",
      "endLine": "174",
      "endCol": "8"
    },
    "292": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "191",
      "startCol": "24",
      "endLine": "195",
      "endCol": "8"
    },
    "293": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "213",
      "startCol": "24",
      "endLine": "217",
      "endCol": "8"
    },
    "294": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "242",
      "startCol": "24",
      "endLine": "248",
      "endCol": "8"
    },
    "295": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "258",
      "startCol": "24",
      "endLine": "264",
      "endCol": "8"
    },
    "296": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "280",
      "startCol": "24",
      "endLine": "284",
      "endCol": "8"
    },
    "297": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "302",
      "startCol": "24",
      "endLine": "306",
      "endCol": "8"
    },
    "298": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "323",
      "startCol": "24",
      "endLine": "327",
      "endCol": "8"
    },
    "299": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "344",
      "startCol": "24",
      "endLine": "348",
      "endCol": "8"
    },
    "300": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "365",
      "startCol": "24",
      "endLine": "369",
      "endCol": "8"
    },
    "301": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "385",
      "startCol": "24",
      "endLine": "389",
      "endCol": "8"
    },
    "302": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "400",
      "startCol": "24",
      "endLine": "403",
      "endCol": "8"
    },
    "303": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "410",
      "startCol": "24",
      "endLine": "413",
      "endCol": "8"
    },
    "304": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "420",
      "startCol": "24",
      "endLine": "423",
      "endCol": "8"
    },
    "305": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "430",
      "startCol": "24",
      "endLine": "433",
      "endCol": "8"
    },
    "306": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "441",
      "startCol": "24",
      "endLine": "444",
      "endCol": "8"
    },
    "307": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "465",
      "startCol": "24",
      "endLine": "471",
      "endCol": "8"
    },
    "308": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "485",
      "startCol": "24",
      "endLine": "489",
      "endCol": "8"
    },
    "309": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "505",
      "startCol": "24",
      "endLine": "509",
      "endCol": "8"
    },
    "310": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "526",
      "startCol": "24",
      "endLine": "530",
      "endCol": "8"
    },
    "311": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "554",
      "startCol": "7",
      "endLine": "574",
      "endCol": "8"
    },
    "312": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "578",
      "startCol": "37",
      "endLine": "584",
      "endCol": "8"
    },
    "313": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "588",
      "startCol": "43",
      "endLine": "595",
      "endCol": "8"
    },
    "314": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "601",
      "startCol": "43",
      "endLine": "607",
      "endCol": "8"
    },
    "315": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "613",
      "startCol": "37",
      "endLine": "619",
      "endCol": "8"
    },
    "316": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "623",
      "startCol": "43",
      "endLine": "630",
      "endCol": "8"
    },
    "317": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "634",
      "startCol": "7",
      "endLine": "637",
      "endCol": "8"
    },
    "318": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "639",
      "startCol": "40",
      "endLine": "642",
      "endCol": "8"
    },
    "319": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "87",
      "startCol": "5",
      "endLine": "90",
      "endCol": "14"
    },
    "320": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "93",
      "startCol": "10",
      "endLine": "93",
      "endCol": "44"
    },
    "321": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "100",
      "startCol": "5",
      "endLine": "100",
      "endCol": "27"
    },
    "322": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "106",
      "startCol": "21",
      "endLine": "112",
      "endCol": "10"
    },
    "323": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "120",
      "startCol": "21",
      "endLine": "126",
      "endCol": "10"
    },
    "324": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "134",
      "startCol": "21",
      "endLine": "140",
      "endCol": "10"
    },
    "325": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "148",
      "startCol": "21",
      "endLine": "154",
      "endCol": "10"
    },
    "326": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "162",
      "startCol": "21",
      "endLine": "168",
      "endCol": "10"
    },
    "327": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "176",
      "startCol": "21",
      "endLine": "182",
      "endCol": "10"
    },
    "328": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "193",
      "startCol": "21",
      "endLine": "199",
      "endCol": "10"
    },
    "329": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "208",
      "startCol": "22",
      "endLine": "214",
      "endCol": "10"
    },
    "330": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "220",
      "startCol": "22",
      "endLine": "226",
      "endCol": "10"
    },
    "331": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "232",
      "startCol": "21",
      "endLine": "238",
      "endCol": "10"
    },
    "332": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "242",
      "startCol": "22",
      "endLine": "248",
      "endCol": "10"
    },
    "333": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "256",
      "startCol": "21",
      "endLine": "262",
      "endCol": "10"
    },
    "334": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "268",
      "startCol": "22",
      "endLine": "274",
      "endCol": "10"
    },
    "335": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "280",
      "startCol": "21",
      "endLine": "286",
      "endCol": "10"
    },
    "336": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "290",
      "startCol": "22",
      "endLine": "296",
      "endCol": "10"
    },
    "337": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "305",
      "startCol": "21",
      "endLine": "311",
      "endCol": "10"
    },
    "338": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "317",
      "startCol": "21",
      "endLine": "323",
      "endCol": "10"
    },
    "339": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "332",
      "startCol": "21",
      "endLine": "338",
      "endCol": "10"
    },
    "340": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "344",
      "startCol": "21",
      "endLine": "350",
      "endCol": "10"
    },
    "341": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "358",
      "startCol": "21",
      "endLine": "364",
      "endCol": "10"
    },
    "342": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "370",
      "startCol": "21",
      "endLine": "376",
      "endCol": "10"
    },
    "343": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "382",
      "startCol": "21",
      "endLine": "388",
      "endCol": "10"
    },
    "344": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "396",
      "startCol": "21",
      "endLine": "402",
      "endCol": "10"
    },
    "345": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "408",
      "startCol": "21",
      "endLine": "414",
      "endCol": "10"
    },
    "346": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "420",
      "startCol": "21",
      "endLine": "426",
      "endCol": "10"
    },
    "347": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "434",
      "startCol": "21",
      "endLine": "440",
      "endCol": "10"
    },
    "348": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "444",
      "startCol": "22",
      "endLine": "450",
      "endCol": "10"
    },
    "349": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "456",
      "startCol": "21",
      "endLine": "462",
      "endCol": "10"
    },
    "350": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "468",
      "startCol": "21",
      "endLine": "474",
      "endCol": "10"
    },
    "351": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "480",
      "startCol": "21",
      "endLine": "486",
      "endCol": "10"
    },
    "352": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "492",
      "startCol": "21",
      "endLine": "498",
      "endCol": "10"
    },
    "353": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "506",
      "startCol": "21",
      "endLine": "512",
      "endCol": "10"
    },
    "354": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "516",
      "startCol": "22",
      "endLine": "522",
      "endCol": "10"
    },
    "355": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "528",
      "startCol": "21",
      "endLine": "534",
      "endCol": "10"
    },
    "356": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "540",
      "startCol": "21",
      "endLine": "546",
      "endCol": "10"
    },
    "357": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "552",
      "startCol": "21",
      "endLine": "558",
      "endCol": "10"
    },
    "358": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "564",
      "startCol": "21",
      "endLine": "570",
      "endCol": "10"
    },
    "359": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "578",
      "startCol": "21",
      "endLine": "584",
      "endCol": "10"
    },
    "360": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "588",
      "startCol": "22",
      "endLine": "594",
      "endCol": "10"
    },
    "361": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "600",
      "startCol": "21",
      "endLine": "606",
      "endCol": "10"
    },
    "362": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "612",
      "startCol": "21",
      "endLine": "618",
      "endCol": "10"
    },
    "363": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "624",
      "startCol": "21",
      "endLine": "630",
      "endCol": "10"
    },
    "364": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "636",
      "startCol": "21",
      "endLine": "642",
      "endCol": "10"
    },
    "365": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "650",
      "startCol": "21",
      "endLine": "656",
      "endCol": "10"
    },
    "366": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "660",
      "startCol": "22",
      "endLine": "666",
      "endCol": "10"
    },
    "367": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "672",
      "startCol": "21",
      "endLine": "678",
      "endCol": "10"
    },
    "368": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "684",
      "startCol": "21",
      "endLine": "690",
      "endCol": "10"
    },
    "369": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "696",
      "startCol": "21",
      "endLine": "702",
      "endCol": "10"
    },
    "370": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "708",
      "startCol": "21",
      "endLine": "714",
      "endCol": "10"
    },
    "371": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "724",
      "startCol": "21",
      "endLine": "739",
      "endCol": "10"
    },
    "372": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "745",
      "startCol": "21",
      "endLine": "760",
      "endCol": "10"
    },
    "373": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "768",
      "startCol": "21",
      "endLine": "788",
      "endCol": "10"
    },
    "374": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "794",
      "startCol": "21",
      "endLine": "818",
      "endCol": "10"
    },
    "375": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "825",
      "startCol": "19",
      "endLine": "831",
      "endCol": "8"
    },
    "376": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "837",
      "startCol": "19",
      "endLine": "843",
      "endCol": "8"
    },
    "377": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "849",
      "startCol": "19",
      "endLine": "855",
      "endCol": "8"
    },
    "378": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "861",
      "startCol": "19",
      "endLine": "867",
      "endCol": "8"
    },
    "379": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "873",
      "startCol": "19",
      "endLine": "879",
      "endCol": "8"
    },
    "380": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "885",
      "startCol": "19",
      "endLine": "891",
      "endCol": "8"
    },
    "381": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "897",
      "startCol": "19",
      "endLine": "903",
      "endCol": "8"
    },
    "382": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "909",
      "startCol": "19",
      "endLine": "915",
      "endCol": "8"
    },
    "383": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "921",
      "startCol": "19",
      "endLine": "927",
      "endCol": "8"
    },
    "384": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "933",
      "startCol": "19",
      "endLine": "939",
      "endCol": "8"
    },
    "385": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "947",
      "startCol": "17",
      "endLine": "954",
      "endCol": "8"
    },
    "386": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "958",
      "startCol": "13",
      "endLine": "965",
      "endCol": "8"
    },
    "387": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "969",
      "startCol": "13",
      "endLine": "976",
      "endCol": "8"
    },
    "388": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "982",
      "startCol": "17",
      "endLine": "989",
      "endCol": "8"
    },
    "389": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "993",
      "startCol": "13",
      "endLine": "1000",
      "endCol": "8"
    },
    "390": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1005",
      "startCol": "13",
      "endLine": "1012",
      "endCol": "8"
    },
    "391": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1018",
      "startCol": "17",
      "endLine": "1025",
      "endCol": "8"
    },
    "392": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1033",
      "startCol": "19",
      "endLine": "1039",
      "endCol": "8"
    },
    "393": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1047",
      "startCol": "19",
      "endLine": "1053",
      "endCol": "8"
    },
    "394": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1059",
      "startCol": "20",
      "endLine": "1065",
      "endCol": "8"
    },
    "395": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1073",
      "startCol": "19",
      "endLine": "1079",
      "endCol": "8"
    },
    "396": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1089",
      "startCol": "19",
      "endLine": "1095",
      "endCol": "8"
    },
    "397": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1101",
      "startCol": "19",
      "endLine": "1108",
      "endCol": "8"
    },
    "398": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1114",
      "startCol": "19",
      "endLine": "1120",
      "endCol": "8"
    },
    "399": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1126",
      "startCol": "19",
      "endLine": "1133",
      "endCol": "8"
    },
    "400": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1141",
      "startCol": "19",
      "endLine": "1147",
      "endCol": "8"
    },
    "401": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1153",
      "startCol": "19",
      "endLine": "1159",
      "endCol": "8"
    },
    "402": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1165",
      "startCol": "19",
      "endLine": "1171",
      "endCol": "8"
    },
    "403": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/publication-state.test.e2e.js",
      "startLine": "136",
      "startCol": "5",
      "endLine": "154",
      "endCol": "14"
    },
    "404": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/publication-state.test.e2e.js",
      "startLine": "157",
      "startCol": "10",
      "endLine": "157",
      "endCol": "44"
    },
    "405": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/publication-state.test.e2e.js",
      "startLine": "164",
      "startCol": "5",
      "endLine": "164",
      "endCol": "27"
    },
    "406": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/publication-state.test.e2e.js",
      "startLine": "173",
      "startCol": "21",
      "endLine": "173",
      "endCol": "74"
    },
    "407": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/publication-state.test.e2e.js",
      "startLine": "179",
      "startCol": "21",
      "endLine": "179",
      "endCol": "80"
    },
    "408": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/publication-state.test.e2e.js",
      "startLine": "192",
      "startCol": "21",
      "endLine": "195",
      "endCol": "10"
    },
    "409": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "124",
      "startCol": "5",
      "endLine": "127",
      "endCol": "14"
    },
    "410": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "130",
      "startCol": "10",
      "endLine": "130",
      "endCol": "44"
    },
    "411": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "137",
      "startCol": "5",
      "endLine": "137",
      "endCol": "27"
    },
    "412": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "142",
      "startCol": "19",
      "endLine": "148",
      "endCol": "8"
    },
    "413": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "156",
      "startCol": "19",
      "endLine": "162",
      "endCol": "8"
    },
    "414": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "170",
      "startCol": "19",
      "endLine": "176",
      "endCol": "8"
    },
    "415": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "184",
      "startCol": "19",
      "endLine": "190",
      "endCol": "8"
    },
    "416": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "200",
      "startCol": "19",
      "endLine": "207",
      "endCol": "8"
    },
    "417": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "214",
      "startCol": "19",
      "endLine": "221",
      "endCol": "8"
    },
    "418": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "228",
      "startCol": "19",
      "endLine": "231",
      "endCol": "8"
    },
    "419": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "238",
      "startCol": "19",
      "endLine": "245",
      "endCol": "8"
    },
    "420": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "26",
      "startCol": "5",
      "endLine": "26",
      "endCol": "47"
    },
    "421": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "29",
      "startCol": "10",
      "endLine": "29",
      "endCol": "44"
    },
    "422": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "34",
      "startCol": "5",
      "endLine": "34",
      "endCol": "27"
    },
    "423": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "38",
      "startCol": "17",
      "endLine": "41",
      "endCol": "6"
    },
    "424": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "47",
      "startCol": "17",
      "endLine": "53",
      "endCol": "6"
    },
    "425": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "65",
      "startCol": "17",
      "endLine": "71",
      "endCol": "6"
    },
    "426": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "81",
      "startCol": "17",
      "endLine": "84",
      "endCol": "6"
    },
    "427": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "94",
      "startCol": "17",
      "endLine": "97",
      "endCol": "6"
    },
    "428": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "105",
      "startCol": "20",
      "endLine": "108",
      "endCol": "6"
    },
    "429": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/components/Users/ModalCreateBody/index.js",
      "startLine": "54",
      "startCol": "28",
      "endLine": "57",
      "endCol": "12"
    },
    "430": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Admin/index.js",
      "startLine": "101",
      "startCol": "9",
      "endLine": "107",
      "endCol": "10"
    },
    "431": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Admin/index.js",
      "startLine": "116",
      "startCol": "24",
      "endLine": "116",
      "endCol": "77"
    },
    "432": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Admin/index.js",
      "startLine": "138",
      "startCol": "11",
      "endLine": "138",
      "endCol": "87"
    },
    "433": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Admin/index.js",
      "startLine": "177",
      "startCol": "24",
      "endLine": "177",
      "endCol": "86"
    },
    "434": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/App/index.js",
      "startLine": "44",
      "startCol": "13",
      "endLine": "47",
      "endCol": "10"
    },
    "435": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/App/index.js",
      "startLine": "64",
      "startCol": "26",
      "endLine": "64",
      "endCol": "72"
    },
    "436": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/AuthPage/index.js",
      "startLine": "58",
      "startCol": "15",
      "endLine": "60",
      "endCol": "11"
    },
    "437": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/AuthPage/index.js",
      "startLine": "134",
      "startCol": "7",
      "endLine": "139",
      "endCol": "8"
    },
    "438": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/AuthPage/index.js",
      "startLine": "158",
      "startCol": "11",
      "endLine": "163",
      "endCol": "8"
    },
    "439": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/AuthPage/index.js",
      "startLine": "199",
      "startCol": "11",
      "endLine": "204",
      "endCol": "8"
    },
    "440": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/AuthPage/index.js",
      "startLine": "243",
      "startCol": "11",
      "endLine": "248",
      "endCol": "8"
    },
    "441": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/HomePage/hooks.js",
      "startLine": "18",
      "startCol": "26",
      "endLine": "23",
      "endCol": "9"
    },
    "442": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/InstalledPluginsPage/index.js",
      "startLine": "23",
      "startCol": "24",
      "endLine": "23",
      "endCol": "92"
    },
    "443": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/LeftMenu/index.js",
      "startLine": "78",
      "startCol": "27",
      "endLine": "78",
      "endCol": "79"
    },
    "444": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/LeftMenu/index.js",
      "startLine": "90",
      "startCol": "24",
      "endLine": "90",
      "endCol": "67"
    },
    "445": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/LeftMenu/index.js",
      "startLine": "97",
      "startCol": "45",
      "endLine": "99",
      "endCol": "7"
    },
    "446": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/LeftMenu/index.js",
      "startLine": "104",
      "startCol": "41",
      "endLine": "104",
      "endCol": "97"
    },
    "447": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/LeftMenu/index.js",
      "startLine": "141",
      "startCol": "37",
      "endLine": "141",
      "endCol": "89"
    },
    "448": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/LeftMenu/index.js",
      "startLine": "142",
      "startCol": "37",
      "endLine": "142",
      "endCol": "89"
    },
    "449": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/MarketplacePage/index.js",
      "startLine": "38",
      "startCol": "24",
      "endLine": "38",
      "endCol": "90"
    },
    "450": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Onboarding/index.js",
      "startLine": "25",
      "startCol": "26",
      "endLine": "27",
      "endCol": "10"
    },
    "451": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Roles/EditPage/index.js",
      "startLine": "87",
      "startCol": "7",
      "endLine": "90",
      "endCol": "8"
    },
    "452": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Roles/EditPage/index.js",
      "startLine": "93",
      "startCol": "9",
      "endLine": "98",
      "endCol": "10"
    },
    "453": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Users/ListPage/index.js",
      "startLine": "72",
      "startCol": "11",
      "endLine": "72",
      "endCol": "67"
    },
    "454": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Users/ListPage/index.js",
      "startLine": "178",
      "startCol": "7",
      "endLine": "183",
      "endCol": "8"
    },
    "455": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/EditView/index.js",
      "startLine": "57",
      "startCol": "26",
      "endLine": "59",
      "endCol": "10"
    },
    "456": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/EditView/index.js",
      "startLine": "168",
      "startCol": "7",
      "endLine": "168",
      "endCol": "64"
    },
    "457": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/EditView/index.js",
      "startLine": "195",
      "startCol": "24",
      "endLine": "198",
      "endCol": "8"
    },
    "458": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/EditView/index.js",
      "startLine": "261",
      "startCol": "24",
      "endLine": "264",
      "endCol": "8"
    },
    "459": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/EditView/index.js",
      "startLine": "363",
      "startCol": "7",
      "endLine": "366",
      "endCol": "8"
    },
    "460": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/ListView/index.js",
      "startLine": "127",
      "startCol": "24",
      "endLine": "129",
      "endCol": "8"
    },
    "461": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/ListView/index.js",
      "startLine": "167",
      "startCol": "7",
      "endLine": "169",
      "endCol": "8"
    },
    "462": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/ListView/index.js",
      "startLine": "192",
      "startCol": "7",
      "endLine": "195",
      "endCol": "8"
    },
    "463": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/ListView/index.js",
      "startLine": "244",
      "startCol": "7",
      "endLine": "247",
      "endCol": "8"
    },
    "464": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useFetchPermissionsLayout/index.js",
      "startLine": "15",
      "startCol": "24",
      "endLine": "15",
      "endCol": "77"
    },
    "465": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useFetchPluginsFromMarketPlace/index.js",
      "startLine": "19",
      "startCol": "26",
      "endLine": "22",
      "endCol": "10"
    },
    "466": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useFetchPluginsFromMarketPlace/tests/useFetchPluginsFromMarketPlace.test.js",
      "startLine": "18",
      "startCol": "5",
      "endLine": "18",
      "endCol": "29"
    },
    "467": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useFetchPluginsFromMarketPlace/tests/useFetchPluginsFromMarketPlace.test.js",
      "startLine": "38",
      "startCol": "5",
      "endLine": "38",
      "endCol": "29"
    },
    "468": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useFetchRole/index.js",
      "startLine": "26",
      "startCol": "55",
      "endLine": "30",
      "endCol": "7"
    },
    "469": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useModels/index.js",
      "startLine": "19",
      "startCol": "62",
      "endLine": "23",
      "endCol": "7"
    },
    "470": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useRolesList/index.js",
      "startLine": "24",
      "startCol": "24",
      "endLine": "24",
      "endCol": "71"
    },
    "471": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useSettingsMenu/index.js",
      "startLine": "18",
      "startCol": "31",
      "endLine": "18",
      "endCol": "83"
    },
    "472": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useSettingsMenu/index.js",
      "startLine": "36",
      "startCol": "20",
      "endLine": "36",
      "endCol": "72"
    },
    "473": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useUsersForm/index.js",
      "startLine": "17",
      "startCol": "26",
      "endLine": "17",
      "endCol": "67"
    },
    "474": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useUsersForm/index.js",
      "startLine": "77",
      "startCol": "26",
      "endLine": "80",
      "endCol": "10"
    },
    "475": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/utils/checkFormValidity.js",
      "startLine": "7",
      "startCol": "5",
      "endLine": "7",
      "endCol": "54"
    },
    "476": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "19",
      "startCol": "3",
      "endLine": "19",
      "endCol": "68"
    },
    "477": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "20",
      "startCol": "3",
      "endLine": "20",
      "endCol": "75"
    },
    "478": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "21",
      "startCol": "3",
      "endLine": "21",
      "endCol": "49"
    },
    "479": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "22",
      "startCol": "3",
      "endLine": "22",
      "endCol": "59"
    },
    "480": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "23",
      "startCol": "3",
      "endLine": "23",
      "endCol": "63"
    },
    "481": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "24",
      "startCol": "3",
      "endLine": "24",
      "endCol": "65"
    },
    "482": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "25",
      "startCol": "3",
      "endLine": "25",
      "endCol": "70"
    },
    "483": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "50",
      "startCol": "22",
      "endLine": "50",
      "endCol": "61"
    },
    "484": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "56",
      "startCol": "21",
      "endLine": "56",
      "endCol": "61"
    },
    "485": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "69",
      "startCol": "7",
      "endLine": "72",
      "endCol": "8"
    },
    "486": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "79",
      "startCol": "21",
      "endLine": "79",
      "endCol": "65"
    },
    "487": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "91",
      "startCol": "7",
      "endLine": "94",
      "endCol": "8"
    },
    "488": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "101",
      "startCol": "21",
      "endLine": "101",
      "endCol": "61"
    },
    "489": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "107",
      "startCol": "28",
      "endLine": "110",
      "endCol": "6"
    },
    "490": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "123",
      "startCol": "21",
      "endLine": "123",
      "endCol": "61"
    },
    "491": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "129",
      "startCol": "5",
      "endLine": "129",
      "endCol": "47"
    },
    "492": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "144",
      "startCol": "23",
      "endLine": "144",
      "endCol": "63"
    },
    "493": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "148",
      "startCol": "7",
      "endLine": "148",
      "endCol": "49"
    },
    "494": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "158",
      "startCol": "21",
      "endLine": "158",
      "endCol": "61"
    },
    "495": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "160",
      "startCol": "22",
      "endLine": "160",
      "endCol": "80"
    },
    "496": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/admin.js",
      "startLine": "22",
      "startCol": "22",
      "endLine": "22",
      "endCol": "62"
    },
    "497": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/admin.js",
      "startLine": "50",
      "startCol": "7",
      "endLine": "50",
      "endCol": "68"
    },
    "498": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/admin.js",
      "startLine": "90",
      "startCol": "7",
      "endLine": "90",
      "endCol": "76"
    },
    "499": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authenticated-user.js",
      "startLine": "18",
      "startCol": "7",
      "endLine": "18",
      "endCol": "45"
    },
    "500": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authenticated-user.js",
      "startLine": "23",
      "startCol": "25",
      "endLine": "23",
      "endCol": "93"
    },
    "501": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authenticated-user.js",
      "startLine": "33",
      "startCol": "29",
      "endLine": "33",
      "endCol": "69"
    },
    "502": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "64",
      "startCol": "7",
      "endLine": "64",
      "endCol": "60"
    },
    "503": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "71",
      "startCol": "30",
      "endLine": "73",
      "endCol": "5"
    },
    "504": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "86",
      "startCol": "7",
      "endLine": "86",
      "endCol": "44"
    },
    "505": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "91",
      "startCol": "18",
      "endLine": "91",
      "endCol": "65"
    },
    "506": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "105",
      "startCol": "7",
      "endLine": "105",
      "endCol": "49"
    },
    "507": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "110",
      "startCol": "22",
      "endLine": "110",
      "endCol": "62"
    },
    "508": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "116",
      "startCol": "28",
      "endLine": "116",
      "endCol": "75"
    },
    "509": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "124",
      "startCol": "18",
      "endLine": "129",
      "endCol": "6"
    },
    "510": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "131",
      "startCol": "5",
      "endLine": "131",
      "endCol": "54"
    },
    "511": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "145",
      "startCol": "7",
      "endLine": "145",
      "endCol": "46"
    },
    "512": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "159",
      "startCol": "7",
      "endLine": "159",
      "endCol": "45"
    },
    "513": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "164",
      "startCol": "18",
      "endLine": "164",
      "endCol": "70"
    },
    "514": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/permission.js",
      "startLine": "15",
      "startCol": "7",
      "endLine": "15",
      "endCol": "48"
    },
    "515": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "15",
      "startCol": "18",
      "endLine": "15",
      "endCol": "79"
    },
    "516": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "31",
      "startCol": "19",
      "endLine": "31",
      "endCol": "74"
    },
    "517": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "46",
      "startCol": "7",
      "endLine": "46",
      "endCol": "53"
    },
    "518": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "51",
      "startCol": "18",
      "endLine": "51",
      "endCol": "65"
    },
    "519": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "60",
      "startCol": "25",
      "endLine": "60",
      "endCol": "89"
    },
    "520": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "76",
      "startCol": "18",
      "endLine": "76",
      "endCol": "65"
    },
    "521": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "82",
      "startCol": "25",
      "endLine": "82",
      "endCol": "98"
    },
    "522": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "100",
      "startCol": "18",
      "endLine": "100",
      "endCol": "65"
    },
    "523": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "132",
      "startCol": "25",
      "endLine": "135",
      "endCol": "5"
    },
    "524": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "15",
      "startCol": "7",
      "endLine": "15",
      "endCol": "43"
    },
    "525": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "22",
      "startCol": "31",
      "endLine": "24",
      "endCol": "6"
    },
    "526": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "30",
      "startCol": "25",
      "endLine": "30",
      "endCol": "75"
    },
    "527": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "41",
      "startCol": "37",
      "endLine": "41",
      "endCol": "87"
    },
    "528": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "54",
      "startCol": "18",
      "endLine": "54",
      "endCol": "65"
    },
    "529": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "70",
      "startCol": "7",
      "endLine": "70",
      "endCol": "42"
    },
    "530": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "76",
      "startCol": "32",
      "endLine": "79",
      "endCol": "8"
    },
    "531": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "86",
      "startCol": "25",
      "endLine": "86",
      "endCol": "78"
    },
    "532": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "100",
      "startCol": "25",
      "endLine": "100",
      "endCol": "71"
    },
    "533": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "123",
      "startCol": "19",
      "endLine": "123",
      "endCol": "72"
    },
    "534": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/admin/containers/Roles/CreatePage/index.js",
      "startLine": "88",
      "startCol": "11",
      "endLine": "91",
      "endCol": "12"
    },
    "535": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/admin/containers/Roles/ListPage/index.js",
      "startLine": "96",
      "startCol": "9",
      "endLine": "101",
      "endCol": "10"
    },
    "536": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/controllers/role.js",
      "startLine": "24",
      "startCol": "16",
      "endLine": "24",
      "endCol": "72"
    },
    "537": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/controllers/role.js",
      "startLine": "43",
      "startCol": "19",
      "endLine": "43",
      "endCol": "68"
    },
    "538": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/controllers/role.js",
      "startLine": "64",
      "startCol": "19",
      "endLine": "64",
      "endCol": "72"
    },
    "539": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/controllers/role.js",
      "startLine": "80",
      "startCol": "18",
      "endLine": "80",
      "endCol": "65"
    },
    "540": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/controllers/role.js",
      "startLine": "90",
      "startCol": "7",
      "endLine": "90",
      "endCol": "50"
    },
    "541": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/controllers/role.js",
      "startLine": "99",
      "startCol": "25",
      "endLine": "102",
      "endCol": "5"
    },
    "542": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/validation/role.js",
      "startLine": "27",
      "startCol": "32",
      "endLine": "27",
      "endCol": "79"
    },
    "543": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/validation/role.js",
      "startLine": "37",
      "startCol": "28",
      "endLine": "37",
      "endCol": "75"
    },
    "544": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "145",
      "startCol": "3",
      "endLine": "145",
      "endCol": "21"
    },
    "545": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "148",
      "startCol": "7",
      "endLine": "148",
      "endCol": "71"
    },
    "546": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "149",
      "startCol": "5",
      "endLine": "149",
      "endCol": "45"
    },
    "547": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "150",
      "startCol": "5",
      "endLine": "150",
      "endCol": "37"
    },
    "548": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "153",
      "startCol": "3",
      "endLine": "153",
      "endCol": "28"
    },
    "549": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "160",
      "startCol": "3",
      "endLine": "160",
      "endCol": "90"
    },
    "550": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "162",
      "startCol": "3",
      "endLine": "162",
      "endCol": "50"
    },
    "551": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "163",
      "startCol": "3",
      "endLine": "163",
      "endCol": "78"
    },
    "552": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "164",
      "startCol": "3",
      "endLine": "167",
      "endCol": "3"
    },
    "553": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "170",
      "startCol": "3",
      "endLine": "170",
      "endCol": "92"
    },
    "554": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "174",
      "startCol": "3",
      "endLine": "174",
      "endCol": "49"
    },
    "555": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "200",
      "startCol": "3",
      "endLine": "200",
      "endCol": "29"
    },
    "556": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "206",
      "startCol": "3",
      "endLine": "206",
      "endCol": "74"
    },
    "557": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "227",
      "startCol": "3",
      "endLine": "234",
      "endCol": "3"
    },
    "558": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "335",
      "startCol": "11",
      "endLine": "338",
      "endCol": "11"
    },
    "559": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "361",
      "startCol": "9",
      "endLine": "361",
      "endCol": "66"
    },
    "560": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/middlewares/auth/index.js",
      "startLine": "39",
      "startCol": "25",
      "endLine": "39",
      "endCol": "98"
    },
    "561": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/middlewares/auth/index.js",
      "startLine": "47",
      "startCol": "35",
      "endLine": "49",
      "endCol": "11"
    },
    "562": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/action-provider.test.js",
      "startLine": "32",
      "startCol": "7",
      "endLine": "32",
      "endCol": "56"
    },
    "563": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/action-provider.test.js",
      "startLine": "42",
      "startCol": "7",
      "endLine": "42",
      "endCol": "58"
    },
    "564": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/action-provider.test.js",
      "startLine": "75",
      "startCol": "7",
      "endLine": "75",
      "endCol": "52"
    },
    "565": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "startLine": "37",
      "startCol": "19",
      "endLine": "37",
      "endCol": "53"
    },
    "566": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "startLine": "62",
      "startCol": "19",
      "endLine": "62",
      "endCol": "53"
    },
    "567": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "startLine": "87",
      "startCol": "19",
      "endLine": "87",
      "endCol": "53"
    },
    "568": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "startLine": "109",
      "startCol": "20",
      "endLine": "109",
      "endCol": "47"
    },
    "569": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "startLine": "111",
      "startCol": "23",
      "endLine": "111",
      "endCol": "60"
    },
    "570": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permission.test.js",
      "startLine": "16",
      "startCol": "7",
      "endLine": "16",
      "endCol": "47"
    },
    "571": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "152",
      "startCol": "23",
      "endLine": "152",
      "endCol": "60"
    },
    "572": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "187",
      "startCol": "23",
      "endLine": "187",
      "endCol": "60"
    },
    "573": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "217",
      "startCol": "23",
      "endLine": "217",
      "endCol": "60"
    },
    "574": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "229",
      "startCol": "19",
      "endLine": "229",
      "endCol": "56"
    },
    "575": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "257",
      "startCol": "23",
      "endLine": "257",
      "endCol": "46"
    },
    "576": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "271",
      "startCol": "7",
      "endLine": "271",
      "endCol": "71"
    },
    "577": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "286",
      "startCol": "7",
      "endLine": "286",
      "endCol": "71"
    },
    "578": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "306",
      "startCol": "7",
      "endLine": "306",
      "endCol": "71"
    },
    "579": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "321",
      "startCol": "7",
      "endLine": "321",
      "endCol": "71"
    },
    "580": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "startLine": "42",
      "startCol": "25",
      "endLine": "42",
      "endCol": "66"
    },
    "581": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "startLine": "84",
      "startCol": "26",
      "endLine": "84",
      "endCol": "49"
    },
    "582": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/user.test.js",
      "startLine": "765",
      "startCol": "7",
      "endLine": "767",
      "endCol": "7"
    },
    "583": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/user.test.js",
      "startLine": "787",
      "startCol": "9",
      "endLine": "791",
      "endCol": "9"
    },
    "584": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/auth.js",
      "startLine": "29",
      "startCol": "16",
      "endLine": "29",
      "endCol": "69"
    },
    "585": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/auth.js",
      "startLine": "35",
      "startCol": "19",
      "endLine": "35",
      "endCol": "65"
    },
    "586": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/auth.js",
      "startLine": "54",
      "startCol": "16",
      "endLine": "54",
      "endCol": "85"
    },
    "587": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/auth.js",
      "startLine": "61",
      "startCol": "3",
      "endLine": "61",
      "endCol": "78"
    },
    "588": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/auth.js",
      "startLine": "93",
      "startCol": "24",
      "endLine": "95",
      "endCol": "52"
    },
    "589": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/metrics.js",
      "startLine": "4",
      "startCol": "25",
      "endLine": "4",
      "endCol": "64"
    },
    "590": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/metrics.js",
      "startLine": "5",
      "startCol": "25",
      "endLine": "5",
      "endCol": "64"
    },
    "591": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/permission/engine.js",
      "startLine": "35",
      "startCol": "25",
      "endLine": "35",
      "endCol": "88"
    },
    "592": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/permission/engine.js",
      "startLine": "108",
      "startCol": "5",
      "endLine": "115",
      "endCol": "28"
    },
    "593": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/permission.js",
      "startLine": "100",
      "startCol": "17",
      "endLine": "100",
      "endCol": "90"
    },
    "594": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/permission.js",
      "startLine": "133",
      "startCol": "5",
      "endLine": "139",
      "endCol": "6"
    },
    "595": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/permission.js",
      "startLine": "149",
      "startCol": "22",
      "endLine": "149",
      "endCol": "91"
    },
    "596": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/permission.js",
      "startLine": "157",
      "startCol": "25",
      "endLine": "164",
      "endCol": "5"
    },
    "597": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "75",
      "startCol": "16",
      "endLine": "75",
      "endCol": "76"
    },
    "598": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "99",
      "startCol": "17",
      "endLine": "99",
      "endCol": "82"
    },
    "599": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "139",
      "startCol": "22",
      "endLine": "139",
      "endCol": "70"
    },
    "600": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "159",
      "startCol": "26",
      "endLine": "159",
      "endCol": "46"
    },
    "601": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "175",
      "startCol": "3",
      "endLine": "175",
      "endCol": "62"
    },
    "602": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "177",
      "startCol": "22",
      "endLine": "177",
      "endCol": "79"
    },
    "603": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "223",
      "startCol": "3",
      "endLine": "223",
      "endCol": "70"
    },
    "604": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "276",
      "startCol": "27",
      "endLine": "276",
      "endCol": "67"
    },
    "605": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "291",
      "startCol": "5",
      "endLine": "291",
      "endCol": "47"
    },
    "606": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "296",
      "startCol": "22",
      "endLine": "296",
      "endCol": "69"
    },
    "607": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "307",
      "startCol": "31",
      "endLine": "310",
      "endCol": "4"
    },
    "608": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "324",
      "startCol": "5",
      "endLine": "324",
      "endCol": "90"
    },
    "609": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "333",
      "startCol": "5",
      "endLine": "333",
      "endCol": "70"
    },
    "610": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "350",
      "startCol": "26",
      "endLine": "350",
      "endCol": "73"
    },
    "611": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "34",
      "startCol": "25",
      "endLine": "34",
      "endCol": "90"
    },
    "612": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "38",
      "startCol": "23",
      "endLine": "38",
      "endCol": "70"
    },
    "613": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "40",
      "startCol": "3",
      "endLine": "40",
      "endCol": "57"
    },
    "614": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "55",
      "startCol": "28",
      "endLine": "55",
      "endCol": "89"
    },
    "615": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "79",
      "startCol": "28",
      "endLine": "79",
      "endCol": "93"
    },
    "616": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "106",
      "startCol": "5",
      "endLine": "106",
      "endCol": "46"
    },
    "617": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "122",
      "startCol": "26",
      "endLine": "122",
      "endCol": "87"
    },
    "618": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "133",
      "startCol": "11",
      "endLine": "133",
      "endCol": "63"
    },
    "619": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "142",
      "startCol": "16",
      "endLine": "142",
      "endCol": "81"
    },
    "620": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "158",
      "startCol": "24",
      "endLine": "158",
      "endCol": "89"
    },
    "621": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "202",
      "startCol": "24",
      "endLine": "202",
      "endCol": "85"
    },
    "622": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "205",
      "startCol": "30",
      "endLine": "205",
      "endCol": "91"
    },
    "623": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "226",
      "startCol": "26",
      "endLine": "226",
      "endCol": "87"
    },
    "624": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "227",
      "startCol": "34",
      "endLine": "229",
      "endCol": "54"
    },
    "625": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "248",
      "startCol": "13",
      "endLine": "248",
      "endCol": "75"
    },
    "626": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "250",
      "startCol": "13",
      "endLine": "252",
      "endCol": "6"
    },
    "627": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "254",
      "startCol": "22",
      "endLine": "254",
      "endCol": "77"
    },
    "628": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "255",
      "startCol": "13",
      "endLine": "257",
      "endCol": "6"
    },
    "629": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "282",
      "startCol": "22",
      "endLine": "287",
      "endCol": "31"
    },
    "630": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "291",
      "startCol": "7",
      "endLine": "291",
      "endCol": "54"
    },
    "631": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "294",
      "startCol": "5",
      "endLine": "294",
      "endCol": "81"
    },
    "632": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "310",
      "startCol": "26",
      "endLine": "310",
      "endCol": "66"
    },
    "633": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "318",
      "startCol": "5",
      "endLine": "320",
      "endCol": "82"
    },
    "634": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "321",
      "startCol": "5",
      "endLine": "323",
      "endCol": "83"
    },
    "635": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "325",
      "startCol": "5",
      "endLine": "325",
      "endCol": "87"
    },
    "636": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "326",
      "startCol": "5",
      "endLine": "326",
      "endCol": "70"
    },
    "637": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "21",
      "startCol": "10",
      "endLine": "21",
      "endCol": "44"
    },
    "638": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "25",
      "startCol": "24",
      "endLine": "28",
      "endCol": "8"
    },
    "639": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "30",
      "startCol": "24",
      "endLine": "30",
      "endCol": "54"
    },
    "640": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "36",
      "startCol": "7",
      "endLine": "36",
      "endCol": "54"
    },
    "641": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "44",
      "startCol": "19",
      "endLine": "48",
      "endCol": "8"
    },
    "642": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "64",
      "startCol": "19",
      "endLine": "71",
      "endCol": "8"
    },
    "643": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "82",
      "startCol": "19",
      "endLine": "89",
      "endCol": "8"
    },
    "644": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "100",
      "startCol": "19",
      "endLine": "106",
      "endCol": "8"
    },
    "645": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "119",
      "startCol": "23",
      "endLine": "123",
      "endCol": "8"
    },
    "646": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "128",
      "startCol": "19",
      "endLine": "134",
      "endCol": "8"
    },
    "647": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "143",
      "startCol": "19",
      "endLine": "149",
      "endCol": "8"
    },
    "648": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "160",
      "startCol": "19",
      "endLine": "164",
      "endCol": "8"
    },
    "649": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "189",
      "startCol": "14",
      "endLine": "189",
      "endCol": "45"
    },
    "650": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "193",
      "startCol": "7",
      "endLine": "193",
      "endCol": "41"
    },
    "651": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "197",
      "startCol": "19",
      "endLine": "201",
      "endCol": "8"
    },
    "652": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "214",
      "startCol": "19",
      "endLine": "218",
      "endCol": "8"
    },
    "653": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "232",
      "startCol": "19",
      "endLine": "236",
      "endCol": "8"
    },
    "654": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "258",
      "startCol": "14",
      "endLine": "258",
      "endCol": "45"
    },
    "655": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "262",
      "startCol": "7",
      "endLine": "262",
      "endCol": "41"
    },
    "656": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "266",
      "startCol": "19",
      "endLine": "272",
      "endCol": "8"
    },
    "657": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "290",
      "startCol": "19",
      "endLine": "301",
      "endCol": "8"
    },
    "658": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "321",
      "startCol": "19",
      "endLine": "328",
      "endCol": "8"
    },
    "659": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "346",
      "startCol": "19",
      "endLine": "350",
      "endCol": "8"
    },
    "660": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "367",
      "startCol": "19",
      "endLine": "376",
      "endCol": "8"
    },
    "661": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "397",
      "startCol": "19",
      "endLine": "401",
      "endCol": "8"
    },
    "662": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "414",
      "startCol": "19",
      "endLine": "420",
      "endCol": "8"
    },
    "663": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "425",
      "startCol": "30",
      "endLine": "431",
      "endCol": "8"
    },
    "664": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "13",
      "startCol": "10",
      "endLine": "13",
      "endCol": "44"
    },
    "665": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "22",
      "startCol": "19",
      "endLine": "26",
      "endCol": "8"
    },
    "666": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "41",
      "startCol": "19",
      "endLine": "45",
      "endCol": "8"
    },
    "667": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "54",
      "startCol": "19",
      "endLine": "58",
      "endCol": "8"
    },
    "668": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "64",
      "startCol": "19",
      "endLine": "70",
      "endCol": "8"
    },
    "669": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "81",
      "startCol": "19",
      "endLine": "87",
      "endCol": "8"
    },
    "670": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "98",
      "startCol": "19",
      "endLine": "104",
      "endCol": "8"
    },
    "671": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "120",
      "startCol": "19",
      "endLine": "124",
      "endCol": "8"
    },
    "672": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permission.test.e2e.js",
      "startLine": "14",
      "startCol": "10",
      "endLine": "14",
      "endCol": "44"
    },
    "673": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permission.test.e2e.js",
      "startLine": "22",
      "startCol": "15",
      "endLine": "25",
      "endCol": "6"
    },
    "674": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "72",
      "startCol": "24",
      "endLine": "72",
      "endCol": "58"
    },
    "675": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "76",
      "startCol": "20",
      "endLine": "76",
      "endCol": "61"
    },
    "676": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "79",
      "startCol": "27",
      "endLine": "79",
      "endCol": "97"
    },
    "677": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "93",
      "startCol": "29",
      "endLine": "93",
      "endCol": "66"
    },
    "678": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "95",
      "startCol": "36",
      "endLine": "95",
      "endCol": "93"
    },
    "679": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "110",
      "startCol": "7",
      "endLine": "110",
      "endCol": "42"
    },
    "680": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "113",
      "startCol": "7",
      "endLine": "113",
      "endCol": "58"
    },
    "681": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "117",
      "startCol": "7",
      "endLine": "117",
      "endCol": "72"
    },
    "682": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "128",
      "startCol": "7",
      "endLine": "128",
      "endCol": "29"
    },
    "683": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "134",
      "startCol": "19",
      "endLine": "138",
      "endCol": "8"
    },
    "684": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "148",
      "startCol": "19",
      "endLine": "151",
      "endCol": "8"
    },
    "685": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "161",
      "startCol": "19",
      "endLine": "164",
      "endCol": "8"
    },
    "686": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "174",
      "startCol": "19",
      "endLine": "177",
      "endCol": "8"
    },
    "687": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "186",
      "startCol": "19",
      "endLine": "189",
      "endCol": "8"
    },
    "688": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "29",
      "startCol": "10",
      "endLine": "29",
      "endCol": "44"
    },
    "689": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "59",
      "startCol": "19",
      "endLine": "62",
      "endCol": "8"
    },
    "690": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "79",
      "startCol": "19",
      "endLine": "82",
      "endCol": "8"
    },
    "691": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "95",
      "startCol": "19",
      "endLine": "98",
      "endCol": "8"
    },
    "692": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "124",
      "startCol": "19",
      "endLine": "128",
      "endCol": "10"
    },
    "693": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "147",
      "startCol": "15",
      "endLine": "151",
      "endCol": "10"
    },
    "694": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "206",
      "startCol": "19",
      "endLine": "210",
      "endCol": "10"
    },
    "695": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "223",
      "startCol": "15",
      "endLine": "227",
      "endCol": "10"
    },
    "696": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "254",
      "startCol": "19",
      "endLine": "258",
      "endCol": "10"
    },
    "697": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "270",
      "startCol": "21",
      "endLine": "274",
      "endCol": "10"
    },
    "698": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "289",
      "startCol": "21",
      "endLine": "293",
      "endCol": "10"
    },
    "699": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "305",
      "startCol": "21",
      "endLine": "308",
      "endCol": "10"
    },
    "700": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "328",
      "startCol": "21",
      "endLine": "331",
      "endCol": "10"
    },
    "701": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "356",
      "startCol": "21",
      "endLine": "360",
      "endCol": "10"
    },
    "702": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "375",
      "startCol": "21",
      "endLine": "379",
      "endCol": "10"
    },
    "703": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "394",
      "startCol": "21",
      "endLine": "398",
      "endCol": "10"
    },
    "704": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "413",
      "startCol": "21",
      "endLine": "417",
      "endCol": "10"
    },
    "705": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "428",
      "startCol": "21",
      "endLine": "432",
      "endCol": "12"
    },
    "706": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "440",
      "startCol": "19",
      "endLine": "443",
      "endCol": "14"
    },
    "707": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "450",
      "startCol": "21",
      "endLine": "454",
      "endCol": "12"
    },
    "708": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "458",
      "startCol": "17",
      "endLine": "461",
      "endCol": "12"
    },
    "709": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "472",
      "startCol": "21",
      "endLine": "476",
      "endCol": "12"
    },
    "710": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "481",
      "startCol": "19",
      "endLine": "484",
      "endCol": "14"
    },
    "711": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "494",
      "startCol": "21",
      "endLine": "497",
      "endCol": "12"
    },
    "712": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "501",
      "startCol": "17",
      "endLine": "504",
      "endCol": "12"
    },
    "713": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "512",
      "startCol": "21",
      "endLine": "515",
      "endCol": "12"
    },
    "714": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "522",
      "startCol": "17",
      "endLine": "525",
      "endCol": "12"
    },
    "715": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "531",
      "startCol": "21",
      "endLine": "534",
      "endCol": "12"
    },
    "716": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "541",
      "startCol": "17",
      "endLine": "544",
      "endCol": "12"
    },
    "717": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "557",
      "startCol": "21",
      "endLine": "561",
      "endCol": "10"
    },
    "718": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "572",
      "startCol": "21",
      "endLine": "575",
      "endCol": "10"
    },
    "719": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "581",
      "startCol": "21",
      "endLine": "585",
      "endCol": "10"
    },
    "720": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "594",
      "startCol": "21",
      "endLine": "597",
      "endCol": "10"
    },
    "721": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "606",
      "startCol": "21",
      "endLine": "622",
      "endCol": "10"
    },
    "722": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "654",
      "startCol": "21",
      "endLine": "666",
      "endCol": "10"
    },
    "723": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "678",
      "startCol": "21",
      "endLine": "688",
      "endCol": "10"
    },
    "724": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "700",
      "startCol": "21",
      "endLine": "703",
      "endCol": "10"
    },
    "725": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "733",
      "startCol": "21",
      "endLine": "737",
      "endCol": "10"
    },
    "726": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "58",
      "startCol": "10",
      "endLine": "58",
      "endCol": "44"
    },
    "727": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "64",
      "startCol": "23",
      "endLine": "64",
      "endCol": "53"
    },
    "728": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "68",
      "startCol": "31",
      "endLine": "68",
      "endCol": "61"
    },
    "729": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "74",
      "startCol": "7",
      "endLine": "74",
      "endCol": "53"
    },
    "730": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "86",
      "startCol": "17",
      "endLine": "90",
      "endCol": "6"
    },
    "731": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "111",
      "startCol": "17",
      "endLine": "115",
      "endCol": "6"
    },
    "732": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "135",
      "startCol": "19",
      "endLine": "139",
      "endCol": "8"
    },
    "733": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "153",
      "startCol": "17",
      "endLine": "157",
      "endCol": "6"
    },
    "734": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "175",
      "startCol": "17",
      "endLine": "179",
      "endCol": "6"
    },
    "735": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "193",
      "startCol": "17",
      "endLine": "196",
      "endCol": "6"
    },
    "736": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "216",
      "startCol": "19",
      "endLine": "219",
      "endCol": "8"
    },
    "737": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "227",
      "startCol": "19",
      "endLine": "230",
      "endCol": "8"
    },
    "738": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "239",
      "startCol": "17",
      "endLine": "242",
      "endCol": "6"
    },
    "739": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "249",
      "startCol": "17",
      "endLine": "252",
      "endCol": "6"
    },
    "740": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "259",
      "startCol": "17",
      "endLine": "265",
      "endCol": "6"
    },
    "741": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "273",
      "startCol": "17",
      "endLine": "276",
      "endCol": "6"
    },
    "742": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "283",
      "startCol": "17",
      "endLine": "286",
      "endCol": "6"
    },
    "743": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "298",
      "startCol": "17",
      "endLine": "304",
      "endCol": "6"
    },
    "744": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "320",
      "startCol": "17",
      "endLine": "324",
      "endCol": "6"
    },
    "745": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "335",
      "startCol": "17",
      "endLine": "338",
      "endCol": "6"
    },
    "746": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "349",
      "startCol": "17",
      "endLine": "352",
      "endCol": "6"
    },
    "747": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/validation/permission.js",
      "startLine": "105",
      "startCol": "7",
      "endLine": "105",
      "endCol": "77"
    },
    "748": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "107",
      "startCol": "18",
      "endLine": "107",
      "endCol": "71"
    },
    "749": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "213",
      "startCol": "23",
      "endLine": "213",
      "endCol": "59"
    },
    "750": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "278",
      "startCol": "5",
      "endLine": "278",
      "endCol": "28"
    },
    "751": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "285",
      "startCol": "23",
      "endLine": "287",
      "endCol": "3"
    },
    "752": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "294",
      "startCol": "5",
      "endLine": "296",
      "endCol": "6"
    },
    "753": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "318",
      "startCol": "11",
      "endLine": "318",
      "endCol": "55"
    },
    "754": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "321",
      "startCol": "11",
      "endLine": "325",
      "endCol": "11"
    },
    "755": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "328",
      "startCol": "11",
      "endLine": "328",
      "endCol": "43"
    },
    "756": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "340",
      "startCol": "11",
      "endLine": "340",
      "endCol": "80"
    },
    "757": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "341",
      "startCol": "11",
      "endLine": "341",
      "endCol": "54"
    },
    "758": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "345",
      "startCol": "11",
      "endLine": "345",
      "endCol": "62"
    },
    "759": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "362",
      "startCol": "11",
      "endLine": "370",
      "endCol": "11"
    },
    "760": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "371",
      "startCol": "11",
      "endLine": "375",
      "endCol": "12"
    },
    "761": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "379",
      "startCol": "11",
      "endLine": "379",
      "endCol": "60"
    },
    "762": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "407",
      "startCol": "3",
      "endLine": "407",
      "endCol": "80"
    },
    "763": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/generate-component-relations.js",
      "startLine": "76",
      "startCol": "9",
      "endLine": "76",
      "endCol": "49"
    },
    "764": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/generate-component-relations.js",
      "startLine": "78",
      "startCol": "5",
      "endLine": "97",
      "endCol": "6"
    },
    "765": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/index.js",
      "startLine": "84",
      "startCol": "31",
      "endLine": "89",
      "endCol": "6"
    },
    "766": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/index.js",
      "startLine": "92",
      "startCol": "7",
      "endLine": "92",
      "endCol": "30"
    },
    "767": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/index.js",
      "startLine": "155",
      "startCol": "5",
      "endLine": "155",
      "endCol": "99"
    },
    "768": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/create-migration-runner.js",
      "startLine": "9",
      "startCol": "9",
      "endLine": "9",
      "endCol": "48"
    },
    "769": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/create-migration-runner.js",
      "startLine": "17",
      "startCol": "9",
      "endLine": "17",
      "endCol": "47"
    },
    "770": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/create-migration-runner.js",
      "startLine": "24",
      "startCol": "5",
      "endLine": "24",
      "endCol": "45"
    },
    "771": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/draft-publish-migration.js",
      "startLine": "30",
      "startCol": "37",
      "endLine": "33",
      "endCol": "5"
    },
    "772": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/draft-publish-migration.js",
      "startLine": "36",
      "startCol": "7",
      "endLine": "38",
      "endCol": "44"
    },
    "773": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/draft-publish-migration.js",
      "startLine": "45",
      "startCol": "9",
      "endLine": "47",
      "endCol": "10"
    },
    "774": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/draft-publish-migration.js",
      "startLine": "63",
      "startCol": "5",
      "endLine": "65",
      "endCol": "42"
    },
    "775": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/draft-publish-migration.js",
      "startLine": "67",
      "startCol": "5",
      "endLine": "69",
      "endCol": "42"
    },
    "776": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/mount-models.js",
      "startLine": "697",
      "startCol": "7",
      "endLine": "697",
      "endCol": "28"
    },
    "777": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "56",
      "startCol": "14",
      "endLine": "56",
      "endCol": "30"
    },
    "778": {
      "patternID": "pattern1",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "54",
      "startCol": "28",
      "endLine": "60",
      "endCol": "3"
    },
    "779": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "66",
      "startCol": "21",
      "endLine": "66",
      "endCol": "83"
    },
    "780": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "111",
      "startCol": "21",
      "endLine": "111",
      "endCol": "76"
    },
    "781": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "122",
      "startCol": "19",
      "endLine": "122",
      "endCol": "66"
    },
    "782": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "137",
      "startCol": "13",
      "endLine": "141",
      "endCol": "14"
    },
    "783": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "157",
      "startCol": "19",
      "endLine": "157",
      "endCol": "86"
    },
    "784": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "165",
      "startCol": "5",
      "endLine": "165",
      "endCol": "52"
    },
    "785": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "169",
      "startCol": "7",
      "endLine": "169",
      "endCol": "87"
    },
    "786": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "178",
      "startCol": "23",
      "endLine": "178",
      "endCol": "81"
    },
    "787": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "186",
      "startCol": "21",
      "endLine": "186",
      "endCol": "73"
    },
    "788": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "258",
      "startCol": "13",
      "endLine": "267",
      "endCol": "13"
    },
    "789": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "292",
      "startCol": "11",
      "endLine": "303",
      "endCol": "11"
    },
    "790": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "385",
      "startCol": "13",
      "endLine": "394",
      "endCol": "13"
    },
    "791": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "424",
      "startCol": "11",
      "endLine": "435",
      "endCol": "11"
    },
    "792": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "457",
      "startCol": "20",
      "endLine": "471",
      "endCol": "8"
    },
    "793": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "495",
      "startCol": "7",
      "endLine": "506",
      "endCol": "33"
    },
    "794": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "511",
      "startCol": "9",
      "endLine": "511",
      "endCol": "71"
    },
    "795": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "527",
      "startCol": "20",
      "endLine": "533",
      "endCol": "51"
    },
    "796": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "548",
      "startCol": "7",
      "endLine": "550",
      "endCol": "49"
    },
    "797": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "552",
      "startCol": "7",
      "endLine": "554",
      "endCol": "86"
    },
    "798": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "574",
      "startCol": "23",
      "endLine": "580",
      "endCol": "46"
    },
    "799": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "582",
      "startCol": "11",
      "endLine": "584",
      "endCol": "82"
    },
    "800": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "586",
      "startCol": "11",
      "endLine": "591",
      "endCol": "53"
    },
    "801": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "597",
      "startCol": "34",
      "endLine": "606",
      "endCol": "15"
    },
    "802": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "615",
      "startCol": "15",
      "endLine": "620",
      "endCol": "15"
    },
    "803": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "624",
      "startCol": "11",
      "endLine": "629",
      "endCol": "53"
    },
    "804": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "29",
      "startCol": "10",
      "endLine": "38",
      "endCol": "3"
    },
    "805": {
      "patternID": "pattern1",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "28",
      "startCol": "26",
      "endLine": "39",
      "endCol": "1"
    },
    "806": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "42",
      "startCol": "10",
      "endLine": "58",
      "endCol": "6"
    },
    "807": {
      "patternID": "pattern1",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "41",
      "startCol": "29",
      "endLine": "59",
      "endCol": "1"
    },
    "808": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "63",
      "startCol": "20",
      "endLine": "68",
      "endCol": "6"
    },
    "809": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "87",
      "startCol": "23",
      "endLine": "87",
      "endCol": "56"
    },
    "810": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "292",
      "startCol": "32",
      "endLine": "300",
      "endCol": "39"
    },
    "811": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "368",
      "startCol": "5",
      "endLine": "368",
      "endCol": "38"
    },
    "812": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "372",
      "startCol": "7",
      "endLine": "377",
      "endCol": "8"
    },
    "813": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "380",
      "startCol": "20",
      "endLine": "384",
      "endCol": "6"
    },
    "814": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/utils/connectivity.js",
      "startLine": "56",
      "startCol": "3",
      "endLine": "56",
      "endCol": "71"
    },
    "815": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/utils/store-definition.js",
      "startLine": "11",
      "startCol": "27",
      "endLine": "11",
      "endCol": "70"
    },
    "816": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/utils/store-definition.js",
      "startLine": "17",
      "startCol": "15",
      "endLine": "19",
      "endCol": "12"
    },
    "817": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/database-migration.js",
      "startLine": "31",
      "startCol": "5",
      "endLine": "42",
      "endCol": "13"
    },
    "818": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/database-migration.js",
      "startLine": "44",
      "startCol": "5",
      "endLine": "44",
      "endCol": "62"
    },
    "819": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/database-migration.js",
      "startLine": "45",
      "startCol": "5",
      "endLine": "45",
      "endCol": "95"
    },
    "820": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/index.js",
      "startLine": "113",
      "startCol": "9",
      "endLine": "113",
      "endCol": "64"
    },
    "821": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/index.js",
      "startLine": "121",
      "startCol": "29",
      "endLine": "121",
      "endCol": "77"
    },
    "822": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/index.js",
      "startLine": "202",
      "startCol": "5",
      "endLine": "213",
      "endCol": "5"
    },
    "823": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "64",
      "startCol": "14",
      "endLine": "64",
      "endCol": "30"
    },
    "824": {
      "patternID": "pattern1",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "62",
      "startCol": "28",
      "endLine": "68",
      "endCol": "3"
    },
    "825": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "93",
      "startCol": "30",
      "endLine": "97",
      "endCol": "11"
    },
    "826": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "105",
      "startCol": "11",
      "endLine": "105",
      "endCol": "39"
    },
    "827": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "109",
      "startCol": "34",
      "endLine": "109",
      "endCol": "98"
    },
    "828": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "116",
      "startCol": "11",
      "endLine": "116",
      "endCol": "39"
    },
    "829": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "133",
      "startCol": "30",
      "endLine": "146",
      "endCol": "9"
    },
    "830": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "158",
      "startCol": "9",
      "endLine": "158",
      "endCol": "37"
    },
    "831": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "201",
      "startCol": "30",
      "endLine": "203",
      "endCol": "11"
    },
    "832": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "210",
      "startCol": "11",
      "endLine": "210",
      "endCol": "39"
    },
    "833": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "231",
      "startCol": "11",
      "endLine": "231",
      "endCol": "39"
    },
    "834": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "243",
      "startCol": "30",
      "endLine": "253",
      "endCol": "9"
    },
    "835": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "265",
      "startCol": "9",
      "endLine": "265",
      "endCol": "37"
    },
    "836": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "325",
      "startCol": "7",
      "endLine": "331",
      "endCol": "7"
    },
    "837": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "368",
      "startCol": "7",
      "endLine": "370",
      "endCol": "73"
    },
    "838": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "387",
      "startCol": "11",
      "endLine": "389",
      "endCol": "77"
    },
    "839": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "410",
      "startCol": "11",
      "endLine": "419",
      "endCol": "11"
    },
    "840": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "438",
      "startCol": "21",
      "endLine": "438",
      "endCol": "79"
    },
    "841": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "465",
      "startCol": "21",
      "endLine": "465",
      "endCol": "59"
    },
    "842": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "480",
      "startCol": "19",
      "endLine": "480",
      "endCol": "62"
    },
    "843": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "495",
      "startCol": "5",
      "endLine": "495",
      "endCol": "44"
    },
    "844": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "503",
      "startCol": "23",
      "endLine": "503",
      "endCol": "77"
    },
    "845": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "510",
      "startCol": "21",
      "endLine": "510",
      "endCol": "57"
    },
    "846": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "515",
      "startCol": "19",
      "endLine": "517",
      "endCol": "34"
    },
    "847": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "527",
      "startCol": "5",
      "endLine": "527",
      "endCol": "51"
    },
    "848": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/relations.js",
      "startLine": "32",
      "startCol": "3",
      "endLine": "46",
      "endCol": "3"
    },
    "849": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/relations.js",
      "startLine": "70",
      "startCol": "3",
      "endLine": "82",
      "endCol": "3"
    },
    "850": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/relations.js",
      "startLine": "91",
      "startCol": "19",
      "endLine": "94",
      "endCol": "13"
    },
    "851": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/relations.js",
      "startLine": "373",
      "startCol": "5",
      "endLine": "378",
      "endCol": "5"
    },
    "852": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/relations.js",
      "startLine": "380",
      "startCol": "27",
      "endLine": "384",
      "endCol": "25"
    },
    "853": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/utils/store-definition.js",
      "startLine": "20",
      "startCol": "3",
      "endLine": "36",
      "endCol": "3"
    },
    "854": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/connector-registry.js",
      "startLine": "30",
      "startCol": "9",
      "endLine": "30",
      "endCol": "36"
    },
    "855": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/database-manager.js",
      "startLine": "36",
      "startCol": "5",
      "endLine": "36",
      "endCol": "38"
    },
    "856": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/database-manager.js",
      "startLine": "44",
      "startCol": "5",
      "endLine": "44",
      "endCol": "85"
    },
    "857": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/__tests__/create-query.test.js",
      "startLine": "24",
      "startCol": "9",
      "endLine": "24",
      "endCol": "35"
    },
    "858": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/__tests__/create-query.test.js",
      "startLine": "57",
      "startCol": "9",
      "endLine": "57",
      "endCol": "39"
    },
    "859": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/__tests__/paginated-queries.test.js",
      "startLine": "62",
      "startCol": "20",
      "endLine": "62",
      "endCol": "43"
    },
    "860": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/__tests__/paginated-queries.test.js",
      "startLine": "85",
      "startCol": "20",
      "endLine": "85",
      "endCol": "43"
    },
    "861": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/helpers.js",
      "startLine": "15",
      "startCol": "18",
      "endLine": "15",
      "endCol": "44"
    },
    "862": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/paginated-queries.js",
      "startLine": "11",
      "startCol": "19",
      "endLine": "11",
      "endCol": "46"
    },
    "863": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/paginated-queries.js",
      "startLine": "24",
      "startCol": "17",
      "endLine": "24",
      "endCol": "35"
    },
    "864": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/relations-counts-queries.js",
      "startLine": "9",
      "startCol": "21",
      "endLine": "9",
      "endCol": "71"
    },
    "865": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/relations-counts-queries.js",
      "startLine": "27",
      "startCol": "37",
      "endLine": "27",
      "endCol": "68"
    },
    "866": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/relations-counts-queries.js",
      "startLine": "30",
      "startCol": "22",
      "endLine": "35",
      "endCol": "5"
    },
    "867": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/utils/lifecycles.js",
      "startLine": "7",
      "startCol": "5",
      "endLine": "7",
      "endCol": "46"
    },
    "868": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "47",
      "startCol": "8",
      "endLine": "47",
      "endCol": "42"
    },
    "869": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "60",
      "startCol": "7",
      "endLine": "63",
      "endCol": "16"
    },
    "870": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "66",
      "startCol": "12",
      "endLine": "66",
      "endCol": "46"
    },
    "871": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "73",
      "startCol": "7",
      "endLine": "73",
      "endCol": "29"
    },
    "872": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "78",
      "startCol": "24",
      "endLine": "81",
      "endCol": "10"
    },
    "873": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "107",
      "startCol": "24",
      "endLine": "110",
      "endCol": "10"
    },
    "874": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "128",
      "startCol": "21",
      "endLine": "131",
      "endCol": "10"
    },
    "875": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "151",
      "startCol": "24",
      "endLine": "154",
      "endCol": "10"
    },
    "876": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "164",
      "startCol": "19",
      "endLine": "168",
      "endCol": "10"
    },
    "877": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "175",
      "startCol": "15",
      "endLine": "179",
      "endCol": "10"
    },
    "878": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "41",
      "startCol": "8",
      "endLine": "41",
      "endCol": "42"
    },
    "879": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "46",
      "startCol": "5",
      "endLine": "49",
      "endCol": "14"
    },
    "880": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "52",
      "startCol": "10",
      "endLine": "52",
      "endCol": "44"
    },
    "881": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "59",
      "startCol": "5",
      "endLine": "59",
      "endCol": "27"
    },
    "882": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "64",
      "startCol": "22",
      "endLine": "67",
      "endCol": "8"
    },
    "883": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "76",
      "startCol": "24",
      "endLine": "80",
      "endCol": "8"
    },
    "884": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "91",
      "startCol": "19",
      "endLine": "95",
      "endCol": "8"
    },
    "885": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "110",
      "startCol": "19",
      "endLine": "114",
      "endCol": "8"
    },
    "886": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "41",
      "startCol": "8",
      "endLine": "41",
      "endCol": "42"
    },
    "887": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "46",
      "startCol": "5",
      "endLine": "49",
      "endCol": "14"
    },
    "888": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "52",
      "startCol": "10",
      "endLine": "52",
      "endCol": "44"
    },
    "889": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "59",
      "startCol": "5",
      "endLine": "59",
      "endCol": "27"
    },
    "890": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "64",
      "startCol": "22",
      "endLine": "67",
      "endCol": "8"
    },
    "891": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "74",
      "startCol": "24",
      "endLine": "78",
      "endCol": "8"
    },
    "892": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "89",
      "startCol": "19",
      "endLine": "93",
      "endCol": "8"
    },
    "893": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "108",
      "startCol": "19",
      "endLine": "112",
      "endCol": "8"
    },
    "894": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-cli-db-project.js",
      "startLine": "12",
      "startCol": "3",
      "endLine": "12",
      "endCol": "63"
    },
    "895": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "17",
      "startCol": "3",
      "endLine": "17",
      "endCol": "63"
    },
    "896": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "19",
      "startCol": "25",
      "endLine": "25",
      "endCol": "4"
    },
    "897": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "29",
      "startCol": "3",
      "endLine": "29",
      "endCol": "58"
    },
    "898": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "133",
      "startCol": "22",
      "endLine": "141",
      "endCol": "4"
    },
    "899": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "143",
      "startCol": "21",
      "endLine": "145",
      "endCol": "3"
    },
    "900": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "174",
      "startCol": "5",
      "endLine": "174",
      "endCol": "38"
    },
    "901": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "181",
      "startCol": "3",
      "endLine": "181",
      "endCol": "47"
    },
    "902": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "26",
      "startCol": "5",
      "endLine": "26",
      "endCol": "54"
    },
    "903": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "29",
      "startCol": "22",
      "endLine": "29",
      "endCol": "68"
    },
    "904": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "34",
      "endCol": "5"
    },
    "905": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "36",
      "startCol": "5",
      "endLine": "36",
      "endCol": "61"
    },
    "906": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "39",
      "startCol": "5",
      "endLine": "51",
      "endCol": "5"
    },
    "907": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "53",
      "endCol": "61"
    },
    "908": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "56",
      "startCol": "5",
      "endLine": "56",
      "endCol": "55"
    },
    "909": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "59",
      "startCol": "5",
      "endLine": "65",
      "endCol": "5"
    },
    "910": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "68",
      "startCol": "5",
      "endLine": "68",
      "endCol": "81"
    },
    "911": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "69",
      "startCol": "5",
      "endLine": "69",
      "endCol": "67"
    },
    "912": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "81",
      "startCol": "5",
      "endLine": "81",
      "endCol": "36"
    },
    "913": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "85",
      "startCol": "3",
      "endLine": "85",
      "endCol": "70"
    },
    "914": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "104",
      "startCol": "7",
      "endLine": "104",
      "endCol": "18"
    },
    "915": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "110",
      "startCol": "5",
      "endLine": "110",
      "endCol": "71"
    },
    "916": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "113",
      "startCol": "5",
      "endLine": "117",
      "endCol": "6"
    },
    "917": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "144",
      "startCol": "3",
      "endLine": "144",
      "endCol": "56"
    },
    "918": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "12",
      "startCol": "3",
      "endLine": "12",
      "endCol": "59"
    },
    "919": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "27",
      "startCol": "5",
      "endLine": "27",
      "endCol": "56"
    },
    "920": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "29",
      "startCol": "5",
      "endLine": "35",
      "endCol": "6"
    },
    "921": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "37",
      "startCol": "5",
      "endLine": "37",
      "endCol": "55"
    },
    "922": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "39",
      "startCol": "5",
      "endLine": "43",
      "endCol": "6"
    },
    "923": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "52",
      "startCol": "5",
      "endLine": "52",
      "endCol": "57"
    },
    "924": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "54",
      "startCol": "5",
      "endLine": "60",
      "endCol": "6"
    },
    "925": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "62",
      "startCol": "5",
      "endLine": "66",
      "endCol": "6"
    },
    "926": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/generate-new.js",
      "startLine": "22",
      "startCol": "7",
      "endLine": "22",
      "endCol": "38"
    },
    "927": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/generate-new.js",
      "startLine": "23",
      "startCol": "18",
      "endLine": "23",
      "endCol": "47"
    },
    "928": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/generate-new.js",
      "startLine": "33",
      "startCol": "19",
      "endLine": "33",
      "endCol": "51"
    },
    "929": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/generate-new.js",
      "startLine": "43",
      "startCol": "3",
      "endLine": "43",
      "endCol": "57"
    },
    "930": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/generate-new.js",
      "startLine": "66",
      "startCol": "18",
      "endLine": "82",
      "endCol": "4"
    },
    "931": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "40",
      "startCol": "24",
      "endLine": "40",
      "endCol": "75"
    },
    "932": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "58",
      "startCol": "3",
      "endLine": "58",
      "endCol": "32"
    },
    "933": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "72",
      "startCol": "22",
      "endLine": "72",
      "endCol": "53"
    },
    "934": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "81",
      "startCol": "26",
      "endLine": "81",
      "endCol": "61"
    },
    "935": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "107",
      "startCol": "18",
      "endLine": "107",
      "endCol": "48"
    },
    "936": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "199",
      "startCol": "20",
      "endLine": "199",
      "endCol": "40"
    },
    "937": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "232",
      "startCol": "3",
      "endLine": "232",
      "endCol": "67"
    },
    "938": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "238",
      "startCol": "3",
      "endLine": "238",
      "endCol": "77"
    },
    "939": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/usage.js",
      "startLine": "10",
      "startCol": "5",
      "endLine": "10",
      "endCol": "24"
    },
    "940": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/usage.js",
      "startLine": "20",
      "startCol": "5",
      "endLine": "20",
      "endCol": "24"
    },
    "941": {
      "patternID": "pattern3",
      "file": "packages/strapi-helper-plugin/lib/src/hooks/useUserPermissions/index.js",
      "startLine": "51",
      "startCol": "25",
      "endLine": "51",
      "endCol": "58"
    },
    "942": {
      "patternID": "pattern3",
      "file": "packages/strapi-helper-plugin/lib/src/utils/hasPermissions.js",
      "startLine": "41",
      "startCol": "24",
      "endLine": "47",
      "endCol": "8"
    },
    "943": {
      "patternID": "pattern3",
      "file": "packages/strapi-hook-redis/lib/index.js",
      "startLine": "100",
      "startCol": "20",
      "endLine": "100",
      "endCol": "29"
    },
    "944": {
      "patternID": "pattern1",
      "file": "packages/strapi-hook-redis/lib/index.js",
      "startLine": "86",
      "startCol": "23",
      "endLine": "135",
      "endCol": "9"
    },
    "945": {
      "patternID": "pattern3",
      "file": "packages/strapi-hook-redis/lib/index.js",
      "startLine": "103",
      "startCol": "23",
      "endLine": "103",
      "endCol": "45"
    },
    "946": {
      "patternID": "pattern3",
      "file": "packages/strapi-hook-redis/lib/index.js",
      "startLine": "106",
      "startCol": "21",
      "endLine": "106",
      "endCol": "30"
    },
    "947": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/components/DraggedFieldWithPreview/DynamicComponent.js",
      "startLine": "19",
      "startCol": "27",
      "endLine": "22",
      "endCol": "9"
    },
    "948": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/components/InputUID/index.js",
      "startLine": "72",
      "startCol": "24",
      "endLine": "79",
      "endCol": "8"
    },
    "949": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/components/InputUID/index.js",
      "startLine": "99",
      "startCol": "20",
      "endLine": "106",
      "endCol": "8"
    },
    "950": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/components/RelationPreviewList/RelationPreviewTooltip.js",
      "startLine": "25",
      "startCol": "29",
      "endLine": "28",
      "endCol": "10"
    },
    "951": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/components/SelectWrapper/index.js",
      "startLine": "108",
      "startCol": "22",
      "endLine": "113",
      "endCol": "10"
    },
    "952": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/components/SettingsViewWrapper/index.js",
      "startLine": "214",
      "startCol": "15",
      "endLine": "214",
      "endCol": "37"
    },
    "953": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js",
      "startLine": "109",
      "startCol": "22",
      "endLine": "109",
      "endCol": "73"
    },
    "954": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js",
      "startLine": "171",
      "startCol": "26",
      "endLine": "173",
      "endCol": "10"
    },
    "955": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js",
      "startLine": "201",
      "startCol": "26",
      "endLine": "201",
      "endCol": "74"
    },
    "956": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js",
      "startLine": "230",
      "startCol": "20",
      "endLine": "230",
      "endCol": "62"
    },
    "957": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js",
      "startLine": "256",
      "startCol": "26",
      "endLine": "256",
      "endCol": "73"
    },
    "958": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js",
      "startLine": "283",
      "startCol": "24",
      "endLine": "283",
      "endCol": "66"
    },
    "959": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/ComponentSetttingsView/index.js",
      "startLine": "25",
      "startCol": "26",
      "endLine": "28",
      "endCol": "10"
    },
    "960": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/EditSettingsView/index.js",
      "startLine": "124",
      "startCol": "24",
      "endLine": "124",
      "endCol": "73"
    },
    "961": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/EditView/DeleteLink/index.js",
      "startLine": "27",
      "startCol": "7",
      "endLine": "27",
      "endCol": "37"
    },
    "962": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/EditViewDataManagerProvider/index.js",
      "startLine": "190",
      "startCol": "9",
      "endLine": "190",
      "endCol": "68"
    },
    "963": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/EditViewDataManagerProvider/index.js",
      "startLine": "285",
      "startCol": "9",
      "endLine": "285",
      "endCol": "69"
    },
    "964": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/EditViewDataManagerProvider/index.js",
      "startLine": "322",
      "startCol": "7",
      "endLine": "322",
      "endCol": "64"
    },
    "965": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/ListSettingsView/index.js",
      "startLine": "94",
      "startCol": "24",
      "endLine": "97",
      "endCol": "8"
    },
    "966": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/ListView/index.js",
      "startLine": "160",
      "startCol": "41",
      "endLine": "160",
      "endCol": "90"
    },
    "967": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/ListView/index.js",
      "startLine": "195",
      "startCol": "7",
      "endLine": "198",
      "endCol": "8"
    },
    "968": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/ListView/index.js",
      "startLine": "222",
      "startCol": "7",
      "endLine": "224",
      "endCol": "8"
    },
    "969": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/Main/index.js",
      "startLine": "33",
      "startCol": "58",
      "endLine": "37",
      "endCol": "9"
    },
    "970": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js",
      "startLine": "84",
      "startCol": "22",
      "endLine": "84",
      "endCol": "82"
    },
    "971": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js",
      "startLine": "137",
      "startCol": "26",
      "endLine": "139",
      "endCol": "10"
    },
    "972": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js",
      "startLine": "168",
      "startCol": "26",
      "endLine": "168",
      "endCol": "73"
    },
    "973": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js",
      "startLine": "195",
      "startCol": "20",
      "endLine": "195",
      "endCol": "62"
    },
    "974": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js",
      "startLine": "220",
      "startCol": "26",
      "endLine": "220",
      "endCol": "73"
    },
    "975": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js",
      "startLine": "249",
      "startCol": "24",
      "endLine": "249",
      "endCol": "66"
    },
    "976": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/hooks/useFetchContentTypeLayout/index.js",
      "startLine": "26",
      "startCol": "26",
      "endLine": "29",
      "endCol": "10"
    },
    "977": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/config/functions/bootstrap.js",
      "startLine": "6",
      "startCol": "3",
      "endLine": "6",
      "endCol": "53"
    },
    "978": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/config/functions/bootstrap.js",
      "startLine": "7",
      "startCol": "3",
      "endLine": "7",
      "endCol": "56"
    },
    "979": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/config/functions/bootstrap.js",
      "startLine": "8",
      "startCol": "3",
      "endLine": "8",
      "endCol": "54"
    },
    "980": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/config/policies/routing.js",
      "startLine": "22",
      "startCol": "14",
      "endLine": "22",
      "endCol": "76"
    },
    "981": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-content-manager/config/policies/routing.js",
      "startLine": "5",
      "startCol": "18",
      "endLine": "27",
      "endCol": "1"
    },
    "982": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/config/policies/routing.js",
      "startLine": "26",
      "startCol": "3",
      "endLine": "26",
      "endCol": "14"
    },
    "983": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "31",
      "startCol": "37",
      "endLine": "31",
      "endCol": "87"
    },
    "984": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "50",
      "startCol": "20",
      "endLine": "50",
      "endCol": "73"
    },
    "985": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "81",
      "startCol": "5",
      "endLine": "86",
      "endCol": "8"
    },
    "986": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "82",
      "startCol": "22",
      "endLine": "82",
      "endCol": "72"
    },
    "987": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "85",
      "startCol": "7",
      "endLine": "85",
      "endCol": "78"
    },
    "988": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "101",
      "startCol": "20",
      "endLine": "101",
      "endCol": "73"
    },
    "989": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "117",
      "startCol": "5",
      "endLine": "121",
      "endCol": "8"
    },
    "990": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "118",
      "startCol": "29",
      "endLine": "118",
      "endCol": "87"
    },
    "991": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "135",
      "startCol": "20",
      "endLine": "135",
      "endCol": "73"
    },
    "992": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "145",
      "startCol": "20",
      "endLine": "145",
      "endCol": "60"
    },
    "993": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "161",
      "startCol": "20",
      "endLine": "161",
      "endCol": "73"
    },
    "994": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "171",
      "startCol": "20",
      "endLine": "171",
      "endCol": "61"
    },
    "995": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "187",
      "startCol": "20",
      "endLine": "187",
      "endCol": "73"
    },
    "996": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "197",
      "startCol": "20",
      "endLine": "197",
      "endCol": "63"
    },
    "997": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "208",
      "startCol": "5",
      "endLine": "208",
      "endCol": "39"
    },
    "998": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "225",
      "startCol": "21",
      "endLine": "225",
      "endCol": "68"
    },
    "999": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "252",
      "startCol": "20",
      "endLine": "252",
      "endCol": "73"
    },
    "1000": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "264",
      "startCol": "31",
      "endLine": "264",
      "endCol": "83"
    },
    "1001": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "266",
      "startCol": "22",
      "endLine": "269",
      "endCol": "7"
    },
    "1002": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "272",
      "startCol": "22",
      "endLine": "275",
      "endCol": "7"
    },
    "1003": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "278",
      "startCol": "20",
      "endLine": "278",
      "endCol": "77"
    },
    "1004": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/components.js",
      "startLine": "25",
      "startCol": "27",
      "endLine": "25",
      "endCol": "77"
    },
    "1005": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/components.js",
      "startLine": "26",
      "startCol": "38",
      "endLine": "26",
      "endCol": "99"
    },
    "1006": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/components.js",
      "startLine": "50",
      "startCol": "15",
      "endLine": "54",
      "endCol": "8"
    },
    "1007": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/components.js",
      "startLine": "62",
      "startCol": "30",
      "endLine": "62",
      "endCol": "89"
    },
    "1008": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "19",
      "startCol": "7",
      "endLine": "19",
      "endCol": "30"
    },
    "1009": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "35",
      "startCol": "25",
      "endLine": "35",
      "endCol": "69"
    },
    "1010": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "41",
      "startCol": "27",
      "endLine": "41",
      "endCol": "81"
    },
    "1011": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "48",
      "startCol": "24",
      "endLine": "48",
      "endCol": "89"
    },
    "1012": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "66",
      "startCol": "25",
      "endLine": "66",
      "endCol": "69"
    },
    "1013": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "78",
      "startCol": "15",
      "endLine": "82",
      "endCol": "8"
    },
    "1014": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "90",
      "startCol": "30",
      "endLine": "90",
      "endCol": "93"
    },
    "1015": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "92",
      "startCol": "5",
      "endLine": "92",
      "endCol": "80"
    },
    "1016": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/relations.js",
      "startLine": "45",
      "startCol": "18",
      "endLine": "45",
      "endCol": "62"
    },
    "1017": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/relations.js",
      "startLine": "47",
      "startCol": "18",
      "endLine": "47",
      "endCol": "60"
    },
    "1018": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/relations.js",
      "startLine": "55",
      "startCol": "9",
      "endLine": "55",
      "endCol": "66"
    },
    "1019": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/relations.js",
      "startLine": "56",
      "startCol": "9",
      "endLine": "56",
      "endCol": "69"
    },
    "1020": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "14",
      "startCol": "18",
      "endLine": "14",
      "endCol": "52"
    },
    "1021": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "73",
      "startCol": "5",
      "endLine": "88",
      "endCol": "8"
    },
    "1022": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "75",
      "startCol": "27",
      "endLine": "75",
      "endCol": "77"
    },
    "1023": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "78",
      "startCol": "9",
      "endLine": "78",
      "endCol": "80"
    },
    "1024": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "86",
      "startCol": "29",
      "endLine": "86",
      "endCol": "87"
    },
    "1025": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "112",
      "startCol": "27",
      "endLine": "112",
      "endCol": "67"
    },
    "1026": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "138",
      "startCol": "29",
      "endLine": "138",
      "endCol": "70"
    },
    "1027": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "164",
      "startCol": "31",
      "endLine": "164",
      "endCol": "74"
    },
    "1028": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "12",
      "startCol": "45",
      "endLine": "12",
      "endCol": "92"
    },
    "1029": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "14",
      "startCol": "5",
      "endLine": "14",
      "endCol": "49"
    },
    "1030": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "19",
      "startCol": "13",
      "endLine": "19",
      "endCol": "78"
    },
    "1031": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "24",
      "startCol": "46",
      "endLine": "26",
      "endCol": "5"
    },
    "1032": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "28",
      "startCol": "5",
      "endLine": "28",
      "endCol": "49"
    },
    "1033": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "32",
      "startCol": "25",
      "endLine": "32",
      "endCol": "95"
    },
    "1034": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "37",
      "startCol": "11",
      "endLine": "37",
      "endCol": "74"
    },
    "1035": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/__tests__/content-types.test.js",
      "startLine": "23",
      "startCol": "5",
      "endLine": "23",
      "endCol": "31"
    },
    "1036": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/__tests__/content-types.test.js",
      "startLine": "34",
      "startCol": "5",
      "endLine": "38",
      "endCol": "6"
    },
    "1037": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/__tests__/content-types.test.js",
      "startLine": "55",
      "startCol": "5",
      "endLine": "59",
      "endCol": "6"
    },
    "1038": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/__tests__/content-types.test.js",
      "startLine": "77",
      "startCol": "5",
      "endLine": "77",
      "endCol": "34"
    },
    "1039": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/__tests__/entity-manager.test.js",
      "startLine": "31",
      "startCol": "7",
      "endLine": "31",
      "endCol": "48"
    },
    "1040": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/__tests__/entity-manager.test.js",
      "startLine": "58",
      "startCol": "7",
      "endLine": "58",
      "endCol": "50"
    },
    "1041": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/components.js",
      "startLine": "40",
      "startCol": "27",
      "endLine": "40",
      "endCol": "84"
    },
    "1042": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/components.js",
      "startLine": "50",
      "startCol": "5",
      "endLine": "50",
      "endCol": "80"
    },
    "1043": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/configuration.js",
      "startLine": "42",
      "startCol": "28",
      "endLine": "44",
      "endCol": "5"
    },
    "1044": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/configuration.js",
      "startLine": "64",
      "startCol": "5",
      "endLine": "64",
      "endCol": "80"
    },
    "1045": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/configuration.js",
      "startLine": "67",
      "startCol": "5",
      "endLine": "67",
      "endCol": "82"
    },
    "1046": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/configuration.js",
      "startLine": "70",
      "startCol": "5",
      "endLine": "70",
      "endCol": "80"
    },
    "1047": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/content-types.js",
      "startLine": "50",
      "startCol": "27",
      "endLine": "50",
      "endCol": "86"
    },
    "1048": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/content-types.js",
      "startLine": "59",
      "startCol": "5",
      "endLine": "59",
      "endCol": "82"
    },
    "1049": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/entity-manager.js",
      "startLine": "14",
      "startCol": "18",
      "endLine": "14",
      "endCol": "40"
    },
    "1050": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/entity-manager.js",
      "startLine": "43",
      "startCol": "19",
      "endLine": "43",
      "endCol": "48"
    },
    "1051": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/entity-manager.js",
      "startLine": "122",
      "startCol": "5",
      "endLine": "122",
      "endCol": "87"
    },
    "1052": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/metrics.js",
      "startLine": "24",
      "startCol": "5",
      "endLine": "24",
      "endCol": "61"
    },
    "1053": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/uid.js",
      "startLine": "32",
      "startCol": "31",
      "endLine": "37",
      "endCol": "60"
    },
    "1054": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/uid.js",
      "startLine": "56",
      "startCol": "19",
      "endLine": "58",
      "endCol": "6"
    },
    "1055": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/utils/configuration/index.js",
      "startLine": "10",
      "startCol": "5",
      "endLine": "12",
      "endCol": "30"
    },
    "1056": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/utils/configuration/index.js",
      "startLine": "25",
      "startCol": "16",
      "endLine": "25",
      "endCol": "51"
    },
    "1057": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/utils/store.js",
      "startLine": "27",
      "startCol": "18",
      "endLine": "27",
      "endCol": "69"
    },
    "1058": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/utils/store.js",
      "startLine": "32",
      "startCol": "25",
      "endLine": "32",
      "endCol": "76"
    },
    "1059": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "54",
      "startCol": "5",
      "endLine": "57",
      "endCol": "14"
    },
    "1060": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "60",
      "startCol": "10",
      "endLine": "60",
      "endCol": "44"
    },
    "1061": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "65",
      "startCol": "5",
      "endLine": "65",
      "endCol": "27"
    },
    "1062": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "83",
      "endCol": "6"
    },
    "1063": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "92",
      "startCol": "17",
      "endLine": "95",
      "endCol": "6"
    },
    "1064": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "115",
      "startCol": "17",
      "endLine": "119",
      "endCol": "6"
    },
    "1065": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "129",
      "startCol": "17",
      "endLine": "132",
      "endCol": "6"
    },
    "1066": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "147",
      "startCol": "19",
      "endLine": "151",
      "endCol": "8"
    },
    "1067": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "168",
      "startCol": "19",
      "endLine": "172",
      "endCol": "8"
    },
    "1068": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "191",
      "startCol": "19",
      "endLine": "195",
      "endCol": "8"
    },
    "1069": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "213",
      "startCol": "19",
      "endLine": "217",
      "endCol": "8"
    },
    "1070": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "56",
      "endCol": "14"
    },
    "1071": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "59",
      "startCol": "10",
      "endLine": "59",
      "endCol": "44"
    },
    "1072": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "64",
      "startCol": "5",
      "endLine": "64",
      "endCol": "27"
    },
    "1073": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "76",
      "startCol": "17",
      "endLine": "80",
      "endCol": "6"
    },
    "1074": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "89",
      "startCol": "17",
      "endLine": "92",
      "endCol": "6"
    },
    "1075": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "110",
      "startCol": "17",
      "endLine": "114",
      "endCol": "6"
    },
    "1076": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "124",
      "startCol": "17",
      "endLine": "127",
      "endCol": "6"
    },
    "1077": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "142",
      "startCol": "19",
      "endLine": "146",
      "endCol": "8"
    },
    "1078": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "161",
      "startCol": "19",
      "endLine": "165",
      "endCol": "8"
    },
    "1079": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "182",
      "startCol": "19",
      "endLine": "186",
      "endCol": "8"
    },
    "1080": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "202",
      "startCol": "19",
      "endLine": "206",
      "endCol": "8"
    },
    "1081": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "57",
      "startCol": "5",
      "endLine": "60",
      "endCol": "14"
    },
    "1082": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "63",
      "startCol": "10",
      "endLine": "63",
      "endCol": "44"
    },
    "1083": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "68",
      "startCol": "5",
      "endLine": "68",
      "endCol": "27"
    },
    "1084": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "82",
      "startCol": "17",
      "endLine": "87",
      "endCol": "6"
    },
    "1085": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "96",
      "startCol": "17",
      "endLine": "100",
      "endCol": "6"
    },
    "1086": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "122",
      "startCol": "17",
      "endLine": "126",
      "endCol": "6"
    },
    "1087": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "136",
      "startCol": "17",
      "endLine": "139",
      "endCol": "6"
    },
    "1088": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "155",
      "startCol": "19",
      "endLine": "160",
      "endCol": "8"
    },
    "1089": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "178",
      "startCol": "19",
      "endLine": "183",
      "endCol": "8"
    },
    "1090": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "201",
      "startCol": "19",
      "endLine": "206",
      "endCol": "8"
    },
    "1091": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "224",
      "startCol": "19",
      "endLine": "229",
      "endCol": "8"
    },
    "1092": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "56",
      "startCol": "5",
      "endLine": "59",
      "endCol": "14"
    },
    "1093": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "62",
      "startCol": "10",
      "endLine": "62",
      "endCol": "44"
    },
    "1094": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "67",
      "startCol": "5",
      "endLine": "67",
      "endCol": "27"
    },
    "1095": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "84",
      "endCol": "6"
    },
    "1096": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "93",
      "startCol": "17",
      "endLine": "97",
      "endCol": "6"
    },
    "1097": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "117",
      "startCol": "17",
      "endLine": "121",
      "endCol": "6"
    },
    "1098": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "131",
      "startCol": "17",
      "endLine": "134",
      "endCol": "6"
    },
    "1099": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "150",
      "startCol": "19",
      "endLine": "155",
      "endCol": "8"
    },
    "1100": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "171",
      "startCol": "19",
      "endLine": "176",
      "endCol": "8"
    },
    "1101": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "192",
      "startCol": "19",
      "endLine": "197",
      "endCol": "8"
    },
    "1102": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "213",
      "startCol": "19",
      "endLine": "218",
      "endCol": "8"
    },
    "1103": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "56",
      "startCol": "5",
      "endLine": "59",
      "endCol": "14"
    },
    "1104": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "62",
      "startCol": "10",
      "endLine": "62",
      "endCol": "44"
    },
    "1105": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "67",
      "startCol": "5",
      "endLine": "67",
      "endCol": "27"
    },
    "1106": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "82",
      "startCol": "17",
      "endLine": "87",
      "endCol": "6"
    },
    "1107": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "96",
      "startCol": "17",
      "endLine": "100",
      "endCol": "6"
    },
    "1108": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "123",
      "startCol": "17",
      "endLine": "127",
      "endCol": "6"
    },
    "1109": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "137",
      "startCol": "17",
      "endLine": "140",
      "endCol": "6"
    },
    "1110": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "157",
      "startCol": "21",
      "endLine": "163",
      "endCol": "10"
    },
    "1111": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "182",
      "startCol": "21",
      "endLine": "188",
      "endCol": "10"
    },
    "1112": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "207",
      "startCol": "21",
      "endLine": "213",
      "endCol": "10"
    },
    "1113": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "232",
      "startCol": "21",
      "endLine": "238",
      "endCol": "10"
    },
    "1114": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "256",
      "startCol": "21",
      "endLine": "262",
      "endCol": "10"
    },
    "1115": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "52",
      "startCol": "5",
      "endLine": "55",
      "endCol": "14"
    },
    "1116": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "58",
      "startCol": "10",
      "endLine": "58",
      "endCol": "44"
    },
    "1117": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "63",
      "startCol": "5",
      "endLine": "63",
      "endCol": "27"
    },
    "1118": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "71",
      "startCol": "17",
      "endLine": "75",
      "endCol": "6"
    },
    "1119": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "89",
      "startCol": "17",
      "endLine": "93",
      "endCol": "6"
    },
    "1120": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "102",
      "startCol": "17",
      "endLine": "105",
      "endCol": "6"
    },
    "1121": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "128",
      "startCol": "17",
      "endLine": "132",
      "endCol": "6"
    },
    "1122": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "147",
      "startCol": "17",
      "endLine": "151",
      "endCol": "6"
    },
    "1123": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "163",
      "startCol": "20",
      "endLine": "166",
      "endCol": "6"
    },
    "1124": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "176",
      "startCol": "20",
      "endLine": "179",
      "endCol": "6"
    },
    "1125": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "188",
      "startCol": "20",
      "endLine": "191",
      "endCol": "6"
    },
    "1126": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "201",
      "startCol": "20",
      "endLine": "204",
      "endCol": "6"
    },
    "1127": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "211",
      "startCol": "17",
      "endLine": "214",
      "endCol": "6"
    },
    "1128": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "229",
      "startCol": "19",
      "endLine": "233",
      "endCol": "8"
    },
    "1129": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "244",
      "startCol": "19",
      "endLine": "248",
      "endCol": "8"
    },
    "1130": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "263",
      "startCol": "19",
      "endLine": "267",
      "endCol": "8"
    },
    "1131": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "56",
      "endCol": "14"
    },
    "1132": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "59",
      "startCol": "10",
      "endLine": "59",
      "endCol": "44"
    },
    "1133": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "64",
      "startCol": "5",
      "endLine": "64",
      "endCol": "27"
    },
    "1134": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "83",
      "endCol": "6"
    },
    "1135": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "92",
      "startCol": "17",
      "endLine": "95",
      "endCol": "6"
    },
    "1136": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "116",
      "startCol": "17",
      "endLine": "120",
      "endCol": "6"
    },
    "1137": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "130",
      "startCol": "17",
      "endLine": "133",
      "endCol": "6"
    },
    "1138": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "148",
      "startCol": "19",
      "endLine": "152",
      "endCol": "8"
    },
    "1139": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "170",
      "startCol": "19",
      "endLine": "174",
      "endCol": "8"
    },
    "1140": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "194",
      "startCol": "19",
      "endLine": "198",
      "endCol": "8"
    },
    "1141": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "217",
      "startCol": "19",
      "endLine": "221",
      "endCol": "8"
    },
    "1142": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "240",
      "startCol": "19",
      "endLine": "244",
      "endCol": "8"
    },
    "1143": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "115",
      "startCol": "5",
      "endLine": "119",
      "endCol": "14"
    },
    "1144": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "122",
      "startCol": "10",
      "endLine": "122",
      "endCol": "44"
    },
    "1145": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "130",
      "startCol": "5",
      "endLine": "130",
      "endCol": "27"
    },
    "1146": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "135",
      "startCol": "19",
      "endLine": "138",
      "endCol": "8"
    },
    "1147": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "149",
      "startCol": "19",
      "endLine": "152",
      "endCol": "8"
    },
    "1148": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "163",
      "startCol": "19",
      "endLine": "166",
      "endCol": "8"
    },
    "1149": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "177",
      "startCol": "19",
      "endLine": "180",
      "endCol": "8"
    },
    "1150": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "193",
      "startCol": "19",
      "endLine": "199",
      "endCol": "8"
    },
    "1151": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "209",
      "startCol": "19",
      "endLine": "215",
      "endCol": "8"
    },
    "1152": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "225",
      "startCol": "19",
      "endLine": "231",
      "endCol": "8"
    },
    "1153": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "241",
      "startCol": "19",
      "endLine": "247",
      "endCol": "8"
    },
    "1154": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "256",
      "startCol": "19",
      "endLine": "262",
      "endCol": "8"
    },
    "1155": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "272",
      "startCol": "19",
      "endLine": "278",
      "endCol": "8"
    },
    "1156": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "287",
      "startCol": "19",
      "endLine": "293",
      "endCol": "8"
    },
    "1157": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "304",
      "startCol": "17",
      "endLine": "310",
      "endCol": "8"
    },
    "1158": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "319",
      "startCol": "13",
      "endLine": "325",
      "endCol": "8"
    },
    "1159": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "336",
      "startCol": "17",
      "endLine": "342",
      "endCol": "8"
    },
    "1160": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "351",
      "startCol": "13",
      "endLine": "357",
      "endCol": "8"
    },
    "1161": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "368",
      "startCol": "17",
      "endLine": "374",
      "endCol": "8"
    },
    "1162": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "383",
      "startCol": "13",
      "endLine": "389",
      "endCol": "8"
    },
    "1163": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "35",
      "startCol": "5",
      "endLine": "35",
      "endCol": "49"
    },
    "1164": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "38",
      "startCol": "10",
      "endLine": "38",
      "endCol": "44"
    },
    "1165": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "43",
      "startCol": "5",
      "endLine": "43",
      "endCol": "27"
    },
    "1166": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "51",
      "startCol": "17",
      "endLine": "55",
      "endCol": "6"
    },
    "1167": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "64",
      "startCol": "17",
      "endLine": "67",
      "endCol": "6"
    },
    "1168": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "88",
      "startCol": "17",
      "endLine": "92",
      "endCol": "6"
    },
    "1169": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "102",
      "startCol": "17",
      "endLine": "105",
      "endCol": "6"
    },
    "1170": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "120",
      "startCol": "19",
      "endLine": "124",
      "endCol": "8"
    },
    "1171": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "136",
      "startCol": "19",
      "endLine": "140",
      "endCol": "8"
    },
    "1172": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "151",
      "startCol": "19",
      "endLine": "155",
      "endCol": "8"
    },
    "1173": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "108",
      "startCol": "5",
      "endLine": "113",
      "endCol": "14"
    },
    "1174": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "116",
      "startCol": "10",
      "endLine": "116",
      "endCol": "44"
    },
    "1175": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "123",
      "startCol": "5",
      "endLine": "123",
      "endCol": "27"
    },
    "1176": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "129",
      "startCol": "36",
      "endLine": "129",
      "endCol": "89"
    },
    "1177": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "137",
      "startCol": "36",
      "endLine": "137",
      "endCol": "97"
    },
    "1178": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "149",
      "startCol": "36",
      "endLine": "149",
      "endCol": "71"
    },
    "1179": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "161",
      "startCol": "36",
      "endLine": "161",
      "endCol": "89"
    },
    "1180": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "181",
      "startCol": "36",
      "endLine": "183",
      "endCol": "7"
    },
    "1181": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "41",
      "startCol": "5",
      "endLine": "44",
      "endCol": "14"
    },
    "1182": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "47",
      "startCol": "10",
      "endLine": "47",
      "endCol": "44"
    },
    "1183": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "53",
      "endCol": "27"
    },
    "1184": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "58",
      "startCol": "19",
      "endLine": "69",
      "endCol": "8"
    },
    "1185": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "86",
      "startCol": "21",
      "endLine": "90",
      "endCol": "10"
    },
    "1186": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "97",
      "startCol": "19",
      "endLine": "105",
      "endCol": "8"
    },
    "1187": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "111",
      "startCol": "19",
      "endLine": "115",
      "endCol": "8"
    },
    "1188": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "121",
      "startCol": "19",
      "endLine": "144",
      "endCol": "8"
    },
    "1189": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "150",
      "startCol": "19",
      "endLine": "152",
      "endCol": "8"
    },
    "1190": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "161",
      "startCol": "19",
      "endLine": "172",
      "endCol": "8"
    },
    "1191": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "174",
      "startCol": "22",
      "endLine": "174",
      "endCol": "52"
    },
    "1192": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "187",
      "startCol": "19",
      "endLine": "187",
      "endCol": "35"
    },
    "1193": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "231",
      "startCol": "21",
      "endLine": "242",
      "endCol": "10"
    },
    "1194": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "244",
      "startCol": "27",
      "endLine": "248",
      "endCol": "10"
    },
    "1195": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "253",
      "startCol": "24",
      "endLine": "253",
      "endCol": "54"
    },
    "1196": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "264",
      "startCol": "19",
      "endLine": "275",
      "endCol": "8"
    },
    "1197": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "284",
      "startCol": "25",
      "endLine": "295",
      "endCol": "8"
    },
    "1198": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "307",
      "startCol": "22",
      "endLine": "307",
      "endCol": "52"
    },
    "1199": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "321",
      "startCol": "19",
      "endLine": "332",
      "endCol": "8"
    },
    "1200": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "334",
      "startCol": "25",
      "endLine": "336",
      "endCol": "8"
    },
    "1201": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "344",
      "startCol": "22",
      "endLine": "344",
      "endCol": "52"
    },
    "1202": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "354",
      "startCol": "19",
      "endLine": "365",
      "endCol": "8"
    },
    "1203": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "367",
      "startCol": "25",
      "endLine": "375",
      "endCol": "8"
    },
    "1204": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "379",
      "startCol": "22",
      "endLine": "379",
      "endCol": "52"
    },
    "1205": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "386",
      "startCol": "19",
      "endLine": "397",
      "endCol": "8"
    },
    "1206": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "399",
      "startCol": "25",
      "endLine": "422",
      "endCol": "8"
    },
    "1207": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "426",
      "startCol": "22",
      "endLine": "426",
      "endCol": "52"
    },
    "1208": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "433",
      "startCol": "19",
      "endLine": "442",
      "endCol": "8"
    },
    "1209": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "444",
      "startCol": "25",
      "endLine": "455",
      "endCol": "8"
    },
    "1210": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "476",
      "startCol": "22",
      "endLine": "476",
      "endCol": "52"
    },
    "1211": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "493",
      "startCol": "19",
      "endLine": "504",
      "endCol": "8"
    },
    "1212": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "506",
      "startCol": "25",
      "endLine": "515",
      "endCol": "8"
    },
    "1213": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "521",
      "startCol": "19",
      "endLine": "535",
      "endCol": "8"
    },
    "1214": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "537",
      "startCol": "25",
      "endLine": "556",
      "endCol": "8"
    },
    "1215": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "582",
      "startCol": "22",
      "endLine": "582",
      "endCol": "52"
    },
    "1216": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "591",
      "startCol": "19",
      "endLine": "605",
      "endCol": "8"
    },
    "1217": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "607",
      "startCol": "25",
      "endLine": "607",
      "endCol": "58"
    },
    "1218": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "612",
      "startCol": "22",
      "endLine": "612",
      "endCol": "52"
    },
    "1219": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "39",
      "startCol": "5",
      "endLine": "42",
      "endCol": "14"
    },
    "1220": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "45",
      "startCol": "10",
      "endLine": "45",
      "endCol": "44"
    },
    "1221": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "51",
      "startCol": "5",
      "endLine": "51",
      "endCol": "27"
    },
    "1222": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "56",
      "startCol": "19",
      "endLine": "64",
      "endCol": "8"
    },
    "1223": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "81",
      "startCol": "21",
      "endLine": "85",
      "endCol": "10"
    },
    "1224": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "92",
      "startCol": "19",
      "endLine": "96",
      "endCol": "8"
    },
    "1225": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "103",
      "startCol": "19",
      "endLine": "105",
      "endCol": "8"
    },
    "1226": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "114",
      "startCol": "19",
      "endLine": "125",
      "endCol": "8"
    },
    "1227": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "127",
      "startCol": "22",
      "endLine": "127",
      "endCol": "52"
    },
    "1228": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "140",
      "startCol": "19",
      "endLine": "140",
      "endCol": "35"
    },
    "1229": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "184",
      "startCol": "21",
      "endLine": "192",
      "endCol": "10"
    },
    "1230": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "194",
      "startCol": "27",
      "endLine": "198",
      "endCol": "10"
    },
    "1231": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "203",
      "startCol": "24",
      "endLine": "203",
      "endCol": "54"
    },
    "1232": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "214",
      "startCol": "19",
      "endLine": "225",
      "endCol": "8"
    },
    "1233": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "234",
      "startCol": "25",
      "endLine": "245",
      "endCol": "8"
    },
    "1234": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "257",
      "startCol": "22",
      "endLine": "257",
      "endCol": "52"
    },
    "1235": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "271",
      "startCol": "19",
      "endLine": "282",
      "endCol": "8"
    },
    "1236": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "284",
      "startCol": "25",
      "endLine": "286",
      "endCol": "8"
    },
    "1237": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "294",
      "startCol": "22",
      "endLine": "294",
      "endCol": "52"
    },
    "1238": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "304",
      "startCol": "19",
      "endLine": "312",
      "endCol": "8"
    },
    "1239": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "314",
      "startCol": "25",
      "endLine": "318",
      "endCol": "8"
    },
    "1240": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "328",
      "startCol": "22",
      "endLine": "328",
      "endCol": "52"
    },
    "1241": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "335",
      "startCol": "19",
      "endLine": "343",
      "endCol": "8"
    },
    "1242": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "345",
      "startCol": "25",
      "endLine": "353",
      "endCol": "8"
    },
    "1243": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "371",
      "startCol": "22",
      "endLine": "371",
      "endCol": "52"
    },
    "1244": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "385",
      "startCol": "19",
      "endLine": "393",
      "endCol": "8"
    },
    "1245": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "395",
      "startCol": "25",
      "endLine": "404",
      "endCol": "8"
    },
    "1246": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "410",
      "startCol": "19",
      "endLine": "424",
      "endCol": "8"
    },
    "1247": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "426",
      "startCol": "25",
      "endLine": "445",
      "endCol": "8"
    },
    "1248": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "470",
      "startCol": "22",
      "endLine": "470",
      "endCol": "52"
    },
    "1249": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "479",
      "startCol": "19",
      "endLine": "493",
      "endCol": "8"
    },
    "1250": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "495",
      "startCol": "25",
      "endLine": "495",
      "endCol": "58"
    },
    "1251": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "500",
      "startCol": "22",
      "endLine": "500",
      "endCol": "52"
    },
    "1252": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "41",
      "startCol": "5",
      "endLine": "44",
      "endCol": "14"
    },
    "1253": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "47",
      "startCol": "10",
      "endLine": "47",
      "endCol": "44"
    },
    "1254": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "53",
      "endCol": "27"
    },
    "1255": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "58",
      "startCol": "19",
      "endLine": "66",
      "endCol": "8"
    },
    "1256": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "81",
      "startCol": "19",
      "endLine": "89",
      "endCol": "8"
    },
    "1257": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "106",
      "startCol": "21",
      "endLine": "110",
      "endCol": "10"
    },
    "1258": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "117",
      "startCol": "19",
      "endLine": "121",
      "endCol": "8"
    },
    "1259": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "127",
      "startCol": "19",
      "endLine": "150",
      "endCol": "8"
    },
    "1260": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "158",
      "startCol": "19",
      "endLine": "169",
      "endCol": "8"
    },
    "1261": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "171",
      "startCol": "22",
      "endLine": "171",
      "endCol": "52"
    },
    "1262": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "184",
      "startCol": "19",
      "endLine": "184",
      "endCol": "35"
    },
    "1263": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "228",
      "startCol": "21",
      "endLine": "236",
      "endCol": "10"
    },
    "1264": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "238",
      "startCol": "27",
      "endLine": "242",
      "endCol": "10"
    },
    "1265": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "247",
      "startCol": "24",
      "endLine": "247",
      "endCol": "54"
    },
    "1266": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "258",
      "startCol": "19",
      "endLine": "269",
      "endCol": "8"
    },
    "1267": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "278",
      "startCol": "25",
      "endLine": "289",
      "endCol": "8"
    },
    "1268": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "301",
      "startCol": "22",
      "endLine": "301",
      "endCol": "52"
    },
    "1269": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "315",
      "startCol": "19",
      "endLine": "326",
      "endCol": "8"
    },
    "1270": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "328",
      "startCol": "25",
      "endLine": "330",
      "endCol": "8"
    },
    "1271": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "338",
      "startCol": "22",
      "endLine": "338",
      "endCol": "52"
    },
    "1272": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "348",
      "startCol": "19",
      "endLine": "356",
      "endCol": "8"
    },
    "1273": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "358",
      "startCol": "25",
      "endLine": "362",
      "endCol": "8"
    },
    "1274": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "366",
      "startCol": "22",
      "endLine": "366",
      "endCol": "52"
    },
    "1275": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "373",
      "startCol": "19",
      "endLine": "381",
      "endCol": "8"
    },
    "1276": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "383",
      "startCol": "25",
      "endLine": "406",
      "endCol": "8"
    },
    "1277": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "410",
      "startCol": "22",
      "endLine": "410",
      "endCol": "52"
    },
    "1278": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "417",
      "startCol": "19",
      "endLine": "425",
      "endCol": "8"
    },
    "1279": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "427",
      "startCol": "25",
      "endLine": "435",
      "endCol": "8"
    },
    "1280": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "453",
      "startCol": "22",
      "endLine": "453",
      "endCol": "52"
    },
    "1281": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "467",
      "startCol": "19",
      "endLine": "475",
      "endCol": "8"
    },
    "1282": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "477",
      "startCol": "25",
      "endLine": "486",
      "endCol": "8"
    },
    "1283": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "492",
      "startCol": "19",
      "endLine": "506",
      "endCol": "8"
    },
    "1284": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "508",
      "startCol": "25",
      "endLine": "527",
      "endCol": "8"
    },
    "1285": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "552",
      "startCol": "22",
      "endLine": "552",
      "endCol": "52"
    },
    "1286": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "561",
      "startCol": "19",
      "endLine": "575",
      "endCol": "8"
    },
    "1287": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "577",
      "startCol": "25",
      "endLine": "577",
      "endCol": "58"
    },
    "1288": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "582",
      "startCol": "22",
      "endLine": "582",
      "endCol": "52"
    },
    "1289": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "39",
      "startCol": "5",
      "endLine": "42",
      "endCol": "14"
    },
    "1290": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "45",
      "startCol": "10",
      "endLine": "45",
      "endCol": "44"
    },
    "1291": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "51",
      "startCol": "5",
      "endLine": "51",
      "endCol": "27"
    },
    "1292": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "56",
      "startCol": "19",
      "endLine": "64",
      "endCol": "8"
    },
    "1293": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "79",
      "startCol": "19",
      "endLine": "87",
      "endCol": "8"
    },
    "1294": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "104",
      "startCol": "21",
      "endLine": "108",
      "endCol": "10"
    },
    "1295": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "115",
      "startCol": "19",
      "endLine": "119",
      "endCol": "8"
    },
    "1296": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "126",
      "startCol": "19",
      "endLine": "128",
      "endCol": "8"
    },
    "1297": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "136",
      "startCol": "19",
      "endLine": "147",
      "endCol": "8"
    },
    "1298": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "149",
      "startCol": "22",
      "endLine": "149",
      "endCol": "52"
    },
    "1299": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "162",
      "startCol": "19",
      "endLine": "162",
      "endCol": "35"
    },
    "1300": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "206",
      "startCol": "21",
      "endLine": "214",
      "endCol": "10"
    },
    "1301": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "216",
      "startCol": "27",
      "endLine": "220",
      "endCol": "10"
    },
    "1302": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "225",
      "startCol": "24",
      "endLine": "225",
      "endCol": "54"
    },
    "1303": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "236",
      "startCol": "19",
      "endLine": "247",
      "endCol": "8"
    },
    "1304": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "256",
      "startCol": "25",
      "endLine": "267",
      "endCol": "8"
    },
    "1305": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "279",
      "startCol": "22",
      "endLine": "279",
      "endCol": "52"
    },
    "1306": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "293",
      "startCol": "19",
      "endLine": "304",
      "endCol": "8"
    },
    "1307": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "306",
      "startCol": "25",
      "endLine": "308",
      "endCol": "8"
    },
    "1308": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "316",
      "startCol": "22",
      "endLine": "316",
      "endCol": "52"
    },
    "1309": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "326",
      "startCol": "19",
      "endLine": "334",
      "endCol": "8"
    },
    "1310": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "336",
      "startCol": "25",
      "endLine": "340",
      "endCol": "8"
    },
    "1311": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "350",
      "startCol": "22",
      "endLine": "350",
      "endCol": "52"
    },
    "1312": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "357",
      "startCol": "19",
      "endLine": "365",
      "endCol": "8"
    },
    "1313": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "367",
      "startCol": "25",
      "endLine": "375",
      "endCol": "8"
    },
    "1314": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "393",
      "startCol": "22",
      "endLine": "393",
      "endCol": "52"
    },
    "1315": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "407",
      "startCol": "19",
      "endLine": "415",
      "endCol": "8"
    },
    "1316": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "417",
      "startCol": "25",
      "endLine": "426",
      "endCol": "8"
    },
    "1317": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "432",
      "startCol": "19",
      "endLine": "446",
      "endCol": "8"
    },
    "1318": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "448",
      "startCol": "25",
      "endLine": "467",
      "endCol": "8"
    },
    "1319": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "492",
      "startCol": "22",
      "endLine": "492",
      "endCol": "52"
    },
    "1320": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "501",
      "startCol": "19",
      "endLine": "515",
      "endCol": "8"
    },
    "1321": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "517",
      "startCol": "25",
      "endLine": "517",
      "endCol": "58"
    },
    "1322": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "522",
      "startCol": "22",
      "endLine": "522",
      "endCol": "52"
    },
    "1323": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "39",
      "startCol": "5",
      "endLine": "42",
      "endCol": "14"
    },
    "1324": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "45",
      "startCol": "10",
      "endLine": "45",
      "endCol": "44"
    },
    "1325": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "51",
      "startCol": "5",
      "endLine": "51",
      "endCol": "27"
    },
    "1326": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "56",
      "startCol": "19",
      "endLine": "62",
      "endCol": "8"
    },
    "1327": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "74",
      "startCol": "19",
      "endLine": "80",
      "endCol": "8"
    },
    "1328": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "94",
      "startCol": "21",
      "endLine": "98",
      "endCol": "10"
    },
    "1329": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "105",
      "startCol": "19",
      "endLine": "109",
      "endCol": "8"
    },
    "1330": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "116",
      "startCol": "19",
      "endLine": "118",
      "endCol": "8"
    },
    "1331": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "127",
      "startCol": "19",
      "endLine": "127",
      "endCol": "35"
    },
    "1332": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "159",
      "startCol": "21",
      "endLine": "165",
      "endCol": "10"
    },
    "1333": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "167",
      "startCol": "27",
      "endLine": "171",
      "endCol": "10"
    },
    "1334": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "176",
      "startCol": "24",
      "endLine": "176",
      "endCol": "54"
    },
    "1335": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "187",
      "startCol": "19",
      "endLine": "193",
      "endCol": "8"
    },
    "1336": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "195",
      "startCol": "25",
      "endLine": "197",
      "endCol": "8"
    },
    "1337": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "205",
      "startCol": "22",
      "endLine": "205",
      "endCol": "52"
    },
    "1338": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "215",
      "startCol": "19",
      "endLine": "221",
      "endCol": "8"
    },
    "1339": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "223",
      "startCol": "25",
      "endLine": "227",
      "endCol": "8"
    },
    "1340": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "237",
      "startCol": "22",
      "endLine": "237",
      "endCol": "52"
    },
    "1341": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "244",
      "startCol": "19",
      "endLine": "250",
      "endCol": "8"
    },
    "1342": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "252",
      "startCol": "25",
      "endLine": "258",
      "endCol": "8"
    },
    "1343": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "269",
      "startCol": "22",
      "endLine": "269",
      "endCol": "52"
    },
    "1344": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "281",
      "startCol": "19",
      "endLine": "287",
      "endCol": "8"
    },
    "1345": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "289",
      "startCol": "25",
      "endLine": "296",
      "endCol": "8"
    },
    "1346": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "302",
      "startCol": "19",
      "endLine": "308",
      "endCol": "8"
    },
    "1347": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "310",
      "startCol": "25",
      "endLine": "317",
      "endCol": "8"
    },
    "1348": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "330",
      "startCol": "22",
      "endLine": "330",
      "endCol": "52"
    },
    "1349": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "339",
      "startCol": "19",
      "endLine": "345",
      "endCol": "8"
    },
    "1350": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "347",
      "startCol": "25",
      "endLine": "347",
      "endCol": "58"
    },
    "1351": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "352",
      "startCol": "22",
      "endLine": "352",
      "endCol": "52"
    },
    "1352": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "39",
      "startCol": "5",
      "endLine": "42",
      "endCol": "14"
    },
    "1353": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "45",
      "startCol": "10",
      "endLine": "45",
      "endCol": "44"
    },
    "1354": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "51",
      "startCol": "5",
      "endLine": "51",
      "endCol": "27"
    },
    "1355": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "56",
      "startCol": "19",
      "endLine": "62",
      "endCol": "8"
    },
    "1356": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "74",
      "startCol": "19",
      "endLine": "80",
      "endCol": "8"
    },
    "1357": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "94",
      "startCol": "21",
      "endLine": "98",
      "endCol": "10"
    },
    "1358": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "105",
      "startCol": "19",
      "endLine": "109",
      "endCol": "8"
    },
    "1359": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "115",
      "startCol": "19",
      "endLine": "117",
      "endCol": "8"
    },
    "1360": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "125",
      "startCol": "19",
      "endLine": "125",
      "endCol": "35"
    },
    "1361": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "158",
      "startCol": "21",
      "endLine": "164",
      "endCol": "10"
    },
    "1362": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "166",
      "startCol": "27",
      "endLine": "170",
      "endCol": "10"
    },
    "1363": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "175",
      "startCol": "24",
      "endLine": "175",
      "endCol": "54"
    },
    "1364": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "186",
      "startCol": "19",
      "endLine": "192",
      "endCol": "8"
    },
    "1365": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "194",
      "startCol": "25",
      "endLine": "196",
      "endCol": "8"
    },
    "1366": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "204",
      "startCol": "22",
      "endLine": "204",
      "endCol": "52"
    },
    "1367": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "214",
      "startCol": "19",
      "endLine": "220",
      "endCol": "8"
    },
    "1368": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "222",
      "startCol": "25",
      "endLine": "226",
      "endCol": "8"
    },
    "1369": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "230",
      "startCol": "22",
      "endLine": "230",
      "endCol": "52"
    },
    "1370": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "237",
      "startCol": "19",
      "endLine": "243",
      "endCol": "8"
    },
    "1371": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "245",
      "startCol": "25",
      "endLine": "251",
      "endCol": "8"
    },
    "1372": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "262",
      "startCol": "22",
      "endLine": "262",
      "endCol": "52"
    },
    "1373": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "274",
      "startCol": "19",
      "endLine": "280",
      "endCol": "8"
    },
    "1374": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "282",
      "startCol": "25",
      "endLine": "289",
      "endCol": "8"
    },
    "1375": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "295",
      "startCol": "19",
      "endLine": "301",
      "endCol": "8"
    },
    "1376": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "303",
      "startCol": "25",
      "endLine": "310",
      "endCol": "8"
    },
    "1377": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "323",
      "startCol": "22",
      "endLine": "323",
      "endCol": "52"
    },
    "1378": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "332",
      "startCol": "19",
      "endLine": "338",
      "endCol": "8"
    },
    "1379": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "340",
      "startCol": "25",
      "endLine": "340",
      "endCol": "58"
    },
    "1380": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "345",
      "startCol": "22",
      "endLine": "345",
      "endCol": "52"
    },
    "1381": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "32",
      "startCol": "5",
      "endLine": "32",
      "endCol": "47"
    },
    "1382": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "35",
      "startCol": "10",
      "endLine": "35",
      "endCol": "44"
    },
    "1383": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "40",
      "startCol": "5",
      "endLine": "40",
      "endCol": "27"
    },
    "1384": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "45",
      "startCol": "19",
      "endLine": "49",
      "endCol": "8"
    },
    "1385": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "65",
      "startCol": "19",
      "endLine": "73",
      "endCol": "8"
    },
    "1386": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "85",
      "startCol": "19",
      "endLine": "93",
      "endCol": "8"
    },
    "1387": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "107",
      "startCol": "19",
      "endLine": "115",
      "endCol": "8"
    },
    "1388": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "120",
      "startCol": "7",
      "endLine": "126",
      "endCol": "8"
    },
    "1389": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "128",
      "startCol": "25",
      "endLine": "136",
      "endCol": "8"
    },
    "1390": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "143",
      "startCol": "19",
      "endLine": "153",
      "endCol": "8"
    },
    "1391": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "158",
      "startCol": "7",
      "endLine": "164",
      "endCol": "8"
    },
    "1392": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "166",
      "startCol": "25",
      "endLine": "176",
      "endCol": "8"
    },
    "1393": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "183",
      "startCol": "19",
      "endLine": "193",
      "endCol": "8"
    },
    "1394": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "198",
      "startCol": "7",
      "endLine": "204",
      "endCol": "8"
    },
    "1395": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "206",
      "startCol": "25",
      "endLine": "216",
      "endCol": "8"
    },
    "1396": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "221",
      "startCol": "7",
      "endLine": "227",
      "endCol": "8"
    },
    "1397": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "229",
      "startCol": "24",
      "endLine": "239",
      "endCol": "8"
    },
    "1398": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "248",
      "startCol": "19",
      "endLine": "252",
      "endCol": "8"
    },
    "1399": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "268",
      "startCol": "19",
      "endLine": "276",
      "endCol": "8"
    },
    "1400": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "287",
      "startCol": "19",
      "endLine": "295",
      "endCol": "8"
    },
    "1401": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "307",
      "startCol": "19",
      "endLine": "315",
      "endCol": "8"
    },
    "1402": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "329",
      "startCol": "19",
      "endLine": "337",
      "endCol": "8"
    },
    "1403": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "348",
      "startCol": "7",
      "endLine": "354",
      "endCol": "8"
    },
    "1404": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "356",
      "startCol": "19",
      "endLine": "364",
      "endCol": "8"
    },
    "1405": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "86",
      "startCol": "5",
      "endLine": "90",
      "endCol": "14"
    },
    "1406": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "93",
      "startCol": "10",
      "endLine": "93",
      "endCol": "44"
    },
    "1407": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "99",
      "startCol": "5",
      "endLine": "99",
      "endCol": "27"
    },
    "1408": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "104",
      "startCol": "19",
      "endLine": "121",
      "endCol": "8"
    },
    "1409": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "145",
      "startCol": "19",
      "endLine": "151",
      "endCol": "8"
    },
    "1410": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "159",
      "startCol": "19",
      "endLine": "170",
      "endCol": "8"
    },
    "1411": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "176",
      "startCol": "19",
      "endLine": "185",
      "endCol": "8"
    },
    "1412": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "193",
      "startCol": "25",
      "endLine": "193",
      "endCol": "43"
    },
    "1413": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "196",
      "startCol": "19",
      "endLine": "196",
      "endCol": "65"
    },
    "1414": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "222",
      "startCol": "19",
      "endLine": "222",
      "endCol": "55"
    },
    "1415": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "262",
      "startCol": "25",
      "endLine": "262",
      "endCol": "43"
    },
    "1416": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "267",
      "startCol": "19",
      "endLine": "273",
      "endCol": "8"
    },
    "1417": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "281",
      "startCol": "25",
      "endLine": "281",
      "endCol": "43"
    },
    "1418": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "286",
      "startCol": "19",
      "endLine": "290",
      "endCol": "8"
    },
    "1419": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "314",
      "startCol": "25",
      "endLine": "314",
      "endCol": "43"
    },
    "1420": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "319",
      "startCol": "19",
      "endLine": "334",
      "endCol": "8"
    },
    "1421": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "355",
      "startCol": "25",
      "endLine": "355",
      "endCol": "43"
    },
    "1422": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "360",
      "startCol": "19",
      "endLine": "371",
      "endCol": "8"
    },
    "1423": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "377",
      "startCol": "25",
      "endLine": "377",
      "endCol": "43"
    },
    "1424": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "382",
      "startCol": "19",
      "endLine": "391",
      "endCol": "8"
    },
    "1425": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "399",
      "startCol": "25",
      "endLine": "399",
      "endCol": "43"
    },
    "1426": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "404",
      "startCol": "19",
      "endLine": "404",
      "endCol": "68"
    },
    "1427": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "77",
      "startCol": "5",
      "endLine": "82",
      "endCol": "14"
    },
    "1428": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "86",
      "startCol": "14",
      "endLine": "86",
      "endCol": "48"
    },
    "1429": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "88",
      "startCol": "10",
      "endLine": "88",
      "endCol": "44"
    },
    "1430": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "94",
      "startCol": "5",
      "endLine": "94",
      "endCol": "27"
    },
    "1431": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "99",
      "startCol": "22",
      "endLine": "99",
      "endCol": "38"
    },
    "1432": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "104",
      "startCol": "19",
      "endLine": "119",
      "endCol": "8"
    },
    "1433": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "148",
      "startCol": "22",
      "endLine": "148",
      "endCol": "38"
    },
    "1434": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "153",
      "startCol": "19",
      "endLine": "168",
      "endCol": "8"
    },
    "1435": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "173",
      "startCol": "25",
      "endLine": "173",
      "endCol": "41"
    },
    "1436": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "177",
      "startCol": "25",
      "endLine": "192",
      "endCol": "8"
    },
    "1437": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "219",
      "startCol": "22",
      "endLine": "219",
      "endCol": "38"
    },
    "1438": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "224",
      "startCol": "19",
      "endLine": "239",
      "endCol": "8"
    },
    "1439": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "243",
      "startCol": "22",
      "endLine": "243",
      "endCol": "72"
    },
    "1440": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "271",
      "startCol": "22",
      "endLine": "271",
      "endCol": "38"
    },
    "1441": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "276",
      "startCol": "19",
      "endLine": "292",
      "endCol": "8"
    },
    "1442": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1443": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1444": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1445": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "35",
      "startCol": "17",
      "endLine": "42",
      "endCol": "5"
    },
    "1446": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "52",
      "startCol": "17",
      "endLine": "59",
      "endCol": "5"
    },
    "1447": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "68",
      "startCol": "17",
      "endLine": "70",
      "endCol": "5"
    },
    "1448": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "82",
      "startCol": "17",
      "endLine": "89",
      "endCol": "5"
    },
    "1449": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "92",
      "startCol": "23",
      "endLine": "99",
      "endCol": "5"
    },
    "1450": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1451": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1452": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1453": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1454": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "50",
      "startCol": "15",
      "endLine": "55",
      "endCol": "5"
    },
    "1455": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "61",
      "startCol": "15",
      "endLine": "66",
      "endCol": "5"
    },
    "1456": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "73",
      "startCol": "11",
      "endLine": "75",
      "endCol": "6"
    },
    "1457": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "84",
      "startCol": "17",
      "endLine": "86",
      "endCol": "5"
    },
    "1458": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "97",
      "startCol": "17",
      "endLine": "104",
      "endCol": "5"
    },
    "1459": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "106",
      "startCol": "23",
      "endLine": "113",
      "endCol": "5"
    },
    "1460": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1461": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1462": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1463": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "38",
      "endCol": "6"
    },
    "1464": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "56",
      "startCol": "17",
      "endLine": "60",
      "endCol": "6"
    },
    "1465": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "71",
      "startCol": "19",
      "endLine": "78",
      "endCol": "7"
    },
    "1466": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "85",
      "startCol": "17",
      "endLine": "85",
      "endCol": "96"
    },
    "1467": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "98",
      "startCol": "17",
      "endLine": "102",
      "endCol": "6"
    },
    "1468": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "105",
      "startCol": "23",
      "endLine": "112",
      "endCol": "5"
    },
    "1469": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1470": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1471": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1472": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1473": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "52",
      "startCol": "17",
      "endLine": "59",
      "endCol": "5"
    },
    "1474": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "70",
      "startCol": "17",
      "endLine": "77",
      "endCol": "5"
    },
    "1475": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "86",
      "startCol": "17",
      "endLine": "93",
      "endCol": "5"
    },
    "1476": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "99",
      "startCol": "17",
      "endLine": "101",
      "endCol": "5"
    },
    "1477": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "114",
      "startCol": "17",
      "endLine": "121",
      "endCol": "5"
    },
    "1478": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "124",
      "startCol": "23",
      "endLine": "131",
      "endCol": "5"
    },
    "1479": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1480": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1481": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1482": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "35",
      "startCol": "17",
      "endLine": "42",
      "endCol": "5"
    },
    "1483": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "52",
      "startCol": "17",
      "endLine": "59",
      "endCol": "5"
    },
    "1484": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "68",
      "startCol": "17",
      "endLine": "70",
      "endCol": "5"
    },
    "1485": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "81",
      "startCol": "17",
      "endLine": "88",
      "endCol": "5"
    },
    "1486": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "90",
      "startCol": "23",
      "endLine": "97",
      "endCol": "5"
    },
    "1487": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1488": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1489": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1490": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1491": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "50",
      "startCol": "17",
      "endLine": "57",
      "endCol": "5"
    },
    "1492": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "63",
      "startCol": "17",
      "endLine": "70",
      "endCol": "5"
    },
    "1493": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "79",
      "endCol": "98"
    },
    "1494": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "93",
      "startCol": "17",
      "endLine": "100",
      "endCol": "5"
    },
    "1495": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "102",
      "startCol": "23",
      "endLine": "109",
      "endCol": "5"
    },
    "1496": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "23",
      "startCol": "5",
      "endLine": "23",
      "endCol": "44"
    },
    "1497": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "26",
      "startCol": "10",
      "endLine": "26",
      "endCol": "44"
    },
    "1498": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "31",
      "startCol": "5",
      "endLine": "31",
      "endCol": "27"
    },
    "1499": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "35",
      "startCol": "17",
      "endLine": "42",
      "endCol": "5"
    },
    "1500": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "51",
      "startCol": "17",
      "endLine": "53",
      "endCol": "5"
    },
    "1501": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "64",
      "startCol": "17",
      "endLine": "71",
      "endCol": "5"
    },
    "1502": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "73",
      "startCol": "23",
      "endLine": "80",
      "endCol": "5"
    },
    "1503": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "90",
      "startCol": "17",
      "endLine": "97",
      "endCol": "5"
    },
    "1504": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "106",
      "startCol": "17",
      "endLine": "113",
      "endCol": "5"
    },
    "1505": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1506": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1507": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1508": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "35",
      "startCol": "17",
      "endLine": "42",
      "endCol": "5"
    },
    "1509": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "52",
      "startCol": "17",
      "endLine": "59",
      "endCol": "5"
    },
    "1510": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "68",
      "startCol": "17",
      "endLine": "68",
      "endCol": "98"
    },
    "1511": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "86",
      "endCol": "5"
    },
    "1512": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "88",
      "startCol": "23",
      "endLine": "95",
      "endCol": "5"
    },
    "1513": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1514": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1515": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1516": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1517": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "51",
      "startCol": "17",
      "endLine": "58",
      "endCol": "5"
    },
    "1518": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "67",
      "startCol": "17",
      "endLine": "69",
      "endCol": "5"
    },
    "1519": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "80",
      "startCol": "17",
      "endLine": "87",
      "endCol": "5"
    },
    "1520": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "89",
      "startCol": "24",
      "endLine": "96",
      "endCol": "5"
    },
    "1521": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1522": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1523": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1524": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "37",
      "startCol": "17",
      "endLine": "41",
      "endCol": "6"
    },
    "1525": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "58",
      "startCol": "17",
      "endLine": "62",
      "endCol": "6"
    },
    "1526": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "71",
      "startCol": "17",
      "endLine": "71",
      "endCol": "96"
    },
    "1527": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "86",
      "startCol": "17",
      "endLine": "92",
      "endCol": "6"
    },
    "1528": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "94",
      "startCol": "23",
      "endLine": "103",
      "endCol": "5"
    },
    "1529": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1530": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1531": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1532": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1533": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "50",
      "startCol": "17",
      "endLine": "57",
      "endCol": "5"
    },
    "1534": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "64",
      "startCol": "17",
      "endLine": "66",
      "endCol": "5"
    },
    "1535": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "76",
      "startCol": "17",
      "endLine": "83",
      "endCol": "5"
    },
    "1536": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "85",
      "startCol": "23",
      "endLine": "92",
      "endCol": "5"
    },
    "1537": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1538": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1539": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1540": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1541": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "50",
      "startCol": "17",
      "endLine": "52",
      "endCol": "5"
    },
    "1542": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "63",
      "startCol": "17",
      "endLine": "68",
      "endCol": "5"
    },
    "1543": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "70",
      "startCol": "23",
      "endLine": "75",
      "endCol": "5"
    },
    "1544": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1545": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1546": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1547": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1548": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "50",
      "startCol": "17",
      "endLine": "52",
      "endCol": "5"
    },
    "1549": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "63",
      "startCol": "17",
      "endLine": "68",
      "endCol": "5"
    },
    "1550": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "70",
      "startCol": "23",
      "endLine": "75",
      "endCol": "5"
    },
    "1551": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1552": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1553": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1554": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "38",
      "endCol": "6"
    },
    "1555": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "47",
      "startCol": "17",
      "endLine": "47",
      "endCol": "96"
    },
    "1556": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "58",
      "startCol": "17",
      "endLine": "60",
      "endCol": "6"
    },
    "1557": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "62",
      "startCol": "23",
      "endLine": "67",
      "endCol": "5"
    },
    "1558": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1559": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1560": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1561": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "38",
      "endCol": "6"
    },
    "1562": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "49",
      "startCol": "19",
      "endLine": "56",
      "endCol": "7"
    },
    "1563": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "65",
      "startCol": "19",
      "endLine": "72",
      "endCol": "7"
    },
    "1564": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "79",
      "endCol": "96"
    },
    "1565": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "89",
      "startCol": "17",
      "endLine": "93",
      "endCol": "6"
    },
    "1566": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "95",
      "startCol": "23",
      "endLine": "102",
      "endCol": "5"
    },
    "1567": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "24",
      "startCol": "7",
      "endLine": "24",
      "endCol": "49"
    },
    "1568": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "27",
      "startCol": "12",
      "endLine": "27",
      "endCol": "46"
    },
    "1569": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "32",
      "startCol": "7",
      "endLine": "32",
      "endCol": "29"
    },
    "1570": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "36",
      "startCol": "19",
      "endLine": "40",
      "endCol": "8"
    },
    "1571": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "49",
      "startCol": "19",
      "endLine": "53",
      "endCol": "8"
    },
    "1572": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "60",
      "startCol": "27",
      "endLine": "67",
      "endCol": "7"
    },
    "1573": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "73",
      "startCol": "19",
      "endLine": "77",
      "endCol": "8"
    },
    "1574": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "100",
      "startCol": "7",
      "endLine": "100",
      "endCol": "49"
    },
    "1575": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "103",
      "startCol": "12",
      "endLine": "103",
      "endCol": "46"
    },
    "1576": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "108",
      "startCol": "7",
      "endLine": "108",
      "endCol": "29"
    },
    "1577": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "112",
      "startCol": "19",
      "endLine": "119",
      "endCol": "7"
    },
    "1578": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "128",
      "startCol": "19",
      "endLine": "135",
      "endCol": "7"
    },
    "1579": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "142",
      "startCol": "27",
      "endLine": "149",
      "endCol": "7"
    },
    "1580": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "155",
      "startCol": "19",
      "endLine": "162",
      "endCol": "7"
    },
    "1581": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "31",
      "startCol": "5",
      "endLine": "37",
      "endCol": "6"
    },
    "1582": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "43",
      "startCol": "5",
      "endLine": "48",
      "endCol": "14"
    },
    "1583": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "51",
      "startCol": "10",
      "endLine": "51",
      "endCol": "44"
    },
    "1584": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "56",
      "startCol": "5",
      "endLine": "56",
      "endCol": "27"
    },
    "1585": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "61",
      "startCol": "19",
      "endLine": "64",
      "endCol": "8"
    },
    "1586": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "102",
      "startCol": "22",
      "endLine": "108",
      "endCol": "8"
    },
    "1587": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "121",
      "startCol": "22",
      "endLine": "127",
      "endCol": "8"
    },
    "1588": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "140",
      "startCol": "22",
      "endLine": "146",
      "endCol": "8"
    },
    "1589": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "165",
      "startCol": "22",
      "endLine": "169",
      "endCol": "8"
    },
    "1590": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "190",
      "startCol": "22",
      "endLine": "194",
      "endCol": "8"
    },
    "1591": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "216",
      "startCol": "22",
      "endLine": "220",
      "endCol": "8"
    },
    "1592": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "242",
      "startCol": "22",
      "endLine": "246",
      "endCol": "8"
    },
    "1593": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "266",
      "startCol": "22",
      "endLine": "270",
      "endCol": "8"
    },
    "1594": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "291",
      "startCol": "22",
      "endLine": "295",
      "endCol": "8"
    },
    "1595": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "310",
      "startCol": "36",
      "endLine": "316",
      "endCol": "8"
    },
    "1596": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "318",
      "startCol": "35",
      "endLine": "326",
      "endCol": "8"
    },
    "1597": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "328",
      "startCol": "36",
      "endLine": "331",
      "endCol": "8"
    },
    "1598": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "333",
      "startCol": "35",
      "endLine": "341",
      "endCol": "8"
    },
    "1599": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "350",
      "startCol": "32",
      "endLine": "353",
      "endCol": "8"
    },
    "1600": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "358",
      "startCol": "7",
      "endLine": "364",
      "endCol": "8"
    },
    "1601": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "366",
      "startCol": "33",
      "endLine": "369",
      "endCol": "8"
    },
    "1602": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "389",
      "startCol": "36",
      "endLine": "395",
      "endCol": "8"
    },
    "1603": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "403",
      "startCol": "22",
      "endLine": "407",
      "endCol": "8"
    },
    "1604": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "433",
      "startCol": "22",
      "endLine": "439",
      "endCol": "8"
    },
    "1605": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "452",
      "startCol": "22",
      "endLine": "458",
      "endCol": "8"
    },
    "1606": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "477",
      "startCol": "22",
      "endLine": "481",
      "endCol": "8"
    },
    "1607": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "501",
      "startCol": "22",
      "endLine": "505",
      "endCol": "8"
    },
    "1608": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "524",
      "startCol": "22",
      "endLine": "528",
      "endCol": "8"
    },
    "1609": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "547",
      "startCol": "22",
      "endLine": "551",
      "endCol": "8"
    },
    "1610": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "570",
      "startCol": "22",
      "endLine": "574",
      "endCol": "8"
    },
    "1611": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "592",
      "startCol": "22",
      "endLine": "596",
      "endCol": "8"
    },
    "1612": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "609",
      "startCol": "22",
      "endLine": "612",
      "endCol": "8"
    },
    "1613": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "621",
      "startCol": "22",
      "endLine": "624",
      "endCol": "8"
    },
    "1614": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "633",
      "startCol": "22",
      "endLine": "636",
      "endCol": "8"
    },
    "1615": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "645",
      "startCol": "22",
      "endLine": "648",
      "endCol": "8"
    },
    "1616": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "658",
      "startCol": "22",
      "endLine": "661",
      "endCol": "8"
    },
    "1617": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "684",
      "startCol": "22",
      "endLine": "690",
      "endCol": "8"
    },
    "1618": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "706",
      "startCol": "22",
      "endLine": "710",
      "endCol": "8"
    },
    "1619": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "729",
      "startCol": "22",
      "endLine": "733",
      "endCol": "8"
    },
    "1620": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "752",
      "startCol": "22",
      "endLine": "756",
      "endCol": "8"
    },
    "1621": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "771",
      "startCol": "37",
      "endLine": "777",
      "endCol": "8"
    },
    "1622": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "779",
      "startCol": "43",
      "endLine": "786",
      "endCol": "8"
    },
    "1623": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "792",
      "startCol": "37",
      "endLine": "798",
      "endCol": "8"
    },
    "1624": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "800",
      "startCol": "43",
      "endLine": "807",
      "endCol": "8"
    },
    "1625": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "811",
      "startCol": "43",
      "endLine": "817",
      "endCol": "8"
    },
    "1626": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "823",
      "startCol": "37",
      "endLine": "829",
      "endCol": "8"
    },
    "1627": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "831",
      "startCol": "43",
      "endLine": "838",
      "endCol": "8"
    },
    "1628": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "840",
      "startCol": "7",
      "endLine": "843",
      "endCol": "8"
    },
    "1629": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "845",
      "startCol": "40",
      "endLine": "848",
      "endCol": "8"
    },
    "1630": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "93",
      "startCol": "7",
      "endLine": "97",
      "endCol": "16"
    },
    "1631": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "100",
      "startCol": "12",
      "endLine": "100",
      "endCol": "46"
    },
    "1632": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "108",
      "startCol": "7",
      "endLine": "108",
      "endCol": "29"
    },
    "1633": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "112",
      "startCol": "19",
      "endLine": "115",
      "endCol": "8"
    },
    "1634": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "124",
      "startCol": "19",
      "endLine": "130",
      "endCol": "8"
    },
    "1635": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "141",
      "startCol": "7",
      "endLine": "145",
      "endCol": "16"
    },
    "1636": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "148",
      "startCol": "12",
      "endLine": "148",
      "endCol": "46"
    },
    "1637": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "156",
      "startCol": "7",
      "endLine": "156",
      "endCol": "29"
    },
    "1638": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "160",
      "startCol": "19",
      "endLine": "163",
      "endCol": "8"
    },
    "1639": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "179",
      "startCol": "19",
      "endLine": "185",
      "endCol": "8"
    },
    "1640": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "121",
      "startCol": "5",
      "endLine": "124",
      "endCol": "14"
    },
    "1641": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "127",
      "startCol": "10",
      "endLine": "127",
      "endCol": "44"
    },
    "1642": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "134",
      "startCol": "5",
      "endLine": "134",
      "endCol": "27"
    },
    "1643": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "139",
      "startCol": "19",
      "endLine": "145",
      "endCol": "8"
    },
    "1644": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "153",
      "startCol": "19",
      "endLine": "159",
      "endCol": "8"
    },
    "1645": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "167",
      "startCol": "19",
      "endLine": "173",
      "endCol": "8"
    },
    "1646": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "181",
      "startCol": "19",
      "endLine": "187",
      "endCol": "8"
    },
    "1647": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "197",
      "startCol": "19",
      "endLine": "204",
      "endCol": "8"
    },
    "1648": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "211",
      "startCol": "19",
      "endLine": "218",
      "endCol": "8"
    },
    "1649": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "225",
      "startCol": "19",
      "endLine": "229",
      "endCol": "8"
    },
    "1650": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "236",
      "startCol": "19",
      "endLine": "243",
      "endCol": "8"
    },
    "1651": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "25",
      "startCol": "5",
      "endLine": "25",
      "endCol": "44"
    },
    "1652": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "28",
      "startCol": "10",
      "endLine": "28",
      "endCol": "44"
    },
    "1653": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "33",
      "startCol": "5",
      "endLine": "33",
      "endCol": "27"
    },
    "1654": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "37",
      "startCol": "17",
      "endLine": "40",
      "endCol": "6"
    },
    "1655": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "55",
      "startCol": "17",
      "endLine": "58",
      "endCol": "6"
    },
    "1656": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "64",
      "startCol": "17",
      "endLine": "70",
      "endCol": "6"
    },
    "1657": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "80",
      "startCol": "17",
      "endLine": "83",
      "endCol": "6"
    },
    "1658": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/utils/wrap-bad-request.js",
      "startLine": "5",
      "startCol": "5",
      "endLine": "5",
      "endCol": "21"
    },
    "1659": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "80",
      "startCol": "11",
      "endLine": "87",
      "endCol": "7"
    },
    "1660": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "229",
      "startCol": "9",
      "endLine": "229",
      "endCol": "61"
    },
    "1661": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "278",
      "startCol": "9",
      "endLine": "278",
      "endCol": "61"
    },
    "1662": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "313",
      "startCol": "7",
      "endLine": "313",
      "endCol": "62"
    },
    "1663": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "447",
      "startCol": "7",
      "endLine": "447",
      "endCol": "55"
    },
    "1664": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "495",
      "startCol": "7",
      "endLine": "495",
      "endCol": "28"
    },
    "1665": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "500",
      "startCol": "5",
      "endLine": "500",
      "endCol": "32"
    },
    "1666": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/FormModal/index.js",
      "startLine": "459",
      "startCol": "5",
      "endLine": "459",
      "endCol": "64"
    },
    "1667": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/LeftMenu/index.js",
      "startLine": "94",
      "startCol": "7",
      "endLine": "94",
      "endCol": "18"
    },
    "1668": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ComponentCategories.js",
      "startLine": "10",
      "startCol": "7",
      "endLine": "10",
      "endCol": "43"
    },
    "1669": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ComponentCategories.js",
      "startLine": "22",
      "startCol": "21",
      "endLine": "22",
      "endCol": "75"
    },
    "1670": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ComponentCategories.js",
      "startLine": "37",
      "startCol": "5",
      "endLine": "37",
      "endCol": "55"
    },
    "1671": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/Components.js",
      "startLine": "60",
      "startCol": "7",
      "endLine": "60",
      "endCol": "40"
    },
    "1672": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/Components.js",
      "startLine": "71",
      "startCol": "25",
      "endLine": "74",
      "endCol": "8"
    },
    "1673": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/Components.js",
      "startLine": "99",
      "startCol": "7",
      "endLine": "99",
      "endCol": "46"
    },
    "1674": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/Components.js",
      "startLine": "110",
      "startCol": "25",
      "endLine": "113",
      "endCol": "8"
    },
    "1675": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/Components.js",
      "startLine": "142",
      "startCol": "25",
      "endLine": "142",
      "endCol": "67"
    },
    "1676": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "16",
      "startCol": "7",
      "endLine": "16",
      "endCol": "30"
    },
    "1677": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "50",
      "startCol": "7",
      "endLine": "50",
      "endCol": "42"
    },
    "1678": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "60",
      "startCol": "27",
      "endLine": "63",
      "endCol": "8"
    },
    "1679": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "66",
      "startCol": "9",
      "endLine": "66",
      "endCol": "92"
    },
    "1680": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "68",
      "startCol": "9",
      "endLine": "68",
      "endCol": "87"
    },
    "1681": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "76",
      "startCol": "7",
      "endLine": "76",
      "endCol": "86"
    },
    "1682": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "90",
      "startCol": "7",
      "endLine": "90",
      "endCol": "48"
    },
    "1683": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "100",
      "startCol": "25",
      "endLine": "103",
      "endCol": "8"
    },
    "1684": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "126",
      "startCol": "25",
      "endLine": "126",
      "endCol": "71"
    },
    "1685": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "30",
      "startCol": "7",
      "endLine": "30",
      "endCol": "63"
    },
    "1686": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "34",
      "startCol": "7",
      "endLine": "34",
      "endCol": "74"
    },
    "1687": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "35",
      "startCol": "7",
      "endLine": "35",
      "endCol": "82"
    },
    "1688": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "39",
      "startCol": "7",
      "endLine": "39",
      "endCol": "59"
    },
    "1689": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "57",
      "startCol": "7",
      "endLine": "63",
      "endCol": "8"
    },
    "1690": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "80",
      "startCol": "7",
      "endLine": "84",
      "endCol": "8"
    },
    "1691": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "128",
      "startCol": "7",
      "endLine": "132",
      "endCol": "8"
    },
    "1692": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "150",
      "startCol": "7",
      "endLine": "152",
      "endCol": "8"
    },
    "1693": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ComponentCategories.js",
      "startLine": "48",
      "startCol": "3",
      "endLine": "48",
      "endCol": "28"
    },
    "1694": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ComponentCategories.js",
      "startLine": "70",
      "startCol": "3",
      "endLine": "70",
      "endCol": "28"
    },
    "1695": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/Components.js",
      "startLine": "54",
      "startCol": "3",
      "endLine": "54",
      "endCol": "28"
    },
    "1696": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/Components.js",
      "startLine": "83",
      "startCol": "3",
      "endLine": "83",
      "endCol": "28"
    },
    "1697": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/Components.js",
      "startLine": "92",
      "startCol": "3",
      "endLine": "92",
      "endCol": "28"
    },
    "1698": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "71",
      "startCol": "3",
      "endLine": "71",
      "endCol": "28"
    },
    "1699": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "121",
      "startCol": "5",
      "endLine": "121",
      "endCol": "30"
    },
    "1700": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "165",
      "startCol": "24",
      "endLine": "165",
      "endCol": "54"
    },
    "1701": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "201",
      "startCol": "7",
      "endLine": "201",
      "endCol": "32"
    },
    "1702": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "210",
      "startCol": "3",
      "endLine": "210",
      "endCol": "28"
    },
    "1703": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "221",
      "startCol": "3",
      "endLine": "221",
      "endCol": "28"
    },
    "1704": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "246",
      "startCol": "7",
      "endLine": "246",
      "endCol": "32"
    },
    "1705": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "34",
      "startCol": "3",
      "endLine": "34",
      "endCol": "41"
    },
    "1706": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "47",
      "startCol": "3",
      "endLine": "47",
      "endCol": "35"
    },
    "1707": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "49",
      "startCol": "16",
      "endLine": "49",
      "endCol": "46"
    },
    "1708": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "51",
      "startCol": "5",
      "endLine": "51",
      "endCol": "34"
    },
    "1709": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "65",
      "startCol": "18",
      "endLine": "65",
      "endCol": "47"
    },
    "1710": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "71",
      "startCol": "3",
      "endLine": "71",
      "endCol": "29"
    },
    "1711": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "72",
      "startCol": "3",
      "endLine": "72",
      "endCol": "41"
    },
    "1712": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "94",
      "startCol": "26",
      "endLine": "94",
      "endCol": "53"
    },
    "1713": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "102",
      "startCol": "7",
      "endLine": "110",
      "endCol": "7"
    },
    "1714": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "134",
      "startCol": "21",
      "endLine": "134",
      "endCol": "45"
    },
    "1715": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "139",
      "startCol": "18",
      "endLine": "139",
      "endCol": "41"
    },
    "1716": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "144",
      "startCol": "7",
      "endLine": "144",
      "endCol": "30"
    },
    "1717": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "148",
      "startCol": "17",
      "endLine": "148",
      "endCol": "41"
    },
    "1718": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "150",
      "startCol": "5",
      "endLine": "150",
      "endCol": "28"
    },
    "1719": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "216",
      "startCol": "9",
      "endLine": "216",
      "endCol": "37"
    },
    "1720": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "218",
      "startCol": "22",
      "endLine": "218",
      "endCol": "56"
    },
    "1721": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "220",
      "startCol": "11",
      "endLine": "220",
      "endCol": "44"
    },
    "1722": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "227",
      "startCol": "9",
      "endLine": "227",
      "endCol": "38"
    },
    "1723": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "229",
      "startCol": "9",
      "endLine": "240",
      "endCol": "9"
    },
    "1724": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "244",
      "startCol": "11",
      "endLine": "244",
      "endCol": "39"
    },
    "1725": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "246",
      "startCol": "24",
      "endLine": "246",
      "endCol": "58"
    },
    "1726": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "248",
      "startCol": "13",
      "endLine": "248",
      "endCol": "46"
    },
    "1727": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "269",
      "startCol": "9",
      "endLine": "269",
      "endCol": "34"
    },
    "1728": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "271",
      "startCol": "22",
      "endLine": "271",
      "endCol": "49"
    },
    "1729": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "273",
      "startCol": "11",
      "endLine": "273",
      "endCol": "37"
    },
    "1730": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "279",
      "startCol": "9",
      "endLine": "279",
      "endCol": "41"
    },
    "1731": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "280",
      "startCol": "9",
      "endLine": "280",
      "endCol": "76"
    },
    "1732": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "284",
      "startCol": "11",
      "endLine": "284",
      "endCol": "36"
    },
    "1733": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "286",
      "startCol": "24",
      "endLine": "286",
      "endCol": "51"
    },
    "1734": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "288",
      "startCol": "13",
      "endLine": "288",
      "endCol": "39"
    },
    "1735": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "12",
      "startCol": "8",
      "endLine": "12",
      "endCol": "42"
    },
    "1736": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "18",
      "startCol": "10",
      "endLine": "18",
      "endCol": "44"
    },
    "1737": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "27",
      "startCol": "19",
      "endLine": "33",
      "endCol": "8"
    },
    "1738": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "47",
      "startCol": "19",
      "endLine": "65",
      "endCol": "8"
    },
    "1739": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "78",
      "startCol": "19",
      "endLine": "89",
      "endCol": "8"
    },
    "1740": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "100",
      "startCol": "19",
      "endLine": "103",
      "endCol": "8"
    },
    "1741": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "127",
      "startCol": "19",
      "endLine": "130",
      "endCol": "8"
    },
    "1742": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "139",
      "startCol": "19",
      "endLine": "142",
      "endCol": "8"
    },
    "1743": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "173",
      "startCol": "19",
      "endLine": "176",
      "endCol": "8"
    },
    "1744": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "185",
      "startCol": "19",
      "endLine": "193",
      "endCol": "8"
    },
    "1745": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "206",
      "startCol": "19",
      "endLine": "217",
      "endCol": "8"
    },
    "1746": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "228",
      "startCol": "22",
      "endLine": "231",
      "endCol": "8"
    },
    "1747": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "247",
      "startCol": "19",
      "endLine": "250",
      "endCol": "8"
    },
    "1748": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "259",
      "startCol": "19",
      "endLine": "262",
      "endCol": "8"
    },
    "1749": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "273",
      "startCol": "22",
      "endLine": "276",
      "endCol": "8"
    },
    "1750": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "16",
      "startCol": "8",
      "endLine": "16",
      "endCol": "42"
    },
    "1751": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "22",
      "startCol": "10",
      "endLine": "22",
      "endCol": "44"
    },
    "1752": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "48",
      "startCol": "19",
      "endLine": "61",
      "endCol": "8"
    },
    "1753": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "72",
      "startCol": "19",
      "endLine": "75",
      "endCol": "8"
    },
    "1754": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "82",
      "startCol": "19",
      "endLine": "96",
      "endCol": "8"
    },
    "1755": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "107",
      "startCol": "19",
      "endLine": "110",
      "endCol": "8"
    },
    "1756": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "121",
      "startCol": "19",
      "endLine": "135",
      "endCol": "8"
    },
    "1757": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "146",
      "startCol": "19",
      "endLine": "149",
      "endCol": "8"
    },
    "1758": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "156",
      "startCol": "19",
      "endLine": "172",
      "endCol": "8"
    },
    "1759": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "185",
      "startCol": "25",
      "endLine": "199",
      "endCol": "8"
    },
    "1760": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "209",
      "startCol": "21",
      "endLine": "215",
      "endCol": "10"
    },
    "1761": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "220",
      "startCol": "25",
      "endLine": "234",
      "endCol": "8"
    },
    "1762": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "245",
      "startCol": "19",
      "endLine": "262",
      "endCol": "8"
    },
    "1763": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "273",
      "startCol": "19",
      "endLine": "276",
      "endCol": "8"
    },
    "1764": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/config/functions/bootstrap.js",
      "startLine": "20",
      "startCol": "28",
      "endLine": "20",
      "endCol": "67"
    },
    "1765": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/config/policies/index.js",
      "startLine": "9",
      "startCol": "18",
      "endLine": "9",
      "endCol": "57"
    },
    "1766": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/config/policies/index.js",
      "startLine": "12",
      "startCol": "12",
      "endLine": "12",
      "endCol": "23"
    },
    "1767": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-documentation/config/policies/index.js",
      "startLine": "3",
      "startCol": "18",
      "endLine": "33",
      "endCol": "1"
    },
    "1768": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/config/policies/index.js",
      "startLine": "22",
      "startCol": "19",
      "endLine": "25",
      "endCol": "3"
    },
    "1769": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/config/policies/index.js",
      "startLine": "32",
      "startCol": "3",
      "endLine": "32",
      "endCol": "14"
    },
    "1770": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "23",
      "startCol": "20",
      "endLine": "23",
      "endCol": "52"
    },
    "1771": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "75",
      "startCol": "11",
      "endLine": "75",
      "endCol": "41"
    },
    "1772": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "76",
      "startCol": "11",
      "endLine": "76",
      "endCol": "54"
    },
    "1773": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "88",
      "startCol": "20",
      "endLine": "88",
      "endCol": "59"
    },
    "1774": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "36",
      "startCol": "14",
      "endLine": "101",
      "endCol": "3"
    },
    "1775": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "123",
      "startCol": "9",
      "endLine": "123",
      "endCol": "39"
    },
    "1776": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "124",
      "startCol": "9",
      "endLine": "124",
      "endCol": "48"
    },
    "1777": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "135",
      "startCol": "18",
      "endLine": "135",
      "endCol": "57"
    },
    "1778": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "103",
      "startCol": "18",
      "endLine": "145",
      "endCol": "3"
    },
    "1779": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "152",
      "startCol": "42",
      "endLine": "159",
      "endCol": "12"
    },
    "1780": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "161",
      "startCol": "21",
      "endLine": "164",
      "endCol": "5"
    },
    "1781": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "249",
      "startCol": "7",
      "endLine": "249",
      "endCol": "48"
    },
    "1782": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "269",
      "startCol": "24",
      "endLine": "269",
      "endCol": "63"
    },
    "1783": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "292",
      "startCol": "29",
      "endLine": "294",
      "endCol": "8"
    },
    "1784": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "299",
      "startCol": "5",
      "endLine": "299",
      "endCol": "63"
    },
    "1785": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/middlewares/documentation/index.js",
      "startLine": "52",
      "startCol": "16",
      "endLine": "55",
      "endCol": "21"
    },
    "1786": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-documentation/middlewares/documentation/index.js",
      "startLine": "49",
      "startCol": "53",
      "endLine": "56",
      "endCol": "7"
    },
    "1787": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/services/Documentation.js",
      "startLine": "247",
      "startCol": "9",
      "endLine": "247",
      "endCol": "42"
    },
    "1788": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/services/Documentation.js",
      "startLine": "297",
      "startCol": "12",
      "endLine": "297",
      "endCol": "45"
    },
    "1789": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-documentation/services/Documentation.js",
      "startLine": "219",
      "startCol": "24",
      "endLine": "298",
      "endCol": "3"
    },
    "1790": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/services/Documentation.js",
      "startLine": "1844",
      "startCol": "20",
      "endLine": "1851",
      "endCol": "12"
    },
    "1791": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-email/controllers/Email.js",
      "startLine": "12",
      "startCol": "7",
      "endLine": "12",
      "endCol": "61"
    },
    "1792": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/hooks/graphql/index.js",
      "startLine": "154",
      "startCol": "9",
      "endLine": "154",
      "endCol": "27"
    },
    "1793": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/hooks/graphql/load-config.js",
      "startLine": "16",
      "startCol": "20",
      "endLine": "16",
      "endCol": "81"
    },
    "1794": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/hooks/graphql/load-config.js",
      "startLine": "34",
      "startCol": "53",
      "endLine": "39",
      "endCol": "4"
    },
    "1795": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/build-aggregation.js",
      "startLine": "261",
      "startCol": "22",
      "endLine": "267",
      "endCol": "8"
    },
    "1796": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/resolvers-builder.js",
      "startLine": "36",
      "startCol": "7",
      "endLine": "36",
      "endCol": "35"
    },
    "1797": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/resolvers-builder.js",
      "startLine": "48",
      "startCol": "5",
      "endLine": "48",
      "endCol": "33"
    },
    "1798": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/resolvers-builder.js",
      "startLine": "50",
      "startCol": "20",
      "endLine": "50",
      "endCol": "36"
    },
    "1799": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/resolvers-builder.js",
      "startLine": "97",
      "startCol": "7",
      "endLine": "97",
      "endCol": "35"
    },
    "1800": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/resolvers-builder.js",
      "startLine": "110",
      "startCol": "5",
      "endLine": "110",
      "endCol": "33"
    },
    "1801": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/resolvers-builder.js",
      "startLine": "112",
      "startCol": "20",
      "endLine": "112",
      "endCol": "36"
    },
    "1802": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/type-definitions.js",
      "startLine": "53",
      "startCol": "19",
      "endLine": "53",
      "endCol": "53"
    },
    "1803": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/type-definitions.js",
      "startLine": "197",
      "startCol": "27",
      "endLine": "197",
      "endCol": "80"
    },
    "1804": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/type-definitions.js",
      "startLine": "256",
      "startCol": "31",
      "endLine": "258",
      "endCol": "70"
    },
    "1805": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "33",
      "startCol": "5",
      "endLine": "33",
      "endCol": "51"
    },
    "1806": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "36",
      "startCol": "10",
      "endLine": "36",
      "endCol": "44"
    },
    "1807": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "49",
      "startCol": "5",
      "endLine": "49",
      "endCol": "27"
    },
    "1808": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "62",
      "startCol": "19",
      "endLine": "79",
      "endCol": "8"
    },
    "1809": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "94",
      "startCol": "19",
      "endLine": "105",
      "endCol": "8"
    },
    "1810": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "121",
      "startCol": "19",
      "endLine": "132",
      "endCol": "8"
    },
    "1811": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "143",
      "startCol": "19",
      "endLine": "154",
      "endCol": "8"
    },
    "1812": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "165",
      "startCol": "19",
      "endLine": "176",
      "endCol": "8"
    },
    "1813": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "187",
      "startCol": "19",
      "endLine": "204",
      "endCol": "8"
    },
    "1814": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "329",
      "startCol": "19",
      "endLine": "342",
      "endCol": "8"
    },
    "1815": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "361",
      "startCol": "19",
      "endLine": "375",
      "endCol": "8"
    },
    "1816": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "387",
      "startCol": "19",
      "endLine": "408",
      "endCol": "8"
    },
    "1817": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "427",
      "startCol": "21",
      "endLine": "446",
      "endCol": "10"
    },
    "1818": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "110",
      "startCol": "5",
      "endLine": "113",
      "endCol": "14"
    },
    "1819": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "116",
      "startCol": "10",
      "endLine": "116",
      "endCol": "44"
    },
    "1820": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "129",
      "startCol": "5",
      "endLine": "129",
      "endCol": "27"
    },
    "1821": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "147",
      "startCol": "19",
      "endLine": "168",
      "endCol": "8"
    },
    "1822": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "181",
      "startCol": "19",
      "endLine": "196",
      "endCol": "8"
    },
    "1823": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "212",
      "startCol": "19",
      "endLine": "240",
      "endCol": "8"
    },
    "1824": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "259",
      "startCol": "19",
      "endLine": "278",
      "endCol": "8"
    },
    "1825": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "299",
      "startCol": "19",
      "endLine": "318",
      "endCol": "8"
    },
    "1826": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "339",
      "startCol": "19",
      "endLine": "358",
      "endCol": "8"
    },
    "1827": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "370",
      "startCol": "19",
      "endLine": "401",
      "endCol": "8"
    },
    "1828": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "418",
      "startCol": "21",
      "endLine": "442",
      "endCol": "10"
    },
    "1829": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "456",
      "startCol": "19",
      "endLine": "475",
      "endCol": "8"
    },
    "1830": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "494",
      "startCol": "21",
      "endLine": "512",
      "endCol": "10"
    },
    "1831": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "532",
      "startCol": "19",
      "endLine": "548",
      "endCol": "8"
    },
    "1832": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "565",
      "startCol": "19",
      "endLine": "574",
      "endCol": "8"
    },
    "1833": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "591",
      "startCol": "19",
      "endLine": "613",
      "endCol": "8"
    },
    "1834": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "632",
      "startCol": "19",
      "endLine": "641",
      "endCol": "8"
    },
    "1835": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "659",
      "startCol": "27",
      "endLine": "679",
      "endCol": "8"
    },
    "1836": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "682",
      "startCol": "24",
      "endLine": "695",
      "endCol": "8"
    },
    "1837": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "45",
      "startCol": "5",
      "endLine": "45",
      "endCol": "55"
    },
    "1838": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "48",
      "startCol": "10",
      "endLine": "48",
      "endCol": "44"
    },
    "1839": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "61",
      "startCol": "5",
      "endLine": "61",
      "endCol": "27"
    },
    "1840": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "66",
      "startCol": "19",
      "endLine": "74",
      "endCol": "8"
    },
    "1841": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "87",
      "startCol": "7",
      "endLine": "89",
      "endCol": "8"
    },
    "1842": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "91",
      "startCol": "19",
      "endLine": "100",
      "endCol": "8"
    },
    "1843": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "116",
      "startCol": "19",
      "endLine": "124",
      "endCol": "8"
    },
    "1844": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "137",
      "startCol": "25",
      "endLine": "155",
      "endCol": "8"
    },
    "1845": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "167",
      "startCol": "22",
      "endLine": "176",
      "endCol": "8"
    },
    "1846": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "188",
      "startCol": "25",
      "endLine": "199",
      "endCol": "8"
    },
    "1847": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "211",
      "startCol": "22",
      "endLine": "220",
      "endCol": "8"
    },
    "1848": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/HomePage/index.js",
      "startLine": "66",
      "startCol": "7",
      "endLine": "68",
      "endCol": "8"
    },
    "1849": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/HomePage/index.js",
      "startLine": "87",
      "startCol": "20",
      "endLine": "89",
      "endCol": "8"
    },
    "1850": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/HomePage/index.js",
      "startLine": "110",
      "startCol": "25",
      "endLine": "112",
      "endCol": "8"
    },
    "1851": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/HomePage/index.js",
      "startLine": "132",
      "startCol": "29",
      "endLine": "132",
      "endCol": "78"
    },
    "1852": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/HomePage/index.js",
      "startLine": "230",
      "startCol": "7",
      "endLine": "230",
      "endCol": "71"
    },
    "1853": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/Initializer/index.js",
      "startLine": "21",
      "startCol": "26",
      "endLine": "21",
      "endCol": "69"
    },
    "1854": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepper/InputModalStepper.js",
      "startLine": "196",
      "startCol": "9",
      "endLine": "196",
      "endCol": "55"
    },
    "1855": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepper/InputModalStepper.js",
      "startLine": "258",
      "startCol": "26",
      "endLine": "268",
      "endCol": "7"
    },
    "1856": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "83",
      "startCol": "7",
      "endLine": "115",
      "endCol": "7"
    },
    "1857": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "137",
      "startCol": "7",
      "endLine": "140",
      "endCol": "7"
    },
    "1858": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "336",
      "startCol": "14",
      "endLine": "338",
      "endCol": "8"
    },
    "1859": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "331",
      "startCol": "35",
      "endLine": "348",
      "endCol": "3"
    },
    "1860": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "352",
      "startCol": "30",
      "endLine": "352",
      "endCol": "97"
    },
    "1861": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "366",
      "startCol": "14",
      "endLine": "368",
      "endCol": "8"
    },
    "1862": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "361",
      "startCol": "30",
      "endLine": "378",
      "endCol": "3"
    },
    "1863": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "421",
      "startCol": "32",
      "endLine": "431",
      "endCol": "11"
    },
    "1864": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "474",
      "startCol": "5",
      "endLine": "474",
      "endCol": "31"
    },
    "1865": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js",
      "startLine": "91",
      "startCol": "7",
      "endLine": "124",
      "endCol": "7"
    },
    "1866": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js",
      "startLine": "186",
      "startCol": "7",
      "endLine": "188",
      "endCol": "8"
    },
    "1867": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js",
      "startLine": "208",
      "startCol": "7",
      "endLine": "211",
      "endCol": "7"
    },
    "1868": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js",
      "startLine": "332",
      "startCol": "7",
      "endLine": "342",
      "endCol": "7"
    },
    "1869": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js",
      "startLine": "418",
      "startCol": "11",
      "endLine": "428",
      "endCol": "11"
    },
    "1870": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js",
      "startLine": "462",
      "startCol": "5",
      "endLine": "462",
      "endCol": "31"
    },
    "1871": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/SettingsPage/index.js",
      "startLine": "25",
      "startCol": "24",
      "endLine": "25",
      "endCol": "90"
    },
    "1872": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/SettingsPage/index.js",
      "startLine": "50",
      "startCol": "7",
      "endLine": "53",
      "endCol": "8"
    },
    "1873": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/functions/bootstrap.js",
      "startLine": "16",
      "startCol": "18",
      "endLine": "16",
      "endCol": "41"
    },
    "1874": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/functions/bootstrap.js",
      "startLine": "19",
      "startCol": "5",
      "endLine": "24",
      "endCol": "6"
    },
    "1875": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/functions/bootstrap.js",
      "startLine": "33",
      "startCol": "12",
      "endLine": "33",
      "endCol": "28"
    },
    "1876": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-upload/config/functions/bootstrap.js",
      "startLine": "31",
      "startCol": "37",
      "endLine": "37",
      "endCol": "1"
    },
    "1877": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/functions/bootstrap.js",
      "startLine": "80",
      "startCol": "3",
      "endLine": "80",
      "endCol": "76"
    },
    "1878": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "35",
      "startCol": "33",
      "endLine": "37",
      "endCol": "11"
    },
    "1879": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "47",
      "startCol": "25",
      "endLine": "47",
      "endCol": "96"
    },
    "1880": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "58",
      "startCol": "18",
      "endLine": "58",
      "endCol": "85"
    },
    "1881": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "57",
      "startCol": "19",
      "endLine": "59",
      "endCol": "9"
    },
    "1882": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "65",
      "startCol": "24",
      "endLine": "65",
      "endCol": "99"
    },
    "1883": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "67",
      "startCol": "32",
      "endLine": "67",
      "endCol": "87"
    },
    "1884": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "77",
      "startCol": "52",
      "endLine": "77",
      "endCol": "63"
    },
    "1885": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "82",
      "startCol": "28",
      "endLine": "82",
      "endCol": "53"
    },
    "1886": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/Upload.js",
      "startLine": "65",
      "startCol": "5",
      "endLine": "65",
      "endCol": "69"
    },
    "1887": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/Upload.js",
      "startLine": "71",
      "startCol": "21",
      "endLine": "73",
      "endCol": "6"
    },
    "1888": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "40",
      "startCol": "19",
      "endLine": "40",
      "endCol": "76"
    },
    "1889": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "75",
      "startCol": "19",
      "endLine": "75",
      "endCol": "76"
    },
    "1890": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "93",
      "startCol": "5",
      "endLine": "93",
      "endCol": "63"
    },
    "1891": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "108",
      "startCol": "18",
      "endLine": "108",
      "endCol": "45"
    },
    "1892": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "110",
      "startCol": "5",
      "endLine": "110",
      "endCol": "65"
    },
    "1893": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "124",
      "startCol": "18",
      "endLine": "124",
      "endCol": "74"
    },
    "1894": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "139",
      "startCol": "18",
      "endLine": "139",
      "endCol": "47"
    },
    "1895": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "140",
      "startCol": "18",
      "endLine": "140",
      "endCol": "80"
    },
    "1896": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "163",
      "startCol": "18",
      "endLine": "163",
      "endCol": "47"
    },
    "1897": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "164",
      "startCol": "27",
      "endLine": "164",
      "endCol": "90"
    },
    "1898": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "186",
      "startCol": "18",
      "endLine": "186",
      "endCol": "47"
    },
    "1899": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "187",
      "startCol": "27",
      "endLine": "187",
      "endCol": "79"
    },
    "1900": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "194",
      "startCol": "16",
      "endLine": "194",
      "endCol": "72"
    },
    "1901": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "203",
      "startCol": "7",
      "endLine": "203",
      "endCol": "97"
    },
    "1902": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "19",
      "startCol": "19",
      "endLine": "19",
      "endCol": "80"
    },
    "1903": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "29",
      "startCol": "18",
      "endLine": "29",
      "endCol": "74"
    },
    "1904": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "41",
      "startCol": "16",
      "endLine": "41",
      "endCol": "77"
    },
    "1905": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "49",
      "startCol": "18",
      "endLine": "49",
      "endCol": "77"
    },
    "1906": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "55",
      "startCol": "5",
      "endLine": "55",
      "endCol": "63"
    },
    "1907": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "65",
      "startCol": "18",
      "endLine": "65",
      "endCol": "45"
    },
    "1908": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "67",
      "startCol": "5",
      "endLine": "67",
      "endCol": "65"
    },
    "1909": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "73",
      "startCol": "18",
      "endLine": "73",
      "endCol": "74"
    },
    "1910": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "83",
      "startCol": "18",
      "endLine": "83",
      "endCol": "47"
    },
    "1911": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "85",
      "startCol": "20",
      "endLine": "85",
      "endCol": "96"
    },
    "1912": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "105",
      "startCol": "27",
      "endLine": "108",
      "endCol": "6"
    },
    "1913": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "106",
      "startCol": "13",
      "endLine": "106",
      "endCol": "42"
    },
    "1914": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "118",
      "startCol": "27",
      "endLine": "121",
      "endCol": "6"
    },
    "1915": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "119",
      "startCol": "13",
      "endLine": "119",
      "endCol": "42"
    },
    "1916": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "93",
      "startCol": "20",
      "endLine": "93",
      "endCol": "63"
    },
    "1917": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "111",
      "startCol": "30",
      "endLine": "111",
      "endCol": "55"
    },
    "1918": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "140",
      "startCol": "12",
      "endLine": "142",
      "endCol": "5"
    },
    "1919": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "128",
      "startCol": "15",
      "endLine": "143",
      "endCol": "3"
    },
    "1920": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "154",
      "startCol": "5",
      "endLine": "154",
      "endCol": "57"
    },
    "1921": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "156",
      "startCol": "27",
      "endLine": "156",
      "endCol": "59"
    },
    "1922": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "158",
      "startCol": "7",
      "endLine": "158",
      "endCol": "64"
    },
    "1923": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "163",
      "startCol": "21",
      "endLine": "163",
      "endCol": "61"
    },
    "1924": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "170",
      "startCol": "9",
      "endLine": "170",
      "endCol": "57"
    },
    "1925": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "177",
      "startCol": "31",
      "endLine": "177",
      "endCol": "66"
    },
    "1926": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "191",
      "startCol": "20",
      "endLine": "191",
      "endCol": "43"
    },
    "1927": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "215",
      "startCol": "20",
      "endLine": "215",
      "endCol": "43"
    },
    "1928": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "232",
      "startCol": "7",
      "endLine": "232",
      "endCol": "57"
    },
    "1929": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "235",
      "startCol": "9",
      "endLine": "239",
      "endCol": "9"
    },
    "1930": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "243",
      "startCol": "5",
      "endLine": "243",
      "endCol": "57"
    },
    "1931": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "248",
      "startCol": "27",
      "endLine": "248",
      "endCol": "59"
    },
    "1932": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "250",
      "startCol": "7",
      "endLine": "250",
      "endCol": "64"
    },
    "1933": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "255",
      "startCol": "21",
      "endLine": "255",
      "endCol": "61"
    },
    "1934": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "262",
      "startCol": "9",
      "endLine": "262",
      "endCol": "57"
    },
    "1935": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "269",
      "startCol": "31",
      "endLine": "269",
      "endCol": "66"
    },
    "1936": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "288",
      "startCol": "17",
      "endLine": "288",
      "endCol": "79"
    },
    "1937": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "302",
      "startCol": "17",
      "endLine": "302",
      "endCol": "71"
    },
    "1938": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "335",
      "startCol": "7",
      "endLine": "335",
      "endCol": "55"
    },
    "1939": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "338",
      "startCol": "9",
      "endLine": "342",
      "endCol": "9"
    },
    "1940": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "346",
      "startCol": "19",
      "endLine": "348",
      "endCol": "6"
    },
    "1941": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "360",
      "startCol": "27",
      "endLine": "373",
      "endCol": "5"
    },
    "1942": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "375",
      "startCol": "5",
      "endLine": "375",
      "endCol": "81"
    },
    "1943": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "36",
      "startCol": "29",
      "endLine": "36",
      "endCol": "60"
    },
    "1944": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "39",
      "startCol": "21",
      "endLine": "39",
      "endCol": "73"
    },
    "1945": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "42",
      "startCol": "39",
      "endLine": "42",
      "endCol": "65"
    },
    "1946": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "65",
      "startCol": "7",
      "endLine": "65",
      "endCol": "63"
    },
    "1947": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "101",
      "startCol": "7",
      "endLine": "101",
      "endCol": "63"
    },
    "1948": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "109",
      "startCol": "30",
      "endLine": "109",
      "endCol": "61"
    },
    "1949": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "124",
      "startCol": "19",
      "endLine": "128",
      "endCol": "4"
    },
    "1950": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "131",
      "startCol": "37",
      "endLine": "131",
      "endCol": "63"
    },
    "1951": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "156",
      "startCol": "22",
      "endLine": "156",
      "endCol": "47"
    },
    "1952": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "17",
      "startCol": "10",
      "endLine": "17",
      "endCol": "44"
    },
    "1953": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "47",
      "startCol": "17",
      "endLine": "47",
      "endCol": "71"
    },
    "1954": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "87",
      "startCol": "17",
      "endLine": "87",
      "endCol": "71"
    },
    "1955": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "103",
      "startCol": "17",
      "endLine": "126",
      "endCol": "6"
    },
    "1956": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "142",
      "startCol": "17",
      "endLine": "159",
      "endCol": "6"
    },
    "1957": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "174",
      "startCol": "17",
      "endLine": "191",
      "endCol": "6"
    },
    "1958": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "228",
      "startCol": "17",
      "endLine": "228",
      "endCol": "71"
    },
    "1959": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "16",
      "startCol": "10",
      "endLine": "16",
      "endCol": "44"
    },
    "1960": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "25",
      "startCol": "19",
      "endLine": "25",
      "endCol": "70"
    },
    "1961": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "39",
      "startCol": "25",
      "endLine": "46",
      "endCol": "8"
    },
    "1962": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "56",
      "startCol": "22",
      "endLine": "56",
      "endCol": "73"
    },
    "1963": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "70",
      "startCol": "19",
      "endLine": "76",
      "endCol": "8"
    },
    "1964": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "98",
      "startCol": "19",
      "endLine": "98",
      "endCol": "76"
    },
    "1965": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "103",
      "startCol": "19",
      "endLine": "109",
      "endCol": "8"
    },
    "1966": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/AdvancedSettings/index.js",
      "startLine": "45",
      "startCol": "22",
      "endLine": "45",
      "endCol": "88"
    },
    "1967": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/AdvancedSettings/index.js",
      "startLine": "95",
      "startCol": "9",
      "endLine": "95",
      "endCol": "87"
    },
    "1968": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/EmailTemplates/index.js",
      "startLine": "100",
      "startCol": "9",
      "endLine": "100",
      "endCol": "85"
    },
    "1969": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/EmailTemplates/index.js",
      "startLine": "107",
      "startCol": "11",
      "endLine": "110",
      "endCol": "12"
    },
    "1970": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/Providers/index.js",
      "startLine": "140",
      "startCol": "9",
      "endLine": "140",
      "endCol": "86"
    },
    "1971": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/Providers/index.js",
      "startLine": "146",
      "startCol": "11",
      "endLine": "149",
      "endCol": "12"
    },
    "1972": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/hooks/useFetchRole/index.js",
      "startLine": "26",
      "startCol": "24",
      "endLine": "26",
      "endCol": "87"
    },
    "1973": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/hooks/useForm/index.js",
      "startLine": "25",
      "startCol": "22",
      "endLine": "25",
      "endCol": "86"
    },
    "1974": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/hooks/usePlugins/index.js",
      "startLine": "24",
      "startCol": "59",
      "endLine": "28",
      "endCol": "7"
    },
    "1975": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/hooks/useRolesList/index.js",
      "startLine": "35",
      "startCol": "25",
      "endLine": "35",
      "endCol": "86"
    },
    "1976": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "134",
      "startCol": "28",
      "endLine": "134",
      "endCol": "66"
    },
    "1977": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "145",
      "startCol": "5",
      "endLine": "145",
      "endCol": "63"
    },
    "1978": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "148",
      "startCol": "9",
      "endLine": "148",
      "endCol": "47"
    },
    "1979": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "189",
      "startCol": "5",
      "endLine": "189",
      "endCol": "50"
    },
    "1980": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "192",
      "startCol": "9",
      "endLine": "192",
      "endCol": "50"
    },
    "1981": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "202",
      "startCol": "5",
      "endLine": "202",
      "endCol": "53"
    },
    "1982": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "205",
      "startCol": "3",
      "endLine": "205",
      "endCol": "82"
    },
    "1983": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "213",
      "startCol": "5",
      "endLine": "217",
      "endCol": "5"
    },
    "1984": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/isAuthenticated.js",
      "startLine": "8",
      "startCol": "3",
      "endLine": "8",
      "endCol": "14"
    },
    "1985": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "15",
      "startCol": "22",
      "endLine": "15",
      "endCol": "89"
    },
    "1986": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "22",
      "startCol": "24",
      "endLine": "24",
      "endCol": "48"
    },
    "1987": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "36",
      "startCol": "14",
      "endLine": "36",
      "endCol": "25"
    },
    "1988": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "5",
      "startCol": "18",
      "endLine": "89",
      "endCol": "1"
    },
    "1989": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "39",
      "startCol": "19",
      "endLine": "43",
      "endCol": "6"
    },
    "1990": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "46",
      "startCol": "13",
      "endLine": "46",
      "endCol": "48"
    },
    "1991": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "63",
      "startCol": "12",
      "endLine": "63",
      "endCol": "90"
    },
    "1992": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "67",
      "startCol": "22",
      "endLine": "76",
      "endCol": "3"
    },
    "1993": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "84",
      "startCol": "12",
      "endLine": "84",
      "endCol": "98"
    },
    "1994": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "88",
      "startCol": "3",
      "endLine": "88",
      "endCol": "14"
    },
    "1995": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "82",
      "startCol": "11",
      "endLine": "82",
      "endCol": "97"
    },
    "1996": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "93",
      "startCol": "11",
      "endLine": "93",
      "endCol": "98"
    },
    "1997": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "104",
      "startCol": "11",
      "endLine": "106",
      "endCol": "11"
    },
    "1998": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "118",
      "startCol": "11",
      "endLine": "120",
      "endCol": "11"
    },
    "1999": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "132",
      "startCol": "11",
      "endLine": "134",
      "endCol": "11"
    },
    "2000": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "146",
      "startCol": "11",
      "endLine": "146",
      "endCol": "84"
    },
    "2001": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "160",
      "startCol": "11",
      "endLine": "160",
      "endCol": "84"
    },
    "2002": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "177",
      "startCol": "11",
      "endLine": "177",
      "endCol": "85"
    },
    "2003": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "182",
      "startCol": "11",
      "endLine": "182",
      "endCol": "85"
    },
    "2004": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "195",
      "startCol": "11",
      "endLine": "195",
      "endCol": "86"
    },
    "2005": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "214",
      "startCol": "11",
      "endLine": "214",
      "endCol": "86"
    },
    "2006": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "230",
      "startCol": "11",
      "endLine": "230",
      "endCol": "92"
    },
    "2007": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "246",
      "startCol": "11",
      "endLine": "246",
      "endCol": "91"
    },
    "2008": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "263",
      "startCol": "11",
      "endLine": "267",
      "endCol": "11"
    },
    "2009": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "25",
      "startCol": "19",
      "endLine": "29",
      "endCol": "6"
    },
    "2010": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "32",
      "startCol": "18",
      "endLine": "32",
      "endCol": "50"
    },
    "2011": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "71",
      "startCol": "20",
      "endLine": "71",
      "endCol": "81"
    },
    "2012": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "84",
      "startCol": "15",
      "endLine": "84",
      "endCol": "50"
    },
    "2013": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "118",
      "startCol": "29",
      "endLine": "120",
      "endCol": "70"
    },
    "2014": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "141",
      "startCol": "18",
      "endLine": "141",
      "endCol": "50"
    },
    "2015": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "154",
      "startCol": "25",
      "endLine": "157",
      "endCol": "9"
    },
    "2016": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "186",
      "startCol": "20",
      "endLine": "188",
      "endCol": "58"
    },
    "2017": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "200",
      "startCol": "24",
      "endLine": "202",
      "endCol": "8"
    },
    "2018": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "205",
      "startCol": "7",
      "endLine": "207",
      "endCol": "72"
    },
    "2019": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "241",
      "startCol": "25",
      "endLine": "248",
      "endCol": "12"
    },
    "2020": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "290",
      "startCol": "25",
      "endLine": "294",
      "endCol": "6"
    },
    "2021": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "297",
      "startCol": "18",
      "endLine": "299",
      "endCol": "46"
    },
    "2022": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "315",
      "startCol": "22",
      "endLine": "321",
      "endCol": "6"
    },
    "2023": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "323",
      "startCol": "22",
      "endLine": "325",
      "endCol": "6"
    },
    "2024": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "331",
      "startCol": "24",
      "endLine": "338",
      "endCol": "5"
    },
    "2025": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "340",
      "startCol": "23",
      "endLine": "345",
      "endCol": "5"
    },
    "2026": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "349",
      "startCol": "7",
      "endLine": "359",
      "endCol": "8"
    },
    "2027": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "365",
      "startCol": "5",
      "endLine": "365",
      "endCol": "99"
    },
    "2028": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "371",
      "startCol": "25",
      "endLine": "375",
      "endCol": "6"
    },
    "2029": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "377",
      "startCol": "22",
      "endLine": "379",
      "endCol": "6"
    },
    "2030": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "430",
      "startCol": "18",
      "endLine": "432",
      "endCol": "51"
    },
    "2031": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "460",
      "startCol": "23",
      "endLine": "460",
      "endCol": "98"
    },
    "2032": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "462",
      "startCol": "18",
      "endLine": "464",
      "endCol": "6"
    },
    "2033": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "491",
      "startCol": "20",
      "endLine": "491",
      "endCol": "81"
    },
    "2034": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "499",
      "startCol": "11",
      "endLine": "499",
      "endCol": "93"
    },
    "2035": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "534",
      "startCol": "18",
      "endLine": "534",
      "endCol": "67"
    },
    "2036": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "540",
      "startCol": "5",
      "endLine": "540",
      "endCol": "89"
    },
    "2037": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "550",
      "startCol": "24",
      "endLine": "557",
      "endCol": "14"
    },
    "2038": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "578",
      "startCol": "18",
      "endLine": "580",
      "endCol": "6"
    },
    "2039": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "591",
      "startCol": "7",
      "endLine": "591",
      "endCol": "89"
    },
    "2040": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "51",
      "startCol": "15",
      "endLine": "51",
      "endCol": "89"
    },
    "2041": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "53",
      "startCol": "15",
      "endLine": "53",
      "endCol": "99"
    },
    "2042": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "65",
      "startCol": "16",
      "endLine": "67",
      "endCol": "6"
    },
    "2043": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "83",
      "startCol": "14",
      "endLine": "83",
      "endCol": "91"
    },
    "2044": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "81",
      "startCol": "14",
      "endLine": "86",
      "endCol": "3"
    },
    "2045": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "85",
      "startCol": "16",
      "endLine": "85",
      "endCol": "87"
    },
    "2046": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "94",
      "startCol": "18",
      "endLine": "94",
      "endCol": "87"
    },
    "2047": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "107",
      "startCol": "18",
      "endLine": "107",
      "endCol": "94"
    },
    "2048": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "24",
      "startCol": "7",
      "endLine": "26",
      "endCol": "7"
    },
    "2049": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "37",
      "startCol": "24",
      "endLine": "37",
      "endCol": "98"
    },
    "2050": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "53",
      "startCol": "7",
      "endLine": "56",
      "endCol": "7"
    },
    "2051": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "67",
      "startCol": "27",
      "endLine": "69",
      "endCol": "46"
    },
    "2052": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "89",
      "startCol": "21",
      "endLine": "91",
      "endCol": "5"
    },
    "2053": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "92",
      "startCol": "18",
      "endLine": "95",
      "endCol": "5"
    },
    "2054": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "106",
      "startCol": "21",
      "endLine": "106",
      "endCol": "98"
    },
    "2055": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "116",
      "startCol": "22",
      "endLine": "118",
      "endCol": "45"
    },
    "2056": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "134",
      "startCol": "18",
      "endLine": "136",
      "endCol": "6"
    },
    "2057": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "149",
      "startCol": "7",
      "endLine": "152",
      "endCol": "7"
    },
    "2058": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "163",
      "startCol": "7",
      "endLine": "170",
      "endCol": "14"
    },
    "2059": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "189",
      "startCol": "5",
      "endLine": "196",
      "endCol": "37"
    },
    "2060": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "203",
      "startCol": "17",
      "endLine": "210",
      "endCol": "14"
    },
    "2061": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "211",
      "startCol": "14",
      "endLine": "211",
      "endCol": "91"
    },
    "2062": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "220",
      "startCol": "5",
      "endLine": "227",
      "endCol": "39"
    },
    "2063": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "233",
      "startCol": "23",
      "endLine": "240",
      "endCol": "12"
    },
    "2064": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "258",
      "startCol": "5",
      "endLine": "265",
      "endCol": "49"
    },
    "2065": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "22",
      "startCol": "18",
      "endLine": "22",
      "endCol": "80"
    },
    "2066": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "31",
      "startCol": "7",
      "endLine": "31",
      "endCol": "99"
    },
    "2067": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "66",
      "startCol": "22",
      "endLine": "73",
      "endCol": "12"
    },
    "2068": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "79",
      "startCol": "34",
      "endLine": "81",
      "endCol": "28"
    },
    "2069": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "95",
      "startCol": "33",
      "endLine": "97",
      "endCol": "48"
    },
    "2070": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "122",
      "startCol": "27",
      "endLine": "124",
      "endCol": "53"
    },
    "2071": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "130",
      "startCol": "20",
      "endLine": "130",
      "endCol": "84"
    },
    "2072": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "143",
      "startCol": "29",
      "endLine": "150",
      "endCol": "12"
    },
    "2073": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "179",
      "startCol": "36",
      "endLine": "181",
      "endCol": "30"
    },
    "2074": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "196",
      "startCol": "33",
      "endLine": "198",
      "endCol": "48"
    },
    "2075": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "220",
      "startCol": "18",
      "endLine": "220",
      "endCol": "97"
    },
    "2076": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "21",
      "startCol": "22",
      "endLine": "28",
      "endCol": "12"
    },
    "2077": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "36",
      "startCol": "34",
      "endLine": "38",
      "endCol": "28"
    },
    "2078": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "52",
      "startCol": "33",
      "endLine": "54",
      "endCol": "48"
    },
    "2079": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "77",
      "startCol": "27",
      "endLine": "79",
      "endCol": "53"
    },
    "2080": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "85",
      "startCol": "20",
      "endLine": "85",
      "endCol": "84"
    },
    "2081": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "98",
      "startCol": "29",
      "endLine": "105",
      "endCol": "12"
    },
    "2082": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "110",
      "startCol": "18",
      "endLine": "112",
      "endCol": "6"
    },
    "2083": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "127",
      "startCol": "36",
      "endLine": "129",
      "endCol": "30"
    },
    "2084": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "144",
      "startCol": "33",
      "endLine": "146",
      "endCol": "48"
    },
    "2085": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "169",
      "startCol": "18",
      "endLine": "169",
      "endCol": "97"
    },
    "2086": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "47",
      "startCol": "23",
      "endLine": "49",
      "endCol": "10"
    },
    "2087": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "51",
      "startCol": "26",
      "endLine": "58",
      "endCol": "16"
    },
    "2088": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "86",
      "startCol": "29",
      "endLine": "88",
      "endCol": "55"
    },
    "2089": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "97",
      "startCol": "29",
      "endLine": "97",
      "endCol": "90"
    },
    "2090": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "117",
      "startCol": "17",
      "endLine": "124",
      "endCol": "10"
    },
    "2091": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "41",
      "startCol": "25",
      "endLine": "43",
      "endCol": "7"
    },
    "2092": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "55",
      "startCol": "25",
      "endLine": "57",
      "endCol": "7"
    },
    "2093": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "128",
      "startCol": "25",
      "endLine": "132",
      "endCol": "6"
    },
    "2094": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "134",
      "startCol": "22",
      "endLine": "136",
      "endCol": "67"
    },
    "2095": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "146",
      "startCol": "24",
      "endLine": "150",
      "endCol": "6"
    },
    "2096": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "152",
      "startCol": "23",
      "endLine": "152",
      "endCol": "95"
    },
    "2097": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "155",
      "startCol": "5",
      "endLine": "165",
      "endCol": "6"
    },
    "2098": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "46",
      "startCol": "18",
      "endLine": "48",
      "endCol": "55"
    },
    "2099": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "79",
      "startCol": "12",
      "endLine": "79",
      "endCol": "45"
    },
    "2100": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "41",
      "startCol": "19",
      "endLine": "80",
      "endCol": "3"
    },
    "2101": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "83",
      "startCol": "18",
      "endLine": "85",
      "endCol": "56"
    },
    "2102": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "119",
      "startCol": "12",
      "endLine": "119",
      "endCol": "45"
    },
    "2103": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "82",
      "startCol": "19",
      "endLine": "120",
      "endCol": "3"
    },
    "2104": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "191",
      "startCol": "18",
      "endLine": "193",
      "endCol": "47"
    },
    "2105": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "221",
      "startCol": "19",
      "endLine": "221",
      "endCol": "93"
    },
    "2106": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "224",
      "startCol": "27",
      "endLine": "226",
      "endCol": "37"
    },
    "2107": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "256",
      "startCol": "19",
      "endLine": "256",
      "endCol": "78"
    },
    "2108": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "259",
      "startCol": "27",
      "endLine": "261",
      "endCol": "27"
    },
    "2109": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "317",
      "startCol": "7",
      "endLine": "328",
      "endCol": "7"
    },
    "2110": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "330",
      "startCol": "7",
      "endLine": "335",
      "endCol": "7"
    },
    "2111": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "340",
      "startCol": "23",
      "endLine": "340",
      "endCol": "77"
    },
    "2112": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "343",
      "startCol": "7",
      "endLine": "347",
      "endCol": "8"
    },
    "2113": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "349",
      "startCol": "7",
      "endLine": "353",
      "endCol": "8"
    },
    "2114": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "360",
      "startCol": "35",
      "endLine": "363",
      "endCol": "6"
    },
    "2115": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "365",
      "startCol": "5",
      "endLine": "367",
      "endCol": "68"
    },
    "2116": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "369",
      "startCol": "5",
      "endLine": "398",
      "endCol": "5"
    },
    "2117": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "402",
      "startCol": "5",
      "endLine": "402",
      "endCol": "78"
    },
    "2118": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "405",
      "startCol": "5",
      "endLine": "405",
      "endCol": "88"
    },
    "2119": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "14",
      "startCol": "15",
      "endLine": "14",
      "endCol": "49"
    },
    "2120": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "24",
      "startCol": "19",
      "endLine": "39",
      "endCol": "8"
    },
    "2121": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "55",
      "startCol": "19",
      "endLine": "74",
      "endCol": "8"
    },
    "2122": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "95",
      "startCol": "19",
      "endLine": "115",
      "endCol": "8"
    },
    "2123": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "131",
      "startCol": "19",
      "endLine": "149",
      "endCol": "8"
    },
    "2124": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "170",
      "startCol": "19",
      "endLine": "188",
      "endCol": "8"
    },
    "2125": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "204",
      "startCol": "19",
      "endLine": "222",
      "endCol": "8"
    },
    "2126": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js",
      "startLine": "45",
      "startCol": "10",
      "endLine": "45",
      "endCol": "44"
    },
    "2127": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js",
      "startLine": "47",
      "startCol": "17",
      "endLine": "47",
      "endCol": "38"
    },
    "2128": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js",
      "startLine": "52",
      "startCol": "5",
      "endLine": "52",
      "endCol": "26"
    },
    "2129": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js",
      "startLine": "57",
      "startCol": "17",
      "endLine": "65",
      "endCol": "6"
    },
    "2130": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js",
      "startLine": "72",
      "startCol": "17",
      "endLine": "75",
      "endCol": "6"
    },
    "2131": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js",
      "startLine": "86",
      "startCol": "17",
      "endLine": "89",
      "endCol": "6"
    },
    "2132": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-api.test.e2e.js",
      "startLine": "15",
      "startCol": "10",
      "endLine": "15",
      "endCol": "44"
    },
    "2133": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-api.test.e2e.js",
      "startLine": "29",
      "startCol": "17",
      "endLine": "33",
      "endCol": "6"
    },
    "2134": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-api.test.e2e.js",
      "startLine": "47",
      "startCol": "17",
      "endLine": "50",
      "endCol": "6"
    },
    "2135": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-graphql.test.e2e.js",
      "startLine": "16",
      "startCol": "10",
      "endLine": "16",
      "endCol": "44"
    },
    "2136": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-graphql.test.e2e.js",
      "startLine": "39",
      "startCol": "19",
      "endLine": "54",
      "endCol": "8"
    },
    "2137": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-graphql.test.e2e.js",
      "startLine": "74",
      "startCol": "19",
      "endLine": "92",
      "endCol": "8"
    },
    "2138": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-graphql.test.e2e.js",
      "startLine": "112",
      "startCol": "19",
      "endLine": "129",
      "endCol": "8"
    },
    "2139": {
      "patternID": "pattern3",
      "file": "packages/strapi-provider-upload-cloudinary/lib/index.js",
      "startLine": "63",
      "startCol": "28",
      "endLine": "67",
      "endCol": "12"
    },
    "2140": {
      "patternID": "pattern3",
      "file": "packages/strapi-utils/lib/policy.js",
      "startLine": "68",
      "startCol": "5",
      "endLine": "68",
      "endCol": "16"
    },
    "2141": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "9",
      "startCol": "16",
      "endLine": "9",
      "endCol": "53"
    },
    "2142": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "19",
      "startCol": "3",
      "endLine": "19",
      "endCol": "69"
    },
    "2143": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "27",
      "startCol": "29",
      "endLine": "27",
      "endCol": "51"
    },
    "2144": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "39",
      "startCol": "7",
      "endLine": "39",
      "endCol": "58"
    },
    "2145": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "45",
      "startCol": "3",
      "endLine": "45",
      "endCol": "66"
    },
    "2146": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "49",
      "startCol": "23",
      "endLine": "49",
      "endCol": "46"
    },
    "2147": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "72",
      "startCol": "3",
      "endLine": "72",
      "endCol": "72"
    },
    "2148": {
      "patternID": "pattern3",
      "file": "scripts/link.js",
      "startLine": "10",
      "startCol": "23",
      "endLine": "10",
      "endCol": "46"
    },
    "2149": {
      "patternID": "pattern3",
      "file": "scripts/link.js",
      "startLine": "19",
      "startCol": "3",
      "endLine": "19",
      "endCol": "85"
    },
    "2150": {
      "patternID": "pattern3",
      "file": "scripts/open-api/serve.js",
      "startLine": "23",
      "startCol": "9",
      "endLine": "23",
      "endCol": "45"
    },
    "2151": {
      "patternID": "pattern3",
      "file": "scripts/open-api/serve.js",
      "startLine": "35",
      "startCol": "16",
      "endLine": "35",
      "endCol": "51"
    },
    "2152": {
      "patternID": "pattern3",
      "file": "scripts/unlink.js",
      "startLine": "10",
      "startCol": "23",
      "endLine": "10",
      "endCol": "46"
    },
    "2153": {
      "patternID": "pattern3",
      "file": "scripts/unlink.js",
      "startLine": "19",
      "startCol": "3",
      "endLine": "19",
      "endCol": "87"
    },
    "2154": {
      "patternID": "pattern3",
      "file": "test/e2e.js",
      "startLine": "55",
      "startCol": "5",
      "endLine": "59",
      "endCol": "6"
    },
    "2155": {
      "patternID": "pattern3",
      "file": "test/helpers/agent.js",
      "startLine": "71",
      "startCol": "31",
      "endLine": "71",
      "endCol": "57"
    },
    "2156": {
      "patternID": "pattern3",
      "file": "test/helpers/agent.js",
      "startLine": "79",
      "startCol": "31",
      "endLine": "79",
      "endCol": "74"
    },
    "2157": {
      "patternID": "pattern3",
      "file": "test/helpers/auth.js",
      "startLine": "15",
      "startCol": "3",
      "endLine": "23",
      "endCol": "4"
    },
    "2158": {
      "patternID": "pattern3",
      "file": "test/helpers/auth.js",
      "startLine": "27",
      "startCol": "20",
      "endLine": "34",
      "endCol": "4"
    },
    "2159": {
      "patternID": "pattern3",
      "file": "test/helpers/builder/index.js",
      "startLine": "68",
      "startCol": "9",
      "endLine": "68",
      "endCol": "31"
    },
    "2160": {
      "patternID": "pattern3",
      "file": "test/helpers/builder/index.js",
      "startLine": "85",
      "startCol": "9",
      "endLine": "85",
      "endCol": "33"
    },
    "2161": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "28",
      "startCol": "23",
      "endLine": "33",
      "endCol": "4"
    },
    "2162": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "35",
      "startCol": "3",
      "endLine": "35",
      "endCol": "17"
    },
    "2163": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "43",
      "startCol": "24",
      "endLine": "50",
      "endCol": "3"
    },
    "2164": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "52",
      "startCol": "3",
      "endLine": "52",
      "endCol": "17"
    },
    "2165": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "60",
      "startCol": "28",
      "endLine": "67",
      "endCol": "4"
    },
    "2166": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "69",
      "startCol": "3",
      "endLine": "69",
      "endCol": "17"
    },
    "2167": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "87",
      "startCol": "21",
      "endLine": "87",
      "endCol": "73"
    },
    "2168": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "89",
      "startCol": "3",
      "endLine": "89",
      "endCol": "17"
    },
    "2169": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "108",
      "startCol": "23",
      "endLine": "108",
      "endCol": "69"
    },
    "2170": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "110",
      "startCol": "3",
      "endLine": "110",
      "endCol": "17"
    },
    "2171": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "119",
      "startCol": "24",
      "endLine": "119",
      "endCol": "89"
    },
    "2172": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "121",
      "startCol": "3",
      "endLine": "121",
      "endCol": "17"
    },
    "2173": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "135",
      "startCol": "3",
      "endLine": "135",
      "endCol": "36"
    },
    "2174": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "137",
      "startCol": "3",
      "endLine": "137",
      "endCol": "17"
    },
    "2175": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "149",
      "startCol": "20",
      "endLine": "149",
      "endCol": "57"
    },
    "2176": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "155",
      "startCol": "3",
      "endLine": "155",
      "endCol": "17"
    },
    "2177": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "166",
      "startCol": "18",
      "endLine": "166",
      "endCol": "63"
    },
    "2178": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "169",
      "startCol": "3",
      "endLine": "169",
      "endCol": "17"
    },
    "2179": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "177",
      "startCol": "3",
      "endLine": "177",
      "endCol": "70"
    },
    "2180": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "179",
      "startCol": "3",
      "endLine": "179",
      "endCol": "17"
    },
    "2181": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "191",
      "startCol": "14",
      "endLine": "196",
      "endCol": "4"
    },
    "2182": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "198",
      "startCol": "3",
      "endLine": "198",
      "endCol": "17"
    },
    "2183": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "209",
      "startCol": "3",
      "endLine": "209",
      "endCol": "17"
    },
    "2184": {
      "patternID": "pattern3",
      "file": "test/helpers/strapi.js",
      "startLine": "27",
      "startCol": "3",
      "endLine": "31",
      "endCol": "42"
    },
    "2185": {
      "patternID": "pattern3",
      "file": "test/helpers/strapi.js",
      "startLine": "36",
      "startCol": "5",
      "endLine": "36",
      "endCol": "60"
    },
    "2186": {
      "patternID": "pattern3",
      "file": "test/helpers/utils.js",
      "startLine": "8",
      "startCol": "18",
      "endLine": "8",
      "endCol": "76"
    },
    "2187": {
      "patternID": "pattern3",
      "file": "test/helpers/utils.js",
      "startLine": "24",
      "startCol": "28",
      "endLine": "24",
      "endCol": "89"
    },
    "2188": {
      "patternID": "pattern3",
      "file": "test/helpers/utils.js",
      "startLine": "41",
      "startCol": "20",
      "endLine": "41",
      "endCol": "54"
    }
  },
  "files": {
    "node_modules/jest-jasmine2/build/queueRunner.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = queueRunner;\n\nvar _jestUtil = require('jest-util');\n\nvar _PCancelable = _interopRequireDefault(require('./PCancelable'));\n\nvar _pTimeout = _interopRequireDefault(require('./pTimeout'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction queueRunner(options) {\n  const token = new _PCancelable.default((onCancel, resolve) => {\n    onCancel(resolve);\n  });\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];\n\n        if (err) {\n          options.fail.apply(null, args);\n        }\n\n        resolve();\n      };\n\n      next.fail = function (...args) {\n        options.fail.apply(null, args);\n        resolve();\n      };\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve();\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise;\n    }\n\n    const timeoutMs = timeout();\n    return (0, _pTimeout.default)(\n      promise,\n      timeoutMs,\n      options.clearTimeout,\n      options.setTimeout,\n      () => {\n        initError.message =\n          'Timeout - Async callback was not invoked within the ' +\n          (0, _jestUtil.formatTime)(timeoutMs) +\n          ' timeout specified by jest.setTimeout.';\n        initError.stack = initError.message + initError.stack;\n        options.onException(initError);\n      }\n    );\n  };\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token),\n    catch: result.catch.bind(result),\n    then: result.then.bind(result)\n  };\n}\n",
    "node_modules/jest-jasmine2/build/treeProcessor.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = treeProcessor;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nfunction treeProcessor(options) {\n  const {\n    nodeComplete,\n    nodeStart,\n    queueRunnerFactory,\n    runnableIds,\n    tree\n  } = options;\n\n  function isEnabled(node, parentEnabled) {\n    return parentEnabled || runnableIds.indexOf(node.id) !== -1;\n  }\n\n  function getNodeHandler(node, parentEnabled) {\n    const enabled = isEnabled(node, parentEnabled);\n    return node.children\n      ? getNodeWithChildrenHandler(node, enabled)\n      : getNodeWithoutChildrenHandler(node, enabled);\n  }\n\n  function getNodeWithoutChildrenHandler(node, enabled) {\n    return function fn(done = () => {}) {\n      node.execute(done, enabled);\n    };\n  }\n\n  function getNodeWithChildrenHandler(node, enabled) {\n    return async function fn(done = () => {}) {\n      nodeStart(node);\n      await queueRunnerFactory({\n        onException: error => node.onException(error),\n        queueableFns: wrapChildren(node, enabled),\n        userContext: node.sharedUserContext()\n      });\n      nodeComplete(node);\n      done();\n    };\n  }\n\n  function hasNoEnabledTest(node) {\n    if (node.children) {\n      return node.children.every(hasNoEnabledTest);\n    }\n\n    return node.disabled || node.markedPending;\n  }\n\n  function wrapChildren(node, enabled) {\n    if (!node.children) {\n      throw new Error('`node.children` is not defined.');\n    }\n\n    const children = node.children.map(child => ({\n      fn: getNodeHandler(child, enabled)\n    }));\n\n    if (hasNoEnabledTest(node)) {\n      return children;\n    }\n\n    return node.beforeAllFns.concat(children).concat(node.afterAllFns);\n  }\n\n  const treeHandler = getNodeHandler(tree, false);\n  return treeHandler();\n}\n",
    "node_modules/jest-runner/build/runTest.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = runTest;\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _sourceMapSupport() {\n  const data = _interopRequireDefault(require('source-map-support'));\n\n  _sourceMapSupport = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _console() {\n  const data = require('@jest/console');\n\n  _console = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestConfig() {\n  const data = require('jest-config');\n\n  _jestConfig = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction docblock() {\n  const data = _interopRequireWildcard(require('jest-docblock'));\n\n  docblock = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestLeakDetector() {\n  const data = _interopRequireDefault(require('jest-leak-detector'));\n\n  _jestLeakDetector = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRuntime() {\n  const data = _interopRequireDefault(require('jest-runtime'));\n\n  _jestRuntime = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction freezeConsole(testConsole, config) {\n  // @ts-expect-error: `_log` is `private` - we should figure out some proper API here\n  testConsole._log = function fakeConsolePush(_type, message) {\n    const error = new (_jestUtil().ErrorWithStack)(\n      `${_chalk().default.red(\n        `${_chalk().default.bold(\n          'Cannot log after tests are done.'\n        )} Did you forget to wait for something async in your test?`\n      )}\\nAttempted to log \"${message}\".`,\n      fakeConsolePush\n    );\n    const formattedError = (0, _jestMessageUtil().formatExecError)(\n      error,\n      config,\n      {\n        noStackTrace: false\n      },\n      undefined,\n      true\n    );\n    process.stderr.write('\\n' + formattedError + '\\n'); // TODO: set exit code in Jest 25\n    // process.exitCode = 1;\n  };\n} // Keeping the core of \"runTest\" as a separate function (as \"runTestInternal\")\n// is key to be able to detect memory leaks. Since all variables are local to\n// the function, when \"runTestInternal\" finishes its execution, they can all be\n// freed, UNLESS something else is leaking them (and that's why we can detect\n// the leak!).\n//\n// If we had all the code in a single function, we should manually nullify all\n// references to verify if there is a leak, which is not maintainable and error\n// prone. That's why \"runTestInternal\" CANNOT be inlined inside \"runTest\".\n\nasync function runTestInternal(\n  path,\n  globalConfig,\n  config,\n  resolver,\n  context,\n  sendMessageToJest\n) {\n  const testSource = fs().readFileSync(path, 'utf8');\n  const docblockPragmas = docblock().parse(docblock().extract(testSource));\n  const customEnvironment = docblockPragmas['jest-environment'];\n  let testEnvironment = config.testEnvironment;\n\n  if (customEnvironment) {\n    if (Array.isArray(customEnvironment)) {\n      throw new Error(\n        `You can only define a single test environment through docblocks, got \"${customEnvironment.join(\n          ', '\n        )}\"`\n      );\n    }\n\n    testEnvironment = (0, _jestConfig().getTestEnvironment)({\n      ...config,\n      testEnvironment: customEnvironment\n    });\n  }\n\n  const TestEnvironment = (0, _jestUtil().interopRequireDefault)(\n    require(testEnvironment)\n  ).default;\n  const testFramework = (0, _jestUtil().interopRequireDefault)(\n    process.env.JEST_CIRCUS === '1' // eslint-disable-next-line import/no-extraneous-dependencies\n      ? require('jest-circus/runner')\n      : require(config.testRunner)\n  ).default;\n  const Runtime = (0, _jestUtil().interopRequireDefault)(\n    config.moduleLoader ? require(config.moduleLoader) : require('jest-runtime')\n  ).default;\n  const consoleOut = globalConfig.useStderr ? process.stderr : process.stdout;\n\n  const consoleFormatter = (type, message) =>\n    (0, _console().getConsoleOutput)(\n      config.cwd,\n      !!globalConfig.verbose, // 4 = the console call is buried 4 stack frames deep\n      _console().BufferedConsole.write([], type, message, 4),\n      config,\n      globalConfig\n    );\n\n  let testConsole;\n\n  if (globalConfig.silent) {\n    testConsole = new (_console().NullConsole)(\n      consoleOut,\n      consoleOut,\n      consoleFormatter\n    );\n  } else if (globalConfig.verbose) {\n    testConsole = new (_console().CustomConsole)(\n      consoleOut,\n      consoleOut,\n      consoleFormatter\n    );\n  } else {\n    testConsole = new (_console().BufferedConsole)();\n  }\n\n  const environment = new TestEnvironment(config, {\n    console: testConsole,\n    docblockPragmas,\n    testPath: path\n  });\n  const leakDetector = config.detectLeaks\n    ? new (_jestLeakDetector().default)(environment)\n    : null;\n  const cacheFS = {\n    [path]: testSource\n  };\n  (0, _jestUtil().setGlobal)(environment.global, 'console', testConsole);\n  const runtime = new Runtime(\n    config,\n    environment,\n    resolver,\n    cacheFS,\n    {\n      changedFiles:\n        context === null || context === void 0 ? void 0 : context.changedFiles,\n      collectCoverage: globalConfig.collectCoverage,\n      collectCoverageFrom: globalConfig.collectCoverageFrom,\n      collectCoverageOnlyFrom: globalConfig.collectCoverageOnlyFrom,\n      coverageProvider: globalConfig.coverageProvider,\n      sourcesRelatedToTestsInChangedFiles:\n        context === null || context === void 0\n          ? void 0\n          : context.sourcesRelatedToTestsInChangedFiles\n    },\n    path\n  );\n  const start = Date.now();\n\n  for (const path of config.setupFiles) {\n    var _runtime$unstable_sho;\n\n    // TODO: remove ? in Jest 26\n    const esm =\n      (_runtime$unstable_sho = runtime.unstable_shouldLoadAsEsm) === null ||\n      _runtime$unstable_sho === void 0\n        ? void 0\n        : _runtime$unstable_sho.call(runtime, path);\n\n    if (esm) {\n      await runtime.unstable_importModule(path);\n    } else {\n      runtime.requireModule(path);\n    }\n  }\n\n  const sourcemapOptions = {\n    environment: 'node',\n    handleUncaughtExceptions: false,\n    retrieveSourceMap: source => {\n      const sourceMaps = runtime.getSourceMaps();\n      const sourceMapSource = sourceMaps && sourceMaps[source];\n\n      if (sourceMapSource) {\n        try {\n          return {\n            map: JSON.parse(fs().readFileSync(sourceMapSource, 'utf8')),\n            url: source\n          };\n        } catch {}\n      }\n\n      return null;\n    }\n  }; // For tests\n\n  runtime\n    .requireInternalModule(\n      require.resolve('source-map-support'),\n      'source-map-support'\n    )\n    .install(sourcemapOptions); // For runtime errors\n\n  _sourceMapSupport().default.install(sourcemapOptions);\n\n  if (\n    environment.global &&\n    environment.global.process &&\n    environment.global.process.exit\n  ) {\n    const realExit = environment.global.process.exit;\n\n    environment.global.process.exit = function exit(...args) {\n      const error = new (_jestUtil().ErrorWithStack)(\n        `process.exit called with \"${args.join(', ')}\"`,\n        exit\n      );\n      const formattedError = (0, _jestMessageUtil().formatExecError)(\n        error,\n        config,\n        {\n          noStackTrace: false\n        },\n        undefined,\n        true\n      );\n      process.stderr.write(formattedError);\n      return realExit(...args);\n    };\n  } // if we don't have `getVmContext` on the env skip coverage\n\n  const collectV8Coverage =\n    globalConfig.coverageProvider === 'v8' &&\n    typeof environment.getVmContext === 'function';\n\n  try {\n    await environment.setup();\n    let result;\n\n    try {\n      if (collectV8Coverage) {\n        await runtime.collectV8Coverage();\n      }\n\n      result = await testFramework(\n        globalConfig,\n        config,\n        environment,\n        runtime,\n        path,\n        sendMessageToJest\n      );\n    } catch (err) {\n      // Access stack before uninstalling sourcemaps\n      err.stack;\n      throw err;\n    } finally {\n      if (collectV8Coverage) {\n        await runtime.stopCollectingV8Coverage();\n      }\n    }\n\n    freezeConsole(testConsole, config);\n    const testCount =\n      result.numPassingTests +\n      result.numFailingTests +\n      result.numPendingTests +\n      result.numTodoTests;\n    const end = Date.now();\n    const testRuntime = end - start;\n    result.perfStats = {\n      end,\n      runtime: testRuntime,\n      slow: testRuntime / 1000 > config.slowTestThreshold,\n      start\n    };\n    result.testFilePath = path;\n    result.console = testConsole.getBuffer();\n    result.skipped = testCount === result.numPendingTests;\n    result.displayName = config.displayName;\n    const coverage = runtime.getAllCoverageInfoCopy();\n\n    if (coverage) {\n      const coverageKeys = Object.keys(coverage);\n\n      if (coverageKeys.length) {\n        result.coverage = coverage;\n      }\n    }\n\n    if (collectV8Coverage) {\n      const v8Coverage = runtime.getAllV8CoverageInfoCopy();\n\n      if (v8Coverage && v8Coverage.length > 0) {\n        result.v8Coverage = v8Coverage;\n      }\n    }\n\n    if (globalConfig.logHeapUsage) {\n      if (global.gc) {\n        global.gc();\n      }\n\n      result.memoryUsage = process.memoryUsage().heapUsed;\n    } // Delay the resolution to allow log messages to be output.\n\n    return new Promise(resolve => {\n      setImmediate(() =>\n        resolve({\n          leakDetector,\n          result\n        })\n      );\n    });\n  } finally {\n    var _runtime$teardown;\n\n    await environment.teardown(); // TODO: this function might be missing, remove ? in Jest 26\n\n    (_runtime$teardown = runtime.teardown) === null ||\n    _runtime$teardown === void 0\n      ? void 0\n      : _runtime$teardown.call(runtime);\n\n    _sourceMapSupport().default.resetRetrieveHandlers();\n  }\n}\n\nasync function runTest(\n  path,\n  globalConfig,\n  config,\n  resolver,\n  context,\n  sendMessageToJest\n) {\n  const {leakDetector, result} = await runTestInternal(\n    path,\n    globalConfig,\n    config,\n    resolver,\n    context,\n    sendMessageToJest\n  );\n\n  if (leakDetector) {\n    // We wanna allow a tiny but time to pass to allow last-minute cleanup\n    await new Promise(resolve => setTimeout(resolve, 100)); // Resolve leak detector, outside the \"runTestInternal\" closure.\n\n    result.leaks = await leakDetector.isLeaking();\n  } else {\n    result.leaks = false;\n  }\n\n  return result;\n}\n",
    "node_modules/jest-jasmine2/build/jasmine/Spec.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _assert = require('assert');\n\nvar _ExpectationFailed = _interopRequireDefault(\n  require('../ExpectationFailed')\n);\n\nvar _assertionErrorMessage = _interopRequireDefault(\n  require('../assertionErrorMessage')\n);\n\nvar _expectationResultFactory = _interopRequireDefault(\n  require('../expectationResultFactory')\n);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nclass Spec {\n  static isPendingSpecException(e) {\n    return !!(\n      e &&\n      e.toString &&\n      e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1\n    );\n  }\n\n  constructor(attrs) {\n    _defineProperty(this, 'id', void 0);\n\n    _defineProperty(this, 'description', void 0);\n\n    _defineProperty(this, 'resultCallback', void 0);\n\n    _defineProperty(this, 'queueableFn', void 0);\n\n    _defineProperty(this, 'beforeAndAfterFns', void 0);\n\n    _defineProperty(this, 'userContext', void 0);\n\n    _defineProperty(this, 'onStart', void 0);\n\n    _defineProperty(this, 'getSpecName', void 0);\n\n    _defineProperty(this, 'queueRunnerFactory', void 0);\n\n    _defineProperty(this, 'throwOnExpectationFailure', void 0);\n\n    _defineProperty(this, 'initError', void 0);\n\n    _defineProperty(this, 'result', void 0);\n\n    _defineProperty(this, 'disabled', void 0);\n\n    _defineProperty(this, 'currentRun', void 0);\n\n    _defineProperty(this, 'markedTodo', void 0);\n\n    _defineProperty(this, 'markedPending', void 0);\n\n    _defineProperty(this, 'expand', void 0);\n\n    this.resultCallback = attrs.resultCallback || function () {};\n\n    this.id = attrs.id;\n    this.description = attrs.description || '';\n    this.queueableFn = attrs.queueableFn;\n\n    this.beforeAndAfterFns =\n      attrs.beforeAndAfterFns ||\n      function () {\n        return {\n          befores: [],\n          afters: []\n        };\n      };\n\n    this.userContext =\n      attrs.userContext ||\n      function () {\n        return {};\n      };\n\n    this.onStart = attrs.onStart || function () {};\n\n    this.getSpecName =\n      attrs.getSpecName ||\n      function () {\n        return '';\n      };\n\n    this.queueRunnerFactory = attrs.queueRunnerFactory || function () {};\n\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\n    this.initError = new Error();\n    this.initError.name = ''; // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n\n    this.initError.stack = this.initError.stack;\n    this.queueableFn.initError = this.initError; // @ts-expect-error\n\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: [],\n      passedExpectations: [],\n      pendingReason: '',\n      testPath: attrs.getTestPath()\n    };\n  }\n\n  addExpectationResult(passed, data, isError) {\n    const expectationResult = (0, _expectationResultFactory.default)(\n      data,\n      this.initError\n    );\n\n    if (passed) {\n      this.result.passedExpectations.push(expectationResult);\n    } else {\n      this.result.failedExpectations.push(expectationResult);\n\n      if (this.throwOnExpectationFailure && !isError) {\n        throw new _ExpectationFailed.default();\n      }\n    }\n  }\n\n  execute(onComplete, enabled) {\n    const self = this;\n    this.onStart(this);\n\n    if (\n      !this.isExecutable() ||\n      this.markedPending ||\n      this.markedTodo ||\n      enabled === false\n    ) {\n      complete(enabled);\n      return;\n    }\n\n    const fns = this.beforeAndAfterFns();\n    const allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\n    this.currentRun = this.queueRunnerFactory({\n      queueableFns: allFns,\n\n      onException() {\n        // @ts-expect-error\n        self.onException.apply(self, arguments);\n      },\n\n      userContext: this.userContext(),\n      setTimeout,\n      clearTimeout,\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain);\n      self.resultCallback(self.result);\n\n      if (onComplete) {\n        onComplete();\n      }\n    }\n  }\n\n  cancel() {\n    if (this.currentRun) {\n      this.currentRun.cancel();\n    }\n  }\n\n  onException(error) {\n    if (Spec.isPendingSpecException(error)) {\n      this.pend(extractCustomPendingMessage(error));\n      return;\n    }\n\n    if (error instanceof _ExpectationFailed.default) {\n      return;\n    }\n\n    this.addExpectationResult(\n      false,\n      {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        error: this.isAssertionError(error)\n          ? (0, _assertionErrorMessage.default)(error, {\n              expand: this.expand\n            })\n          : error\n      },\n      true\n    );\n  }\n\n  disable() {\n    this.disabled = true;\n  }\n\n  pend(message) {\n    this.markedPending = true;\n\n    if (message) {\n      this.result.pendingReason = message;\n    }\n  }\n\n  todo() {\n    this.markedTodo = true;\n  }\n\n  getResult() {\n    this.result.status = this.status();\n    return this.result;\n  }\n\n  status(enabled) {\n    if (this.disabled || enabled === false) {\n      return 'disabled';\n    }\n\n    if (this.markedTodo) {\n      return 'todo';\n    }\n\n    if (this.markedPending) {\n      return 'pending';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'passed';\n    }\n  }\n\n  isExecutable() {\n    return !this.disabled;\n  }\n\n  getFullName() {\n    return this.getSpecName(this);\n  }\n\n  isAssertionError(error) {\n    return (\n      error instanceof _assert.AssertionError ||\n      (error && error.name === _assert.AssertionError.name)\n    );\n  }\n}\n\nexports.default = Spec;\n\n_defineProperty(Spec, 'pendingSpecExceptionMessage', void 0);\n\nSpec.pendingSpecExceptionMessage = '=> marked Pending';\n\nconst extractCustomPendingMessage = function (e) {\n  const fullMessage = e.toString();\n  const boilerplateStart = fullMessage.indexOf(\n    Spec.pendingSpecExceptionMessage\n  );\n  const boilerplateEnd =\n    boilerplateStart + Spec.pendingSpecExceptionMessage.length;\n  return fullMessage.substr(boilerplateEnd);\n};\n",
    "node_modules/jest-jasmine2/build/pTimeout.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = pTimeout;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// A specialized version of `p-timeout` that does not touch globals.\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val);\n      },\n      err => {\n        clearTimeout(timer);\n        reject(err);\n      }\n    );\n  });\n}\n",
    "packages/strapi-admin/services/__tests__/auth.test.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst {\n  validatePassword,\n  hashPassword,\n  checkCredentials,\n  forgotPassword,\n  resetPassword,\n} = require('../auth');\n\ndescribe('Auth', () => {\n  describe('checkCredentials', () => {\n    test('Fails on not found user, without leaking not found info', async () => {\n      const findOne = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n      };\n\n      const input = { email: 'test@strapi.io', password: 'pcw123' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'Invalid credentials' }]);\n    });\n\n    test('Fails when password is invalid, without leaking specific info', async () => {\n      const user = {\n        id: 1,\n        firstname: '',\n        lastname: '',\n        email: 'test@strapi.io',\n        password: await hashPassword('test-password'),\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n      };\n\n      const input = { email: 'test@strapi.io', password: 'wrong-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'Invalid credentials' }]);\n    });\n\n    test.each([false, null, 1, 0])('Fails when user is not active (%s)', async isActive => {\n      const user = {\n        id: 1,\n        firstname: '',\n        lastname: '',\n        email: 'test@strapi.io',\n        isActive,\n        password: await hashPassword('test-password'),\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n      };\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }]);\n    });\n\n    test('Returns user when all checks pass', async () => {\n      const user = {\n        id: 1,\n        firstname: '',\n        lastname: '',\n        email: 'test@strapi.io',\n        isActive: true,\n        password: await hashPassword('test-password'),\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n      };\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, user]);\n    });\n  });\n\n  describe('validatePassword', () => {\n    test('Compares password with hash', async () => {\n      const password = 'pcw123';\n      const hash = await hashPassword(password);\n\n      const isValid = await validatePassword(password, hash);\n      expect(isValid).toBe(true);\n    });\n  });\n\n  describe('forgotPassword', () => {\n    test('Only run the process for active users', async () => {\n      const findOne = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n      };\n\n      const input = { email: 'test@strapi.io' };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email, isActive: true });\n    });\n\n    test('Will return silently in case the user is not found', async () => {\n      const findOne = jest.fn(() => Promise.resolve());\n      const send = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n        plugins: {\n          email: {\n            services: {\n              email: { send },\n            },\n          },\n        },\n      };\n\n      const input = { email: 'test@strapi.io' };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(send).not.toHaveBeenCalled();\n    });\n\n    test('Will assign a new reset token', async () => {\n      const user = {\n        id: 1,\n        email: 'test@strapi.io',\n      };\n      const resetPasswordToken = '123';\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const send = jest.fn(() => Promise.resolve());\n      const updateById = jest.fn(() => Promise.resolve());\n      const createToken = jest.fn(() => resetPasswordToken);\n\n      const config = {\n        server: {\n          host: '0.0.0.0',\n        },\n        admin: { url: '/admin' },\n      };\n\n      global.strapi = {\n        config: {\n          ...config,\n          get(path, def) {\n            return _.get(path, def);\n          },\n        },\n        query() {\n          return { findOne };\n        },\n        admin: { services: { user: { updateById }, token: { createToken } } },\n        plugins: { email: { services: { email: { send, sendTemplatedEmail: send } } } },\n      };\n\n      const input = { email: user.email };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(createToken).toHaveBeenCalled();\n      expect(updateById).toHaveBeenCalledWith(user.id, { resetPasswordToken });\n    });\n\n    test('Will call the send service', async () => {\n      const user = {\n        id: 1,\n        email: 'test@strapi.io',\n      };\n      const resetPasswordToken = '123';\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const send = jest.fn(() => Promise.resolve());\n      const sendTemplatedEmail = jest.fn(() => Promise.resolve());\n      const updateById = jest.fn(() => Promise.resolve());\n      const createToken = jest.fn(() => resetPasswordToken);\n\n      const config = {\n        server: {\n          host: '0.0.0.0',\n          admin: { url: '/admin', forgotPassword: { emailTemplate: {} } },\n        },\n      };\n\n      global.strapi = {\n        config: {\n          ...config,\n          get(path, def) {\n            return _.get(path, def);\n          },\n        },\n        query() {\n          return { findOne };\n        },\n        admin: {\n          services: {\n            user: { updateById },\n            token: { createToken },\n          },\n        },\n        plugins: { email: { services: { email: { send, sendTemplatedEmail } } } },\n      };\n\n      const input = { email: user.email };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(createToken).toHaveBeenCalled();\n      expect(sendTemplatedEmail).toHaveBeenCalled();\n    });\n  });\n\n  describe('resetPassword', () => {\n    test('Check user is active', async () => {\n      const resetPasswordToken = '123';\n      const findOne = jest.fn(() => Promise.resolve());\n      const badRequest = jest.fn(() => {});\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n        errors: { badRequest },\n      };\n\n      expect.assertions(2);\n      return resetPassword({ resetPasswordToken, password: 'Test1234' }).catch(() => {\n        expect(findOne).toHaveBeenCalledWith({ resetPasswordToken, isActive: true });\n        expect(badRequest).toHaveBeenCalled();\n      });\n    });\n\n    test('Fails if user is not found', async () => {\n      const resetPasswordToken = '123';\n      const findOne = jest.fn(() => Promise.resolve());\n      const badRequest = jest.fn(() => {});\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n        errors: { badRequest },\n      };\n\n      expect.assertions(1);\n      return resetPassword({ resetPasswordToken, password: 'Test1234' }).catch(() => {\n        expect(badRequest).toHaveBeenCalled();\n      });\n    });\n\n    test('Changes password and clear reset token', async () => {\n      const resetPasswordToken = '123';\n      const user = { id: 1 };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const updateById = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n        admin: { services: { user: { updateById } } },\n      };\n\n      const input = { resetPasswordToken, password: 'Test1234' };\n      await resetPassword(input);\n\n      expect(updateById).toHaveBeenCalledWith(user.id, {\n        password: input.password,\n        resetPasswordToken: null,\n      });\n    });\n  });\n});\n",
    "node_modules/jest-jasmine2/build/PCancelable.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nclass CancelError extends Error {\n  constructor() {\n    super('Promise was canceled');\n    this.name = 'CancelError';\n  }\n}\n\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);\n\n    _defineProperty(this, '_canceled', false);\n\n    _defineProperty(this, '_promise', void 0);\n\n    _defineProperty(this, '_cancel', void 0);\n\n    _defineProperty(this, '_reject', () => {});\n\n    this._promise = new Promise((resolve, reject) => {\n      this._reject = reject;\n      return executor(\n        fn => {\n          this._cancel = fn;\n        },\n        val => {\n          this._pending = false;\n          resolve(val);\n        },\n        err => {\n          this._pending = false;\n          reject(err);\n        }\n      );\n    });\n  }\n\n  then(onFulfilled, onRejected) {\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    return this._promise.catch(onRejected);\n  }\n\n  cancel() {\n    if (!this._pending || this._canceled) {\n      return;\n    }\n\n    if (typeof this._cancel === 'function') {\n      try {\n        this._cancel();\n      } catch (err) {\n        this._reject(err);\n      }\n    }\n\n    this._canceled = true;\n\n    this._reject(new CancelError());\n  }\n}\n\nexports.default = PCancelable;\n",
    "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = jasmineAsyncInstall;\n\nvar _co = _interopRequireDefault(require('co'));\n\nvar _isGeneratorFn = _interopRequireDefault(require('is-generator-fn'));\n\nvar _throat = _interopRequireDefault(require('throat'));\n\nvar _isError = _interopRequireDefault(require('./isError'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction isPromise(obj) {\n  return obj && typeof obj.then === 'function';\n}\n\nconst doneFnNoop = () => {};\n\ndoneFnNoop.fail = () => {};\n\nfunction promisifyLifeCycleFunction(originalFn, env) {\n  return function (fn, timeout) {\n    if (!fn) {\n      // @ts-expect-error: missing fn arg is handled by originalFn\n      return originalFn.call(env);\n    }\n\n    const hasDoneCallback = typeof fn === 'function' && fn.length > 0;\n\n    if (hasDoneCallback) {\n      // Jasmine will handle it\n      return originalFn.call(env, fn, timeout);\n    }\n\n    const extraError = new Error(); // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n\n    extraError.stack = extraError.stack; // We make *all* functions async and run `done` right away if they\n    // didn't return a promise.\n\n    const asyncJestLifecycle = function (done) {\n      const wrappedFn = (0, _isGeneratorFn.default)(fn)\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) {\n            extraError.message = message;\n          }\n\n          done.fail(checkIsError ? error : extraError);\n        });\n      } else {\n        done();\n      }\n    };\n\n    return originalFn.call(env, asyncJestLifecycle, timeout);\n  };\n} // Similar to promisifyLifeCycleFunction but throws an error\n// when the return value is neither a Promise nor `undefined`\n\nfunction promisifyIt(originalFn, env, jasmine) {\n  return function (specName, fn, timeout) {\n    if (!fn) {\n      // @ts-expect-error: missing fn arg is handled by originalFn\n      const spec = originalFn.call(env, specName);\n      spec.pend('not implemented');\n      return spec;\n    }\n\n    const hasDoneCallback = fn.length > 0;\n\n    if (hasDoneCallback) {\n      return originalFn.call(env, specName, fn, timeout);\n    }\n\n    const extraError = new Error(); // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n\n    extraError.stack = extraError.stack;\n\n    const asyncJestTest = function (done) {\n      const wrappedFn = (0, _isGeneratorFn.default)(fn)\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) {\n            extraError.message = message;\n          }\n\n          if (jasmine.Spec.isPendingSpecException(error)) {\n            env.pending(message);\n            done();\n          } else {\n            done.fail(checkIsError ? error : extraError);\n          }\n        });\n      } else if (returnValue === undefined) {\n        done();\n      } else {\n        done.fail(\n          new Error(\n            'Jest: `it` and `test` must return either a Promise or undefined.'\n          )\n        );\n      }\n    };\n\n    return originalFn.call(env, specName, asyncJestTest, timeout);\n  };\n}\n\nfunction makeConcurrent(originalFn, env, mutex) {\n  const concurrentFn = function (specName, fn, timeout) {\n    let promise = Promise.resolve();\n    const spec = originalFn.call(env, specName, () => promise, timeout);\n\n    if (env != null && !env.specFilter(spec)) {\n      return spec;\n    }\n\n    try {\n      promise = mutex(() => {\n        const promise = fn();\n\n        if (isPromise(promise)) {\n          return promise;\n        }\n\n        throw new Error(\n          `Jest: concurrent test \"${spec.getFullName()}\" must return a Promise.`\n        );\n      });\n    } catch (error) {\n      promise = Promise.reject(error);\n    }\n\n    return spec;\n  }; // each is binded after the function is made concurrent, so for now it is made noop\n\n  concurrentFn.each = () => () => {};\n\n  return concurrentFn;\n}\n\nfunction jasmineAsyncInstall(globalConfig, global) {\n  const jasmine = global.jasmine;\n  const mutex = (0, _throat.default)(globalConfig.maxConcurrency);\n  const env = jasmine.getEnv();\n  env.it = promisifyIt(env.it, env, jasmine);\n  env.fit = promisifyIt(env.fit, env, jasmine);\n\n  global.it.concurrent = (env => {\n    const concurrent = makeConcurrent(env.it, env, mutex);\n    concurrent.only = makeConcurrent(env.fit, env, mutex);\n    concurrent.skip = makeConcurrent(env.xit, env, mutex);\n    return concurrent;\n  })(env);\n\n  global.fit.concurrent = makeConcurrent(env.fit, env, mutex);\n  env.afterAll = promisifyLifeCycleFunction(env.afterAll, env);\n  env.afterEach = promisifyLifeCycleFunction(env.afterEach, env);\n  env.beforeAll = promisifyLifeCycleFunction(env.beforeAll, env);\n  env.beforeEach = promisifyLifeCycleFunction(env.beforeEach, env);\n}\n",
    "node_modules/jest-each/build/bind.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _array = _interopRequireDefault(require('./table/array'));\n\nvar _template = _interopRequireDefault(require('./table/template'));\n\nvar _validation = require('./validation');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nvar _default = (cb, supportsDone = true) => (table, ...taggedTemplateData) =>\n  function eachBind(title, test, timeout) {\n    try {\n      const tests = isArrayTable(taggedTemplateData)\n        ? buildArrayTests(title, table)\n        : buildTemplateTests(title, table, taggedTemplateData);\n      return tests.forEach(row =>\n        cb(\n          row.title,\n          applyArguments(supportsDone, row.arguments, test),\n          timeout\n        )\n      );\n    } catch (e) {\n      const error = new (_jestUtil().ErrorWithStack)(e.message, eachBind);\n      return cb(title, () => {\n        throw error;\n      });\n    }\n  };\n\nexports.default = _default;\n\nconst isArrayTable = data => data.length === 0;\n\nconst buildArrayTests = (title, table) => {\n  (0, _validation.validateArrayTable)(table);\n  return (0, _array.default)(title, table);\n};\n\nconst buildTemplateTests = (title, table, taggedTemplateData) => {\n  const headings = getHeadingKeys(table[0]);\n  (0, _validation.validateTemplateTableHeadings)(headings, taggedTemplateData);\n  return (0, _template.default)(title, headings, taggedTemplateData);\n};\n\nconst getHeadingKeys = headings => headings.replace(/\\s/g, '').split('|');\n\nconst applyArguments = (supportsDone, params, test) =>\n  supportsDone && params.length < test.length\n    ? done => test(...params, done)\n    : () => test(...params);\n",
    "node_modules/bcryptjs/dist/bcrypt.js": "/*\r\n Copyright (c) 2012 Nevins Bartolomeo <nevins.bartolomeo@gmail.com>\r\n Copyright (c) 2012 Shane Girish <shaneGirish@gmail.com>\r\n Copyright (c) 2014 Daniel Wirtz <dcode@dcode.io>\r\n\r\n Redistribution and use in source and binary forms, with or without\r\n modification, are permitted provided that the following conditions\r\n are met:\r\n 1. Redistributions of source code must retain the above copyright\r\n notice, this list of conditions and the following disclaimer.\r\n 2. Redistributions in binary form must reproduce the above copyright\r\n notice, this list of conditions and the following disclaimer in the\r\n documentation and/or other materials provided with the distribution.\r\n 3. The name of the author may not be used to endorse or promote products\r\n derived from this software without specific prior written permission.\r\n\r\n THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\r\n IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/**\r\n * @license bcrypt.js (c) 2013 Daniel Wirtz <dcode@dcode.io>\r\n * Released under the Apache License, Version 2.0\r\n * see: https://github.com/dcodeIO/bcrypt.js for details\r\n */\r\n(function(global, factory) {\r\n\r\n    /* AMD */ if (typeof define === 'function' && define[\"amd\"])\r\n        define([], factory);\r\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === \"object\" && module && module[\"exports\"])\r\n        module[\"exports\"] = factory();\r\n    /* Global */ else\r\n        (global[\"dcodeIO\"] = global[\"dcodeIO\"] || {})[\"bcrypt\"] = factory();\r\n\r\n}(this, function() {\r\n    \"use strict\";\r\n\r\n    /**\r\n     * bcrypt namespace.\r\n     * @type {Object.<string,*>}\r\n     */\r\n    var bcrypt = {};\r\n\r\n    /**\r\n     * The random implementation to use as a fallback.\r\n     * @type {?function(number):!Array.<number>}\r\n     * @inner\r\n     */\r\n    var randomFallback = null;\r\n\r\n    /**\r\n     * Generates cryptographically secure random bytes.\r\n     * @function\r\n     * @param {number} len Bytes length\r\n     * @returns {!Array.<number>} Random bytes\r\n     * @throws {Error} If no random implementation is available\r\n     * @inner\r\n     */\r\n    function random(len) {\r\n        /* node */ if (typeof module !== 'undefined' && module && module['exports'])\r\n            try {\r\n                return require(\"crypto\")['randomBytes'](len);\r\n            } catch (e) {}\r\n        /* WCA */ try {\r\n            var a; (self['crypto']||self['msCrypto'])['getRandomValues'](a = new Uint32Array(len));\r\n            return Array.prototype.slice.call(a);\r\n        } catch (e) {}\r\n        /* fallback */ if (!randomFallback)\r\n            throw Error(\"Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative\");\r\n        return randomFallback(len);\r\n    }\r\n\r\n    // Test if any secure randomness source is available\r\n    var randomAvailable = false;\r\n    try {\r\n        random(1);\r\n        randomAvailable = true;\r\n    } catch (e) {}\r\n\r\n    // Default fallback, if any\r\n    randomFallback = null;\r\n    /**\r\n     * Sets the pseudo random number generator to use as a fallback if neither node's `crypto` module nor the Web Crypto\r\n     *  API is available. Please note: It is highly important that the PRNG used is cryptographically secure and that it\r\n     *  is seeded properly!\r\n     * @param {?function(number):!Array.<number>} random Function taking the number of bytes to generate as its\r\n     *  sole argument, returning the corresponding array of cryptographically secure random byte values.\r\n     * @see http://nodejs.org/api/crypto.html\r\n     * @see http://www.w3.org/TR/WebCryptoAPI/\r\n     */\r\n    bcrypt.setRandomFallback = function(random) {\r\n        randomFallback = random;\r\n    };\r\n\r\n    /**\r\n     * Synchronously generates a salt.\r\n     * @param {number=} rounds Number of rounds to use, defaults to 10 if omitted\r\n     * @param {number=} seed_length Not supported.\r\n     * @returns {string} Resulting salt\r\n     * @throws {Error} If a random fallback is required but not set\r\n     * @expose\r\n     */\r\n    bcrypt.genSaltSync = function(rounds, seed_length) {\r\n        rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;\r\n        if (typeof rounds !== 'number')\r\n            throw Error(\"Illegal arguments: \"+(typeof rounds)+\", \"+(typeof seed_length));\r\n        if (rounds < 4)\r\n            rounds = 4;\r\n        else if (rounds > 31)\r\n            rounds = 31;\r\n        var salt = [];\r\n        salt.push(\"$2a$\");\r\n        if (rounds < 10)\r\n            salt.push(\"0\");\r\n        salt.push(rounds.toString());\r\n        salt.push('$');\r\n        salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN)); // May throw\r\n        return salt.join('');\r\n    };\r\n\r\n    /**\r\n     * Asynchronously generates a salt.\r\n     * @param {(number|function(Error, string=))=} rounds Number of rounds to use, defaults to 10 if omitted\r\n     * @param {(number|function(Error, string=))=} seed_length Not supported.\r\n     * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting salt\r\n     * @returns {!Promise} If `callback` has been omitted\r\n     * @throws {Error} If `callback` is present but not a function\r\n     * @expose\r\n     */\r\n    bcrypt.genSalt = function(rounds, seed_length, callback) {\r\n        if (typeof seed_length === 'function')\r\n            callback = seed_length,\r\n            seed_length = undefined; // Not supported.\r\n        if (typeof rounds === 'function')\r\n            callback = rounds,\r\n            rounds = undefined;\r\n        if (typeof rounds === 'undefined')\r\n            rounds = GENSALT_DEFAULT_LOG2_ROUNDS;\r\n        else if (typeof rounds !== 'number')\r\n            throw Error(\"illegal arguments: \"+(typeof rounds));\r\n\r\n        function _async(callback) {\r\n            nextTick(function() { // Pretty thin, but salting is fast enough\r\n                try {\r\n                    callback(null, bcrypt.genSaltSync(rounds));\r\n                } catch (err) {\r\n                    callback(err);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (callback) {\r\n            if (typeof callback !== 'function')\r\n                throw Error(\"Illegal callback: \"+typeof(callback));\r\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);\r\n                        return;\r\n                    }\r\n                    resolve(res);\r\n                });\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Synchronously generates a hash for the given string.\r\n     * @param {string} s String to hash\r\n     * @param {(number|string)=} salt Salt length to generate or salt to use, default to 10\r\n     * @returns {string} Resulting hash\r\n     * @expose\r\n     */\r\n    bcrypt.hashSync = function(s, salt) {\r\n        if (typeof salt === 'undefined')\r\n            salt = GENSALT_DEFAULT_LOG2_ROUNDS;\r\n        if (typeof salt === 'number')\r\n            salt = bcrypt.genSaltSync(salt);\r\n        if (typeof s !== 'string' || typeof salt !== 'string')\r\n            throw Error(\"Illegal arguments: \"+(typeof s)+', '+(typeof salt));\r\n        return _hash(s, salt);\r\n    };\r\n\r\n    /**\r\n     * Asynchronously generates a hash for the given string.\r\n     * @param {string} s String to hash\r\n     * @param {number|string} salt Salt length to generate or salt to use\r\n     * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting hash\r\n     * @param {function(number)=} progressCallback Callback successively called with the percentage of rounds completed\r\n     *  (0.0 - 1.0), maximally once per `MAX_EXECUTION_TIME = 100` ms.\r\n     * @returns {!Promise} If `callback` has been omitted\r\n     * @throws {Error} If `callback` is present but not a function\r\n     * @expose\r\n     */\r\n    bcrypt.hash = function(s, salt, callback, progressCallback) {\r\n\r\n        function _async(callback) {\r\n            if (typeof s === 'string' && typeof salt === 'number')\r\n                bcrypt.genSalt(salt, function(err, salt) {\r\n                    _hash(s, salt, callback, progressCallback);\r\n                });\r\n            else if (typeof s === 'string' && typeof salt === 'string')\r\n                _hash(s, salt, callback, progressCallback);\r\n            else\r\n                nextTick(callback.bind(this, Error(\"Illegal arguments: \"+(typeof s)+', '+(typeof salt))));\r\n        }\r\n\r\n        if (callback) {\r\n            if (typeof callback !== 'function')\r\n                throw Error(\"Illegal callback: \"+typeof(callback));\r\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);\r\n                        return;\r\n                    }\r\n                    resolve(res);\r\n                });\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Compares two strings of the same length in constant time.\r\n     * @param {string} known Must be of the correct length\r\n     * @param {string} unknown Must be the same length as `known`\r\n     * @returns {boolean}\r\n     * @inner\r\n     */\r\n    function safeStringCompare(known, unknown) {\r\n        var right = 0,\r\n            wrong = 0;\r\n        for (var i=0, k=known.length; i<k; ++i) {\r\n            if (known.charCodeAt(i) === unknown.charCodeAt(i))\r\n                ++right;\r\n            else\r\n                ++wrong;\r\n        }\r\n        // Prevent removal of unused variables (never true, actually)\r\n        if (right < 0)\r\n            return false;\r\n        return wrong === 0;\r\n    }\r\n\r\n    /**\r\n     * Synchronously tests a string against a hash.\r\n     * @param {string} s String to compare\r\n     * @param {string} hash Hash to test against\r\n     * @returns {boolean} true if matching, otherwise false\r\n     * @throws {Error} If an argument is illegal\r\n     * @expose\r\n     */\r\n    bcrypt.compareSync = function(s, hash) {\r\n        if (typeof s !== \"string\" || typeof hash !== \"string\")\r\n            throw Error(\"Illegal arguments: \"+(typeof s)+', '+(typeof hash));\r\n        if (hash.length !== 60)\r\n            return false;\r\n        return safeStringCompare(bcrypt.hashSync(s, hash.substr(0, hash.length-31)), hash);\r\n    };\r\n\r\n    /**\r\n     * Asynchronously compares the given data against the given hash.\r\n     * @param {string} s Data to compare\r\n     * @param {string} hash Data to be compared to\r\n     * @param {function(Error, boolean)=} callback Callback receiving the error, if any, otherwise the result\r\n     * @param {function(number)=} progressCallback Callback successively called with the percentage of rounds completed\r\n     *  (0.0 - 1.0), maximally once per `MAX_EXECUTION_TIME = 100` ms.\r\n     * @returns {!Promise} If `callback` has been omitted\r\n     * @throws {Error} If `callback` is present but not a function\r\n     * @expose\r\n     */\r\n    bcrypt.compare = function(s, hash, callback, progressCallback) {\r\n\r\n        function _async(callback) {\r\n            if (typeof s !== \"string\" || typeof hash !== \"string\") {\r\n                nextTick(callback.bind(this, Error(\"Illegal arguments: \"+(typeof s)+', '+(typeof hash))));\r\n                return;\r\n            }\r\n            if (hash.length !== 60) {\r\n                nextTick(callback.bind(this, null, false));\r\n                return;\r\n            }\r\n            bcrypt.hash(s, hash.substr(0, 29), function(err, comp) {\r\n                if (err)\r\n                    callback(err);\r\n                else\r\n                    callback(null, safeStringCompare(comp, hash));\r\n            }, progressCallback);\r\n        }\r\n\r\n        if (callback) {\r\n            if (typeof callback !== 'function')\r\n                throw Error(\"Illegal callback: \"+typeof(callback));\r\n            _async(callback);\r\n        } else\r\n            return new Promise(function(resolve, reject) {\r\n                _async(function(err, res) {\r\n                    if (err) {\r\n                        reject(err);\r\n                        return;\r\n                    }\r\n                    resolve(res);\r\n                });\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Gets the number of rounds used to encrypt the specified hash.\r\n     * @param {string} hash Hash to extract the used number of rounds from\r\n     * @returns {number} Number of rounds used\r\n     * @throws {Error} If `hash` is not a string\r\n     * @expose\r\n     */\r\n    bcrypt.getRounds = function(hash) {\r\n        if (typeof hash !== \"string\")\r\n            throw Error(\"Illegal arguments: \"+(typeof hash));\r\n        return parseInt(hash.split(\"$\")[2], 10);\r\n    };\r\n\r\n    /**\r\n     * Gets the salt portion from a hash. Does not validate the hash.\r\n     * @param {string} hash Hash to extract the salt from\r\n     * @returns {string} Extracted salt part\r\n     * @throws {Error} If `hash` is not a string or otherwise invalid\r\n     * @expose\r\n     */\r\n    bcrypt.getSalt = function(hash) {\r\n        if (typeof hash !== 'string')\r\n            throw Error(\"Illegal arguments: \"+(typeof hash));\r\n        if (hash.length !== 60)\r\n            throw Error(\"Illegal hash length: \"+hash.length+\" != 60\");\r\n        return hash.substring(0, 29);\r\n    };\r\n\r\n    /**\r\n     * Continues with the callback on the next tick.\r\n     * @function\r\n     * @param {function(...[*])} callback Callback to execute\r\n     * @inner\r\n     */\r\n    var nextTick = typeof process !== 'undefined' && process && typeof process.nextTick === 'function'\r\n        ? (typeof setImmediate === 'function' ? setImmediate : process.nextTick)\r\n        : setTimeout;\r\n\r\n    /**\r\n     * Converts a JavaScript string to UTF8 bytes.\r\n     * @param {string} str String\r\n     * @returns {!Array.<number>} UTF8 bytes\r\n     * @inner\r\n     */\r\n    function stringToBytes(str) {\r\n        var out = [],\r\n            i = 0;\r\n        utfx.encodeUTF16toUTF8(function() {\r\n            if (i >= str.length) return null;\r\n            return str.charCodeAt(i++);\r\n        }, function(b) {\r\n            out.push(b);\r\n        });\r\n        return out;\r\n    }\r\n\r\n    // A base64 implementation for the bcrypt algorithm. This is partly non-standard.\r\n\r\n    /**\r\n     * bcrypt's own non-standard base64 dictionary.\r\n     * @type {!Array.<string>}\r\n     * @const\r\n     * @inner\r\n     **/\r\n    var BASE64_CODE = \"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\".split('');\r\n\r\n    /**\r\n     * @type {!Array.<number>}\r\n     * @const\r\n     * @inner\r\n     **/\r\n    var BASE64_INDEX = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\r\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\r\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0,\r\n        1, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -1, -1, -1, -1, -1, -1,\r\n        -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\r\n        20, 21, 22, 23, 24, 25, 26, 27, -1, -1, -1, -1, -1, -1, 28, 29, 30,\r\n        31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\r\n        48, 49, 50, 51, 52, 53, -1, -1, -1, -1, -1];\r\n\r\n    /**\r\n     * @type {!function(...number):string}\r\n     * @inner\r\n     */\r\n    var stringFromCharCode = String.fromCharCode;\r\n\r\n    /**\r\n     * Encodes a byte array to base64 with up to len bytes of input.\r\n     * @param {!Array.<number>} b Byte array\r\n     * @param {number} len Maximum input length\r\n     * @returns {string}\r\n     * @inner\r\n     */\r\n    function base64_encode(b, len) {\r\n        var off = 0,\r\n            rs = [],\r\n            c1, c2;\r\n        if (len <= 0 || len > b.length)\r\n            throw Error(\"Illegal len: \"+len);\r\n        while (off < len) {\r\n            c1 = b[off++] & 0xff;\r\n            rs.push(BASE64_CODE[(c1 >> 2) & 0x3f]);\r\n            c1 = (c1 & 0x03) << 4;\r\n            if (off >= len) {\r\n                rs.push(BASE64_CODE[c1 & 0x3f]);\r\n                break;\r\n            }\r\n            c2 = b[off++] & 0xff;\r\n            c1 |= (c2 >> 4) & 0x0f;\r\n            rs.push(BASE64_CODE[c1 & 0x3f]);\r\n            c1 = (c2 & 0x0f) << 2;\r\n            if (off >= len) {\r\n                rs.push(BASE64_CODE[c1 & 0x3f]);\r\n                break;\r\n            }\r\n            c2 = b[off++] & 0xff;\r\n            c1 |= (c2 >> 6) & 0x03;\r\n            rs.push(BASE64_CODE[c1 & 0x3f]);\r\n            rs.push(BASE64_CODE[c2 & 0x3f]);\r\n        }\r\n        return rs.join('');\r\n    }\r\n\r\n    /**\r\n     * Decodes a base64 encoded string to up to len bytes of output.\r\n     * @param {string} s String to decode\r\n     * @param {number} len Maximum output length\r\n     * @returns {!Array.<number>}\r\n     * @inner\r\n     */\r\n    function base64_decode(s, len) {\r\n        var off = 0,\r\n            slen = s.length,\r\n            olen = 0,\r\n            rs = [],\r\n            c1, c2, c3, c4, o, code;\r\n        if (len <= 0)\r\n            throw Error(\"Illegal len: \"+len);\r\n        while (off < slen - 1 && olen < len) {\r\n            code = s.charCodeAt(off++);\r\n            c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;\r\n            code = s.charCodeAt(off++);\r\n            c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;\r\n            if (c1 == -1 || c2 == -1)\r\n                break;\r\n            o = (c1 << 2) >>> 0;\r\n            o |= (c2 & 0x30) >> 4;\r\n            rs.push(stringFromCharCode(o));\r\n            if (++olen >= len || off >= slen)\r\n                break;\r\n            code = s.charCodeAt(off++);\r\n            c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;\r\n            if (c3 == -1)\r\n                break;\r\n            o = ((c2 & 0x0f) << 4) >>> 0;\r\n            o |= (c3 & 0x3c) >> 2;\r\n            rs.push(stringFromCharCode(o));\r\n            if (++olen >= len || off >= slen)\r\n                break;\r\n            code = s.charCodeAt(off++);\r\n            c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;\r\n            o = ((c3 & 0x03) << 6) >>> 0;\r\n            o |= c4;\r\n            rs.push(stringFromCharCode(o));\r\n            ++olen;\r\n        }\r\n        var res = [];\r\n        for (off = 0; off<olen; off++)\r\n            res.push(rs[off].charCodeAt(0));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>\r\n     * Released under the Apache License, Version 2.0\r\n     * see: https://github.com/dcodeIO/utfx for details\r\n     */\r\n    var utfx = function() {\r\n        \"use strict\";\r\n\r\n        /**\r\n         * utfx namespace.\r\n         * @inner\r\n         * @type {!Object.<string,*>}\r\n         */\r\n        var utfx = {};\r\n\r\n        /**\r\n         * Maximum valid code point.\r\n         * @type {number}\r\n         * @const\r\n         */\r\n        utfx.MAX_CODEPOINT = 0x10FFFF;\r\n\r\n        /**\r\n         * Encodes UTF8 code points to UTF8 bytes.\r\n         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point\r\n         *  respectively `null` if there are no more code points left or a single numeric code point.\r\n         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte\r\n         */\r\n        utfx.encodeUTF8 = function(src, dst) {\r\n            var cp = null;\r\n            if (typeof src === 'number')\r\n                cp = src,\r\n                src = function() { return null; };\r\n            while (cp !== null || (cp = src()) !== null) {\r\n                if (cp < 0x80)\r\n                    dst(cp&0x7F);\r\n                else if (cp < 0x800)\r\n                    dst(((cp>>6)&0x1F)|0xC0),\r\n                    dst((cp&0x3F)|0x80);\r\n                else if (cp < 0x10000)\r\n                    dst(((cp>>12)&0x0F)|0xE0),\r\n                    dst(((cp>>6)&0x3F)|0x80),\r\n                    dst((cp&0x3F)|0x80);\r\n                else\r\n                    dst(((cp>>18)&0x07)|0xF0),\r\n                    dst(((cp>>12)&0x3F)|0x80),\r\n                    dst(((cp>>6)&0x3F)|0x80),\r\n                    dst((cp&0x3F)|0x80);\r\n                cp = null;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Decodes UTF8 bytes to UTF8 code points.\r\n         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there\r\n         *  are no more bytes left.\r\n         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.\r\n         * @throws {RangeError} If a starting byte is invalid in UTF8\r\n         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the\r\n         *  remaining bytes.\r\n         */\r\n        utfx.decodeUTF8 = function(src, dst) {\r\n            var a, b, c, d, fail = function(b) {\r\n                b = b.slice(0, b.indexOf(null));\r\n                var err = Error(b.toString());\r\n                err.name = \"TruncatedError\";\r\n                err['bytes'] = b;\r\n                throw err;\r\n            };\r\n            while ((a = src()) !== null) {\r\n                if ((a&0x80) === 0)\r\n                    dst(a);\r\n                else if ((a&0xE0) === 0xC0)\r\n                    ((b = src()) === null) && fail([a, b]),\r\n                    dst(((a&0x1F)<<6) | (b&0x3F));\r\n                else if ((a&0xF0) === 0xE0)\r\n                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),\r\n                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));\r\n                else if ((a&0xF8) === 0xF0)\r\n                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),\r\n                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));\r\n                else throw RangeError(\"Illegal starting byte: \"+a);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Converts UTF16 characters to UTF8 code points.\r\n         * @param {!function():number|null} src Characters source as a function returning the next char code respectively\r\n         *  `null` if there are no more characters left.\r\n         * @param {!function(number)} dst Code points destination as a function successively called with each converted code\r\n         *  point.\r\n         */\r\n        utfx.UTF16toUTF8 = function(src, dst) {\r\n            var c1, c2 = null;\r\n            while (true) {\r\n                if ((c1 = c2 !== null ? c2 : src()) === null)\r\n                    break;\r\n                if (c1 >= 0xD800 && c1 <= 0xDFFF) {\r\n                    if ((c2 = src()) !== null) {\r\n                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {\r\n                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);\r\n                            c2 = null; continue;\r\n                        }\r\n                    }\r\n                }\r\n                dst(c1);\r\n            }\r\n            if (c2 !== null) dst(c2);\r\n        };\r\n\r\n        /**\r\n         * Converts UTF8 code points to UTF16 characters.\r\n         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point\r\n         *  respectively `null` if there are no more code points left or a single numeric code point.\r\n         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.\r\n         * @throws {RangeError} If a code point is out of range\r\n         */\r\n        utfx.UTF8toUTF16 = function(src, dst) {\r\n            var cp = null;\r\n            if (typeof src === 'number')\r\n                cp = src, src = function() { return null; };\r\n            while (cp !== null || (cp = src()) !== null) {\r\n                if (cp <= 0xFFFF)\r\n                    dst(cp);\r\n                else\r\n                    cp -= 0x10000,\r\n                    dst((cp>>10)+0xD800),\r\n                    dst((cp%0x400)+0xDC00);\r\n                cp = null;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Converts and encodes UTF16 characters to UTF8 bytes.\r\n         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`\r\n         *  if there are no more characters left.\r\n         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.\r\n         */\r\n        utfx.encodeUTF16toUTF8 = function(src, dst) {\r\n            utfx.UTF16toUTF8(src, function(cp) {\r\n                utfx.encodeUTF8(cp, dst);\r\n            });\r\n        };\r\n\r\n        /**\r\n         * Decodes and converts UTF8 bytes to UTF16 characters.\r\n         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there\r\n         *  are no more bytes left.\r\n         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.\r\n         * @throws {RangeError} If a starting byte is invalid in UTF8\r\n         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.\r\n         */\r\n        utfx.decodeUTF8toUTF16 = function(src, dst) {\r\n            utfx.decodeUTF8(src, function(cp) {\r\n                utfx.UTF8toUTF16(cp, dst);\r\n            });\r\n        };\r\n\r\n        /**\r\n         * Calculates the byte length of an UTF8 code point.\r\n         * @param {number} cp UTF8 code point\r\n         * @returns {number} Byte length\r\n         */\r\n        utfx.calculateCodePoint = function(cp) {\r\n            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;\r\n        };\r\n\r\n        /**\r\n         * Calculates the number of UTF8 bytes required to store UTF8 code points.\r\n         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively\r\n         *  `null` if there are no more code points left.\r\n         * @returns {number} The number of UTF8 bytes required\r\n         */\r\n        utfx.calculateUTF8 = function(src) {\r\n            var cp, l=0;\r\n            while ((cp = src()) !== null)\r\n                l += utfx.calculateCodePoint(cp);\r\n            return l;\r\n        };\r\n\r\n        /**\r\n         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.\r\n         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively\r\n         *  `null` if there are no more characters left.\r\n         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.\r\n         */\r\n        utfx.calculateUTF16asUTF8 = function(src) {\r\n            var n=0, l=0;\r\n            utfx.UTF16toUTF8(src, function(cp) {\r\n                ++n; l += utfx.calculateCodePoint(cp);\r\n            });\r\n            return [n,l];\r\n        };\r\n\r\n        return utfx;\r\n    }();\r\n\r\n    Date.now = Date.now || function() { return +new Date; };\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var BCRYPT_SALT_LEN = 16;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var GENSALT_DEFAULT_LOG2_ROUNDS = 10;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var BLOWFISH_NUM_ROUNDS = 16;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var MAX_EXECUTION_TIME = 100;\r\n\r\n    /**\r\n     * @type {Array.<number>}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var P_ORIG = [\r\n        0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822,\r\n        0x299f31d0, 0x082efa98, 0xec4e6c89, 0x452821e6, 0x38d01377,\r\n        0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5,\r\n        0xb5470917, 0x9216d5d9, 0x8979fb1b\r\n    ];\r\n\r\n    /**\r\n     * @type {Array.<number>}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var S_ORIG = [\r\n        0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed,\r\n        0x6a267e96, 0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7,\r\n        0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3,\r\n        0xf4933d7e, 0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,\r\n        0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013, 0xc5d1b023,\r\n        0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e,\r\n        0x6c9e0e8b, 0xb01e8a3e, 0xd71577c1, 0xbd314b27, 0x78af2fda,\r\n        0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,\r\n        0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af,\r\n        0x7c72e993, 0xb3ee1411, 0x636fbc2a, 0x2ba9c55d, 0x741831f6,\r\n        0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381,\r\n        0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,\r\n        0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032, 0xef845d5d,\r\n        0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5,\r\n        0x0f6d6ff3, 0x83f44239, 0x2e0b4482, 0xa4842004, 0x69c8f04a,\r\n        0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,\r\n        0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c,\r\n        0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176,\r\n        0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3,\r\n        0x3b8b5ebe, 0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,\r\n        0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d, 0x37d0d724,\r\n        0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b,\r\n        0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b, 0x976ce0bd,\r\n        0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,\r\n        0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f,\r\n        0x9b30952c, 0xcc814544, 0xaf5ebd09, 0xbee3d004, 0xde334afd,\r\n        0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39,\r\n        0xb9d3fbdb, 0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,\r\n        0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8, 0x3c7516df,\r\n        0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760,\r\n        0x53317b48, 0x3e00df82, 0x9e5c57bb, 0xca6f8ca0, 0x1a87562e,\r\n        0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,\r\n        0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98,\r\n        0xfd2183b8, 0x4afcb56c, 0x2dd1d35b, 0x9a53e479, 0xb6f84565,\r\n        0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341,\r\n        0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,\r\n        0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0,\r\n        0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64,\r\n        0x8888b812, 0x900df01c, 0x4fad5ea0, 0x688fc31c, 0xd1cff191,\r\n        0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,\r\n        0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0,\r\n        0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9, 0x165fa266, 0x80957705,\r\n        0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5,\r\n        0xfb9d35cf, 0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,\r\n        0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af, 0x2464369b,\r\n        0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f,\r\n        0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9, 0x11c81968,\r\n        0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,\r\n        0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5,\r\n        0x571be91f, 0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6,\r\n        0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799,\r\n        0x6e85076a, 0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,\r\n        0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266, 0xecaa8c71,\r\n        0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29,\r\n        0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65, 0x6b8fe4d6,\r\n        0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,\r\n        0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f,\r\n        0x3ebaefc9, 0x3c971814, 0x6b6a70a1, 0x687f3584, 0x52a0e286,\r\n        0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec,\r\n        0x5716f2b8, 0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,\r\n        0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd, 0xd19113f9,\r\n        0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc,\r\n        0xc8b57634, 0x9af3dda7, 0xa9446146, 0x0fd0030e, 0xecc8c73e,\r\n        0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,\r\n        0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290,\r\n        0x24977c79, 0x5679b072, 0xbcaf89af, 0xde9a771f, 0xd9930810,\r\n        0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6,\r\n        0x9f84cd87, 0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,\r\n        0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 0xef1c1847,\r\n        0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451,\r\n        0x50940002, 0x133ae4dd, 0x71dff89e, 0x10314e55, 0x81ac77d6,\r\n        0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,\r\n        0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570,\r\n        0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa,\r\n        0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978,\r\n        0x9c10b36a, 0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,\r\n        0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960, 0x5223a708,\r\n        0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883,\r\n        0xb17f37d1, 0x018cff28, 0xc332ddef, 0xbe6c5aa5, 0x65582185,\r\n        0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,\r\n        0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830,\r\n        0xeb61bd96, 0x0334fe1e, 0xaa0363cf, 0xb5735c90, 0x4c70a239,\r\n        0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab,\r\n        0xb2f3846e, 0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,\r\n        0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 0x9b540b19,\r\n        0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77,\r\n        0x11ed935f, 0x16681281, 0x0e358829, 0xc7e61fd6, 0x96dedfa1,\r\n        0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,\r\n        0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef,\r\n        0x34c6ffea, 0xfe28ed61, 0xee7c3c73, 0x5d4a14d9, 0xe864b7e3,\r\n        0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15,\r\n        0xfacb4fd0, 0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,\r\n        0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250, 0xcf62a1f2,\r\n        0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492,\r\n        0x47848a0b, 0x5692b285, 0x095bbf00, 0xad19489d, 0x1462b174,\r\n        0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,\r\n        0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759,\r\n        0xcbee7460, 0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e,\r\n        0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc,\r\n        0x800bcadc, 0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,\r\n        0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340, 0xc5c43465,\r\n        0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a,\r\n        0xe6e39f2b, 0xdb83adf7, 0xe93d5a68, 0x948140f7, 0xf64c261c,\r\n        0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,\r\n        0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e,\r\n        0x97244546, 0x14214f74, 0xbf8b8840, 0x4d95fc1d, 0x96b591af,\r\n        0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0,\r\n        0x31cb8504, 0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,\r\n        0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb, 0x68dc1462,\r\n        0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c,\r\n        0xb58ce006, 0x7af4d6b6, 0xaace1e7c, 0xd3375fec, 0xce78a399,\r\n        0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,\r\n        0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74,\r\n        0xdd5b4332, 0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397,\r\n        0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7,\r\n        0xd096954b, 0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,\r\n        0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c, 0xfdf8e802,\r\n        0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22,\r\n        0x48c1133f, 0xc70f86dc, 0x07f9c9ee, 0x41041f0f, 0x404779a4,\r\n        0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,\r\n        0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2,\r\n        0x02e1329e, 0xaf664fd1, 0xcad18115, 0x6b2395e0, 0x333e92e1,\r\n        0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c,\r\n        0x2da2f728, 0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,\r\n        0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e, 0x0a476341,\r\n        0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8,\r\n        0x991be14c, 0xdb6e6b0d, 0xc67b5510, 0x6d672c37, 0x2765d43b,\r\n        0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,\r\n        0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88,\r\n        0x515bad24, 0x7b9479bf, 0x763bd6eb, 0x37392eb3, 0xcc115979,\r\n        0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc,\r\n        0x782ef11c, 0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,\r\n        0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9, 0x44421659,\r\n        0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f,\r\n        0xbebfe988, 0x64e4c3fe, 0x9dbc8057, 0xf0f7c086, 0x60787bf8,\r\n        0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,\r\n        0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be,\r\n        0xbde8ae24, 0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2,\r\n        0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255,\r\n        0x46fcd9b9, 0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,\r\n        0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c, 0xb90bace1,\r\n        0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09,\r\n        0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c, 0x4a99a025,\r\n        0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,\r\n        0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01,\r\n        0xa70683fa, 0xa002b5c4, 0x0de6d027, 0x9af88c27, 0x773f8641,\r\n        0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa,\r\n        0x30dc7d62, 0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,\r\n        0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76, 0x6f05e409,\r\n        0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9,\r\n        0x1ac15bb4, 0xd39eb8fc, 0xed545578, 0x08fca5b5, 0xd83d7cd3,\r\n        0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,\r\n        0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234,\r\n        0x92638212, 0x670efa8e, 0x406000e0, 0x3a39ce37, 0xd3faf5cf,\r\n        0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740,\r\n        0x99bc9bbe, 0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,\r\n        0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f,\r\n        0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d,\r\n        0xd5730a1d, 0x4cd04dc6, 0x2939bbdb, 0xa9ba4650, 0xac9526e8,\r\n        0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,\r\n        0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba,\r\n        0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1,\r\n        0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69,\r\n        0x77fa0a59, 0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,\r\n        0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a,\r\n        0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b,\r\n        0x5ad6b472, 0x5a88f54c, 0xe029ac71, 0xe019a5e6, 0x47b0acfd,\r\n        0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,\r\n        0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4,\r\n        0x88f46dba, 0x03a16125, 0x0564f0bd, 0xc3eb9e15, 0x3c9057a2,\r\n        0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb,\r\n        0x26dcf319, 0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,\r\n        0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f, 0x4de81751,\r\n        0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce,\r\n        0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369,\r\n        0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,\r\n        0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd,\r\n        0x1b588d40, 0xccd2017f, 0x6bb4e3bb, 0xdda26a7e, 0x3a59ff45,\r\n        0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae,\r\n        0xbf3c6f47, 0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,\r\n        0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 0x4040cb08,\r\n        0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d,\r\n        0x06b89fb4, 0xce6ea048, 0x6f3f3b82, 0x3520ab82, 0x011a1d4b,\r\n        0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,\r\n        0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e,\r\n        0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 0x1a908749, 0xd44fbd9a,\r\n        0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c,\r\n        0xe0b12b4f, 0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,\r\n        0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525, 0xfae59361,\r\n        0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c,\r\n        0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b, 0x4c98a0be,\r\n        0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,\r\n        0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d,\r\n        0x9b992f2e, 0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891,\r\n        0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5,\r\n        0xf6fb2299, 0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,\r\n        0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc, 0xde966292,\r\n        0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a,\r\n        0x45e1d006, 0xc3f27b9a, 0xc9aa53fd, 0x62a80f00, 0xbb25bfe2,\r\n        0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,\r\n        0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c,\r\n        0xf746ce76, 0x77afa1c5, 0x20756060, 0x85cbfe4e, 0x8ae88dd8,\r\n        0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4,\r\n        0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,\r\n        0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6\r\n    ];\r\n\r\n    /**\r\n     * @type {Array.<number>}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var C_ORIG = [\r\n        0x4f727068, 0x65616e42, 0x65686f6c, 0x64657253, 0x63727944,\r\n        0x6f756274\r\n    ];\r\n\r\n    /**\r\n     * @param {Array.<number>} lr\r\n     * @param {number} off\r\n     * @param {Array.<number>} P\r\n     * @param {Array.<number>} S\r\n     * @returns {Array.<number>}\r\n     * @inner\r\n     */\r\n    function _encipher(lr, off, P, S) { // This is our bottleneck: 1714/1905 ticks / 90% - see profile.txt\r\n        var n,\r\n            l = lr[off],\r\n            r = lr[off + 1];\r\n\r\n        l ^= P[0];\r\n\r\n        /*\r\n        for (var i=0, k=BLOWFISH_NUM_ROUNDS-2; i<=k;)\r\n            // Feistel substitution on left word\r\n            n  = S[l >>> 24],\r\n            n += S[0x100 | ((l >> 16) & 0xff)],\r\n            n ^= S[0x200 | ((l >> 8) & 0xff)],\r\n            n += S[0x300 | (l & 0xff)],\r\n            r ^= n ^ P[++i],\r\n            // Feistel substitution on right word\r\n            n  = S[r >>> 24],\r\n            n += S[0x100 | ((r >> 16) & 0xff)],\r\n            n ^= S[0x200 | ((r >> 8) & 0xff)],\r\n            n += S[0x300 | (r & 0xff)],\r\n            l ^= n ^ P[++i];\r\n        */\r\n\r\n        //The following is an unrolled version of the above loop.\r\n        //Iteration 0\r\n        n  = S[l >>> 24];\r\n        n += S[0x100 | ((l >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((l >> 8) & 0xff)];\r\n        n += S[0x300 | (l & 0xff)];\r\n        r ^= n ^ P[1];\r\n        n  = S[r >>> 24];\r\n        n += S[0x100 | ((r >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((r >> 8) & 0xff)];\r\n        n += S[0x300 | (r & 0xff)];\r\n        l ^= n ^ P[2];\r\n        //Iteration 1\r\n        n  = S[l >>> 24];\r\n        n += S[0x100 | ((l >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((l >> 8) & 0xff)];\r\n        n += S[0x300 | (l & 0xff)];\r\n        r ^= n ^ P[3];\r\n        n  = S[r >>> 24];\r\n        n += S[0x100 | ((r >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((r >> 8) & 0xff)];\r\n        n += S[0x300 | (r & 0xff)];\r\n        l ^= n ^ P[4];\r\n        //Iteration 2\r\n        n  = S[l >>> 24];\r\n        n += S[0x100 | ((l >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((l >> 8) & 0xff)];\r\n        n += S[0x300 | (l & 0xff)];\r\n        r ^= n ^ P[5];\r\n        n  = S[r >>> 24];\r\n        n += S[0x100 | ((r >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((r >> 8) & 0xff)];\r\n        n += S[0x300 | (r & 0xff)];\r\n        l ^= n ^ P[6];\r\n        //Iteration 3\r\n        n  = S[l >>> 24];\r\n        n += S[0x100 | ((l >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((l >> 8) & 0xff)];\r\n        n += S[0x300 | (l & 0xff)];\r\n        r ^= n ^ P[7];\r\n        n  = S[r >>> 24];\r\n        n += S[0x100 | ((r >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((r >> 8) & 0xff)];\r\n        n += S[0x300 | (r & 0xff)];\r\n        l ^= n ^ P[8];\r\n        //Iteration 4\r\n        n  = S[l >>> 24];\r\n        n += S[0x100 | ((l >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((l >> 8) & 0xff)];\r\n        n += S[0x300 | (l & 0xff)];\r\n        r ^= n ^ P[9];\r\n        n  = S[r >>> 24];\r\n        n += S[0x100 | ((r >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((r >> 8) & 0xff)];\r\n        n += S[0x300 | (r & 0xff)];\r\n        l ^= n ^ P[10];\r\n        //Iteration 5\r\n        n  = S[l >>> 24];\r\n        n += S[0x100 | ((l >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((l >> 8) & 0xff)];\r\n        n += S[0x300 | (l & 0xff)];\r\n        r ^= n ^ P[11];\r\n        n  = S[r >>> 24];\r\n        n += S[0x100 | ((r >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((r >> 8) & 0xff)];\r\n        n += S[0x300 | (r & 0xff)];\r\n        l ^= n ^ P[12];\r\n        //Iteration 6\r\n        n  = S[l >>> 24];\r\n        n += S[0x100 | ((l >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((l >> 8) & 0xff)];\r\n        n += S[0x300 | (l & 0xff)];\r\n        r ^= n ^ P[13];\r\n        n  = S[r >>> 24];\r\n        n += S[0x100 | ((r >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((r >> 8) & 0xff)];\r\n        n += S[0x300 | (r & 0xff)];\r\n        l ^= n ^ P[14];\r\n        //Iteration 7\r\n        n  = S[l >>> 24];\r\n        n += S[0x100 | ((l >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((l >> 8) & 0xff)];\r\n        n += S[0x300 | (l & 0xff)];\r\n        r ^= n ^ P[15];\r\n        n  = S[r >>> 24];\r\n        n += S[0x100 | ((r >> 16) & 0xff)];\r\n        n ^= S[0x200 | ((r >> 8) & 0xff)];\r\n        n += S[0x300 | (r & 0xff)];\r\n        l ^= n ^ P[16];\r\n\r\n        lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];\r\n        lr[off + 1] = l;\r\n        return lr;\r\n    }\r\n\r\n    /**\r\n     * @param {Array.<number>} data\r\n     * @param {number} offp\r\n     * @returns {{key: number, offp: number}}\r\n     * @inner\r\n     */\r\n    function _streamtoword(data, offp) {\r\n        for (var i = 0, word = 0; i < 4; ++i)\r\n            word = (word << 8) | (data[offp] & 0xff),\r\n            offp = (offp + 1) % data.length;\r\n        return { key: word, offp: offp };\r\n    }\r\n\r\n    /**\r\n     * @param {Array.<number>} key\r\n     * @param {Array.<number>} P\r\n     * @param {Array.<number>} S\r\n     * @inner\r\n     */\r\n    function _key(key, P, S) {\r\n        var offset = 0,\r\n            lr = [0, 0],\r\n            plen = P.length,\r\n            slen = S.length,\r\n            sw;\r\n        for (var i = 0; i < plen; i++)\r\n            sw = _streamtoword(key, offset),\r\n            offset = sw.offp,\r\n            P[i] = P[i] ^ sw.key;\r\n        for (i = 0; i < plen; i += 2)\r\n            lr = _encipher(lr, 0, P, S),\r\n            P[i] = lr[0],\r\n            P[i + 1] = lr[1];\r\n        for (i = 0; i < slen; i += 2)\r\n            lr = _encipher(lr, 0, P, S),\r\n            S[i] = lr[0],\r\n            S[i + 1] = lr[1];\r\n    }\r\n\r\n    /**\r\n     * Expensive key schedule Blowfish.\r\n     * @param {Array.<number>} data\r\n     * @param {Array.<number>} key\r\n     * @param {Array.<number>} P\r\n     * @param {Array.<number>} S\r\n     * @inner\r\n     */\r\n    function _ekskey(data, key, P, S) {\r\n        var offp = 0,\r\n            lr = [0, 0],\r\n            plen = P.length,\r\n            slen = S.length,\r\n            sw;\r\n        for (var i = 0; i < plen; i++)\r\n            sw = _streamtoword(key, offp),\r\n            offp = sw.offp,\r\n            P[i] = P[i] ^ sw.key;\r\n        offp = 0;\r\n        for (i = 0; i < plen; i += 2)\r\n            sw = _streamtoword(data, offp),\r\n            offp = sw.offp,\r\n            lr[0] ^= sw.key,\r\n            sw = _streamtoword(data, offp),\r\n            offp = sw.offp,\r\n            lr[1] ^= sw.key,\r\n            lr = _encipher(lr, 0, P, S),\r\n            P[i] = lr[0],\r\n            P[i + 1] = lr[1];\r\n        for (i = 0; i < slen; i += 2)\r\n            sw = _streamtoword(data, offp),\r\n            offp = sw.offp,\r\n            lr[0] ^= sw.key,\r\n            sw = _streamtoword(data, offp),\r\n            offp = sw.offp,\r\n            lr[1] ^= sw.key,\r\n            lr = _encipher(lr, 0, P, S),\r\n            S[i] = lr[0],\r\n            S[i + 1] = lr[1];\r\n    }\r\n\r\n    /**\r\n     * Internaly crypts a string.\r\n     * @param {Array.<number>} b Bytes to crypt\r\n     * @param {Array.<number>} salt Salt bytes to use\r\n     * @param {number} rounds Number of rounds\r\n     * @param {function(Error, Array.<number>=)=} callback Callback receiving the error, if any, and the resulting bytes. If\r\n     *  omitted, the operation will be performed synchronously.\r\n     *  @param {function(number)=} progressCallback Callback called with the current progress\r\n     * @returns {!Array.<number>|undefined} Resulting bytes if callback has been omitted, otherwise `undefined`\r\n     * @inner\r\n     */\r\n    function _crypt(b, salt, rounds, callback, progressCallback) {\r\n        var cdata = C_ORIG.slice(),\r\n            clen = cdata.length,\r\n            err;\r\n\r\n        // Validate\r\n        if (rounds < 4 || rounds > 31) {\r\n            err = Error(\"Illegal number of rounds (4-31): \"+rounds);\r\n            if (callback) {\r\n                nextTick(callback.bind(this, err));\r\n                return;\r\n            } else\r\n                throw err;\r\n        }\r\n        if (salt.length !== BCRYPT_SALT_LEN) {\r\n            err =Error(\"Illegal salt length: \"+salt.length+\" != \"+BCRYPT_SALT_LEN);\r\n            if (callback) {\r\n                nextTick(callback.bind(this, err));\r\n                return;\r\n            } else\r\n                throw err;\r\n        }\r\n        rounds = (1 << rounds) >>> 0;\r\n\r\n        var P, S, i = 0, j;\r\n\r\n        //Use typed arrays when available - huge speedup!\r\n        if (Int32Array) {\r\n            P = new Int32Array(P_ORIG);\r\n            S = new Int32Array(S_ORIG);\r\n        } else {\r\n            P = P_ORIG.slice();\r\n            S = S_ORIG.slice();\r\n        }\r\n\r\n        _ekskey(salt, b, P, S);\r\n\r\n        /**\r\n         * Calcualtes the next round.\r\n         * @returns {Array.<number>|undefined} Resulting array if callback has been omitted, otherwise `undefined`\r\n         * @inner\r\n         */\r\n        function next() {\r\n            if (progressCallback)\r\n                progressCallback(i / rounds);\r\n            if (i < rounds) {\r\n                var start = Date.now();\r\n                for (; i < rounds;) {\r\n                    i = i + 1;\r\n                    _key(b, P, S);\r\n                    _key(salt, P, S);\r\n                    if (Date.now() - start > MAX_EXECUTION_TIME)\r\n                        break;\r\n                }\r\n            } else {\r\n                for (i = 0; i < 64; i++)\r\n                    for (j = 0; j < (clen >> 1); j++)\r\n                        _encipher(cdata, j << 1, P, S);\r\n                var ret = [];\r\n                for (i = 0; i < clen; i++)\r\n                    ret.push(((cdata[i] >> 24) & 0xff) >>> 0),\r\n                    ret.push(((cdata[i] >> 16) & 0xff) >>> 0),\r\n                    ret.push(((cdata[i] >> 8) & 0xff) >>> 0),\r\n                    ret.push((cdata[i] & 0xff) >>> 0);\r\n                if (callback) {\r\n                    callback(null, ret);\r\n                    return;\r\n                } else\r\n                    return ret;\r\n            }\r\n            if (callback)\r\n                nextTick(next);\r\n        }\r\n\r\n        // Async\r\n        if (typeof callback !== 'undefined') {\r\n            next();\r\n\r\n            // Sync\r\n        } else {\r\n            var res;\r\n            while (true)\r\n                if (typeof(res = next()) !== 'undefined')\r\n                    return res || [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internally hashes a string.\r\n     * @param {string} s String to hash\r\n     * @param {?string} salt Salt to use, actually never null\r\n     * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting hash. If omitted,\r\n     *  hashing is perormed synchronously.\r\n     *  @param {function(number)=} progressCallback Callback called with the current progress\r\n     * @returns {string|undefined} Resulting hash if callback has been omitted, otherwise `undefined`\r\n     * @inner\r\n     */\r\n    function _hash(s, salt, callback, progressCallback) {\r\n        var err;\r\n        if (typeof s !== 'string' || typeof salt !== 'string') {\r\n            err = Error(\"Invalid string / salt: Not a string\");\r\n            if (callback) {\r\n                nextTick(callback.bind(this, err));\r\n                return;\r\n            }\r\n            else\r\n                throw err;\r\n        }\r\n\r\n        // Validate the salt\r\n        var minor, offset;\r\n        if (salt.charAt(0) !== '$' || salt.charAt(1) !== '2') {\r\n            err = Error(\"Invalid salt version: \"+salt.substring(0,2));\r\n            if (callback) {\r\n                nextTick(callback.bind(this, err));\r\n                return;\r\n            }\r\n            else\r\n                throw err;\r\n        }\r\n        if (salt.charAt(2) === '$')\r\n            minor = String.fromCharCode(0),\r\n            offset = 3;\r\n        else {\r\n            minor = salt.charAt(2);\r\n            if ((minor !== 'a' && minor !== 'b' && minor !== 'y') || salt.charAt(3) !== '$') {\r\n                err = Error(\"Invalid salt revision: \"+salt.substring(2,4));\r\n                if (callback) {\r\n                    nextTick(callback.bind(this, err));\r\n                    return;\r\n                } else\r\n                    throw err;\r\n            }\r\n            offset = 4;\r\n        }\r\n\r\n        // Extract number of rounds\r\n        if (salt.charAt(offset + 2) > '$') {\r\n            err = Error(\"Missing salt rounds\");\r\n            if (callback) {\r\n                nextTick(callback.bind(this, err));\r\n                return;\r\n            } else\r\n                throw err;\r\n        }\r\n        var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10,\r\n            r2 = parseInt(salt.substring(offset + 1, offset + 2), 10),\r\n            rounds = r1 + r2,\r\n            real_salt = salt.substring(offset + 3, offset + 25);\r\n        s += minor >= 'a' ? \"\\x00\" : \"\";\r\n\r\n        var passwordb = stringToBytes(s),\r\n            saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);\r\n\r\n        /**\r\n         * Finishes hashing.\r\n         * @param {Array.<number>} bytes Byte array\r\n         * @returns {string}\r\n         * @inner\r\n         */\r\n        function finish(bytes) {\r\n            var res = [];\r\n            res.push(\"$2\");\r\n            if (minor >= 'a')\r\n                res.push(minor);\r\n            res.push(\"$\");\r\n            if (rounds < 10)\r\n                res.push(\"0\");\r\n            res.push(rounds.toString());\r\n            res.push(\"$\");\r\n            res.push(base64_encode(saltb, saltb.length));\r\n            res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));\r\n            return res.join('');\r\n        }\r\n\r\n        // Sync\r\n        if (typeof callback == 'undefined')\r\n            return finish(_crypt(passwordb, saltb, rounds));\r\n\r\n        // Async\r\n        else {\r\n            _crypt(passwordb, saltb, rounds, function(err, bytes) {\r\n                if (err)\r\n                    callback(err, null);\r\n                else\r\n                    callback(null, finish(bytes));\r\n            }, progressCallback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array to base64 with up to len bytes of input, using the custom bcrypt alphabet.\r\n     * @function\r\n     * @param {!Array.<number>} b Byte array\r\n     * @param {number} len Maximum input length\r\n     * @returns {string}\r\n     * @expose\r\n     */\r\n    bcrypt.encodeBase64 = base64_encode;\r\n\r\n    /**\r\n     * Decodes a base64 encoded string to up to len bytes of output, using the custom bcrypt alphabet.\r\n     * @function\r\n     * @param {string} s String to decode\r\n     * @param {number} len Maximum output length\r\n     * @returns {!Array.<number>}\r\n     * @expose\r\n     */\r\n    bcrypt.decodeBase64 = base64_decode;\r\n\r\n    return bcrypt;\r\n}));\r\n",
    "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js": "\"use strict\";\n\n/**\n * Queue for all the resources to be download except async scripts.\n * Async scripts have their own queue AsyncResourceQueue.\n */\nmodule.exports = class ResourceQueue {\n  constructor({ paused, asyncQueue } = {}) {\n    this.paused = Boolean(paused);\n    this._asyncQueue = asyncQueue;\n  }\n\n  getLastScript() {\n    let head = this.tail;\n\n    while (head) {\n      if (head.isScript) {\n        return head;\n      }\n      head = head.prev;\n    }\n\n    return null;\n  }\n\n  _moreScripts() {\n    let found = false;\n\n    let head = this.tail;\n    while (head && !found) {\n      found = head.isScript;\n      head = head.prev;\n    }\n\n    return found;\n  }\n\n  _notify() {\n    if (this._listener) {\n      this._listener();\n    }\n  }\n\n  setListener(listener) {\n    this._listener = listener;\n  }\n\n  push(request, onLoad, onError, keepLast, element) {\n    const isScript = element ? element.localName === \"script\" : false;\n\n    if (!request) {\n      if (isScript && !this._moreScripts()) {\n        return onLoad();\n      }\n\n      request = new Promise(resolve => resolve());\n    }\n    const q = this;\n    const item = {\n      isScript,\n      err: null,\n      element,\n      fired: false,\n      data: null,\n      keepLast,\n      prev: q.tail,\n      check() {\n        if (!q.paused && !this.prev && this.fired) {\n          let promise;\n\n          if (this.err && onError) {\n            promise = onError(this.err);\n          }\n\n          if (!this.err && onLoad) {\n            promise = onLoad(this.data);\n          }\n\n          Promise.resolve(promise)\n            .then(() => {\n              if (this.next) {\n                this.next.prev = null;\n                this.next.check();\n              } else { // q.tail===this\n                q.tail = null;\n                q._notify();\n              }\n\n              this.finished = true;\n\n              if (q._asyncQueue) {\n                q._asyncQueue.notifyItem(this);\n              }\n            });\n        }\n      }\n    };\n    if (q.tail) {\n      if (q.tail.keepLast) {\n        // if the tail is the load event in document and we receive a new element to load\n        // we should add this new request before the load event.\n        if (q.tail.prev) {\n          q.tail.prev.next = item;\n        }\n        item.prev = q.tail.prev;\n        q.tail.prev = item;\n        item.next = q.tail;\n      } else {\n        q.tail.next = item;\n        q.tail = item;\n      }\n    } else {\n      q.tail = item;\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check();\n      })\n      .catch(err => {\n        item.fired = true;\n        item.err = err;\n        item.check();\n      });\n  }\n\n  resume() {\n    if (!this.paused) {\n      return;\n    }\n    this.paused = false;\n\n    let head = this.tail;\n    while (head && head.prev) {\n      head = head.prev;\n    }\n    if (head) {\n      head.check();\n    }\n  }\n};\n",
    "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js": "\"use strict\";\n\nconst { domSymbolTree } = require(\"./internal-constants\");\nconst reportException = require(\"./runtime-script-errors\");\n\nconst Event = require(\"../generated/Event\");\nconst idlUtils = require(\"../generated/utils\");\nconst MutationRecord = require(\"../generated/MutationRecord\");\n\nconst MUTATION_TYPE = {\n  ATTRIBUTES: \"attributes\",\n  CHARACTER_DATA: \"characterData\",\n  CHILD_LIST: \"childList\"\n};\n\n// Note:\n// Since jsdom doesn't currently implement the concept of \"unit of related similar-origin browsing contexts\"\n// (https://html.spec.whatwg.org/multipage/browsers.html#unit-of-related-similar-origin-browsing-contexts)\n// we will approximate that the following properties are global for now.\n\n// https://dom.spec.whatwg.org/#mutation-observer-compound-microtask-queued-flag\nlet mutationObserverMicrotaskQueueFlag = false;\n\n// Non-spec compliant: List of all the mutation observers with mutation records enqueued. It's a replacement for\n// mutation observer list (https://dom.spec.whatwg.org/#mutation-observer-list) but without leaking since it's empty\n// before notifying the mutation observers.\nconst activeMutationObservers = new Set();\n\n// https://dom.spec.whatwg.org/#signal-slot-list\nconst signalSlotList = [];\n\n// https://dom.spec.whatwg.org/#queue-a-mutation-record\nfunction queueMutationRecord(\n  type,\n  target,\n  name,\n  namespace,\n  oldValue,\n  addedNodes,\n  removedNodes,\n  previousSibling,\n  nextSibling\n) {\n  const interestedObservers = new Map();\n\n  const nodes = domSymbolTree.ancestorsToArray(target);\n\n  for (const node of nodes) {\n    for (const registered of node._registeredObserverList) {\n      const { options, observer: mo } = registered;\n\n      if (\n        !(node !== target && options.subtree === false) &&\n        !(type === MUTATION_TYPE.ATTRIBUTES && options.attributes !== true) &&\n        !(type === MUTATION_TYPE.ATTRIBUTES && options.attributeFilter &&\n          !options.attributeFilter.some(value => value === name || value === namespace)) &&\n        !(type === MUTATION_TYPE.CHARACTER_DATA && options.characterData !== true) &&\n        !(type === MUTATION_TYPE.CHILD_LIST && options.childList === false)\n      ) {\n        if (!interestedObservers.has(mo)) {\n          interestedObservers.set(mo, null);\n        }\n\n        if (\n          (type === MUTATION_TYPE.ATTRIBUTES && options.attributeOldValue === true) ||\n          (type === MUTATION_TYPE.CHARACTER_DATA && options.characterDataOldValue === true)\n        ) {\n          interestedObservers.set(mo, oldValue);\n        }\n      }\n    }\n  }\n\n  for (const [observer, mappedOldValue] of interestedObservers.entries()) {\n    const record = MutationRecord.createImpl(target._globalObject, [], {\n      type,\n      target,\n      attributeName: name,\n      attributeNamespace: namespace,\n      oldValue: mappedOldValue,\n      addedNodes,\n      removedNodes,\n      previousSibling,\n      nextSibling\n    });\n\n    observer._recordQueue.push(record);\n    activeMutationObservers.add(observer);\n  }\n\n  queueMutationObserverMicrotask();\n}\n\n// https://dom.spec.whatwg.org/#queue-a-tree-mutation-record\nfunction queueTreeMutationRecord(target, addedNodes, removedNodes, previousSibling, nextSibling) {\n  queueMutationRecord(\n    MUTATION_TYPE.CHILD_LIST,\n    target,\n    null,\n    null,\n    null,\n    addedNodes,\n    removedNodes,\n    previousSibling,\n    nextSibling\n  );\n}\n\n// https://dom.spec.whatwg.org/#queue-an-attribute-mutation-record\nfunction queueAttributeMutationRecord(target, name, namespace, oldValue) {\n  queueMutationRecord(\n    MUTATION_TYPE.ATTRIBUTES,\n    target,\n    name,\n    namespace,\n    oldValue,\n    [],\n    [],\n    null,\n    null\n  );\n}\n\n// https://dom.spec.whatwg.org/#queue-a-mutation-observer-compound-microtask\nfunction queueMutationObserverMicrotask() {\n  if (mutationObserverMicrotaskQueueFlag) {\n    return;\n  }\n\n  mutationObserverMicrotaskQueueFlag = true;\n\n  Promise.resolve().then(() => {\n    notifyMutationObservers();\n  });\n}\n\n// https://dom.spec.whatwg.org/#notify-mutation-observers\nfunction notifyMutationObservers() {\n  mutationObserverMicrotaskQueueFlag = false;\n\n  const notifyList = [...activeMutationObservers].sort((a, b) => a._id - b._id);\n  activeMutationObservers.clear();\n\n  const signalList = [...signalSlotList];\n  signalSlotList.splice(0, signalSlotList.length);\n\n  for (const mo of notifyList) {\n    const records = [...mo._recordQueue];\n    mo._recordQueue = [];\n\n    for (const node of mo._nodeList) {\n      node._registeredObserverList = node._registeredObserverList.filter(registeredObserver => {\n        return registeredObserver.source !== mo;\n      });\n\n      if (records.length) {\n        try {\n          mo._callback(\n            records.map(idlUtils.wrapperForImpl),\n            idlUtils.wrapperForImpl(mo)\n          );\n        } catch (e) {\n          const { target } = records[0];\n          const window = target._ownerDocument._defaultView;\n\n          reportException(window, e);\n        }\n      }\n    }\n  }\n\n  for (const slot of signalList) {\n    const slotChangeEvent = Event.createImpl(\n      slot._globalObject,\n      [\n        \"slotchange\",\n        { bubbles: true }\n      ],\n      { isTrusted: true }\n    );\n\n    slot._dispatch(slotChangeEvent);\n  }\n}\n\nmodule.exports = {\n  MUTATION_TYPE,\n\n  queueMutationRecord,\n  queueTreeMutationRecord,\n  queueAttributeMutationRecord,\n\n  queueMutationObserverMicrotask,\n\n  signalSlotList\n};\n",
    "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js": "\"use strict\";\n\nconst { CookieJar } = require(\"tough-cookie\");\n\nconst NodeImpl = require(\"./Node-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\nconst NODE_TYPE = require(\"../node-type\");\nconst { mixin, memoizeQuery } = require(\"../../utils\");\nconst { firstChildWithLocalName, firstChildWithLocalNames, firstDescendantWithLocalName } =\n  require(\"../helpers/traversal\");\nconst whatwgURL = require(\"whatwg-url\");\nconst StyleSheetList = require(\"../generated/StyleSheetList.js\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst eventAccessors = require(\"../helpers/create-event-accessor\");\nconst { asciiLowercase, stripAndCollapseASCIIWhitespace } = require(\"../helpers/strings\");\nconst { childTextContent } = require(\"../helpers/text\");\nconst { HTML_NS, SVG_NS } = require(\"../helpers/namespaces\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst { parseIntoDocument } = require(\"../../browser/parser\");\nconst History = require(\"../generated/History\");\nconst Location = require(\"../generated/Location\");\nconst HTMLCollection = require(\"../generated/HTMLCollection\");\nconst NodeList = require(\"../generated/NodeList\");\nconst validateName = require(\"../helpers/validate-names\").name;\nconst { validateAndExtract } = require(\"../helpers/validate-names\");\nconst { fireAnEvent } = require(\"../helpers/events\");\nconst { shadowIncludingInclusiveDescendantsIterator } = require(\"../helpers/shadow-dom\");\nconst { enqueueCECallbackReaction } = require(\"../helpers/custom-elements\");\nconst { createElement, internalCreateElementNSSteps } = require(\"../helpers/create-element\");\n\nconst DocumentOrShadowRootImpl = require(\"./DocumentOrShadowRoot-impl\").implementation;\nconst GlobalEventHandlersImpl = require(\"./GlobalEventHandlers-impl\").implementation;\nconst NonElementParentNodeImpl = require(\"./NonElementParentNode-impl\").implementation;\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\n\nconst { clone, listOfElementsWithQualifiedName, listOfElementsWithNamespaceAndLocalName,\n  listOfElementsWithClassNames } = require(\"../node\");\nconst generatedAttr = require(\"../generated/Attr\");\nconst Comment = require(\"../generated/Comment\");\nconst ProcessingInstruction = require(\"../generated/ProcessingInstruction\");\nconst CDATASection = require(\"../generated/CDATASection\");\nconst Text = require(\"../generated/Text\");\nconst DocumentFragment = require(\"../generated/DocumentFragment\");\nconst DOMImplementation = require(\"../generated/DOMImplementation\");\nconst TreeWalker = require(\"../generated/TreeWalker\");\nconst NodeIterator = require(\"../generated/NodeIterator\");\nconst ShadowRoot = require(\"../generated/ShadowRoot\");\nconst Range = require(\"../generated/Range\");\nconst documents = require(\"../documents.js\");\n\nconst CustomEvent = require(\"../generated/CustomEvent\");\nconst ErrorEvent = require(\"../generated/ErrorEvent\");\nconst Event = require(\"../generated/Event\");\nconst FocusEvent = require(\"../generated/FocusEvent\");\nconst HashChangeEvent = require(\"../generated/HashChangeEvent\");\nconst KeyboardEvent = require(\"../generated/KeyboardEvent\");\nconst MessageEvent = require(\"../generated/MessageEvent\");\nconst MouseEvent = require(\"../generated/MouseEvent\");\nconst PopStateEvent = require(\"../generated/PopStateEvent\");\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\nconst TouchEvent = require(\"../generated/TouchEvent\");\nconst UIEvent = require(\"../generated/UIEvent\");\n\nconst RequestManager = require(\"../../browser/resources/request-manager\");\nconst AsyncResourceQueue = require(\"../../browser/resources/async-resource-queue\");\nconst ResourceQueue = require(\"../../browser/resources/resource-queue\");\nconst PerDocumentResourceLoader = require(\"../../browser/resources/per-document-resource-loader\");\n\nfunction clearChildNodes(node) {\n  for (let child = domSymbolTree.firstChild(node); child; child = domSymbolTree.firstChild(node)) {\n    node.removeChild(child);\n  }\n}\n\nfunction pad(number) {\n  if (number < 10) {\n    return \"0\" + number;\n  }\n  return number;\n}\n\nfunction toLastModifiedString(date) {\n  return pad(date.getMonth() + 1) +\n    \"/\" + pad(date.getDate()) +\n    \"/\" + date.getFullYear() +\n    \" \" + pad(date.getHours()) +\n    \":\" + pad(date.getMinutes()) +\n    \":\" + pad(date.getSeconds());\n}\n\nconst eventInterfaceTable = {\n  customevent: CustomEvent,\n  errorevent: ErrorEvent,\n  event: Event,\n  events: Event,\n  focusevent: FocusEvent,\n  hashchangeevent: HashChangeEvent,\n  htmlevents: Event,\n  keyboardevent: KeyboardEvent,\n  messageevent: MessageEvent,\n  mouseevent: MouseEvent,\n  mouseevents: MouseEvent,\n  popstateevent: PopStateEvent,\n  progressevent: ProgressEvent,\n  svgevents: Event,\n  touchevent: TouchEvent,\n  uievent: UIEvent,\n  uievents: UIEvent\n};\n\nclass DocumentImpl extends NodeImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n\n    this._initGlobalEvents();\n\n    this._ownerDocument = this;\n    this.nodeType = NODE_TYPE.DOCUMENT_NODE;\n    if (!privateData.options) {\n      privateData.options = {};\n    }\n    if (!privateData.options.parsingMode) {\n      privateData.options.parsingMode = \"xml\";\n    }\n    if (!privateData.options.encoding) {\n      privateData.options.encoding = \"UTF-8\";\n    }\n    if (!privateData.options.contentType) {\n      privateData.options.contentType = privateData.options.parsingMode === \"xml\" ? \"application/xml\" : \"text/html\";\n    }\n\n    this._parsingMode = privateData.options.parsingMode;\n\n    this._implementation = DOMImplementation.createImpl(this._globalObject, [], {\n      ownerDocument: this\n    });\n\n    this._defaultView = privateData.options.defaultView || null;\n    this._global = privateData.options.global;\n    this._ids = Object.create(null);\n    this._attached = true;\n    this._currentScript = null;\n    this._pageShowingFlag = false;\n    this._cookieJar = privateData.options.cookieJar;\n    this._parseOptions = privateData.options.parseOptions;\n    this._scriptingDisabled = privateData.options.scriptingDisabled;\n    if (this._cookieJar === undefined) {\n      this._cookieJar = new CookieJar(null, { looseMode: true });\n    }\n\n    this.contentType = privateData.options.contentType;\n    this._encoding = privateData.options.encoding;\n\n    const urlOption = privateData.options.url === undefined ? \"about:blank\" : privateData.options.url;\n    const parsed = whatwgURL.parseURL(urlOption);\n    if (parsed === null) {\n      throw new TypeError(`Could not parse \"${urlOption}\" as a URL`);\n    }\n\n    this._URL = parsed;\n    this._origin = whatwgURL.serializeURLOrigin(parsed);\n\n    this._location = Location.createImpl(this._globalObject, [], { relevantDocument: this });\n    this._history = History.createImpl(this._globalObject, [], {\n      window: this._defaultView,\n      document: this,\n      actAsIfLocationReloadCalled: () => this._location.reload()\n    });\n\n    this._workingNodeIterators = [];\n    this._workingNodeIteratorsMax = privateData.options.concurrentNodeIterators === undefined ?\n                                    10 :\n                                    Number(privateData.options.concurrentNodeIterators);\n\n    if (isNaN(this._workingNodeIteratorsMax)) {\n      throw new TypeError(\"The 'concurrentNodeIterators' option must be a Number\");\n    }\n\n    if (this._workingNodeIteratorsMax < 0) {\n      throw new RangeError(\"The 'concurrentNodeIterators' option must be a non negative Number\");\n    }\n\n    this._referrer = privateData.options.referrer || \"\";\n    this._lastModified = toLastModifiedString(privateData.options.lastModified || new Date());\n    this._asyncQueue = new AsyncResourceQueue();\n    this._queue = new ResourceQueue({ asyncQueue: this._asyncQueue, paused: false });\n    this._deferQueue = new ResourceQueue({ paused: true });\n    this._requestManager = new RequestManager();\n    this._currentDocumentReadiness = privateData.options.readyState || \"loading\";\n\n    this._lastFocusedElement = null;\n\n    this._resourceLoader = new PerDocumentResourceLoader(this);\n\n    // Each Document in a browsing context can also have a latest entry. This is the entry for that Document\n    // to which the browsing context's session history was most recently traversed. When a Document is created,\n    // it initially has no latest entry.\n    this._latestEntry = null;\n\n    // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#throw-on-dynamic-markup-insertion-counter\n    this._throwOnDynamicMarkupInsertionCounter = 0;\n  }\n\n  _getTheParent(event) {\n    if (event.type === \"load\" || !this._defaultView) {\n      return null;\n    }\n\n    return idlUtils.implForWrapper(this._defaultView);\n  }\n\n  get compatMode() {\n    return this._parsingMode === \"xml\" || this.doctype ? \"CSS1Compat\" : \"BackCompat\";\n  }\n  get charset() {\n    return this._encoding;\n  }\n  get characterSet() {\n    return this._encoding;\n  }\n  get inputEncoding() {\n    return this._encoding;\n  }\n  get doctype() {\n    for (const childNode of domSymbolTree.childrenIterator(this)) {\n      if (childNode.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n        return childNode;\n      }\n    }\n    return null;\n  }\n  get URL() {\n    return whatwgURL.serializeURL(this._URL);\n  }\n  get documentURI() {\n    return whatwgURL.serializeURL(this._URL);\n  }\n  get location() {\n    return this._defaultView ? this._location : null;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-document-documentelement\n  get documentElement() {\n    for (const childNode of domSymbolTree.childrenIterator(this)) {\n      if (childNode.nodeType === NODE_TYPE.ELEMENT_NODE) {\n        return childNode;\n      }\n    }\n\n    return null;\n  }\n\n  get implementation() {\n    return this._implementation;\n  }\n  set implementation(implementation) {\n    this._implementation = implementation;\n  }\n\n  get defaultView() {\n    return this._defaultView;\n  }\n\n  get currentScript() {\n    return this._currentScript;\n  }\n\n  get readyState() {\n    return this._currentDocumentReadiness;\n  }\n\n  set readyState(state) {\n    this._currentDocumentReadiness = state;\n    fireAnEvent(\"readystatechange\", this);\n  }\n\n  hasFocus() {\n    return Boolean(this._lastFocusedElement);\n  }\n\n  _descendantRemoved(parent, child) {\n    if (child.tagName === \"STYLE\") {\n      this.styleSheets._remove(child.sheet);\n    }\n\n    super._descendantRemoved.apply(this, arguments);\n  }\n\n  write() {\n    let text = \"\";\n    for (let i = 0; i < arguments.length; ++i) {\n      text += String(arguments[i]);\n    }\n\n    if (this._parsingMode === \"xml\") {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot use document.write on XML documents\",\n        \"InvalidStateError\"\n      ]);\n    }\n\n    if (this._throwOnDynamicMarkupInsertionCounter > 0) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot use document.write while a custom element upgrades\",\n        \"InvalidStateError\"\n      ]);\n    }\n\n    if (this._writeAfterElement) {\n      // If called from an script element directly (during the first tick),\n      // the new elements are inserted right after that element.\n      const tempDiv = this.createElement(\"div\");\n      tempDiv.innerHTML = text;\n\n      let child = tempDiv.firstChild;\n      let previous = this._writeAfterElement;\n      const parent = this._writeAfterElement.parentNode;\n\n      while (child) {\n        const node = child;\n        child = child.nextSibling;\n\n        node._isMovingDueToDocumentWrite = true; // hack for script execution\n        parent.insertBefore(node, previous.nextSibling);\n        node._isMovingDueToDocumentWrite = false;\n\n        previous = node;\n      }\n    } else if (this.readyState === \"loading\") {\n      // During page loading, document.write appends to the current element\n      // Find the last child that has been added to the document.\n      if (this.lastChild) {\n        let node = this;\n        while (node.lastChild && node.lastChild.nodeType === NODE_TYPE.ELEMENT_NODE) {\n          node = node.lastChild;\n        }\n        node.innerHTML = text;\n      } else {\n        clearChildNodes(this);\n        parseIntoDocument(text, this);\n      }\n    } else if (text) {\n      clearChildNodes(this);\n      parseIntoDocument(text, this);\n    }\n  }\n\n  writeln() {\n    this.write(...arguments, \"\\n\");\n  }\n\n  // This is implemented separately for Document (which has a _ids cache) and DocumentFragment (which does not).\n  getElementById(id) {\n    if (!this._ids[id]) {\n      return null;\n    }\n\n    // Let's find the first element with where it's root is the document.\n    const matchElement = this._ids[id].find(candidate => {\n      let root = candidate;\n      while (domSymbolTree.parent(root)) {\n        root = domSymbolTree.parent(root);\n      }\n\n      return root === this;\n    });\n\n    return matchElement || null;\n  }\n\n  get referrer() {\n    return this._referrer || \"\";\n  }\n  get lastModified() {\n    return this._lastModified;\n  }\n  get images() {\n    return this.getElementsByTagName(\"IMG\");\n  }\n  get embeds() {\n    return this.getElementsByTagName(\"EMBED\");\n  }\n  get plugins() {\n    return this.embeds;\n  }\n  get links() {\n    return HTMLCollection.createImpl(this._globalObject, [], {\n      element: this,\n      query: () => domSymbolTree.treeToArray(this, {\n        filter: node => (node._localName === \"a\" || node._localName === \"area\") &&\n                        node.hasAttributeNS(null, \"href\") &&\n                        node._namespaceURI === HTML_NS\n      })\n    });\n  }\n  get forms() {\n    return this.getElementsByTagName(\"FORM\");\n  }\n  get scripts() {\n    return this.getElementsByTagName(\"SCRIPT\");\n  }\n  get anchors() {\n    return HTMLCollection.createImpl(this._globalObject, [], {\n      element: this,\n      query: () => domSymbolTree.treeToArray(this, {\n        filter: node => node._localName === \"a\" &&\n                        node.hasAttributeNS(null, \"name\") &&\n                        node._namespaceURI === HTML_NS\n      })\n    });\n  }\n\n  // The applets attribute must return an\n  // HTMLCollection rooted at the Document node,\n  // whose filter matches nothing.\n  // (It exists for historical reasons.)\n  get applets() {\n    return HTMLCollection.createImpl(this._globalObject, [], {\n      element: this,\n      query: () => []\n    });\n  }\n\n  open() {\n    let child = domSymbolTree.firstChild(this);\n    while (child) {\n      this.removeChild(child);\n      child = domSymbolTree.firstChild(this);\n    }\n    this._modified();\n    return this;\n  }\n  close(noQueue) {\n    // In some cases like when creating an empty iframe, I want to emit the\n    // events right away to avoid problems if later I asign the property src.\n    if (noQueue) {\n      this.readyState = \"complete\";\n\n      fireAnEvent(\"DOMContentLoaded\", this, undefined, { bubbles: true });\n      fireAnEvent(\"load\", this);\n\n      return;\n    }\n    this._queue.resume();\n\n    const dummyPromise = Promise.resolve();\n\n    const onDOMContentLoad = () => {\n      const doc = this;\n      function dispatchEvent() {\n        // https://html.spec.whatwg.org/#the-end\n        doc.readyState = \"interactive\";\n        fireAnEvent(\"DOMContentLoaded\", doc, undefined, { bubbles: true });\n      }\n\n      return new Promise(resolve => {\n        if (!this._deferQueue.tail) {\n          dispatchEvent();\n          return resolve();\n        }\n\n        this._deferQueue.setListener(() => {\n          dispatchEvent();\n          resolve();\n        });\n\n        return this._deferQueue.resume();\n      });\n    };\n\n    const onLoad = () => {\n      const doc = this;\n      function dispatchEvent() {\n        doc.readyState = \"complete\";\n        fireAnEvent(\"load\", doc);\n      }\n\n      return new Promise(resolve => {\n        if (this._asyncQueue.count() === 0) {\n          dispatchEvent();\n          return resolve();\n        }\n\n        return this._asyncQueue.setListener(() => {\n          dispatchEvent();\n          resolve();\n        });\n      });\n    };\n\n    this._queue.push(dummyPromise, onDOMContentLoad, null);\n    // Set the readyState to 'complete' once all resources are loaded.\n    // As a side-effect the document's load-event will be dispatched.\n    this._queue.push(dummyPromise, onLoad, null, true);\n  }\n\n  getElementsByName(elementName) {\n    return NodeList.createImpl(this._globalObject, [], {\n      element: this,\n      query: () => domSymbolTree.treeToArray(this, {\n        filter: node => node.getAttributeNS && node.getAttributeNS(null, \"name\") === elementName\n      })\n    });\n  }\n\n  get title() {\n    const { documentElement } = this;\n    let value = \"\";\n\n    if (documentElement && documentElement._localName === \"svg\") {\n      const svgTitleElement = firstChildWithLocalName(documentElement, \"title\", SVG_NS);\n\n      if (svgTitleElement) {\n        value = childTextContent(svgTitleElement);\n      }\n    } else {\n      const titleElement = firstDescendantWithLocalName(this, \"title\");\n\n      if (titleElement) {\n        value = childTextContent(titleElement);\n      }\n    }\n\n    value = stripAndCollapseASCIIWhitespace(value);\n\n    return value;\n  }\n\n  set title(value) {\n    const { documentElement } = this;\n    let element;\n\n    if (documentElement && documentElement._localName === \"svg\") {\n      element = firstChildWithLocalName(documentElement, \"title\", SVG_NS);\n\n      if (!element) {\n        element = this.createElementNS(SVG_NS, \"title\");\n\n        this._insert(element, documentElement.firstChild);\n      }\n\n      element.textContent = value;\n    } else if (documentElement && documentElement._namespaceURI === HTML_NS) {\n      const titleElement = firstDescendantWithLocalName(this, \"title\");\n      const headElement = this.head;\n\n      if (titleElement === null && headElement === null) {\n        return;\n      }\n\n      if (titleElement !== null) {\n        element = titleElement;\n      } else {\n        element = this.createElement(\"title\");\n        headElement._append(element);\n      }\n\n      element.textContent = value;\n    }\n  }\n\n  get dir() {\n    return this.documentElement ? this.documentElement.dir : \"\";\n  }\n  set dir(value) {\n    if (this.documentElement) {\n      this.documentElement.dir = value;\n    }\n  }\n\n  get head() {\n    return this.documentElement ? firstChildWithLocalName(this.documentElement, \"head\") : null;\n  }\n\n  get body() {\n    const { documentElement } = this;\n    if (!documentElement || documentElement._localName !== \"html\" ||\n        documentElement._namespaceURI !== HTML_NS) {\n      return null;\n    }\n\n    return firstChildWithLocalNames(this.documentElement, new Set([\"body\", \"frameset\"]));\n  }\n\n  set body(value) {\n    if (value === null ||\n        value._namespaceURI !== HTML_NS ||\n        (value._localName !== \"body\" && value._localName !== \"frameset\")) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot set the body to null or a non-body/frameset element\",\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    const bodyElement = this.body;\n    if (value === bodyElement) {\n      return;\n    }\n\n    if (bodyElement !== null) {\n      bodyElement.parentNode._replace(value, bodyElement);\n      return;\n    }\n\n    const { documentElement } = this;\n    if (documentElement === null) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot set the body when there is no document element\",\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    documentElement._append(value);\n  }\n\n  _runPreRemovingSteps(oldNode) {\n    // https://html.spec.whatwg.org/#focus-fixup-rule\n    if (oldNode === this.activeElement) {\n      this._lastFocusedElement = this.body;\n    }\n    for (const activeNodeIterator of this._workingNodeIterators) {\n      activeNodeIterator._preRemovingSteps(oldNode);\n    }\n  }\n\n  createEvent(type) {\n    const typeLower = type.toLowerCase();\n    const eventWrapper = eventInterfaceTable[typeLower] || null;\n\n    if (!eventWrapper) {\n      throw DOMException.create(this._globalObject, [\n        \"The provided event type (\\\"\" + type + \"\\\") is invalid\",\n        \"NotSupportedError\"\n      ]);\n    }\n\n    const impl = eventWrapper.createImpl(this._globalObject, [\"\"]);\n    impl._initializedFlag = false;\n    return impl;\n  }\n\n  createRange() {\n    return Range.createImpl(this._globalObject, [], {\n      start: { node: this, offset: 0 },\n      end: { node: this, offset: 0 }\n    });\n  }\n\n  createProcessingInstruction(target, data) {\n    validateName(this._globalObject, target);\n\n    if (data.includes(\"?>\")) {\n      throw DOMException.create(this._globalObject, [\n        \"Processing instruction data cannot contain the string \\\"?>\\\"\",\n        \"InvalidCharacterError\"\n      ]);\n    }\n\n    return ProcessingInstruction.createImpl(this._globalObject, [], {\n      ownerDocument: this,\n      target,\n      data\n    });\n  }\n\n  // https://dom.spec.whatwg.org/#dom-document-createcdatasection\n  createCDATASection(data) {\n    if (this._parsingMode === \"html\") {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot create CDATA sections in HTML documents\",\n        \"NotSupportedError\"\n      ]);\n    }\n\n    if (data.includes(\"]]>\")) {\n      throw DOMException.create(this._globalObject, [\n        \"CDATA section data cannot contain the string \\\"]]>\\\"\",\n        \"InvalidCharacterError\"\n      ]);\n    }\n\n    return CDATASection.createImpl(this._globalObject, [], {\n      ownerDocument: this,\n      data\n    });\n  }\n\n  createTextNode(data) {\n    return Text.createImpl(this._globalObject, [], {\n      ownerDocument: this,\n      data\n    });\n  }\n\n  createComment(data) {\n    return Comment.createImpl(this._globalObject, [], {\n      ownerDocument: this,\n      data\n    });\n  }\n\n  // https://dom.spec.whatwg.org/#dom-document-createelement\n  createElement(localName, options) {\n    validateName(this._globalObject, localName);\n\n    if (this._parsingMode === \"html\") {\n      localName = asciiLowercase(localName);\n    }\n\n    let isValue = null;\n    if (options && options.is !== undefined) {\n      isValue = options.is;\n    }\n\n    const namespace = this._parsingMode === \"html\" || this.contentType === \"application/xhtml+xml\" ? HTML_NS : null;\n\n    return createElement(this, localName, namespace, null, isValue, true);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-document-createelementns\n  createElementNS(namespace, qualifiedName, options) {\n    return internalCreateElementNSSteps(this, namespace, qualifiedName, options);\n  }\n\n  createDocumentFragment() {\n    return DocumentFragment.createImpl(this._globalObject, [], { ownerDocument: this });\n  }\n\n  createAttribute(localName) {\n    validateName(this._globalObject, localName);\n\n    if (this._parsingMode === \"html\") {\n      localName = asciiLowercase(localName);\n    }\n\n    return this._createAttribute({ localName });\n  }\n\n  createAttributeNS(namespace, name) {\n    if (namespace === undefined) {\n      namespace = null;\n    }\n    namespace = namespace !== null ? String(namespace) : namespace;\n\n    const extracted = validateAndExtract(this._globalObject, namespace, name);\n    return this._createAttribute({\n      namespace: extracted.namespace,\n      namespacePrefix: extracted.prefix,\n      localName: extracted.localName\n    });\n  }\n\n  // Using this helper function rather than directly calling generatedAttr.createImpl may be preferred in some files,\n  // to avoid introducing a potentially cyclic dependency on generated/Attr.js.\n  _createAttribute({\n    localName,\n    value,\n    namespace,\n    namespacePrefix\n  }) {\n    return generatedAttr.createImpl(this._globalObject, [], {\n      localName,\n      value,\n      namespace,\n      namespacePrefix,\n      ownerDocument: this\n    });\n  }\n\n  createTreeWalker(root, whatToShow, filter) {\n    return TreeWalker.createImpl(this._globalObject, [], { root, whatToShow, filter });\n  }\n\n  createNodeIterator(root, whatToShow, filter) {\n    const nodeIterator = NodeIterator.createImpl(this._globalObject, [], { root, whatToShow, filter });\n\n    this._workingNodeIterators.push(nodeIterator);\n    while (this._workingNodeIterators.length > this._workingNodeIteratorsMax) {\n      const toInactivate = this._workingNodeIterators.shift();\n      toInactivate._working = false;\n    }\n\n    return nodeIterator;\n  }\n\n  importNode(node, deep) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot import a document node\",\n        \"NotSupportedError\"\n      ]);\n    } else if (ShadowRoot.isImpl(node)) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot adopt a shadow root\",\n        \"NotSupportedError\"\n      ]);\n    }\n\n    return clone(node, this, deep);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-document-adoptnode\n  adoptNode(node) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot adopt a document node\",\n        \"NotSupportedError\"\n      ]);\n    } else if (ShadowRoot.isImpl(node)) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot adopt a shadow root\",\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    this._adoptNode(node);\n\n    return node;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-adopt\n  _adoptNode(node) {\n    const newDocument = this;\n    const oldDocument = node._ownerDocument;\n\n    const parent = domSymbolTree.parent(node);\n    if (parent) {\n      parent._remove(node);\n    }\n\n    if (oldDocument !== newDocument) {\n      for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {\n        inclusiveDescendant._ownerDocument = newDocument;\n      }\n\n      for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {\n        if (inclusiveDescendant._ceState === \"custom\") {\n          enqueueCECallbackReaction(inclusiveDescendant, \"adoptedCallback\", [\n            idlUtils.wrapperForImpl(oldDocument),\n            idlUtils.wrapperForImpl(newDocument)\n          ]);\n        }\n      }\n\n      for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {\n        if (inclusiveDescendant._adoptingSteps) {\n          inclusiveDescendant._adoptingSteps(oldDocument);\n        }\n      }\n    }\n  }\n\n  get cookie() {\n    return this._cookieJar.getCookieStringSync(this.URL, { http: false });\n  }\n  set cookie(cookieStr) {\n    cookieStr = String(cookieStr);\n    this._cookieJar.setCookieSync(cookieStr, this.URL, {\n      http: false,\n      ignoreError: true\n    });\n  }\n\n  // The clear(), captureEvents(), and releaseEvents() methods must do nothing\n  clear() {}\n\n  captureEvents() {}\n\n  releaseEvents() {}\n\n  get styleSheets() {\n    if (!this._styleSheets) {\n      this._styleSheets = StyleSheetList.createImpl(this._globalObject);\n    }\n\n    // TODO: each style and link element should register its sheet on creation\n    // and remove it on removal.\n    return this._styleSheets;\n  }\n\n  get hidden() {\n    if (this._defaultView && this._defaultView._pretendToBeVisual) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get visibilityState() {\n    if (this._defaultView && this._defaultView._pretendToBeVisual) {\n      return \"visible\";\n    }\n\n    return \"prerender\";\n  }\n\n  // https://w3c.github.io/selection-api/#extensions-to-document-interface\n  getSelection() {\n    return this._defaultView ? this._defaultView._selection : null;\n  }\n\n  // Needed to ensure that the resulting document has the correct prototype chain:\n  // https://dom.spec.whatwg.org/#concept-node-clone says \"that implements the same interfaces as node\".\n  _cloneDocument() {\n    const copy = documents.createImpl(\n      this._globalObject,\n      {\n        contentType: this.contentType,\n        encoding: this._encoding,\n        parsingMode: this._parsingMode\n      }\n    );\n\n    copy._URL = this._URL;\n    copy._origin = this._origin;\n    return copy;\n  }\n}\n\neventAccessors.createEventAccessor(DocumentImpl.prototype, \"readystatechange\");\nmixin(DocumentImpl.prototype, DocumentOrShadowRootImpl.prototype);\nmixin(DocumentImpl.prototype, GlobalEventHandlersImpl.prototype);\nmixin(DocumentImpl.prototype, NonElementParentNodeImpl.prototype);\nmixin(DocumentImpl.prototype, ParentNodeImpl.prototype);\n\nDocumentImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\n\nDocumentImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\n\nDocumentImpl.prototype.getElementsByClassName = memoizeQuery(function getElementsByClassName(classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\n\nmodule.exports = {\n  implementation: DocumentImpl\n};\n",
    "packages/strapi-database/lib/utils/lifecycles.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst executeLifecycle = async (lifecycle, model, ...args) => {\n  if (_.has(model, `lifecycles.${lifecycle}`)) {\n    await model.lifecycles[lifecycle](...args);\n  }\n};\n\nconst executeBeforeLifecycle = (lifecycle, model, ...args) =>\n  executeLifecycle(`before${_.upperFirst(lifecycle)}`, model, ...args);\n\nconst executeAfterLifecycle = (lifecycle, model, ...args) =>\n  executeLifecycle(`after${_.upperFirst(lifecycle)}`, model, ...args);\n\nmodule.exports = {\n  executeBeforeLifecycle,\n  executeAfterLifecycle,\n};\n",
    "packages/strapi-admin/node_modules/p-map/index.js": "'use strict';\nconst AggregateError = require('aggregate-error');\n\nmodule.exports = async (\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Infinity,\n\t\tstopOnError = true\n\t} = {}\n) => {\n\treturn new Promise((resolve, reject) => {\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst result = [];\n\t\tconst errors = [];\n\t\tconst iterator = iterable[Symbol.iterator]();\n\t\tlet isRejected = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\n\t\tconst next = () => {\n\t\t\tif (isRejected) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = iterator.next();\n\t\t\tconst index = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0) {\n\t\t\t\t\tif (!stopOnError && errors.length !== 0) {\n\t\t\t\t\t\treject(new AggregateError(errors));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\t\t\t\t\tresult[index] = await mapper(element, index);\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tnext();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\tisRejected = true;\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\tfor (let i = 0; i < concurrency; i++) {\n\t\t\tnext();\n\n\t\t\tif (isIterableDone) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n};\n",
    "packages/strapi-database/lib/queries/__tests__/create-query.test.js": "'use strict';\n\nconst _ = require('lodash');\nconst createQuery = require('../create-query');\n\ndescribe('Database queries', () => {\n  describe('Substitute id with primaryKey in parameters', () => {\n    test.each(['create', 'update', 'delete', 'find', 'findOne', 'search', 'count', 'countSearch'])(\n      'Calling \"%s\" replaces id by the primaryKey in the params of the model before calling the underlying connector',\n      async method => {\n        const model = {\n          primaryKey: 'testId',\n        };\n        const params = {\n          id: 'someValue',\n        };\n\n        const connectorQuery = {\n          [method]: jest.fn(() => Promise.resolve({})),\n        };\n\n        const query = createQuery({ model, connectorQuery });\n\n        await query[method](params);\n\n        expect(connectorQuery[method]).toHaveBeenCalledWith({\n          testId: 'someValue',\n        });\n      }\n    );\n  });\n\n  describe('Lifecycles', () => {\n    test.each(['create', 'update', 'delete', 'find', 'findOne', 'search', 'count', 'countSearch'])(\n      'Calling \"%s\" calls the before adn after lifecycle hooks with the correct arguments',\n      async method => {\n        const arg1 = {};\n        const arg2 = {};\n        const output = {};\n        const beforeLifecycleMethod = jest.fn();\n        const afterLifecycleMethod = jest.fn();\n        const queryMethod = jest.fn(() => Promise.resolve(output));\n\n        const model = {\n          lifecycles: {\n            [`before${_.upperFirst(method)}`]: beforeLifecycleMethod,\n            [`after${_.upperFirst(method)}`]: afterLifecycleMethod,\n          },\n        };\n\n        const connectorQuery = {\n          [method]: queryMethod,\n        };\n\n        const query = createQuery({ model, connectorQuery });\n\n        await query[method](arg1, arg2);\n\n        expect(queryMethod).toHaveBeenCalledWith(arg1, arg2);\n        expect(beforeLifecycleMethod).toHaveBeenCalledWith(arg1, arg2);\n        expect(afterLifecycleMethod).toHaveBeenCalledWith(output, arg1, arg2);\n      }\n    );\n  });\n});\n",
    "packages/strapi/bin/strapi.js": "#!/usr/bin/env node\n'use strict';\n\nconst _ = require('lodash');\nconst resolveCwd = require('resolve-cwd');\nconst { yellow } = require('chalk');\nconst { Command } = require('commander');\n\nconst program = new Command();\n\nconst packageJSON = require('../package.json');\n\nconst checkCwdIsStrapiApp = name => {\n  let logErrorAndExit = () => {\n    console.log(\n      `You need to run ${yellow(\n        `strapi ${name}`\n      )} in a Strapi project. Make sure you are in the right directory`\n    );\n    process.exit(1);\n  };\n\n  try {\n    const pkgJSON = require(process.cwd() + '/package.json');\n    if (!_.has(pkgJSON, 'dependencies.strapi')) {\n      logErrorAndExit(name);\n    }\n  } catch (err) {\n    logErrorAndExit(name);\n  }\n};\n\nconst getLocalScript = name => (...args) => {\n  checkCwdIsStrapiApp(name);\n\n  const cmdPath = resolveCwd.silent(`strapi/lib/commands/${name}`);\n  if (!cmdPath) {\n    console.log(\n      `Error loading the local ${yellow(\n        name\n      )} command. Strapi might not be installed in your \"node_modules\". You may need to run \"npm install\"`\n    );\n    process.exit(1);\n  }\n\n  const script = require(cmdPath);\n\n  Promise.resolve()\n    .then(() => {\n      return script(...args);\n    })\n    .catch(error => {\n      console.error(`Error while running command ${name}: ${error.message || error}`);\n      process.exit(1);\n    });\n};\n\n// Initial program setup\nprogram\n  .storeOptionsAsProperties(false)\n  .passCommandToAction(false)\n  .allowUnknownOption(true);\n\nprogram.helpOption('-h, --help', 'Display help for command');\nprogram.addHelpCommand('help [command]', 'Display help for command');\n\n// `$ strapi version` (--version synonym)\nprogram.version(packageJSON.version, '-v, --version', 'Output the version number');\nprogram\n  .command('version')\n  .description('Output your version of Strapi')\n  .action(() => {\n    process.stdout.write(packageJSON.version + '\\n');\n    process.exit(0);\n  });\n\n// `$ strapi console`\nprogram\n  .command('console')\n  .description('Open the Strapi framework console')\n  .action(getLocalScript('console'));\n\n// `$ strapi new`\nprogram\n  .command('new <directory>')\n  .option('--no-run', 'Do not start the application after it is created')\n  .option('--use-npm', 'Force usage of npm instead of yarn to create the project')\n  .option('--debug', 'Display database connection error')\n  .option('--quickstart', 'Quickstart app creation')\n  .option('--dbclient <dbclient>', 'Database client')\n  .option('--dbhost <dbhost>', 'Database host')\n  .option('--dbsrv <dbsrv>', 'Database srv')\n  .option('--dbport <dbport>', 'Database port')\n  .option('--dbname <dbname>', 'Database name')\n  .option('--dbusername <dbusername>', 'Database username')\n  .option('--dbpassword <dbpassword>', 'Database password')\n  .option('--dbssl <dbssl>', 'Database SSL')\n  .option('--dbauth <dbauth>', 'Authentication Database')\n  .option('--dbfile <dbfile>', 'Database file path for sqlite')\n  .option('--dbforce', 'Overwrite database content if any')\n  .description('Create a new application')\n  .action(require('../lib/commands/new'));\n\n// `$ strapi start`\nprogram\n  .command('start')\n  .description('Start your Strapi application')\n  .action(getLocalScript('start'));\n\n// `$ strapi develop`\nprogram\n  .command('develop')\n  .alias('dev')\n  .option('--no-build', 'Disable build')\n  .option('--watch-admin', 'Enable watch', false)\n  .option('--browser <name>', 'Open the browser', true)\n  .description('Start your Strapi application in development mode')\n  .action(getLocalScript('develop'));\n\n// `$ strapi generate:api`\nprogram\n  .command('generate:api <id> [attributes...]')\n  .option('-a, --api <api>', 'API name to generate the files in')\n  .option('-p, --plugin <api>', 'Name of the local plugin')\n  .option('-e, --extend <api>', 'Name of the plugin to extend')\n  .option('-c, --connection <connection>', 'The name of the connection to use')\n  .option('--draft-and-publish', 'Enable draft/publish', false)\n  .description('Generate a basic API')\n  .action((id, attributes, cliArguments) => {\n    cliArguments.attributes = attributes;\n    getLocalScript('generate')(id, cliArguments);\n  });\n\n// `$ strapi generate:controller`\nprogram\n  .command('generate:controller <id>')\n  .option('-a, --api <api>', 'API name to generate the files in')\n  .option('-p, --plugin <api>', 'Name of the local plugin')\n  .option('-e, --extend <api>', 'Name of the plugin to extend')\n  .description('Generate a controller for an API')\n  .action(getLocalScript('generate'));\n\n// `$ strapi generate:model`\nprogram\n  .command('generate:model <id> [attributes...]')\n  .option('-a, --api <api>', 'API name to generate a sub API')\n  .option('-p, --plugin <api>', 'plugin name')\n  .option('-c, --connection <connection>', 'The name of the connection to use')\n  .option('--draft-and-publish', 'Enable draft/publish', false)\n  .description('Generate a model for an API')\n  .action((id, attributes, cliArguments) => {\n    cliArguments.attributes = attributes;\n    getLocalScript('generate')(id, cliArguments);\n  });\n\n// `$ strapi generate:policy`\nprogram\n  .command('generate:policy <id>')\n  .option('-a, --api <api>', 'API name')\n  .option('-p, --plugin <api>', 'plugin name')\n  .description('Generate a policy for an API')\n  .action(getLocalScript('generate'));\n\n// `$ strapi generate:service`\nprogram\n  .command('generate:service <id>')\n  .option('-a, --api <api>', 'API name')\n  .option('-p, --plugin <api>', 'plugin name')\n  .option('-t, --tpl <template>', 'template name')\n  .description('Generate a service for an API')\n  .action(getLocalScript('generate'));\n\n// `$ strapi generate:plugin`\nprogram\n  .command('generate:plugin <id>')\n  .option('-n, --name <name>', 'Plugin name')\n  .description('Generate a basic plugin')\n  .action(getLocalScript('generate'));\n\nprogram\n  .command('build')\n  .option('--clean', 'Remove the build and .cache folders', false)\n  .option('--no-optimization', 'Build the Administration without assets optimization')\n  .description('Builds the strapi admin app')\n  .action(getLocalScript('build'));\n\n// `$ strapi install`\nprogram\n  .command('install [plugins...]')\n  .description('Install a Strapi plugin')\n  .action(getLocalScript('install'));\n\n// `$ strapi uninstall`\nprogram\n  .command('uninstall [plugins...]')\n  .description('Uninstall a Strapi plugin')\n  .option('-d, --delete-files', 'Delete files', false)\n  .action(getLocalScript('uninstall'));\n\n//   `$ strapi watch-admin`\nprogram\n  .command('watch-admin')\n  .option('--browser <name>', 'Open the browser', true)\n  .description('Starts the admin dev server')\n  .action(getLocalScript('watchAdmin'));\n\nprogram\n  .command('configuration:dump')\n  .alias('config:dump')\n  .description('Dump configurations of your application')\n  .option('-f, --file <file>', 'Output file, default output is stdout')\n  .option('-p, --pretty', 'Format the output JSON with indentation and line breaks', false)\n  .action(getLocalScript('configurationDump'));\n\nprogram\n  .command('configuration:restore')\n  .alias('config:restore')\n  .description('Restore configurations of your application')\n  .option('-f, --file <file>', 'Input file, default input is stdin')\n  .option('-s, --strategy <strategy>', 'Strategy name, one of: \"replace\", \"merge\", \"keep\"')\n  .action(getLocalScript('configurationRestore'));\n\n// Admin\nprogram\n  .command('admin:reset-user-password')\n  .alias('admin:reset-password')\n  .description(\"Reset an admin user's password\")\n  .option('-e, --email <email>', 'The user email')\n  .option('-p, --password <password>', 'New password for the user')\n  .action(getLocalScript('admin-reset'));\n\nprogram.parseAsync(process.argv);\n",
    "packages/strapi/lib/hooks/index.js": "'use strict';\n\nconst { uniq, difference, get, isUndefined, merge } = require('lodash');\n\nmodule.exports = async function() {\n  /** Utils */\n\n  const hookConfig = this.config.hook;\n\n  // check if a hook exists\n  const hookExists = key => {\n    return !isUndefined(this.hook[key]);\n  };\n\n  // check if a hook is enabled\n  const hookEnabled = key => get(hookConfig, ['settings', key, 'enabled'], false) === true;\n\n  // list of enabled hooks\n  const enableddHook = Object.keys(this.hook).filter(hookEnabled);\n\n  // Method to initialize hooks and emit an event.\n  const initialize = hookKey => {\n    if (this.hook[hookKey].loaded === true) return;\n\n    const module = this.hook[hookKey].load;\n    const hookTimeout = get(hookConfig, ['settings', hookKey, 'timeout'], hookConfig.timeout);\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(\n        () => reject(`(hook: ${hookKey}) is taking too long to load.`),\n        hookTimeout || 1000\n      );\n\n      this.hook[hookKey] = merge(this.hook[hookKey], module);\n\n      Promise.resolve()\n        .then(() => module.initialize())\n        .then(() => {\n          clearTimeout(timeout);\n          this.hook[hookKey].loaded = true;\n          resolve();\n        })\n        .catch(err => {\n          clearTimeout(timeout);\n\n          if (err) {\n            return reject(err);\n          }\n        });\n    });\n  };\n\n  /**\n   * Run init functions\n   */\n\n  // Run beforeInitialize of every hook\n  await Promise.all(\n    enableddHook.map(key => {\n      const { beforeInitialize } = this.hook[key].load;\n      if (typeof beforeInitialize === 'function') {\n        return beforeInitialize();\n      }\n    })\n  );\n\n  // run the initialization of an array of hooks sequentially\n  const initdHookSeq = async hookArr => {\n    for (let key of uniq(hookArr)) {\n      await initialize(key);\n    }\n  };\n\n  const hooksBefore = get(hookConfig, 'load.before', [])\n    .filter(hookExists)\n    .filter(hookEnabled);\n\n  const hooksAfter = get(hookConfig, 'load.after', [])\n    .filter(hookExists)\n    .filter(hookEnabled);\n\n  const hooksOrder = get(hookConfig, 'load.order', [])\n    .filter(hookExists)\n    .filter(hookEnabled);\n\n  const unspecifieddHook = difference(enableddHook, hooksBefore, hooksOrder, hooksAfter);\n\n  // before\n  await initdHookSeq(hooksBefore);\n\n  // ordered // rest of hooks\n  await initdHookSeq(hooksOrder);\n  await initdHookSeq(unspecifieddHook);\n\n  // after\n  await initdHookSeq(hooksAfter);\n};\n",
    "packages/strapi/lib/middlewares/index.js": "'use strict';\n\nconst { uniq, difference, get, isUndefined, merge } = require('lodash');\n\nconst requiredMiddlewares = [\n  'responses',\n  'router',\n  'logger',\n  'boom',\n  'cors',\n  'cron',\n  'xframe',\n  'xss',\n  'public',\n  'favicon',\n];\n\nmodule.exports = async function() {\n  /** Utils */\n  const middlewareConfig = this.config.middleware;\n\n  // check if a middleware exists\n  const middlewareExists = key => {\n    return !isUndefined(this.middleware[key]);\n  };\n\n  // check if a middleware is enabled\n  const middlewareEnabled = key => {\n    return (\n      requiredMiddlewares.includes(key) ||\n      get(middlewareConfig, ['settings', key, 'enabled'], false) === true\n    );\n  };\n\n  // list of enabled middlewares\n  const enabledMiddlewares = Object.keys(this.middleware).filter(middlewareEnabled);\n\n  // Method to initialize middlewares and emit an event.\n  const initialize = middlewareKey => {\n    if (this.middleware[middlewareKey].loaded === true) return;\n\n    const module = this.middleware[middlewareKey].load;\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(\n        () => reject(`(middleware: ${middlewareKey}) is taking too long to load.`),\n        middlewareConfig.timeout || 1000\n      );\n\n      this.middleware[middlewareKey] = merge(this.middleware[middlewareKey], module);\n\n      Promise.resolve()\n        .then(() => module.initialize())\n        .then(() => {\n          clearTimeout(timeout);\n          this.middleware[middlewareKey].loaded = true;\n          resolve();\n        })\n        .catch(err => {\n          clearTimeout(timeout);\n\n          if (err) {\n            return reject(err);\n          }\n        });\n    });\n  };\n\n  /**\n   * Run init functions\n   */\n\n  // Run beforeInitialize of every middleware\n  await Promise.all(\n    enabledMiddlewares.map(key => {\n      const { beforeInitialize } = this.middleware[key].load;\n      if (typeof beforeInitialize === 'function') {\n        return beforeInitialize();\n      }\n    })\n  );\n\n  // run the initialization of an array of middlewares sequentially\n  const initMiddlewaresSeq = async middlewareArr => {\n    for (let key of uniq(middlewareArr)) {\n      await initialize(key);\n    }\n  };\n\n  const middlewaresBefore = get(middlewareConfig, 'load.before', [])\n    .filter(middlewareExists)\n    .filter(middlewareEnabled);\n\n  const middlewaresAfter = get(middlewareConfig, 'load.after', [])\n    .filter(middlewareExists)\n    .filter(middlewareEnabled);\n\n  const middlewaresOrder = get(middlewareConfig, 'load.order', [])\n    .filter(middlewareExists)\n    .filter(middlewareEnabled);\n\n  const unspecifiedMiddlewares = difference(\n    enabledMiddlewares,\n    middlewaresBefore,\n    middlewaresOrder,\n    middlewaresAfter\n  );\n\n  // before\n  await initMiddlewaresSeq(middlewaresBefore);\n\n  // ordered // rest of middlewares\n  await Promise.all([\n    initMiddlewaresSeq(middlewaresOrder),\n    Promise.all(unspecifiedMiddlewares.map(initialize)),\n  ]);\n\n  // after\n  await initMiddlewaresSeq(middlewaresAfter);\n};\n",
    "packages/strapi-admin/ee/admin/containers/Roles/CreatePage/index.js": "import React, { useState, useRef } from 'react';\nimport { Header } from '@buffetjs/custom';\nimport { Padded } from '@buffetjs/core';\nimport moment from 'moment';\nimport { Formik } from 'formik';\nimport { get, isEmpty } from 'lodash';\nimport { useIntl } from 'react-intl';\nimport {\n  BaselineAlignment,\n  CheckPagePermissions,\n  request,\n  useGlobalContext,\n} from 'strapi-helper-plugin';\nimport { useHistory, useRouteMatch } from 'react-router-dom';\nimport adminPermissions from '../../../../../admin/src/permissions';\nimport { useFetchPermissionsLayout, useFetchRole } from '../../../../../admin/src/hooks';\nimport PageTitle from '../../../../../admin/src/components/SettingsPageTitle';\nimport ContainerFluid from '../../../../../admin/src/components/ContainerFluid';\nimport FormCard from '../../../../../admin/src/components/FormBloc';\nimport { ButtonWithNumber, Permissions } from '../../../../../admin/src/components/Roles';\nimport SizedInput from '../../../../../admin/src/components/SizedInput';\nimport { formatPermissionsToApi } from '../../../../../admin/src/utils';\n\nimport schema from './utils/schema';\n\nconst CreatePage = () => {\n  const { formatMessage } = useIntl();\n  const [isSubmiting, setIsSubmiting] = useState(false);\n  const { replace } = useHistory();\n  const permissionsRef = useRef();\n  const { emitEvent, settingsBaseURL } = useGlobalContext();\n  const params = useRouteMatch(`${settingsBaseURL}/roles/duplicate/:id`);\n  const id = get(params, 'params.id', null);\n  const { isLoading: isLayoutLoading, data: permissionsLayout } = useFetchPermissionsLayout();\n  const { role, permissions: rolePermissions, isLoading: isRoleLoading } = useFetchRole(id);\n\n  const headerActions = (handleSubmit, handleReset) => [\n    {\n      label: formatMessage({\n        id: 'app.components.Button.reset',\n        defaultMessage: 'Reset',\n      }),\n      onClick: () => {\n        handleReset();\n        permissionsRef.current.resetForm();\n      },\n      color: 'cancel',\n      type: 'button',\n    },\n    {\n      label: formatMessage({\n        id: 'app.components.Button.save',\n        defaultMessage: 'Save',\n      }),\n      onClick: handleSubmit,\n      color: 'success',\n      type: 'submit',\n      isLoading: isSubmiting,\n    },\n  ];\n\n  const handleCreateRoleSubmit = data => {\n    strapi.lockAppWithOverlay();\n    setIsSubmiting(true);\n\n    if (id) {\n      emitEvent('willDuplicateRole');\n    } else {\n      emitEvent('willCreateNewRole');\n    }\n\n    Promise.resolve(\n      request('/admin/roles', {\n        method: 'POST',\n        body: data,\n      })\n    )\n      .then(async res => {\n        const permissionsToSend = permissionsRef.current.getPermissions();\n\n        if (id) {\n          emitEvent('didDuplicateRole');\n        } else {\n          emitEvent('didCreateNewRole');\n        }\n\n        if (res.data.id && !isEmpty(permissionsToSend)) {\n          await request(`/admin/roles/${res.data.id}/permissions`, {\n            method: 'PUT',\n            body: { permissions: formatPermissionsToApi(permissionsToSend) },\n          });\n        }\n\n        return res;\n      })\n      .then(res => {\n        setIsSubmiting(false);\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: 'Settings.roles.created' },\n        });\n        replace(`${settingsBaseURL}/roles/${res.data.id}`);\n      })\n      .catch(err => {\n        console.error(err);\n        setIsSubmiting(false);\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      })\n      .finally(() => {\n        strapi.unlockApp();\n      });\n  };\n\n  const actions = [\n    <ButtonWithNumber number={0} onClick={() => console.log('Open user modal')} key=\"user-button\">\n      {formatMessage({\n        id: 'Settings.roles.form.button.users-with-role',\n        defaultMessage: 'Users with this role',\n      })}\n    </ButtonWithNumber>,\n  ];\n\n  const defaultDescription = `${formatMessage({\n    id: 'Settings.roles.form.created',\n  })} ${moment().format('LL')}`;\n\n  return (\n    <>\n      <PageTitle name=\"Roles\" />\n      <Formik\n        initialValues={{ name: '', description: defaultDescription }}\n        onSubmit={handleCreateRoleSubmit}\n        validationSchema={schema}\n        validateOnChange={false}\n      >\n        {({ handleSubmit, values, errors, handleReset, handleChange, handleBlur }) => (\n          <form onSubmit={handleSubmit}>\n            <ContainerFluid padding=\"0\">\n              <Header\n                title={{\n                  label: formatMessage({\n                    id: 'Settings.roles.create.title',\n                    defaultMessage: 'Create a role',\n                  }),\n                }}\n                content={formatMessage({\n                  id: 'Settings.roles.create.description',\n                  defaultMessage: 'Define the rights given to the role',\n                })}\n                actions={headerActions(handleSubmit, handleReset)}\n                isLoading={isLayoutLoading}\n              />\n              <BaselineAlignment top size=\"3px\" />\n              <FormCard\n                actions={actions}\n                title={formatMessage({\n                  id: 'Settings.roles.form.title',\n                  defaultMessage: 'Details',\n                })}\n                subtitle={formatMessage({\n                  id: 'Settings.roles.form.description',\n                  defaultMessage: 'Name and description of the role',\n                })}\n              >\n                <SizedInput\n                  label=\"Settings.roles.form.input.name\"\n                  defaultMessage=\"Name\"\n                  name=\"name\"\n                  type=\"text\"\n                  error={errors.name ? { id: errors.name } : null}\n                  onBlur={handleBlur}\n                  value={values.name}\n                  onChange={handleChange}\n                />\n\n                <SizedInput\n                  label=\"Settings.roles.form.input.description\"\n                  defaultMessage=\"Description\"\n                  name=\"description\"\n                  type=\"textarea\"\n                  onBlur={handleBlur}\n                  value={values.description}\n                  onChange={handleChange}\n                  // Override the default height of the textarea\n                  style={{ height: 115 }}\n                />\n              </FormCard>\n              {!isLayoutLoading && !isRoleLoading && (\n                <Padded top bottom size=\"md\">\n                  <Permissions\n                    permissionsLayout={permissionsLayout}\n                    ref={permissionsRef}\n                    rolePermissions={rolePermissions}\n                    role={role}\n                  />\n                </Padded>\n              )}\n            </ContainerFluid>\n          </form>\n        )}\n      </Formik>\n    </>\n  );\n};\n\nexport default () => (\n  <CheckPagePermissions permissions={adminPermissions.settings.roles.create}>\n    <CreatePage />\n  </CheckPagePermissions>\n);\n\nexport { CreatePage };\n",
    "packages/strapi-admin/services/permission/engine.js": "'use strict';\n\nconst _ = require('lodash');\nconst { map, filter, each } = require('lodash/fp');\nconst { AbilityBuilder, Ability } = require('@casl/ability');\nconst sift = require('sift');\n\nconst allowedOperations = [\n  '$or',\n  '$eq',\n  '$ne',\n  '$in',\n  '$nin',\n  '$lt',\n  '$lte',\n  '$gt',\n  '$gte',\n  '$exists',\n  '$elemMatch',\n];\nconst operations = _.pick(sift, allowedOperations);\n\nconst conditionsMatcher = conditions => {\n  return sift.createQueryTester(conditions, { operations });\n};\n\nmodule.exports = conditionProvider => ({\n  /**\n   * Generate an ability based on the given user (using associated roles & permissions)\n   * @param user\n   * @param options\n   * @returns {Promise<Ability>}\n   */\n  async generateUserAbility(user, options) {\n    const permissions = await strapi.admin.services.permission.findUserPermissions(user);\n    const abilityCreator = this.generateAbilityCreatorFor(user);\n\n    return abilityCreator(permissions, options);\n  },\n\n  /**\n   * Create an ability factory for a specific user\n   * @param user\n   * @returns {function(*, *): Promise<Ability>}\n   */\n  generateAbilityCreatorFor(user) {\n    return async (permissions, options) => {\n      const { can, build } = new AbilityBuilder(Ability);\n      const registerFn = this.createRegisterFunction(can);\n\n      for (const permission of permissions) {\n        await this.evaluatePermission({ permission, user, options, registerFn });\n      }\n\n      return build({ conditionsMatcher });\n    };\n  },\n\n  /**\n   * Register new rules using `registerFn` based on valid permission's conditions\n   * @param permission\n   * @param user\n   * @param options\n   * @param registerFn\n   * @returns {Promise<void>}\n   */\n  async evaluatePermission({ permission, user, options, registerFn }) {\n    const { action, fields, conditions } = permission;\n    const subject = permission.subject || 'all';\n\n    // Permissions with empty fields array should be removed\n    if (Array.isArray(fields) && fields.length === 0) {\n      return;\n    }\n\n    // Directly registers the permission if there is no condition to check/evaluate\n    if (_.isUndefined(conditions) || _.isEmpty(conditions)) {\n      return registerFn({ action, subject, fields, condition: true });\n    }\n\n    // Replace each condition name by its associated value\n    const resolveConditions = map(conditionProvider.getById);\n\n    // Only keep the handler of each condition\n    const pickHandlers = map(_.property('handler'));\n\n    // Filter conditions, only keeps objects and functions\n    const filterValidConditions = filter(_.isObject);\n\n    // Evaluate the conditions if they're a function, returns the object otherwise\n    const evaluateConditions = conditions =>\n      Promise.all(conditions.map(cond => (_.isFunction(cond) ? cond(user, options) : cond)));\n\n    // Only keeps 'true' booleans or objects as condition's result\n    const filterValidResults = filter(result => result === true || _.isObject(result));\n\n    // Transform each result into registerFn options\n    const transformToRegisterOptions = map(result => ({\n      action,\n      subject,\n      fields,\n      condition: result,\n    }));\n\n    // Register each result using the registerFn\n    const registerResults = each(registerFn);\n\n    await Promise.resolve(conditions)\n      .then(resolveConditions)\n      .then(pickHandlers)\n      .then(filterValidConditions)\n      .then(evaluateConditions)\n      .then(filterValidResults)\n      .then(transformToRegisterOptions)\n      .then(registerResults);\n  },\n\n  /**\n   * Encapsulate a register function with custom params to fit `evaluatePermission`'s syntax\n   * @param can\n   * @returns {function({action?: *, subject?: *, fields?: *, condition?: *}): *}\n   */\n  createRegisterFunction(can) {\n    return ({ action, subject, fields, condition }) => {\n      return can(action, subject, fields, _.isObject(condition) ? condition : undefined);\n    };\n  },\n\n  /**\n   * Check many permissions based on an ability\n   */\n  checkMany: _.curry((ability, permissions) => {\n    return permissions.map(({ action, subject, field }) => ability.can(action, subject, field));\n  }),\n});\n",
    "packages/strapi-plugin-users-permissions/admin/src/containers/Roles/CreatePage/index.js": "import React, { useState, useRef } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { Header } from '@buffetjs/custom';\nimport { Padded } from '@buffetjs/core';\nimport { Formik } from 'formik';\nimport { useIntl } from 'react-intl';\nimport { request, useGlobalContext } from 'strapi-helper-plugin';\nimport BaselineAlignement from '../../../components/BaselineAlignement';\nimport ContainerFluid from '../../../components/ContainerFluid';\nimport FormCard from '../../../components/FormBloc';\nimport SizedInput from '../../../components/SizedInput';\nimport getTrad from '../../../utils/getTrad';\nimport pluginId from '../../../pluginId';\nimport UsersPermissions from '../../../components/UsersPermissions';\nimport { usePlugins } from '../../../hooks';\nimport schema from './utils/schema';\n\nconst CreatePage = () => {\n  const { formatMessage } = useIntl();\n  const { emitEvent } = useGlobalContext();\n  const { goBack } = useHistory();\n  const [isSubmiting, setIsSubmiting] = useState(false);\n  const { permissions, routes, policies, isLoading } = usePlugins();\n  const permissionsRef = useRef();\n\n  const headerActions = (handleSubmit, handleReset) => {\n    if (isLoading) {\n      return [];\n    }\n\n    return [\n      {\n        label: formatMessage({\n          id: getTrad('app.components.Button.reset'),\n          defaultMessage: 'Reset',\n        }),\n        onClick: () => {\n          handleReset();\n          permissionsRef.current.resetForm();\n        },\n        color: 'cancel',\n        type: 'button',\n      },\n      {\n        label: formatMessage({\n          id: getTrad('app.components.Button.save'),\n          defaultMessage: 'Save',\n        }),\n        onClick: handleSubmit,\n        color: 'success',\n        type: 'submit',\n        isLoading: isSubmiting,\n      },\n    ];\n  };\n\n  const handleCreateRoleSubmit = data => {\n    strapi.lockAppWithOverlay();\n    setIsSubmiting(true);\n\n    const permissions = permissionsRef.current.getPermissions();\n\n    Promise.resolve(\n      request(`/${pluginId}/roles`, {\n        method: 'POST',\n        body: { ...data, ...permissions, users: [] },\n      })\n    )\n      .then(() => {\n        emitEvent('didCreateRole');\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: 'Settings.roles.created' },\n        });\n        // Forcing redirecting since we don't have the id in the response\n        // TODO\n        goBack();\n      })\n      .catch(err => {\n        console.error(err);\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      })\n      .finally(() => {\n        setIsSubmiting(false);\n        strapi.unlockApp();\n      });\n  };\n\n  return (\n    <Formik\n      initialValues={{ name: '', description: '' }}\n      onSubmit={handleCreateRoleSubmit}\n      validationSchema={schema}\n    >\n      {({ handleSubmit, values, errors, handleReset, handleChange, handleBlur, touched }) => {\n        return (\n          <form onSubmit={handleSubmit}>\n            <ContainerFluid padding=\"0\">\n              <Header\n                title={{\n                  label: formatMessage({\n                    id: getTrad('Settings.roles.create.title'),\n                    defaultMessage: 'Create a role',\n                  }),\n                }}\n                content={formatMessage({\n                  id: getTrad('Settings.roles.create.description'),\n                  defaultMessage: 'Define the rights given to the role',\n                })}\n                actions={headerActions(handleSubmit, handleReset)}\n                isLoading={isLoading}\n              />\n              <BaselineAlignement top size=\"3px\" />\n              <FormCard\n                isLoading={isLoading}\n                title={formatMessage({\n                  id: getTrad('EditPage.form.roles'),\n                  defaultMessage: 'Role details',\n                })}\n              >\n                <SizedInput\n                  label=\"Settings.roles.form.input.name\"\n                  defaultMessage=\"Name\"\n                  name=\"name\"\n                  type=\"text\"\n                  error={errors.name && touched.name ? { id: errors.name } : null}\n                  onBlur={handleBlur}\n                  value={values.name}\n                  onChange={handleChange}\n                />\n                <SizedInput\n                  label=\"Settings.roles.form.input.description\"\n                  defaultMessage=\"Description\"\n                  name=\"description\"\n                  type=\"textarea\"\n                  error={\n                    errors.description && touched.description ? { id: errors.description } : null\n                  }\n                  onBlur={handleBlur}\n                  value={values.description}\n                  onChange={handleChange}\n                  // Override the default height of the textarea\n                  style={{ height: 115 }}\n                />\n              </FormCard>\n            </ContainerFluid>\n            <div style={{ paddingTop: '1.8rem' }} />\n            {!isLoading && (\n              <UsersPermissions\n                ref={permissionsRef}\n                permissions={permissions}\n                routes={routes}\n                policies={policies}\n              />\n            )}\n            <Padded top size=\"md\" />\n          </form>\n        );\n      }}\n    </Formik>\n  );\n};\n\nexport default CreatePage;\n",
    "packages/strapi-plugin-users-permissions/admin/src/containers/Roles/EditPage/index.js": "import React, { useState, useRef } from 'react';\nimport { Header } from '@buffetjs/custom';\nimport { Padded } from '@buffetjs/core';\nimport { Formik } from 'formik';\nimport { useIntl } from 'react-intl';\nimport { useRouteMatch } from 'react-router-dom';\nimport { request, useGlobalContext } from 'strapi-helper-plugin';\n\nimport BaselineAlignement from '../../../components/BaselineAlignement';\nimport ContainerFluid from '../../../components/ContainerFluid';\nimport FormCard from '../../../components/FormBloc';\nimport SizedInput from '../../../components/SizedInput';\nimport getTrad from '../../../utils/getTrad';\nimport pluginId from '../../../pluginId';\nimport UsersPermissions from '../../../components/UsersPermissions';\nimport { usePlugins, useFetchRole } from '../../../hooks';\n\nimport schema from './utils/schema';\n\nconst EditPage = () => {\n  const { formatMessage } = useIntl();\n  const [isSubmiting, setIsSubmiting] = useState(false);\n  const { settingsBaseURL } = useGlobalContext();\n  const {\n    params: { id },\n  } = useRouteMatch(`${settingsBaseURL}/${pluginId}/roles/:id`);\n  const { routes, policies, isLoading } = usePlugins();\n  const { role, isLoading: isRoleLoading, onSubmitSucceeded } = useFetchRole(id);\n  const permissionsRef = useRef();\n\n  const headerActions = (handleSubmit, handleReset) => {\n    if (isLoading) {\n      return [];\n    }\n\n    return [\n      {\n        label: formatMessage({\n          id: getTrad('app.components.Button.reset'),\n          defaultMessage: 'Reset',\n        }),\n        onClick: () => {\n          handleReset();\n          permissionsRef.current.resetForm();\n        },\n        color: 'cancel',\n        type: 'button',\n      },\n      {\n        label: formatMessage({\n          id: getTrad('app.components.Button.save'),\n          defaultMessage: 'Save',\n        }),\n        onClick: handleSubmit,\n        color: 'success',\n        type: 'submit',\n        isLoading: isSubmiting,\n      },\n    ];\n  };\n\n  const handleCreateRoleSubmit = data => {\n    strapi.lockAppWithOverlay();\n    setIsSubmiting(true);\n\n    const permissions = permissionsRef.current.getPermissions();\n\n    Promise.resolve(\n      request(`/${pluginId}/roles/${id}`, {\n        method: 'PUT',\n        body: { ...data, ...permissions, users: [] },\n      })\n    )\n      .then(() => {\n        onSubmitSucceeded({ name: data.name, description: data.description });\n        permissionsRef.current.setFormAfterSubmit();\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('Settings.roles.edited') },\n        });\n      })\n      .catch(err => {\n        console.error(err);\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      })\n      .finally(() => {\n        setIsSubmiting(false);\n        strapi.unlockApp();\n      });\n  };\n\n  return (\n    <Formik\n      enableReinitialize\n      initialValues={{ name: role.name, description: role.description }}\n      onSubmit={handleCreateRoleSubmit}\n      validationSchema={schema}\n    >\n      {({ handleSubmit, values, errors, handleReset, handleChange, handleBlur }) => (\n        <form onSubmit={handleSubmit}>\n          <ContainerFluid padding=\"0\">\n            <Header\n              title={{\n                label: role.name,\n              }}\n              content={role.description}\n              actions={headerActions(handleSubmit, handleReset)}\n              isLoading={isRoleLoading}\n            />\n            <BaselineAlignement top size=\"3px\" />\n            <FormCard\n              title={formatMessage({\n                id: getTrad('EditPage.form.roles'),\n                defaultMessage: 'Role details',\n              })}\n              isLoading={isLoading}\n            >\n              <SizedInput\n                label=\"Settings.roles.form.input.name\"\n                defaultMessage=\"Name\"\n                name=\"name\"\n                type=\"text\"\n                error={errors.name ? { id: errors.name } : null}\n                onBlur={handleBlur}\n                value={values.name}\n                onChange={handleChange}\n              />\n              <SizedInput\n                label=\"Settings.roles.form.input.description\"\n                defaultMessage=\"Description\"\n                name=\"description\"\n                type=\"textarea\"\n                error={errors.description ? { id: errors.description } : null}\n                onBlur={handleBlur}\n                value={values.description}\n                onChange={handleChange}\n                // Override the default height of the textarea\n                style={{ height: 115 }}\n              />\n            </FormCard>\n          </ContainerFluid>\n          <div style={{ paddingTop: '1.8rem' }} />\n          {!isLoading && !isRoleLoading && (\n            <UsersPermissions\n              ref={permissionsRef}\n              permissions={role.permissions}\n              routes={routes}\n              policies={policies}\n            />\n          )}\n          <Padded top size=\"md\" />\n        </form>\n      )}\n    </Formik>\n  );\n};\n\nexport default EditPage;\n",
    "packages/strapi-plugin-users-permissions/admin/src/containers/Roles/ListPage/index.js": "import React, { useCallback, useMemo, useState } from 'react';\nimport { List, Header } from '@buffetjs/custom';\nimport { useIntl } from 'react-intl';\nimport { useHistory } from 'react-router-dom';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { useUserPermissions, PopUpWarning, request, useGlobalContext } from 'strapi-helper-plugin';\n\nimport permissions from '../../../permissions';\nimport { EmptyRole, RoleListWrapper, RoleRow } from '../../../components/Roles';\nimport { useRolesList } from '../../../hooks';\nimport BaselineAlignment from './BaselineAlignment';\nimport pluginId from '../../../pluginId';\nimport { getTrad } from '../../../utils';\n\nconst RoleListPage = () => {\n  const { formatMessage } = useIntl();\n  const { emitEvent } = useGlobalContext();\n  const { push } = useHistory();\n\n  const [modalToDelete, setModalDelete] = useState();\n  const [shouldRefetchData, setShouldRefetchData] = useState(false);\n  const [showModalConfirmButtonLoading, setModalButtonLoading] = useState(false);\n\n  const updatePermissions = useMemo(() => {\n    return {\n      update: permissions.updateRole,\n      create: permissions.createRole,\n      delete: permissions.deleteRole,\n      read: permissions.readRoles,\n    };\n  }, []);\n  const {\n    isLoading: isLoadingForPermissions,\n    allowedActions: { canCreate, canUpdate, canDelete, canRead },\n  } = useUserPermissions(updatePermissions);\n  const shouldFetchData = !isLoadingForPermissions && canRead;\n\n  const { roles, getData, isLoading } = useRolesList(shouldFetchData);\n\n  const handleGoTo = id => {\n    if (canUpdate) {\n      push(`/settings/${pluginId}/roles/${id}`);\n    }\n  };\n\n  const handleDelete = () => {\n    strapi.lockAppWithOverlay();\n\n    setModalButtonLoading(true);\n\n    Promise.resolve(\n      request(`/${pluginId}/roles/${modalToDelete}`, {\n        method: 'DELETE',\n      })\n    )\n      .then(() => {\n        setShouldRefetchData(true);\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('Settings.roles.deleted') },\n        });\n      })\n      .catch(err => {\n        console.error(err);\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      })\n      .finally(() => {\n        setModalDelete(null);\n        strapi.unlockApp();\n      });\n  };\n\n  const handleClosedModalDelete = () => {\n    if (shouldRefetchData) {\n      getData();\n    }\n    setModalButtonLoading(false);\n    setShouldRefetchData(false);\n  };\n\n  const handleNewRoleClick = () => {\n    emitEvent('willCreateRole');\n    push(`/settings/${pluginId}/roles/new`);\n  };\n\n  /* eslint-disable indent */\n  const headerActions = canCreate\n    ? [\n        {\n          label: formatMessage({\n            id: 'List.button.roles',\n            defaultMessage: 'Add new role',\n          }),\n          onClick: handleNewRoleClick,\n          color: 'primary',\n          type: 'button',\n          icon: true,\n        },\n      ]\n    : [];\n  /* eslint-enable indent */\n\n  const checkCanDeleteRole = useCallback(\n    role => {\n      return canDelete && !['public', 'authenticated'].includes(role.type);\n    },\n    [canDelete]\n  );\n\n  const getLinks = role => {\n    const links = [];\n\n    if (canUpdate) {\n      links.push({\n        icon: <FontAwesomeIcon icon=\"pencil-alt\" />,\n        onClick: () => handleGoTo(role.id),\n      });\n    }\n    if (checkCanDeleteRole(role)) {\n      links.push({\n        icon: <FontAwesomeIcon icon=\"trash-alt\" />,\n        onClick: e => {\n          e.preventDefault();\n          setModalDelete(role.id);\n          e.stopPropagation();\n        },\n      });\n    }\n\n    return links;\n  };\n\n  return (\n    <>\n      <Header\n        icon\n        title={{\n          label: formatMessage({\n            id: 'Settings.roles.title',\n            defaultMessage: 'Roles & Permissions',\n          }),\n        }}\n        content={formatMessage({\n          id: 'Settings.roles.list.description',\n          defaultMessage: 'Define the roles and permissions for your users.',\n        })}\n        actions={headerActions}\n        // Show a loader in the header while requesting data\n        isLoading={isLoading || isLoadingForPermissions}\n      />\n      <BaselineAlignment />\n      {canRead && (\n        <RoleListWrapper>\n          <List\n            title={formatMessage(\n              {\n                id: `Settings.roles.list.title${roles.length > 1 ? '.plural' : '.singular'}`,\n              },\n              { number: roles.length }\n            )}\n            items={roles}\n            isLoading={isLoading || isLoadingForPermissions}\n            customRowComponent={role => (\n              <RoleRow onClick={() => handleGoTo(role.id)} links={getLinks(role)} role={role} />\n            )}\n          />\n          {!roles && !isLoading && !isLoadingForPermissions && <EmptyRole />}\n          <PopUpWarning\n            isOpen={Boolean(modalToDelete)}\n            onConfirm={handleDelete}\n            onClosed={handleClosedModalDelete}\n            toggleModal={() => setModalDelete(null)}\n            isConfirmButtonLoading={showModalConfirmButtonLoading}\n          />\n        </RoleListWrapper>\n      )}\n    </>\n  );\n};\n\nexport default RoleListPage;\n",
    "packages/strapi/lib/commands/configurationRestore.js": "'use strict';\n\nconst fs = require('fs');\nconst _ = require('lodash');\nconst strapi = require('../index');\n\n/**\n * Will restore configurations. It reads from a file or stdin\n * @param {string} file filepath to use as input\n * @param {string} strategy import strategy. one of (replace, merge, keep, default: replace)\n */\nmodule.exports = async function({ file: filePath, strategy = 'replace' }) {\n  const input = filePath ? fs.readFileSync(filePath) : await readStdin(process.stdin);\n\n  const app = await strapi().load();\n\n  let dataToImport;\n  try {\n    dataToImport = JSON.parse(input);\n  } catch (error) {\n    throw new Error(`Invalid input data: ${error.message}. Expected a valid JSON array.`);\n  }\n\n  if (!Array.isArray(dataToImport)) {\n    throw new Error(`Invalid input data. Expected a valid JSON array.`);\n  }\n\n  const importer = createImporter(app.db, strategy);\n\n  for (const config of dataToImport) {\n    await importer.import(config);\n  }\n\n  console.log(\n    `Successfully imported configuration with ${strategy} strategy. Statistics: ${importer.printStatistics()}.`\n  );\n\n  process.exit(0);\n};\n\nconst readStdin = () => {\n  const { stdin } = process;\n  let result = '';\n\n  if (stdin.isTTY) return Promise.resolve(result);\n\n  return new Promise((resolve, reject) => {\n    stdin.setEncoding('utf8');\n    stdin.on('readable', () => {\n      let chunk;\n      while ((chunk = stdin.read())) {\n        result += chunk;\n      }\n    });\n\n    stdin.on('end', () => {\n      resolve(result);\n    });\n\n    stdin.on('error', reject);\n  });\n};\n\nconst createImporter = (db, strategy) => {\n  switch (strategy) {\n    case 'replace':\n      return createReplaceImporter(db);\n    case 'merge':\n      return createMergeImporter(db);\n    case 'keep':\n      return createKeepImporter(db);\n    default:\n      throw new Error(`No importer available for strategy \"${strategy}\"`);\n  }\n};\n\n/**\n * Replace importer. Will replace the keys that already exist and create the new ones\n * @param {Object} db - DatabaseManager instance\n */\nconst createReplaceImporter = db => {\n  const stats = {\n    created: 0,\n    replaced: 0,\n  };\n\n  return {\n    printStatistics() {\n      return `${stats.created} created, ${stats.replaced} replaced`;\n    },\n\n    async import(conf) {\n      const matching = await db.query('core_store').count({ key: conf.key });\n      if (matching > 0) {\n        stats.replaced += 1;\n        await db.query('core_store').update({ key: conf.key }, conf);\n      } else {\n        stats.created += 1;\n        await db.query('core_store').create(conf);\n      }\n    },\n  };\n};\n\n/**\n * Merge importer. Will merge the keys that already exist with their new value and create the new ones\n * @param {Object} db - DatabaseManager instance\n */\nconst createMergeImporter = db => {\n  const stats = {\n    created: 0,\n    merged: 0,\n  };\n\n  return {\n    printStatistics() {\n      return `${stats.created} created, ${stats.merged} merged`;\n    },\n\n    async import(conf) {\n      const existingConf = await db.query('core_store').find({ key: conf.key });\n      if (existingConf) {\n        stats.merged += 1;\n        await db.query('core_store').update({ key: conf.key }, _.merge(existingConf, conf));\n      } else {\n        stats.created += 1;\n        await db.query('core_store').create(conf);\n      }\n    },\n  };\n};\n\n/**\n * Merge importer. Will keep the keys that already exist without changing them and create the new ones\n * @param {Object} db - DatabaseManager instance\n */\nconst createKeepImporter = db => {\n  const stats = {\n    created: 0,\n    untouched: 0,\n  };\n\n  return {\n    printStatistics() {\n      return `${stats.created} created, ${stats.untouched} untouched`;\n    },\n\n    async import(conf) {\n      const matching = await db.query('core_store').count({ key: conf.key });\n      if (matching > 0) {\n        stats.untouched += 1;\n        // if configuration already exists do not overwrite it\n        return;\n      }\n\n      stats.created += 1;\n      await db.query('core_store').create(conf);\n    },\n  };\n};\n",
    "packages/strapi/lib/load/glob.js": "'use strict';\n\nconst glob = require('glob');\n\n/**\n * Promise based glob\n */\nmodule.exports = (...args) => {\n  return new Promise((resolve, reject) => {\n    glob(...args, (err, files) => {\n      if (err) return reject(err);\n      resolve(files);\n    });\n  });\n};\n",
    "packages/strapi-admin/admin/src/hooks/useFetchPluginsFromMarketPlace/tests/useFetchPluginsFromMarketPlace.test.js": "import { renderHook } from '@testing-library/react-hooks';\nimport axios from 'axios';\n// eslint-disable-next-line import/no-unresolved\nimport MockAdapter from 'axios-mock-adapter';\n\nimport useFetch from '../index';\n\ndescribe('ADMIN | hooks | useFetchPluginsFromMarketPlace', () => {\n  it('should perform a GET request', async () => {\n    const mock = new MockAdapter(axios);\n    const mockData = [{ ok: true }];\n    mock.onGet().replyOnce(200, mockData);\n\n    const { result, waitForNextUpdate } = renderHook(() => useFetch());\n\n    expect(result.current.isLoading).toBeTruthy();\n\n    await waitForNextUpdate();\n\n    expect(result.current.isLoading).toBeFalsy();\n    expect(result.current.error).toBeFalsy();\n    expect(result.current.data).toEqual(mockData);\n  });\n\n  it('should handle the errors correctly', async () => {\n    const mock = new MockAdapter(axios);\n\n    mock.onGet().replyOnce(() => {\n      return new Promise((_, reject) => {\n        reject(new Error(''));\n      });\n    });\n\n    const { result, waitForNextUpdate } = renderHook(() => useFetch());\n\n    expect(result.current.isLoading).toBeTruthy();\n\n    await waitForNextUpdate();\n\n    expect(result.current.isLoading).toBeFalsy();\n    expect(result.current.error).toBeTruthy();\n    expect(result.current.data).toBeNull();\n  });\n});\n",
    "packages/strapi-admin/index.js": "'use strict';\n/* eslint-disable no-useless-escape */\nconst path = require('path');\nconst _ = require('lodash');\nconst fs = require('fs-extra');\nconst webpack = require('webpack');\nconst WebpackDevServer = require('webpack-dev-server');\nconst chalk = require('chalk');\nconst chokidar = require('chokidar');\n// eslint-disable-next-line node/no-extraneous-require\nconst hasEE = require('strapi/lib/utils/ee');\nconst getWebpackConfig = require('./webpack.config.js');\n\nconst getPkgPath = name => path.dirname(require.resolve(`${name}/package.json`));\n\nfunction getCustomWebpackConfig(dir, config) {\n  const adminConfigPath = path.join(dir, 'admin', 'admin.config.js');\n\n  let webpackConfig = getWebpackConfig({ useEE: hasEE({ dir }), ...config });\n\n  if (fs.existsSync(adminConfigPath)) {\n    const adminConfig = require(path.resolve(adminConfigPath));\n\n    if (_.isFunction(adminConfig.webpack)) {\n      webpackConfig = adminConfig.webpack(webpackConfig, webpack);\n\n      if (!webpackConfig) {\n        console.error(\n          `${chalk.red('Error:')} Nothing was returned from your custom webpack configuration`\n        );\n        process.exit(1);\n      }\n    }\n  }\n\n  return webpackConfig;\n}\n\nasync function build({ dir, env, options, optimize }) {\n  // Create the cache dir containing the front-end files.\n  await createCacheDir(dir);\n\n  const cacheDir = path.resolve(dir, '.cache');\n  const entry = path.resolve(cacheDir, 'admin', 'src', 'app.js');\n  const dest = path.resolve(dir, 'build');\n  const config = getCustomWebpackConfig(dir, { entry, dest, env, options, optimize });\n\n  const compiler = webpack(config);\n\n  return new Promise((resolve, reject) => {\n    compiler.run((err, stats) => {\n      let messages;\n      if (err) {\n        if (!err.message) {\n          return reject(err);\n        }\n        messages = {\n          errors: [err.message],\n          warnings: [],\n        };\n      } else {\n        messages = stats.toJson({ all: false, warnings: true, errors: true });\n      }\n\n      if (messages.errors.length) {\n        // Only keep the first error. Others are often indicative\n        // of the same problem, but confuse the reader with noise.\n        if (messages.errors.length > 1) {\n          messages.errors.length = 1;\n        }\n        return reject(new Error(messages.errors.join('\\n\\n')));\n      }\n\n      return resolve({\n        stats,\n        warnings: messages.warnings,\n      });\n    });\n  });\n}\n\nasync function createPluginsJs(plugins, localPlugins, dest) {\n  const content = `\nconst injectReducer = require('./utils/injectReducer').default;\nconst injectSaga = require('./utils/injectSaga').default;\nconst useInjectReducer = require('./utils/injectReducer').useInjectReducer;\nconst useInjectSaga = require('./utils/injectSaga').useInjectSaga;\nconst { languages } = require('./i18n');\n\nwindow.strapi = Object.assign(window.strapi || {}, {\n  node: MODE || 'host',\n  backendURL: BACKEND_URL === '/' ? window.location.origin : BACKEND_URL,\n  languages,\n  currentLanguage:\n  window.localStorage.getItem('strapi-admin-language') ||\n  window.navigator.language ||\n  window.navigator.userLanguage ||\n  'en',\n  injectReducer,\n  injectSaga,\n  useInjectReducer,\n  useInjectSaga,\n});\n\nmodule.exports = {\n  ${plugins\n    .map(name => {\n      const shortName = name.replace(/^strapi-plugin-/i, '');\n      const req = `require('../../plugins/${name}/admin/src').default`;\n      return `'${shortName}': ${req},`;\n    })\n    .join('\\n')}\n  ${localPlugins\n    .map(name => {\n      const shortName = name.replace(/^strapi-plugin-/i, '');\n      const req = `require('../../../plugins/${name}/admin/src').default`;\n      return `'${shortName}': ${req}`;\n    })\n    .join(',\\n')}\n}\n  `;\n\n  return fs.writeFile(path.resolve(dest, 'admin', 'src', 'plugins.js'), content);\n}\n\nasync function clean({ dir }) {\n  const buildDir = path.join(dir, 'build');\n  const cacheDir = path.join(dir, '.cache');\n\n  fs.removeSync(buildDir);\n  fs.removeSync(cacheDir);\n}\n\nasync function copyPlugin(name, dest) {\n  const pkgFilePath = getPkgPath(name);\n\n  const resolveDepPath = (...args) => path.resolve(pkgFilePath, ...args);\n  const resolveDest = (...args) => path.resolve(dest, 'plugins', name, ...args);\n\n  const copy = (...args) => {\n    return fs.copy(resolveDepPath(...args), resolveDest(...args));\n  };\n\n  // Copy the entire admin folder\n  await copy('admin');\n\n  // Copy the layout.js if it exists\n  if (await fs.exists(path.resolve(pkgFilePath, 'config', 'layout.js'))) {\n    await fs.ensureDir(resolveDest('config'));\n    await copy('config', 'layout.js');\n  }\n\n  await copy('package.json');\n}\n\nasync function copyAdmin(dest) {\n  const adminPath = getPkgPath('strapi-admin');\n\n  // TODO copy ee folders for plugins\n  await fs.copy(path.resolve(adminPath, 'ee', 'admin'), path.resolve(dest, 'ee', 'admin'));\n\n  await fs.ensureDir(path.resolve(dest, 'config'));\n  await fs.copy(path.resolve(adminPath, 'admin'), path.resolve(dest, 'admin'));\n  await fs.copy(\n    path.resolve(adminPath, 'config', 'layout.js'),\n    path.resolve(dest, 'config', 'layout.js')\n  );\n\n  // Copy package.json\n  await fs.copy(path.resolve(adminPath, 'package.json'), path.resolve(dest, 'package.json'));\n}\n\nasync function copyCustomAdmin(src, dest) {\n  await fs.copy(src, path.resolve(dest, 'admin'));\n}\n\nasync function createCacheDir(dir) {\n  const cacheDir = path.resolve(dir, '.cache');\n\n  const pkgJSON = require(path.join(dir, 'package.json'));\n\n  const pluginsToCopy = Object.keys(pkgJSON.dependencies).filter(\n    dep =>\n      dep.startsWith('strapi-plugin') &&\n      fs.existsSync(path.resolve(getPkgPath(dep), 'admin', 'src', 'index.js'))\n  );\n\n  let localPluginsToCopy = [];\n  if (fs.existsSync(path.join(dir, 'plugins'))) {\n    localPluginsToCopy = fs\n      .readdirSync(path.join(dir, 'plugins'))\n      .filter(plugin =>\n        fs.existsSync(path.resolve(dir, 'plugins', plugin, 'admin', 'src', 'index.js'))\n      );\n  }\n\n  // TODO: add logic to avoid copying files if not necessary\n\n  // create .cache dir\n  await fs.emptyDir(cacheDir);\n\n  // copy admin core code\n  await copyAdmin(cacheDir);\n\n  // copy plugins code\n  await Promise.all(pluginsToCopy.map(name => copyPlugin(name, cacheDir)));\n\n  // override admin code with user customizations\n  if (fs.pathExistsSync(path.join(dir, 'admin'))) {\n    await copyCustomAdmin(path.join(dir, 'admin'), cacheDir);\n  }\n\n  // create plugins.js with plugins requires\n  await createPluginsJs(pluginsToCopy, localPluginsToCopy, cacheDir);\n\n  // override plugins' admin code with user customizations\n  const pluginsToOverride = pluginsToCopy.reduce((acc, current) => {\n    const pluginName = current.replace(/^strapi-plugin-/i, '');\n\n    if (fs.pathExistsSync(path.join(dir, 'extensions', pluginName, 'admin'))) {\n      acc.push(pluginName);\n    }\n\n    return acc;\n  }, []);\n\n  await Promise.all(\n    pluginsToOverride.map(plugin =>\n      copyCustomAdmin(\n        path.join(dir, 'extensions', plugin, 'admin'),\n        path.join(cacheDir, 'plugins', `strapi-plugin-${plugin}`)\n      )\n    )\n  );\n}\n\nasync function watchAdmin({ dir, host, port, browser, options }) {\n  // Create the cache dir containing the front-end files.\n  await createCacheDir(dir);\n\n  const entry = path.join(dir, '.cache', 'admin', 'src', 'app.js');\n  const dest = path.join(dir, 'build');\n  const env = 'development';\n\n  const args = {\n    entry,\n    dest,\n    env,\n    port,\n    options,\n  };\n\n  const opts = {\n    clientLogLevel: 'silent',\n    quiet: true,\n    open: browser === 'true' ? true : browser,\n    publicPath: options.publicPath,\n    historyApiFallback: {\n      index: options.publicPath,\n      disableDotRule: true,\n    },\n  };\n\n  const webpackConfig = getCustomWebpackConfig(dir, args);\n  const server = new WebpackDevServer(webpack(webpackConfig), opts);\n\n  server.listen(port, host, function(err) {\n    if (err) {\n      console.log(err);\n    }\n\n    console.log(chalk.green('Starting the development server...'));\n    console.log();\n    console.log(chalk.green(`Admin development at http://${host}:${port}${opts.publicPath}`));\n  });\n\n  watchFiles(dir, options.watchIgnoreFiles);\n}\n\nasync function watchFiles(dir, ignoreFiles = []) {\n  const cacheDir = path.join(dir, '.cache');\n  const pkgJSON = require(path.join(dir, 'package.json'));\n  const admin = path.join(dir, 'admin');\n  const extensionsPath = path.join(dir, 'extensions');\n\n  const appPlugins = Object.keys(pkgJSON.dependencies).filter(\n    dep =>\n      dep.startsWith('strapi-plugin') &&\n      fs.existsSync(path.resolve(getPkgPath(dep), 'admin', 'src', 'index.js'))\n  );\n  const pluginsToWatch = appPlugins.map(plugin =>\n    path.join(extensionsPath, plugin.replace(/^strapi-plugin-/i, ''), 'admin')\n  );\n  const filesToWatch = [admin, ...pluginsToWatch];\n\n  const watcher = chokidar.watch(filesToWatch, {\n    ignoreInitial: true,\n    ignorePermissionErrors: true,\n    ignored: [...ignoreFiles],\n  });\n\n  watcher.on('all', async (event, filePath) => {\n    const isExtension = filePath.includes(extensionsPath);\n    const pluginName = isExtension ? filePath.replace(extensionsPath, '').split(path.sep)[1] : '';\n\n    const packageName = isExtension ? `strapi-plugin-${pluginName}` : 'strapi-admin';\n\n    const targetPath = isExtension\n      ? path.normalize(filePath.split(extensionsPath)[1].replace(pluginName, ''))\n      : path.normalize(filePath.split(admin)[1]);\n\n    const destFolder = isExtension\n      ? path.join(cacheDir, 'plugins', packageName)\n      : path.join(cacheDir, 'admin');\n\n    if (event === 'unlink' || event === 'unlinkDir') {\n      const originalFilePathInNodeModules = path.join(\n        getPkgPath(packageName),\n        isExtension ? '' : 'admin',\n        targetPath\n      );\n\n      // Remove the file or folder\n      // We need to copy the original files when deleting an override one\n      try {\n        fs.removeSync(path.join(destFolder, targetPath));\n      } catch (err) {\n        console.log('An error occured while deleting the file', err);\n      }\n\n      // Check if the file or folder exists in node_modules\n      // If so copy the old one\n      if (fs.pathExistsSync(path.resolve(originalFilePathInNodeModules))) {\n        try {\n          await fs.copy(\n            path.resolve(originalFilePathInNodeModules),\n            path.join(destFolder, targetPath)\n          );\n\n          // The plugins.js file needs to be recreated\n          // when we delete either the admin folder\n          // the admin/src folder\n          // or the plugins.js file\n          // since the path are different when developing inside the monorepository or inside an app\n          const shouldCopyPluginsJSFile =\n            filePath.split('/admin/src').filter(p => !!p).length === 1;\n\n          if (\n            (event === 'unlinkDir' && !isExtension && shouldCopyPluginsJSFile) ||\n            (!isExtension && filePath.includes('plugins.js'))\n          ) {\n            await createPluginsJs(appPlugins, path.join(cacheDir));\n          }\n        } catch (err) {\n          // Do nothing\n        }\n      }\n    } else {\n      // In any other case just copy the file into the .cache folder\n      try {\n        await fs.copy(filePath, path.join(destFolder, targetPath));\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  });\n}\n\nmodule.exports = {\n  clean,\n  build,\n  watchAdmin,\n};\n",
    "packages/strapi-admin/services/__tests__/permissions.engine.test.js": "'use strict';\n\nconst _ = require('lodash');\nconst { subject } = require('@casl/ability');\nconst createConditionProvider = require('../permission/condition-provider');\nconst createPermissionsEngine = require('../permission/engine');\n\ndescribe('Permissions Engine', () => {\n  let conditionProvider;\n  let engine;\n\n  const localTestData = {\n    users: {\n      bob: {\n        firstname: 'Bob',\n        title: 'guest',\n        roles: [{ id: 1 }, { id: 2 }],\n      },\n      alice: {\n        firstname: 'Alice',\n        title: 'admin',\n        roles: [{ id: 1 }],\n      },\n      kai: {\n        firstname: 'Kai',\n        title: 'admin',\n        roles: [{ id: 3 }],\n      },\n      foo: {\n        firstname: 'Foo',\n        title: 'Bar',\n        roles: [{ id: 4 }],\n      },\n    },\n    roles: {\n      1: {\n        permissions: [\n          {\n            action: 'read',\n            subject: 'article',\n            fields: ['**'],\n            conditions: ['plugins::test.isBob'],\n          },\n          {\n            action: 'read',\n            subject: 'user',\n            fields: ['title'],\n            conditions: ['plugins::test.isAdmin'],\n          },\n        ],\n      },\n      2: {\n        permissions: [\n          {\n            action: 'post',\n            subject: 'article',\n            fields: ['*'],\n            conditions: ['plugins::test.isBob'],\n          },\n        ],\n      },\n      3: {\n        permissions: [\n          {\n            action: 'read',\n            subject: 'user',\n            fields: ['title'],\n            conditions: ['plugins::test.isContainedIn'],\n          },\n        ],\n      },\n      4: {\n        permissions: [\n          {\n            action: 'read',\n            subject: 'user',\n            fields: [],\n          },\n        ],\n      },\n    },\n    conditions: [\n      {\n        plugin: 'test',\n        name: 'isBob',\n        category: 'default',\n        handler: async user => new Promise(resolve => resolve(user.firstname === 'Bob')),\n      },\n      {\n        plugin: 'test',\n        name: 'isAdmin',\n        category: 'default',\n        handler: user => user.title === 'admin',\n      },\n      {\n        plugin: 'test',\n        name: 'isCreatedBy',\n        category: 'default',\n        handler: user => ({ created_by: user.firstname }),\n      },\n      {\n        plugin: 'test',\n        name: 'isContainedIn',\n        category: 'default',\n        handler: { firstname: { $in: ['Alice', 'Foo'] } },\n      },\n    ],\n  };\n\n  const getUser = name => localTestData.users[name];\n\n  beforeEach(() => {\n    global.strapi = {\n      isLoaded: false,\n      admin: {\n        services: {\n          permission: {\n            findUserPermissions: jest.fn(({ roles }) =>\n              _.reduce(\n                localTestData.roles,\n                (acc, { permissions: value }, key) => {\n                  return roles.map(_.property('id')).includes(_.toNumber(key))\n                    ? [...acc, ...value]\n                    : acc;\n                },\n                []\n              )\n            ),\n          },\n        },\n      },\n    };\n\n    conditionProvider = createConditionProvider();\n    conditionProvider.registerMany(localTestData.conditions);\n\n    engine = createPermissionsEngine(conditionProvider);\n\n    jest.spyOn(engine, 'evaluatePermission');\n    jest.spyOn(engine, 'createRegisterFunction');\n    jest.spyOn(engine, 'generateAbilityCreatorFor');\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('GenerateUserAbility', () => {\n    test('Successfully creates an ability for Bob', async () => {\n      const user = getUser('bob');\n\n      const ability = await engine.generateUserAbility(user);\n\n      const expected = [\n        {\n          action: 'read',\n          fields: ['**'],\n          subject: 'article',\n        },\n        {\n          action: 'post',\n          fields: ['*'],\n          subject: 'article',\n        },\n      ];\n\n      expect(engine.generateAbilityCreatorFor).toHaveBeenCalledWith(user);\n      expect(_.orderBy(ability.rules, ['subject'], ['asc'])).toMatchObject(expected);\n\n      expect(ability.can('post', 'article')).toBeTruthy();\n      expect(ability.can('post', 'article', 'user')).toBeTruthy();\n      expect(ability.can('post', 'article', 'user.nested')).toBeFalsy();\n\n      expect(ability.can('read', 'article')).toBeTruthy();\n      expect(ability.can('read', 'article', 'title')).toBeTruthy();\n      expect(ability.can('read', 'article', 'title.nested')).toBeTruthy();\n\n      expect(ability.can('read', 'user')).toBeFalsy();\n      expect(ability.can('read', 'user', 'firstname')).toBeFalsy();\n      expect(ability.can('read', 'user', 'title')).toBeFalsy();\n      expect(ability.can('read', 'user', 'title.nested')).toBeFalsy();\n    });\n\n    test('Successfully creates an ability for Alice', async () => {\n      const user = getUser('alice');\n\n      const ability = await engine.generateUserAbility(user);\n\n      const expected = [\n        {\n          action: 'read',\n          fields: ['title'],\n          subject: 'user',\n        },\n      ];\n\n      expect(engine.generateAbilityCreatorFor).toHaveBeenCalledWith(user);\n      expect(_.orderBy(ability.rules, ['action'], ['asc'])).toMatchObject(expected);\n\n      expect(ability.can('post', 'article')).toBeFalsy();\n      expect(ability.can('post', 'article', 'user')).toBeFalsy();\n      expect(ability.can('post', 'article', 'user.nested')).toBeFalsy();\n\n      expect(ability.can('read', 'article')).toBeFalsy();\n      expect(ability.can('read', 'article', 'title')).toBeFalsy();\n      expect(ability.can('read', 'article', 'title.nested')).toBeFalsy();\n\n      expect(ability.can('read', 'user')).toBeTruthy();\n      expect(ability.can('read', 'user', 'firstname')).toBeFalsy();\n      expect(ability.can('read', 'user', 'title')).toBeTruthy();\n      expect(ability.can('read', 'user', 'title.nested')).toBeFalsy();\n    });\n\n    test('Ignore permission on empty fields array', async () => {\n      const user = getUser('foo');\n\n      const ability = await engine.generateUserAbility(user);\n\n      expect(engine.generateAbilityCreatorFor).toHaveBeenCalledWith(user);\n      expect(ability.rules).toHaveLength(0);\n      expect(ability.can('read', 'user')).toBeFalsy();\n    });\n\n    describe('Use objects as subject', () => {\n      let ability;\n\n      beforeAll(async () => {\n        const user = getUser('kai');\n        ability = await engine.generateUserAbility(user);\n      });\n\n      test('Fails to validate the object condition', () => {\n        const args = ['read', subject('user', { firstname: 'Bar' }), 'title'];\n\n        expect(ability.can(...args)).toBeFalsy();\n      });\n\n      test('Fails to read a restricted field', () => {\n        const args = ['read', subject('user', { firstname: 'Foo' }), 'bar'];\n\n        expect(ability.can(...args)).toBeFalsy();\n      });\n\n      test('Successfully validate the permission', () => {\n        const args = ['read', subject('user', { firstname: 'Foo' }), 'title'];\n\n        expect(ability.can(...args)).toBeTruthy();\n      });\n    });\n  });\n\n  describe('Generate Ability Creator For', () => {\n    test('Successfully generates an ability creator for Alice', async () => {\n      const user = getUser('alice');\n\n      const abilityCreator = engine.generateAbilityCreatorFor(user);\n      const ability = await abilityCreator([]);\n\n      expect(abilityCreator).not.toBeUndefined();\n      expect(typeof abilityCreator).toBe('function');\n      expect(ability.rules).toStrictEqual([]);\n    });\n  });\n\n  describe('Evaluate Permission', () => {\n    test('It should register the permission (no conditions / true result)', async () => {\n      const permission = { action: 'read', subject: 'article', fields: ['title'] };\n      const user = getUser('alice');\n      const registerFn = jest.fn();\n\n      await engine.evaluatePermission({ permission, user, registerFn });\n\n      expect(registerFn).toHaveBeenCalledWith({ ...permission, condition: true });\n    });\n\n    test('It should register the permission (conditions / true result)', async () => {\n      const permission = {\n        action: 'read',\n        subject: 'article',\n        fields: ['title'],\n        conditions: ['plugins::test.isAdmin'],\n      };\n      const user = getUser('alice');\n      const registerFn = jest.fn();\n\n      await engine.evaluatePermission({ permission, user, registerFn });\n\n      const expected = {\n        ..._.omit(permission, 'conditions'),\n        condition: true,\n      };\n\n      expect(registerFn).toHaveBeenCalledWith(expected);\n    });\n\n    test('It should not register the permission (conditions / false result)', async () => {\n      const permission = {\n        action: 'read',\n        subject: 'article',\n        fields: ['title'],\n        conditions: ['plugins::test.isBob'],\n      };\n      const user = getUser('alice');\n      const registerFn = jest.fn();\n\n      await engine.evaluatePermission({ permission, user, registerFn });\n\n      expect(registerFn).not.toHaveBeenCalled();\n    });\n\n    test('It should register the permission (conditions / object result)', async () => {\n      const permission = {\n        action: 'read',\n        subject: 'article',\n        fields: ['title'],\n        conditions: ['plugins::test.isCreatedBy'],\n      };\n      const user = getUser('alice');\n      const registerFn = jest.fn();\n\n      await engine.evaluatePermission({ permission, user, registerFn });\n\n      const expected = {\n        ..._.omit(permission, 'conditions'),\n        condition: { created_by: user.firstname },\n      };\n\n      expect(registerFn).toHaveBeenCalledWith(expected);\n    });\n  });\n\n  describe('Create Register Function', () => {\n    let can;\n    let registerFn;\n\n    beforeEach(() => {\n      can = jest.fn();\n      registerFn = engine.createRegisterFunction(can);\n    });\n\n    test('It should calls the can function without any condition', () => {\n      registerFn({ action: 'read', subject: 'article', fields: '*', condition: true });\n\n      expect(can).toHaveBeenCalledTimes(1);\n      expect(can).toHaveBeenCalledWith('read', 'article', '*', undefined);\n    });\n\n    test('It should calls the can function with a condition', () => {\n      registerFn({ action: 'read', subject: 'article', fields: '*', condition: { created_by: 1 } });\n\n      expect(can).toHaveBeenCalledTimes(1);\n      expect(can).toHaveBeenCalledWith('read', 'article', '*', { created_by: 1 });\n    });\n  });\n\n  describe('Check Many', () => {\n    let ability;\n    const permissions = [\n      { action: 'read', subject: 'user', field: 'title' },\n      { action: 'post', subject: 'article' },\n    ];\n\n    beforeEach(() => {\n      ability = { can: jest.fn(() => true) };\n    });\n\n    afterEach(() => {\n      jest.clearAllMocks();\n    });\n\n    test('Using curried version of checkMany', () => {\n      const checkMany = engine.checkMany(ability);\n\n      const res = checkMany(permissions);\n\n      expect(res).toHaveLength(permissions.length);\n      expect(ability.can).toHaveBeenCalledTimes(2);\n    });\n\n    test('Using raw version of checkMany', () => {\n      const res = engine.checkMany(ability, permissions);\n\n      expect(res).toHaveLength(permissions.length);\n      expect(ability.can).toHaveBeenCalledTimes(2);\n    });\n  });\n});\n",
    "packages/strapi-admin/services/__tests__/token.test.js": "'use strict';\n\nconst { createJwtToken, getTokenOptions, decodeJwtToken, createToken } = require('../token');\n\nconst delay = time => new Promise(resolve => setTimeout(resolve, time));\n\ndescribe('Token', () => {\n  describe('token options', () => {\n    test('Has defaults', () => {\n      const getFn = jest.fn(() => ({}));\n      global.strapi = {\n        config: {\n          get: getFn,\n        },\n      };\n\n      const res = getTokenOptions();\n\n      expect(getFn).toHaveBeenCalledWith('server.admin.auth', {});\n      expect(res).toEqual({ options: { expiresIn: '30d' } });\n    });\n\n    test('Merges defaults with configuration', () => {\n      const config = {\n        options: {},\n        secret: '123',\n      };\n\n      const getFn = jest.fn(() => config);\n      global.strapi = {\n        config: {\n          get: getFn,\n        },\n      };\n\n      const res = getTokenOptions();\n\n      expect(getFn).toHaveBeenCalledWith('server.admin.auth', {});\n      expect(res).toEqual({\n        options: {\n          expiresIn: '30d',\n        },\n        secret: config.secret,\n      });\n    });\n\n    test('Overwrite defaults with configuration options', () => {\n      const config = {\n        options: {\n          expiresIn: '1d',\n        },\n        secret: '123',\n      };\n\n      const getFn = jest.fn(() => config);\n      global.strapi = {\n        config: {\n          get: getFn,\n        },\n      };\n\n      const res = getTokenOptions();\n\n      expect(getFn).toHaveBeenCalledWith('server.admin.auth', {});\n      expect(res).toEqual({\n        options: {\n          expiresIn: '1d',\n        },\n        secret: config.secret,\n      });\n    });\n  });\n\n  describe('createJwtToken', () => {\n    test('Returns a jwt token', () => {\n      global.strapi = {\n        config: {\n          get() {\n            return {\n              secret: 'test-123',\n            };\n          },\n        },\n      };\n\n      const token = createJwtToken({ id: 1 });\n\n      expect(token).toBeDefined();\n      expect(typeof token === 'string').toBe(true);\n    });\n\n    test('Token payload does not leak user infos', () => {\n      global.strapi = {\n        config: {\n          get() {\n            return {\n              secret: 'test-123',\n            };\n          },\n        },\n      };\n\n      const token = createJwtToken({\n        id: 1,\n        password: 'pcw123',\n        firstname: 'Test',\n        email: 'test@strapi.io',\n      });\n\n      const { payload } = decodeJwtToken(token);\n\n      expect(payload).toEqual({\n        id: 1,\n        iat: expect.any(Number),\n        exp: expect.any(Number),\n      });\n    });\n  });\n\n  describe('decodeJwtToken', () => {\n    test('Fails if the token is invalid', () => {\n      const { payload, isValid } = decodeJwtToken('invalid-token');\n      expect(payload).toBe(null);\n      expect(isValid).toBe(false);\n    });\n\n    test('Fails if the token was not generated with the same secret', () => {\n      global.strapi = {\n        config: {\n          get() {\n            return {\n              secret: 'test-123',\n            };\n          },\n        },\n      };\n\n      const user = { id: 1 };\n      const token = createJwtToken(user);\n\n      global.strapi = {\n        config: {\n          get() {\n            return {\n              secret: 'not-the-same-secret',\n            };\n          },\n        },\n      };\n\n      const { payload, isValid } = decodeJwtToken(token);\n      expect(payload).toBe(null);\n      expect(isValid).toBe(false);\n    });\n\n    test('Fails if the token has expired', async () => {\n      global.strapi = {\n        config: {\n          get() {\n            return {\n              options: {\n                expiresIn: '1ms',\n              },\n              secret: 'test-123',\n            };\n          },\n        },\n      };\n\n      const user = { id: 1 };\n      const token = createJwtToken(user);\n\n      await delay(10);\n\n      const { payload, isValid } = decodeJwtToken(token);\n      expect(payload).toBe(null);\n      expect(isValid).toBe(false);\n    });\n\n    test('Returns payload if token is valid', async () => {\n      global.strapi = {\n        config: {\n          get() {\n            return {\n              options: { expiresIn: '30d' },\n              secret: 'test-123',\n            };\n          },\n        },\n      };\n\n      const user = { id: 1 };\n      const token = createJwtToken(user);\n\n      const { payload, isValid } = decodeJwtToken(token);\n      expect(payload).toEqual({\n        id: 1,\n        iat: expect.any(Number),\n        exp: expect.any(Number),\n      });\n      expect(isValid).toBe(true);\n    });\n  });\n\n  describe('createToken', () => {\n    test('Create a random token of length 128', () => {\n      const token = createToken();\n\n      expect(token).toBeDefined();\n      expect(typeof token === 'string').toBe(true);\n      expect(token.length).toBe(40);\n    });\n  });\n});\n",
    "packages/strapi-helper-plugin/lib/src/utils/request.js": "import 'whatwg-fetch';\nimport _ from 'lodash';\nimport auth from './auth';\n\n/**\n * Parses the JSON returned by a network request\n *\n * @param  {object} response A response from a network request\n *\n * @return {object}          The parsed JSON from the request\n */\nfunction parseJSON(response) {\n  return response.json ? response.json() : response;\n}\n\n/**\n * Checks if a network request came back fine, and throws an error if not\n *\n * @param  {object} response   A response from a network request\n *\n * @return {object|undefined} Returns either the response, or throws an error\n */\nfunction checkStatus(response, checkToken = true) {\n  if ((response.status >= 200 && response.status < 300) || response.status === 0) {\n    return response;\n  }\n\n  // TODO handle 403...\n\n  if (response.status === 401 && auth.getToken() && checkToken) {\n    // Temporary fix until we create a new request helper\n    auth.clearAppStorage();\n    window.location.reload();\n  }\n\n  return parseJSON(response)\n    .then(responseFormatted => {\n      const error = new Error(response.statusText);\n      error.response = response;\n      error.response.payload = responseFormatted;\n      throw error;\n    })\n    .catch(() => {\n      const error = new Error(response.statusText);\n      error.response = response;\n\n      throw error;\n    });\n}\n\n/**\n * Format query params\n *\n * @param params\n * @returns {string}\n */\nfunction formatQueryParams(params) {\n  return Object.keys(params)\n    .map(k => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`)\n    .join('&');\n}\n\n/**\n * Server restart watcher\n * @param response\n * @returns {object} the response data\n */\nfunction serverRestartWatcher(response) {\n  return new Promise(resolve => {\n    fetch(`${strapi.backendURL}/_health`, {\n      method: 'HEAD',\n      mode: 'no-cors',\n      headers: {\n        'Content-Type': 'application/json',\n        'Keep-Alive': false,\n      },\n    })\n      .then(res => {\n        if (res.status >= 400) {\n          throw new Error('not available');\n        }\n\n        resolve(response);\n      })\n      .catch(() => {\n        setTimeout(() => {\n          return serverRestartWatcher(response).then(resolve);\n        }, 100);\n      });\n  });\n}\n\n/**\n * Requests a URL, returning a promise\n *\n * @param  {string} url       The URL we want to request\n * @param  {object} [options] The options we want to pass to \"fetch\"\n *\n * @return {object}           The response data\n */\nexport default function request(...args) {\n  let [url, options = {}, shouldWatchServerRestart, stringify = true, ...rest] = args;\n  let noAuth;\n\n  try {\n    [{ noAuth }] = rest;\n  } catch (err) {\n    noAuth = false;\n  }\n\n  // Set headers\n  if (!options.headers) {\n    options.headers = Object.assign(\n      {\n        'Content-Type': 'application/json',\n      },\n      options.headers\n    );\n  }\n\n  const token = auth.getToken();\n\n  if (token && !noAuth) {\n    options.headers = Object.assign(\n      {\n        Authorization: `Bearer ${token}`,\n      },\n      options.headers\n    );\n  }\n\n  // Add parameters to url\n  url = _.startsWith(url, '/') ? `${strapi.backendURL}${url}` : url;\n\n  if (options && options.params) {\n    const params = formatQueryParams(options.params);\n    url = `${url}?${params}`;\n  }\n\n  // Stringify body object\n  if (options && options.body && stringify) {\n    options.body = JSON.stringify(options.body);\n  }\n\n  return fetch(url, options)\n    .then(checkStatus)\n    .then(parseJSON)\n    .then(response => {\n      if (shouldWatchServerRestart) {\n        return serverRestartWatcher(response);\n      }\n\n      return response;\n    });\n}\n",
    "packages/strapi-plugin-content-type-builder/admin/src/containers/ListView/index.js": "import React, { useEffect, useMemo, useState } from 'react';\nimport { Prompt, useHistory, useLocation } from 'react-router-dom';\nimport PropTypes from 'prop-types';\nimport { get, has, isEqual } from 'lodash';\nimport { BackHeader, ListWrapper, useGlobalContext } from 'strapi-helper-plugin';\nimport { Header } from '@buffetjs/custom';\nimport ListViewContext from '../../contexts/ListViewContext';\nimport convertAttrObjToArray from '../../utils/convertAttrObjToArray';\nimport getAttributeDisplayedType from '../../utils/getAttributeDisplayedType';\nimport pluginId from '../../pluginId';\nimport getComponents from '../../utils/getComponents';\nimport getTrad from '../../utils/getTrad';\nimport makeSearch from '../../utils/makeSearch';\nimport ListRow from '../../components/ListRow';\nimport List from '../../components/List';\nimport ListButton from '../../components/ListButton';\nimport useDataManager from '../../hooks/useDataManager';\nimport ListHeader from '../../components/ListHeader';\nimport LeftMenu from '../LeftMenu';\nimport Wrapper from './Wrapper';\n\n/* eslint-disable indent */\n\nconst ListView = () => {\n  const {\n    initialData,\n    modifiedData,\n    isInDevelopmentMode,\n    isInContentTypeView,\n    submitData,\n    toggleModalCancel,\n  } = useDataManager();\n\n  const { emitEvent, formatMessage, plugins } = useGlobalContext();\n  const { push, goBack } = useHistory();\n  const { search } = useLocation();\n  const [enablePrompt, togglePrompt] = useState(true);\n\n  useEffect(() => {\n    if (search === '') {\n      togglePrompt(true);\n    }\n  }, [search]);\n\n  // Disabling the prompt on the first render if one of the modal is open\n  useEffect(() => {\n    if (search !== '') {\n      togglePrompt(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const firstMainDataPath = isInContentTypeView ? 'contentType' : 'component';\n  const mainDataTypeAttributesPath = [firstMainDataPath, 'schema', 'attributes'];\n  const targetUid = get(modifiedData, [firstMainDataPath, 'uid']);\n  const isTemporary = get(modifiedData, [firstMainDataPath, 'isTemporary'], false);\n  const contentTypeKind = get(modifiedData, [firstMainDataPath, 'schema', 'kind'], null);\n\n  const attributes = get(modifiedData, mainDataTypeAttributesPath, {});\n  const attributesLength = Object.keys(attributes).length;\n  const currentDataName = get(initialData, [firstMainDataPath, 'schema', 'name'], '');\n  const isFromPlugin = has(initialData, [firstMainDataPath, 'plugin']);\n  const hasModelBeenModified = !isEqual(modifiedData, initialData);\n  const forTarget = isInContentTypeView ? 'contentType' : 'component';\n\n  const handleClickAddField = async (\n    forTarget,\n    targetUid,\n    firstHeaderObj,\n    secondHeaderObj,\n    thirdHeaderObj,\n    fourthHeaderObj\n  ) => {\n    // disable the prompt\n    await wait();\n\n    const searchObj = {\n      modalType: 'chooseAttribute',\n      forTarget,\n      targetUid,\n      ...firstHeaderObj,\n      ...secondHeaderObj,\n      ...thirdHeaderObj,\n      ...fourthHeaderObj,\n    };\n\n    push({ search: makeSearch(searchObj) });\n  };\n\n  const handleClickAddComponentToDZ = async dzName => {\n    const firstHeaderObject = {\n      header_label_1: currentDataName,\n      header_icon_name_1: 'dynamiczone',\n      header_icon_isCustom_1: false,\n    };\n    const secondHeaderObj = {\n      header_label_2: dzName,\n    };\n    const search = {\n      modalType: 'addComponentToDynamicZone',\n      forTarget: 'contentType',\n      targetUid,\n      dynamicZoneTarget: dzName,\n      settingType: 'base',\n      step: '1',\n      actionType: 'edit',\n      ...firstHeaderObject,\n      ...secondHeaderObj,\n    };\n\n    await wait();\n\n    push({ search: makeSearch(search, true) });\n  };\n\n  const handleClickEditField = async (\n    forTarget,\n    targetUid,\n    attributeName,\n    type,\n    firstHeaderObj,\n    secondHeaderObj,\n    thirdHeaderObj,\n    fourthHeaderObj,\n    fifthHeaderObj\n  ) => {\n    const attributeType = getAttributeDisplayedType(type);\n\n    await wait();\n\n    const search = {\n      modalType: 'attribute',\n      actionType: 'edit',\n      settingType: 'base',\n      forTarget,\n      targetUid,\n      attributeName,\n      attributeType,\n      step: type === 'component' ? '2' : null,\n      ...firstHeaderObj,\n      ...secondHeaderObj,\n      ...thirdHeaderObj,\n      ...fourthHeaderObj,\n      ...fifthHeaderObj,\n    };\n\n    await wait();\n\n    push({ search: makeSearch(search, true) });\n  };\n\n  const getDescription = () => {\n    const description = get(modifiedData, [firstMainDataPath, 'schema', 'description'], null);\n\n    return (\n      description ||\n      formatMessage({\n        id: `${pluginId}.modelPage.contentHeader.emptyDescription.description`,\n      })\n    );\n  };\n\n  const wait = async () => {\n    togglePrompt(false);\n\n    return new Promise(resolve => setTimeout(resolve, 100));\n  };\n  const label = get(modifiedData, [firstMainDataPath, 'schema', 'name'], '');\n  const kind = get(modifiedData, [firstMainDataPath, 'schema', 'kind'], '');\n\n  const headerProps = {\n    actions: isInDevelopmentMode\n      ? [\n          {\n            color: 'cancel',\n            onClick: () => {\n              toggleModalCancel();\n            },\n            label: formatMessage({\n              id: `${pluginId}.form.button.cancel`,\n            }),\n            type: 'button',\n            disabled: isEqual(modifiedData, initialData),\n          },\n          {\n            className: 'button-submit',\n            color: 'success',\n            onClick: () => submitData(),\n            label: formatMessage({\n              id: `${pluginId}.form.button.save`,\n            }),\n            type: 'submit',\n            disabled: isEqual(modifiedData, initialData),\n          },\n        ]\n      : [],\n    title: {\n      label,\n      cta:\n        isInDevelopmentMode && !isFromPlugin\n          ? {\n              icon: 'pencil-alt',\n              onClick: async () => {\n                await wait();\n\n                const contentType = kind || firstMainDataPath;\n\n                if (contentType === 'collectionType') {\n                  emitEvent('willEditNameOfContentType');\n                }\n                if (contentType === 'singleType') {\n                  emitEvent('willEditNameOfSingleType');\n                }\n\n                push({\n                  search: makeSearch({\n                    modalType: firstMainDataPath,\n                    actionType: 'edit',\n                    settingType: 'base',\n                    forTarget: firstMainDataPath,\n                    targetUid,\n                    header_label_1: label,\n                    header_icon_isCustom_1: false,\n                    header_icon_name_1:\n                      contentType === 'singleType' ? contentType : firstMainDataPath,\n                    headerId: getTrad('modalForm.header-edit'),\n                  }),\n                });\n              },\n            }\n          : null,\n    },\n    content: getDescription(),\n  };\n\n  const listTitle = [\n    formatMessage(\n      {\n        id: `${pluginId}.table.attributes.title.${attributesLength > 1 ? 'plural' : 'singular'}`,\n      },\n      { number: attributesLength }\n    ),\n  ];\n\n  const addButtonProps = {\n    icon: true,\n    color: 'primary',\n    label: formatMessage({ id: `${pluginId}.button.attributes.add.another` }),\n    onClick: () => {\n      const headerDisplayObject = {\n        header_label_1: currentDataName,\n        header_icon_name_1: forTarget === 'contentType' ? contentTypeKind : forTarget,\n        header_icon_isCustom_1: false,\n      };\n      handleClickAddField(forTarget, targetUid, headerDisplayObject);\n    },\n  };\n\n  const listInjectedComponents = useMemo(() => {\n    return getComponents('listView', 'list.link', plugins, {\n      targetUid,\n      isTemporary,\n      isInContentTypeView,\n      contentTypeKind,\n    });\n  }, [plugins, isTemporary, targetUid, isInContentTypeView, contentTypeKind]);\n\n  const listActions = isInDevelopmentMode\n    ? [...listInjectedComponents, <ListButton {...addButtonProps} key=\"add-button\" />]\n    : listInjectedComponents;\n\n  const CustomRow = props => {\n    const { name } = props;\n\n    return <ListRow {...props} attributeName={name} name={name} onClick={handleClickEditField} />;\n  };\n\n  CustomRow.defaultProps = {\n    name: null,\n  };\n\n  CustomRow.propTypes = {\n    name: PropTypes.string,\n  };\n\n  return (\n    <ListViewContext.Provider value={{ openModalAddField: handleClickAddField }}>\n      <Wrapper>\n        <BackHeader onClick={goBack} />\n        <Prompt\n          message={formatMessage({ id: getTrad('prompt.unsaved') })}\n          when={hasModelBeenModified && enablePrompt}\n        />\n        <div className=\"container-fluid\">\n          <div className=\"row\">\n            <LeftMenu wait={wait} />\n            <div className=\"col-md-9 content\" style={{ paddingLeft: '30px', paddingRight: '30px' }}>\n              <Header {...headerProps} />\n\n              <ListWrapper style={{ marginBottom: 80 }}>\n                <ListHeader actions={listActions} title={listTitle} />\n                <List\n                  items={convertAttrObjToArray(attributes)}\n                  customRowComponent={props => <CustomRow {...props} />}\n                  addComponentToDZ={handleClickAddComponentToDZ}\n                  targetUid={targetUid}\n                  dataType={forTarget}\n                  dataTypeName={currentDataName}\n                  mainTypeName={currentDataName}\n                  editTarget={forTarget}\n                  isMain\n                />\n              </ListWrapper>\n            </div>\n          </div>\n        </div>\n      </Wrapper>\n    </ListViewContext.Provider>\n  );\n};\n\nexport default ListView;\n",
    "packages/strapi-plugin-content-type-builder/services/ContentTypes.js": "'use strict';\n\nconst _ = require('lodash');\nconst pluralize = require('pluralize');\nconst generator = require('strapi-generate');\n\nconst { nameToSlug, contentTypes: contentTypesUtils } = require('strapi-utils');\nconst { formatAttributes, replaceTemporaryUIDs } = require('../utils/attributes');\nconst createBuilder = require('./schema-builder');\nconst apiHandler = require('./api-handler');\nconst { coreUids, pluginsUids } = require('./constants');\n\nconst isContentTypeEditable = (contentType = {}) => {\n  const { uid } = contentType;\n  return !uid.startsWith(coreUids.PREFIX) && uid !== pluginsUids.UPLOAD_FILE;\n};\n\nconst getRestrictRelationsTo = (contentType = {}) => {\n  const { uid } = contentType;\n  if (uid === coreUids.STRAPI_USER) {\n    return ['oneWay', 'manyWay'];\n  }\n\n  if (uid.startsWith(coreUids.PREFIX) || uid === pluginsUids.UPLOAD_FILE) {\n    return [];\n  }\n\n  return null;\n};\n\nconst getformattedName = (contentType = {}) => {\n  const { uid, info } = contentType;\n  const name = _.get(info, 'name') || _.upperFirst(pluralize(uid));\n\n  return name;\n};\n\n/**\n * Format a contentType info to be used by the front-end\n * @param {Object} contentType\n */\nconst formatContentType = contentType => {\n  const { uid, kind, modelName, plugin, connection, collectionName, info, options } = contentType;\n\n  return {\n    uid,\n    plugin,\n    apiID: modelName,\n    schema: {\n      name: getformattedName(contentType),\n      description: _.get(info, 'description', ''),\n      draftAndPublish: contentTypesUtils.hasDraftAndPublish({ options }),\n      connection,\n      kind: kind || 'collectionType',\n      collectionName,\n      attributes: formatAttributes(contentType),\n      editable: isContentTypeEditable(contentType),\n      restrictRelationsTo: getRestrictRelationsTo(contentType),\n    },\n  };\n};\n\nconst createContentTypes = async contentTypes => {\n  const builder = createBuilder();\n  const createdContentTypes = [];\n\n  for (const contentType of contentTypes) {\n    createdContentTypes.push(await createContentType(contentType, { defaultBuilder: builder }));\n  }\n\n  await builder.writeFiles();\n\n  return createdContentTypes;\n};\n\n/**\n * Creates a content type and handle the nested components sent with it\n * @param {Object} params params object\n * @param {Object} params.contentType Main component to create\n * @param {Array<Object>} params.components List of nested components to created or edit\n * @param {Object} options\n * @param {Builder} options.defaultBuilder\n */\nconst createContentType = async ({ contentType, components = [] }, options = {}) => {\n  const builder = options.defaultBuilder || createBuilder();\n  const uidMap = builder.createNewComponentUIDMap(components);\n\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const newContentType = builder.createContentType(replaceTmpUIDs(contentType));\n\n  // allow components to target the new contentType\n  const targetContentType = infos => {\n    Object.keys(infos.attributes).forEach(key => {\n      const { target } = infos.attributes[key];\n      if (target === '__contentType__') {\n        infos.attributes[key].target = newContentType.uid;\n      }\n    });\n\n    return infos;\n  };\n\n  components.forEach(component => {\n    const options = replaceTmpUIDs(targetContentType(component));\n\n    if (!_.has(component, 'uid')) {\n      return builder.createComponent(options);\n    }\n\n    return builder.editComponent(options);\n  });\n\n  // generate api skeleton\n  await generateAPI({\n    name: contentType.name,\n    kind: contentType.kind,\n  });\n\n  if (!options.defaultBuilder) {\n    await builder.writeFiles();\n  }\n\n  return newContentType;\n};\n\n/**\n * Generate an API squeleton\n * @param {string} name\n */\nconst generateAPI = ({ name, kind = 'collectionType' }) => {\n  return new Promise((resolve, reject) => {\n    const scope = {\n      generatorType: 'api',\n      id: nameToSlug(name),\n      name: nameToSlug(name),\n      rootPath: strapi.dir,\n      args: {\n        attributes: {},\n        kind,\n      },\n    };\n\n    generator(scope, {\n      success: () => resolve(),\n      error: err => reject(err),\n    });\n  });\n};\n\n/**\n * Edits a contentType and handle the nested contentTypes sent with it\n * @param {String} uid Content-type's uid\n * @param {Object} params params object\n * @param {Object} params.contentType Main contentType to create\n * @param {Array<Object>} params.components List of nested components to created or edit\n */\nconst editContentType = async (uid, { contentType, components = [] }) => {\n  const builder = createBuilder();\n\n  const previousKind = builder.contentTypes.get(uid).schema.kind;\n  const newKind = contentType.kind || previousKind;\n\n  if (newKind !== previousKind && newKind === 'singleType') {\n    const entryCount = await strapi.query(uid).count();\n    if (entryCount > 1) {\n      throw strapi.errors.badRequest(\n        'You cannot convert a collectionType to a singleType when having multiple entries in DB'\n      );\n    }\n  }\n\n  const uidMap = builder.createNewComponentUIDMap(components);\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const updatedContentType = builder.editContentType({\n    uid,\n    ...replaceTmpUIDs(contentType),\n  });\n\n  components.forEach(component => {\n    if (!_.has(component, 'uid')) {\n      return builder.createComponent(replaceTmpUIDs(component));\n    }\n\n    return builder.editComponent(replaceTmpUIDs(component));\n  });\n\n  if (newKind !== previousKind) {\n    await apiHandler.backup(uid);\n\n    try {\n      await apiHandler.clear(uid);\n\n      // generate new api skeleton\n      await generateAPI({\n        name: updatedContentType.schema.info.name,\n        kind: updatedContentType.schema.kind,\n      });\n\n      await builder.writeFiles();\n    } catch (error) {\n      strapi.log.error(error);\n      await apiHandler.rollback(uid);\n    }\n\n    return updatedContentType;\n  }\n\n  await builder.writeFiles();\n  return updatedContentType;\n};\n\nconst deleteContentTypes = async uids => {\n  const builder = createBuilder();\n\n  for (const uid of uids) {\n    await deleteContentType(uid, builder);\n  }\n\n  await builder.writeFiles();\n  for (const uid of uids) {\n    try {\n      await apiHandler.clear(uid);\n    } catch (error) {\n      strapi.log.error(error);\n      await apiHandler.rollback(uid);\n    }\n  }\n};\n\n/**\n * Deletes a content type and the api files related to it\n * @param {string} uid content type uid\n * @param defaultBuilder\n */\nconst deleteContentType = async (uid, defaultBuilder = undefined) => {\n  const builder = defaultBuilder || createBuilder();\n  // make a backup\n  await apiHandler.backup(uid);\n\n  const contentType = builder.deleteContentType(uid);\n\n  if (!defaultBuilder) {\n    try {\n      await builder.writeFiles();\n      await apiHandler.clear(uid);\n    } catch (error) {\n      await apiHandler.rollback(uid);\n    }\n  }\n\n  return contentType;\n};\n\nmodule.exports = {\n  createContentType,\n  editContentType,\n  deleteContentType,\n  formatContentType,\n  createContentTypes,\n  deleteContentTypes,\n};\n",
    "packages/strapi-plugin-upload/admin/src/components/EditForm/index.js": "/* eslint-disable jsx-a11y/anchor-is-valid */\n/* eslint-disable react/jsx-fragments */\nimport React, {\n  Fragment,\n  forwardRef,\n  useState,\n  useEffect,\n  useRef,\n  useImperativeHandle,\n} from 'react';\nimport { CopyToClipboard } from 'react-copy-to-clipboard';\nimport axios from 'axios';\nimport { get } from 'lodash';\nimport PropTypes from 'prop-types';\nimport { Row } from 'reactstrap';\nimport { Inputs } from '@buffetjs/custom';\nimport { useGlobalContext, prefixFileUrlWithBackendUrl } from 'strapi-helper-plugin';\nimport Cropper from 'cropperjs';\nimport 'cropperjs/dist/cropper.css';\nimport { createFileToDownloadName } from '../../utils';\nimport CardControl from '../CardControl';\nimport CardControlsWrapper from '../CardControlsWrapper';\nimport CardPreview from '../CardPreview';\nimport InfiniteLoadingIndicator from '../InfiniteLoadingIndicator';\nimport ModalSection from '../ModalSection';\nimport VideoPlayer from '../VideoPlayer';\nimport CropWrapper from './CropWrapper';\nimport FileDetailsBox from './FileDetailsBox';\nimport FileWrapper from './FileWrapper';\nimport FormWrapper from './FormWrapper';\nimport SizeBox from './SizeBox';\nimport Wrapper from './Wrapper';\nimport ErrorMessage from './ErrorMessage';\nimport form from './utils/form';\nimport isImageType from './utils/isImageType';\nimport isVideoType from './utils/isVideoType';\n\nconst EditForm = forwardRef(\n  (\n    {\n      canCopyLink,\n      canDownload,\n      components,\n      fileToEdit,\n      isEditingUploadedFile,\n      isFormDisabled,\n      onAbortUpload,\n      onChange,\n      onClickDeleteFileToUpload,\n      onSubmitEdit,\n      setCropResult,\n      toggleDisableForm,\n    },\n    ref\n  ) => {\n    const { formatMessage } = useGlobalContext();\n    const [isCropping, setIsCropping] = useState(false);\n    const [infos, setInfos] = useState({ width: null, height: null });\n    const [src, setSrc] = useState(null);\n    const cacheRef = useRef(performance.now());\n\n    const fileURL = get(fileToEdit, ['file', 'url'], null);\n    const prefixedFileURL = fileURL\n      ? prefixFileUrlWithBackendUrl(`${fileURL}?${cacheRef.current}`)\n      : null;\n    const downloadFileName = createFileToDownloadName(fileToEdit);\n    const mimeType =\n      get(fileToEdit, ['file', 'type'], null) || get(fileToEdit, ['file', 'mime'], '');\n    const isImg = isImageType(mimeType);\n    const isVideo = isVideoType(mimeType);\n    const canCrop = isImg && !mimeType.includes('svg') && !mimeType.includes('gif');\n    const aRef = useRef();\n    const imgRef = useRef();\n    const inputRef = useRef();\n    const cropper = useRef();\n\n    useImperativeHandle(ref, () => ({\n      click: () => {\n        inputRef.current.click();\n        setIsCropping(false);\n      },\n    }));\n\n    useEffect(() => {\n      if (isImg || isVideo) {\n        if (prefixedFileURL) {\n          setSrc(prefixedFileURL);\n        } else {\n          setSrc(URL.createObjectURL(fileToEdit.file));\n        }\n      }\n    }, [isImg, isVideo, fileToEdit, prefixedFileURL]);\n\n    useEffect(() => {\n      if (isCropping) {\n        cropper.current = new Cropper(imgRef.current, {\n          modal: true,\n          initialAspectRatio: 16 / 9,\n          movable: true,\n          zoomable: false,\n          cropBoxResizable: true,\n          background: false,\n          crop: handleResize,\n        });\n      } else if (cropper.current) {\n        cropper.current.destroy();\n\n        setInfos({ width: null, height: null });\n        toggleDisableForm(false);\n      }\n\n      return () => {\n        if (cropper.current) {\n          cropper.current.destroy();\n        }\n      };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [cropper, isCropping]);\n\n    const handleResize = ({ detail: { height, width } }) => {\n      const roundedDataHeight = Math.round(height);\n      const roundedDataWidth = Math.round(width);\n\n      setInfos({ width: roundedDataWidth, height: roundedDataHeight });\n    };\n\n    const handleToggleCropMode = () => {\n      setIsCropping(prev => {\n        if (!prev && isEditingUploadedFile) {\n          toggleDisableForm(true);\n        }\n\n        return !prev;\n      });\n    };\n\n    const handleChange = ({ target: { files } }) => {\n      if (files[0]) {\n        onChange({ target: { name: 'file', value: files[0] } });\n      }\n    };\n\n    const handleClick = async () => {\n      const cropResult = await getCroppedResult();\n\n      setCropResult(cropResult);\n\n      setIsCropping(false);\n    };\n\n    const getCroppedResult = () => {\n      return new Promise((resolve, reject) => {\n        try {\n          const canvas = cropper.current.getCroppedCanvas();\n\n          canvas.toBlob(\n            async blob => {\n              const {\n                file: { lastModifiedDate, lastModified, name },\n              } = fileToEdit;\n\n              resolve(\n                new File([blob], name, {\n                  type: mimeType,\n                  lastModified,\n                  lastModifiedDate,\n                })\n              );\n            },\n            mimeType,\n            1\n          );\n        } catch (err) {\n          reject();\n        }\n      });\n    };\n\n    const handleClickEditCroppedFile = async (e, shouldDuplicate = false) => {\n      try {\n        const file = await getCroppedResult();\n\n        onSubmitEdit(e, shouldDuplicate, file, true);\n      } catch (err) {\n        // Silent\n      } finally {\n        setIsCropping(false);\n      }\n    };\n\n    const handleClickDelete = () => {\n      onClickDeleteFileToUpload(fileToEdit.originalIndex);\n    };\n\n    const handleCopy = () => {\n      strapi.notification.toggle({\n        type: 'info',\n        message: { id: 'notification.link-copied' },\n      });\n    };\n\n    const handleClickDownload = () => {\n      axios\n        .get(prefixedFileURL, {\n          responseType: 'blob',\n        })\n        .then(({ data }) => {\n          const blobUrl = URL.createObjectURL(data);\n\n          aRef.current.download = downloadFileName;\n          aRef.current.href = blobUrl;\n\n          aRef.current.click();\n        })\n        .catch(err => {\n          console.error(err);\n        });\n    };\n\n    const handleSubmit = e => {\n      e.preventDefault();\n\n      onSubmitEdit(e);\n    };\n\n    const CheckButton = components.CheckControl;\n\n    return (\n      <form onSubmit={handleSubmit}>\n        <ModalSection>\n          <Wrapper>\n            <div className=\"row\">\n              <div className=\"col-6\">\n                <FileWrapper hasError={fileToEdit.hasError}>\n                  {fileToEdit.isUploading ? (\n                    <InfiniteLoadingIndicator onClick={onAbortUpload} />\n                  ) : (\n                    <Fragment>\n                      <CardControlsWrapper className=\"card-control-wrapper-displayed\">\n                        {!isCropping ? (\n                          <>\n                            <CardControl\n                              color=\"#9EA7B8\"\n                              type=\"trash-alt\"\n                              onClick={handleClickDelete}\n                              title=\"delete\"\n                            />\n                            {fileURL && (\n                              <>\n                                {canDownload && (\n                                  <CardControl\n                                    color=\"#9EA7B8\"\n                                    onClick={handleClickDownload}\n                                    type=\"download\"\n                                    title=\"download\"\n                                  />\n                                )}\n                                <a\n                                  title={fileToEdit.fileInfo.name}\n                                  style={{ display: 'none' }}\n                                  ref={aRef}\n                                >\n                                  hidden\n                                </a>\n                                {canCopyLink && (\n                                  <CopyToClipboard\n                                    onCopy={handleCopy}\n                                    text={prefixFileUrlWithBackendUrl(fileURL)}\n                                  >\n                                    <CardControl color=\"#9EA7B8\" type=\"link\" title=\"copy-link\" />\n                                  </CopyToClipboard>\n                                )}\n                              </>\n                            )}\n                            {canCrop && (\n                              <CardControl\n                                color=\"#9EA7B8\"\n                                onClick={handleToggleCropMode}\n                                type=\"crop\"\n                                title=\"crop\"\n                              />\n                            )}\n                          </>\n                        ) : (\n                          <>\n                            <CardControl\n                              color=\"#F64D0A\"\n                              onClick={handleToggleCropMode}\n                              type=\"times\"\n                              title=\"cancel\"\n                              iconStyle={{ height: '1.6rem', width: '1.6rem' }}\n                            />\n                            <CheckButton\n                              color=\"#6DBB1A\"\n                              onClick={handleClick}\n                              onSubmitEdit={handleClickEditCroppedFile}\n                              type=\"check\"\n                              title=\"save\"\n                            />\n                          </>\n                        )}\n                      </CardControlsWrapper>\n                      {isImg ? (\n                        <CropWrapper>\n                          <img\n                            src={src}\n                            alt={get(fileToEdit, ['file', 'name'], '')}\n                            ref={isCropping ? imgRef : null}\n                          />\n                        </CropWrapper>\n                      ) : (\n                        <>\n                          {isVideo ? (\n                            <VideoPlayer src={src} />\n                          ) : (\n                            <CardPreview type={mimeType} url={src} />\n                          )}\n                        </>\n                      )}\n\n                      {isCropping && infos.width !== null && (\n                        <SizeBox>\n                          &nbsp;\n                          {infos.width} x {infos.height}\n                          &nbsp;\n                        </SizeBox>\n                      )}\n                    </Fragment>\n                  )}\n                </FileWrapper>\n                {fileToEdit.hasError && (\n                  <ErrorMessage title={fileToEdit.errorMessage}>\n                    {fileToEdit.errorMessage}\n                  </ErrorMessage>\n                )}\n              </div>\n              <div className=\"col-6\">\n                <FileDetailsBox file={fileToEdit.file} />\n                <FormWrapper>\n                  {form.map(({ key, inputs }) => {\n                    return (\n                      <Row key={key}>\n                        {inputs.map(input => {\n                          return (\n                            <div className=\"col-12\" key={input.name}>\n                              <Inputs\n                                {...input}\n                                disabled={isFormDisabled}\n                                description={\n                                  input.description ? formatMessage(input.description) : null\n                                }\n                                label={formatMessage(input.label)}\n                                onChange={onChange}\n                                type=\"text\"\n                                value={get(fileToEdit, input.name, '')}\n                              />\n                            </div>\n                          );\n                        })}\n                      </Row>\n                    );\n                  })}\n                </FormWrapper>\n              </div>\n            </div>\n          </Wrapper>\n          <input\n            ref={inputRef}\n            type=\"file\"\n            multiple={false}\n            onChange={handleChange}\n            style={{ display: 'none' }}\n            accept={mimeType\n              .split('/')\n              .map((v, i) => {\n                if (i === 1) {\n                  return '*';\n                }\n\n                return v;\n              })\n              .join('/')}\n          />\n          <button type=\"submit\" style={{ display: 'none' }}>\n            hidden button to make to get the native form event\n          </button>\n        </ModalSection>\n      </form>\n    );\n  }\n);\n\nEditForm.defaultProps = {\n  canCopyLink: true,\n  canDownload: true,\n  components: {\n    CheckControl: CardControl,\n  },\n  fileToEdit: null,\n  isEditingUploadedFile: false,\n  isFormDisabled: false,\n  onAbortUpload: () => {},\n  onChange: () => {},\n  onClickDeleteFileToUpload: () => {},\n  onSubmitEdit: e => e.preventDefault(),\n  setCropResult: () => {},\n  toggleDisableForm: () => {},\n};\n\nEditForm.propTypes = {\n  canCopyLink: PropTypes.bool,\n  canDownload: PropTypes.bool,\n  onAbortUpload: PropTypes.func,\n  components: PropTypes.object,\n  fileToEdit: PropTypes.object,\n  isEditingUploadedFile: PropTypes.bool,\n  isFormDisabled: PropTypes.bool,\n  onChange: PropTypes.func,\n  onClickDeleteFileToUpload: PropTypes.func,\n  onSubmitEdit: PropTypes.func,\n  setCropResult: PropTypes.func,\n  toggleDisableForm: PropTypes.func,\n};\n\nexport default EditForm;\n",
    "packages/strapi-plugin-upload/utils/file.js": "'use strict';\n/**\n * Utils file containing file treatment utils\n */\n\nconst bytesToKbytes = bytes => Math.round((bytes / 1000) * 100) / 100;\n\nconst streamToBuffer = stream =>\n  new Promise((resolve, reject) => {\n    const chunks = [];\n    stream.on('data', chunk => {\n      chunks.push(chunk);\n    });\n    stream.on('end', () => {\n      resolve(Buffer.concat(chunks));\n    });\n    stream.on('error', reject);\n  });\n\nmodule.exports = {\n  streamToBuffer,\n  bytesToKbytes,\n};\n",
    "packages/strapi-plugin-users-permissions/services/Jwt.js": "'use strict';\n\n/**\n * Jwt.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\n\nconst _ = require('lodash');\nconst jwt = require('jsonwebtoken');\n\nmodule.exports = {\n  getToken(ctx) {\n    const params = _.assign({}, ctx.request.body, ctx.request.query);\n\n    let token = '';\n\n    if (ctx.request && ctx.request.header && ctx.request.header.authorization) {\n      const parts = ctx.request.header.authorization.split(' ');\n\n      if (parts.length === 2) {\n        const scheme = parts[0];\n        const credentials = parts[1];\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        }\n      } else {\n        throw new Error(\n          'Invalid authorization header format. Format is Authorization: Bearer [token]'\n        );\n      }\n    } else if (params.token) {\n      token = params.token;\n    } else {\n      throw new Error('No authorization header was found');\n    }\n\n    return this.verify(token);\n  },\n\n  issue(payload, jwtOptions = {}) {\n    _.defaults(jwtOptions, strapi.plugins['users-permissions'].config.jwt);\n    return jwt.sign(\n      _.clone(payload.toJSON ? payload.toJSON() : payload),\n      _.get(strapi.plugins, ['users-permissions', 'config', 'jwtSecret']),\n      jwtOptions\n    );\n  },\n\n  verify(token) {\n    return new Promise(function(resolve, reject) {\n      jwt.verify(\n        token,\n        _.get(strapi.plugins, ['users-permissions', 'config', 'jwtSecret']),\n        {},\n        function(err, tokenPayload = {}) {\n          if (err) {\n            return reject(new Error('Invalid token.'));\n          }\n          resolve(tokenPayload);\n        }\n      );\n    });\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/services/Providers.js": "'use strict';\n\n/**\n * Module dependencies.\n */\n\n// Public node modules.\nconst _ = require('lodash');\nconst request = require('request');\n\n// Purest strategies.\nconst purest = require('purest')({ request });\nconst purestConfig = require('@purest/providers');\nconst { getAbsoluteServerUrl } = require('strapi-utils');\nconst jwt = require('jsonwebtoken');\n\n/**\n * Connect thanks to a third-party provider.\n *\n *\n * @param {String}    provider\n * @param {String}    access_token\n *\n * @return  {*}\n */\n\nconst connect = (provider, query) => {\n  const access_token = query.access_token || query.code || query.oauth_token;\n\n  return new Promise((resolve, reject) => {\n    if (!access_token) {\n      return reject([null, { message: 'No access_token.' }]);\n    }\n\n    // Get the profile.\n    getProfile(provider, query, async (err, profile) => {\n      if (err) {\n        return reject([null, err]);\n      }\n\n      // We need at least the mail.\n      if (!profile.email) {\n        return reject([null, { message: 'Email was not available.' }]);\n      }\n\n      try {\n        const users = await strapi.query('user', 'users-permissions').find({\n          email: profile.email,\n        });\n\n        const advanced = await strapi\n          .store({\n            environment: '',\n            type: 'plugin',\n            name: 'users-permissions',\n            key: 'advanced',\n          })\n          .get();\n\n        const user = _.find(users, { provider });\n\n        if (_.isEmpty(user) && !advanced.allow_register) {\n          return resolve([\n            null,\n            [{ messages: [{ id: 'Auth.advanced.allow_register' }] }],\n            'Register action is actualy not available.',\n          ]);\n        }\n\n        if (!_.isEmpty(user)) {\n          return resolve([user, null]);\n        }\n\n        if (\n          !_.isEmpty(_.find(users, user => user.provider !== provider)) &&\n          advanced.unique_email\n        ) {\n          return resolve([\n            null,\n            [{ messages: [{ id: 'Auth.form.error.email.taken' }] }],\n            'Email is already taken.',\n          ]);\n        }\n\n        // Retrieve default role.\n        const defaultRole = await strapi\n          .query('role', 'users-permissions')\n          .findOne({ type: advanced.default_role }, []);\n\n        // Create the new user.\n        const params = _.assign(profile, {\n          provider: provider,\n          role: defaultRole.id,\n          confirmed: true,\n        });\n\n        const createdUser = await strapi.query('user', 'users-permissions').create(params);\n\n        return resolve([createdUser, null]);\n      } catch (err) {\n        reject([null, err]);\n      }\n    });\n  });\n};\n\n/**\n * Helper to get profiles\n *\n * @param {String}   provider\n * @param {Function} callback\n */\n\nconst getProfile = async (provider, query, callback) => {\n  const access_token = query.access_token || query.code || query.oauth_token;\n\n  const grant = await strapi\n    .store({\n      environment: '',\n      type: 'plugin',\n      name: 'users-permissions',\n      key: 'grant',\n    })\n    .get();\n\n  switch (provider) {\n    case 'discord': {\n      const discord = purest({\n        provider: 'discord',\n        config: {\n          discord: {\n            'https://discordapp.com/api/': {\n              __domain: {\n                auth: {\n                  auth: { bearer: '[0]' },\n                },\n              },\n              '{endpoint}': {\n                __path: {\n                  alias: '__default',\n                },\n              },\n            },\n          },\n        },\n      });\n      discord\n        .query()\n        .get('users/@me')\n        .auth(access_token)\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            // Combine username and discriminator because discord username is not unique\n            var username = `${body.username}#${body.discriminator}`;\n            callback(null, {\n              username: username,\n              email: body.email,\n            });\n          }\n        });\n      break;\n    }\n    case 'cognito': {\n      // get the id_token\n      const idToken = query.id_token;\n      // decode the jwt token\n      const tokenPayload = jwt.decode(idToken);\n      if (!tokenPayload) {\n        callback(new Error('unable to decode jwt token'));\n      } else {\n        callback(null, {\n          username: tokenPayload['cognito:username'],\n          email: tokenPayload.email,\n        });\n      }\n      break;\n    }\n    case 'facebook': {\n      const facebook = purest({\n        provider: 'facebook',\n        config: purestConfig,\n      });\n\n      facebook\n        .query()\n        .get('me?fields=name,email')\n        .auth(access_token)\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.name,\n              email: body.email,\n            });\n          }\n        });\n      break;\n    }\n    case 'google': {\n      const google = purest({ provider: 'google', config: purestConfig });\n\n      google\n        .query('oauth')\n        .get('tokeninfo')\n        .qs({ access_token })\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.email.split('@')[0],\n              email: body.email,\n            });\n          }\n        });\n      break;\n    }\n    case 'github': {\n      const github = purest({\n        provider: 'github',\n        config: purestConfig,\n        defaults: {\n          headers: {\n            'user-agent': 'strapi',\n          },\n        },\n      });\n\n      github\n        .query()\n        .get('user')\n        .auth(access_token)\n        .request((err, res, userbody) => {\n          if (err) {\n            return callback(err);\n          }\n\n          // This is the public email on the github profile\n          if (userbody.email) {\n            return callback(null, {\n              username: userbody.login,\n              email: userbody.email,\n            });\n          }\n\n          // Get the email with Github's user/emails API\n          github\n            .query()\n            .get('user/emails')\n            .auth(access_token)\n            .request((err, res, emailsbody) => {\n              if (err) {\n                return callback(err);\n              }\n\n              return callback(null, {\n                username: userbody.login,\n                email: Array.isArray(emailsbody)\n                  ? emailsbody.find(email => email.primary === true).email\n                  : null,\n              });\n            });\n        });\n      break;\n    }\n    case 'microsoft': {\n      const microsoft = purest({\n        provider: 'microsoft',\n        config: purestConfig,\n      });\n\n      microsoft\n        .query()\n        .get('me')\n        .auth(access_token)\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.userPrincipalName,\n              email: body.userPrincipalName,\n            });\n          }\n        });\n      break;\n    }\n    case 'twitter': {\n      const twitter = purest({\n        provider: 'twitter',\n        config: purestConfig,\n        key: grant.twitter.key,\n        secret: grant.twitter.secret,\n      });\n\n      twitter\n        .query()\n        .get('account/verify_credentials')\n        .auth(access_token, query.access_secret)\n        .qs({ screen_name: query['raw[screen_name]'], include_email: 'true' })\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.screen_name,\n              email: body.email,\n            });\n          }\n        });\n      break;\n    }\n    case 'instagram': {\n      const instagram = purest({\n        provider: 'instagram',\n        key: grant.instagram.key,\n        secret: grant.instagram.secret,\n        config: purestConfig,\n      });\n\n      instagram\n        .query()\n        .get('me')\n        .qs({ access_token, fields: 'id,username' })\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.username,\n              email: `${body.username}@strapi.io`, // dummy email as Instagram does not provide user email\n            });\n          }\n        });\n      break;\n    }\n    case 'vk': {\n      const vk = purest({\n        provider: 'vk',\n        config: purestConfig,\n      });\n\n      vk.query()\n        .get('users.get')\n        .qs({ access_token, id: query.raw.user_id, v: '5.122' })\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: `${body.response[0].last_name} ${body.response[0].first_name}`,\n              email: query.raw.email,\n            });\n          }\n        });\n      break;\n    }\n    case 'twitch': {\n      const twitch = purest({\n        provider: 'twitch',\n        config: {\n          twitch: {\n            'https://api.twitch.tv': {\n              __domain: {\n                auth: {\n                  headers: {\n                    Authorization: 'Bearer [0]',\n                    'Client-ID': '[1]',\n                  },\n                },\n              },\n              'helix/{endpoint}': {\n                __path: {\n                  alias: '__default',\n                },\n              },\n              'oauth2/{endpoint}': {\n                __path: {\n                  alias: 'oauth',\n                },\n              },\n            },\n          },\n        },\n      });\n\n      twitch\n        .get('users')\n        .auth(access_token, grant.twitch.key)\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.data[0].login,\n              email: body.data[0].email,\n            });\n          }\n        });\n      break;\n    }\n    case 'linkedin': {\n      const linkedIn = purest({\n        provider: 'linkedin',\n        config: {\n          linkedin: {\n            'https://api.linkedin.com': {\n              __domain: {\n                auth: [{ auth: { bearer: '[0]' } }],\n              },\n              '[version]/{endpoint}': {\n                __path: {\n                  alias: '__default',\n                  version: 'v2',\n                },\n              },\n            },\n          },\n        },\n      });\n      try {\n        const getDetailsRequest = () => {\n          return new Promise((resolve, reject) => {\n            linkedIn\n              .query()\n              .get('me')\n              .auth(access_token)\n              .request((err, res, body) => {\n                if (err) {\n                  return reject(err);\n                }\n                resolve(body);\n              });\n          });\n        };\n\n        const getEmailRequest = () => {\n          return new Promise((resolve, reject) => {\n            linkedIn\n              .query()\n              .get('emailAddress?q=members&projection=(elements*(handle~))')\n              .auth(access_token)\n              .request((err, res, body) => {\n                if (err) {\n                  return reject(err);\n                }\n                resolve(body);\n              });\n          });\n        };\n\n        const { localizedFirstName } = await getDetailsRequest();\n        const { elements } = await getEmailRequest();\n        const email = elements[0]['handle~'];\n\n        callback(null, {\n          username: localizedFirstName,\n          email: email.emailAddress,\n        });\n      } catch (err) {\n        callback(err);\n      }\n      break;\n    }\n    case 'reddit': {\n      const reddit = purest({\n        provider: 'reddit',\n        config: purestConfig,\n        defaults: {\n          headers: {\n            'user-agent': 'strapi',\n          },\n        },\n      });\n\n      reddit\n        .query('auth')\n        .get('me')\n        .auth(access_token)\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.name,\n              email: `${body.name}@strapi.io`, // dummy email as Reddit does not provide user email\n            });\n          }\n        });\n      break;\n    }\n    case 'auth0': {\n      const purestAuth0Conf = {};\n      purestAuth0Conf[`https://${grant.auth0.subdomain}.auth0.com`] = {\n        __domain: {\n          auth: {\n            auth: { bearer: '[0]' },\n          },\n        },\n        '{endpoint}': {\n          __path: {\n            alias: '__default',\n          },\n        },\n      };\n      const auth0 = purest({\n        provider: 'auth0',\n        config: {\n          auth0: purestAuth0Conf,\n        },\n      });\n\n      auth0\n        .get('userinfo')\n        .auth(access_token)\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            const username =\n              body.username || body.nickname || body.name || body.email.split('@')[0];\n            const email = body.email || `${username.replace(/\\s+/g, '.')}@strapi.io`;\n\n            callback(null, {\n              username,\n              email,\n            });\n          }\n        });\n      break;\n    }\n    default:\n      callback(new Error('Unknown provider.'));\n      break;\n  }\n};\n\nconst buildRedirectUri = (provider = '') =>\n  `${getAbsoluteServerUrl(strapi.config)}/connect/${provider}/callback`;\n\nmodule.exports = {\n  connect,\n  buildRedirectUri,\n};\n",
    "packages/strapi-plugin-users-permissions/services/User.js": "'use strict';\n\n/**\n * User.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\n\nconst crypto = require('crypto');\nconst bcrypt = require('bcryptjs');\n\nconst { sanitizeEntity, getAbsoluteServerUrl } = require('strapi-utils');\n\nmodule.exports = {\n  /**\n   * Promise to count users\n   *\n   * @return {Promise}\n   */\n\n  count(params) {\n    return strapi.query('user', 'users-permissions').count(params);\n  },\n\n  /**\n   * Promise to search count users\n   *\n   * @return {Promise}\n   */\n\n  countSearch(params) {\n    return strapi.query('user', 'users-permissions').countSearch(params);\n  },\n\n  /**\n   * Promise to add a/an user.\n   * @return {Promise}\n   */\n  async add(values) {\n    if (values.password) {\n      values.password = await strapi.plugins['users-permissions'].services.user.hashPassword(\n        values\n      );\n    }\n\n    return strapi.query('user', 'users-permissions').create(values);\n  },\n\n  /**\n   * Promise to edit a/an user.\n   * @return {Promise}\n   */\n  async edit(params, values) {\n    if (values.password) {\n      values.password = await strapi.plugins['users-permissions'].services.user.hashPassword(\n        values\n      );\n    }\n\n    return strapi.query('user', 'users-permissions').update(params, values);\n  },\n\n  /**\n   * Promise to fetch a/an user.\n   * @return {Promise}\n   */\n  fetch(params, populate) {\n    return strapi.query('user', 'users-permissions').findOne(params, populate);\n  },\n\n  /**\n   * Promise to fetch authenticated user.\n   * @return {Promise}\n   */\n  fetchAuthenticatedUser(id) {\n    return strapi.query('user', 'users-permissions').findOne({ id }, ['role']);\n  },\n\n  /**\n   * Promise to fetch all users.\n   * @return {Promise}\n   */\n  fetchAll(params, populate) {\n    return strapi.query('user', 'users-permissions').find(params, populate);\n  },\n\n  hashPassword(user = {}) {\n    return new Promise((resolve, reject) => {\n      if (!user.password || this.isHashed(user.password)) {\n        resolve(null);\n      } else {\n        bcrypt.hash(`${user.password}`, 10, (err, hash) => {\n          if (err) {\n            return reject(err);\n          }\n          resolve(hash);\n        });\n      }\n    });\n  },\n\n  isHashed(password) {\n    if (typeof password !== 'string' || !password) {\n      return false;\n    }\n\n    return password.split('$').length === 4;\n  },\n\n  /**\n   * Promise to remove a/an user.\n   * @return {Promise}\n   */\n  async remove(params) {\n    return strapi.query('user', 'users-permissions').delete(params);\n  },\n\n  async removeAll(params) {\n    return strapi.query('user', 'users-permissions').delete(params);\n  },\n\n  validatePassword(password, hash) {\n    return bcrypt.compare(password, hash);\n  },\n\n  async sendConfirmationEmail(user) {\n    const userPermissionService = strapi.plugins['users-permissions'].services.userspermissions;\n    const pluginStore = await strapi.store({\n      environment: '',\n      type: 'plugin',\n      name: 'users-permissions',\n    });\n\n    const settings = await pluginStore\n      .get({ key: 'email' })\n      .then(storeEmail => storeEmail['email_confirmation'].options);\n\n    const userInfo = sanitizeEntity(user, {\n      model: strapi.query('user', 'users-permissions').model,\n    });\n\n    const confirmationToken = crypto.randomBytes(20).toString('hex');\n\n    await this.edit({ id: user.id }, { confirmationToken });\n\n    settings.message = await userPermissionService.template(settings.message, {\n      URL: `${getAbsoluteServerUrl(strapi.config)}/auth/email-confirmation`,\n      USER: userInfo,\n      CODE: confirmationToken,\n    });\n\n    settings.object = await userPermissionService.template(settings.object, { USER: userInfo });\n\n    // Send an email to the user.\n    await strapi.plugins['email'].services.email.send({\n      to: user.email,\n      from:\n        settings.from.email && settings.from.name\n          ? `${settings.from.name} <${settings.from.email}>`\n          : undefined,\n      replyTo: settings.response_email,\n      subject: settings.object,\n      text: settings.message,\n      html: settings.message,\n    });\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/services/UsersPermissions.js": "'use strict';\n\nconst _ = require('lodash');\nconst request = require('request');\n\n/**\n * UsersPermissions.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\n\nconst DEFAULT_PERMISSIONS = [\n  { action: 'admincallback', controller: 'auth', type: 'users-permissions', roleType: 'public' },\n  { action: 'adminregister', controller: 'auth', type: 'users-permissions', roleType: 'public' },\n  { action: 'callback', controller: 'auth', type: 'users-permissions', roleType: 'public' },\n  { action: 'connect', controller: 'auth', type: 'users-permissions', roleType: null },\n  { action: 'forgotpassword', controller: 'auth', type: 'users-permissions', roleType: 'public' },\n  { action: 'register', controller: 'auth', type: 'users-permissions', roleType: 'public' },\n  {\n    action: 'emailconfirmation',\n    controller: 'auth',\n    type: 'users-permissions',\n    roleType: 'public',\n  },\n  { action: 'resetpassword', controller: 'auth', type: 'users-permissions', roleType: 'public' },\n  { action: 'init', controller: 'userspermissions', type: null, roleType: null },\n  { action: 'me', controller: 'user', type: 'users-permissions', roleType: null },\n  { action: 'autoreload', controller: null, type: null, roleType: null },\n];\n\nconst isPermissionEnabled = (permission, role) =>\n  DEFAULT_PERMISSIONS.some(\n    defaultPerm =>\n      (defaultPerm.action === null || permission.action === defaultPerm.action) &&\n      (defaultPerm.controller === null || permission.controller === defaultPerm.controller) &&\n      (defaultPerm.type === null || permission.type === defaultPerm.type) &&\n      (defaultPerm.roleType === null || role.type === defaultPerm.roleType)\n  );\n\nmodule.exports = {\n  async createRole(params) {\n    if (!params.type) {\n      params.type = _.snakeCase(_.deburr(_.toLower(params.name)));\n    }\n\n    const role = await strapi\n      .query('role', 'users-permissions')\n      .create(_.omit(params, ['users', 'permissions']));\n\n    const arrayOfPromises = Object.keys(params.permissions || {}).reduce((acc, type) => {\n      Object.keys(params.permissions[type].controllers).forEach(controller => {\n        Object.keys(params.permissions[type].controllers[controller]).forEach(action => {\n          acc.push(\n            strapi.query('permission', 'users-permissions').create({\n              role: role.id,\n              type,\n              controller,\n              action: action.toLowerCase(),\n              ...params.permissions[type].controllers[controller][action],\n            })\n          );\n        });\n      });\n\n      return acc;\n    }, []);\n\n    // Use Content Manager business logic to handle relation.\n    if (params.users && params.users.length > 0)\n      arrayOfPromises.push(\n        strapi.query('role', 'users-permissions').update(\n          {\n            id: role.id,\n          },\n          { users: params.users }\n        )\n      );\n\n    return await Promise.all(arrayOfPromises);\n  },\n\n  async deleteRole(roleID, publicRoleID) {\n    const role = await strapi\n      .query('role', 'users-permissions')\n      .findOne({ id: roleID }, ['users', 'permissions']);\n\n    if (!role) {\n      throw new Error('Cannot found this role');\n    }\n\n    // Move users to guest role.\n    const arrayOfPromises = role.users.reduce((acc, user) => {\n      acc.push(\n        strapi.query('user', 'users-permissions').update(\n          {\n            id: user.id,\n          },\n          {\n            role: publicRoleID,\n          }\n        )\n      );\n\n      return acc;\n    }, []);\n\n    // Remove permissions related to this role.\n    role.permissions.forEach(permission => {\n      arrayOfPromises.push(\n        strapi.query('permission', 'users-permissions').delete({\n          id: permission.id,\n        })\n      );\n    });\n\n    // Delete the role.\n    arrayOfPromises.push(strapi.query('role', 'users-permissions').delete({ id: roleID }));\n\n    return await Promise.all(arrayOfPromises);\n  },\n\n  getPlugins(lang = 'en') {\n    return new Promise(resolve => {\n      request(\n        {\n          uri: `https://marketplace.strapi.io/plugins?lang=${lang}`,\n          json: true,\n          timeout: 3000,\n          headers: {\n            'cache-control': 'max-age=3600',\n          },\n        },\n        (err, response, body) => {\n          if (err || response.statusCode !== 200) {\n            return resolve([]);\n          }\n\n          resolve(body);\n        }\n      );\n    });\n  },\n\n  getActions() {\n    const generateActions = data =>\n      Object.keys(data).reduce((acc, key) => {\n        if (_.isFunction(data[key])) {\n          acc[key] = { enabled: false, policy: '' };\n        }\n\n        return acc;\n      }, {});\n\n    const appControllers = Object.keys(strapi.api || {})\n      .filter(key => !!strapi.api[key].controllers)\n      .reduce(\n        (acc, key) => {\n          Object.keys(strapi.api[key].controllers).forEach(controller => {\n            acc.controllers[controller] = generateActions(strapi.api[key].controllers[controller]);\n          });\n\n          return acc;\n        },\n        { controllers: {} }\n      );\n\n    const pluginsPermissions = Object.keys(strapi.plugins).reduce((acc, key) => {\n      const initialState = {\n        controllers: {},\n      };\n\n      acc[key] = Object.keys(strapi.plugins[key].controllers).reduce((obj, k) => {\n        obj.controllers[k] = generateActions(strapi.plugins[key].controllers[k]);\n\n        return obj;\n      }, initialState);\n\n      return acc;\n    }, {});\n\n    const permissions = {\n      application: {\n        controllers: appControllers.controllers,\n      },\n    };\n\n    return _.merge(permissions, pluginsPermissions);\n  },\n\n  async getRole(roleID, plugins) {\n    const role = await strapi\n      .query('role', 'users-permissions')\n      .findOne({ id: roleID }, ['permissions']);\n\n    if (!role) {\n      throw new Error('Cannot find this role');\n    }\n\n    // Group by `type`.\n    const permissions = role.permissions.reduce((acc, permission) => {\n      _.set(acc, `${permission.type}.controllers.${permission.controller}.${permission.action}`, {\n        enabled: _.toNumber(permission.enabled) == true,\n        policy: permission.policy,\n      });\n\n      if (permission.type !== 'application' && !acc[permission.type].information) {\n        acc[permission.type].information =\n          plugins.find(plugin => plugin.id === permission.type) || {};\n      }\n\n      return acc;\n    }, {});\n\n    return {\n      ...role,\n      permissions,\n    };\n  },\n\n  async getRoles() {\n    const roles = await strapi.query('role', 'users-permissions').find({ _sort: 'name' }, []);\n\n    for (let i = 0; i < roles.length; ++i) {\n      roles[i].nb_users = await strapi\n        .query('user', 'users-permissions')\n        .count({ role: roles[i].id });\n    }\n\n    return roles;\n  },\n\n  async getRoutes() {\n    const routes = Object.keys(strapi.api || {}).reduce((acc, current) => {\n      return acc.concat(_.get(strapi.api[current].config, 'routes', []));\n    }, []);\n    const clonedPlugins = _.cloneDeep(strapi.plugins);\n    const pluginsRoutes = Object.keys(clonedPlugins || {}).reduce((acc, current) => {\n      const routes = _.get(clonedPlugins, [current, 'config', 'routes'], []).reduce((acc, curr) => {\n        const prefix = curr.config.prefix;\n        const path = prefix !== undefined ? `${prefix}${curr.path}` : `/${current}${curr.path}`;\n        _.set(curr, 'path', path);\n\n        return acc.concat(curr);\n      }, []);\n\n      acc[current] = routes;\n\n      return acc;\n    }, {});\n\n    return _.merge({ application: routes }, pluginsRoutes);\n  },\n\n  async updatePermissions() {\n    const { primaryKey } = strapi.query('permission', 'users-permissions');\n    const roles = await strapi.query('role', 'users-permissions').find({}, []);\n    const rolesMap = roles.reduce((map, role) => ({ ...map, [role[primaryKey]]: role }), {});\n\n    const dbPermissions = await strapi\n      .query('permission', 'users-permissions')\n      .find({ _limit: -1 });\n    let permissionsFoundInDB = dbPermissions.map(\n      p => `${p.type}.${p.controller}.${p.action}.${p.role[primaryKey]}`\n    );\n    permissionsFoundInDB = _.uniq(permissionsFoundInDB);\n\n    // Aggregate first level actions.\n    const appActions = Object.keys(strapi.api || {}).reduce((acc, api) => {\n      Object.keys(_.get(strapi.api[api], 'controllers', {})).forEach(controller => {\n        const actions = Object.keys(strapi.api[api].controllers[controller])\n          .filter(action => _.isFunction(strapi.api[api].controllers[controller][action]))\n          .map(action => `application.${controller}.${action.toLowerCase()}`);\n\n        acc = acc.concat(actions);\n      });\n\n      return acc;\n    }, []);\n\n    // Aggregate plugins' actions.\n    const pluginsActions = Object.keys(strapi.plugins).reduce((acc, plugin) => {\n      Object.keys(strapi.plugins[plugin].controllers).forEach(controller => {\n        const actions = Object.keys(strapi.plugins[plugin].controllers[controller])\n          .filter(action => _.isFunction(strapi.plugins[plugin].controllers[controller][action]))\n          .map(action => `${plugin}.${controller}.${action.toLowerCase()}`);\n\n        acc = acc.concat(actions);\n      });\n\n      return acc;\n    }, []);\n\n    const actionsFoundInFiles = appActions.concat(pluginsActions);\n\n    // create permissions for each role\n    let permissionsFoundInFiles = actionsFoundInFiles.reduce(\n      (acc, action) => [...acc, ...roles.map(role => `${action}.${role[primaryKey]}`)],\n      []\n    );\n    permissionsFoundInFiles = _.uniq(permissionsFoundInFiles);\n\n    // Compare to know if actions have been added or removed from controllers.\n    if (!_.isEqual(permissionsFoundInDB.sort(), permissionsFoundInFiles.sort())) {\n      const splitted = str => {\n        const [type, controller, action, roleId] = str.split('.');\n\n        return { type, controller, action, roleId };\n      };\n\n      // We have to know the difference to add or remove the permissions entries in the database.\n      const toRemove = _.difference(permissionsFoundInDB, permissionsFoundInFiles).map(splitted);\n      const toAdd = _.difference(permissionsFoundInFiles, permissionsFoundInDB).map(splitted);\n\n      const query = strapi.query('permission', 'users-permissions');\n\n      // Execute request to update entries in database for each role.\n      await Promise.all(\n        toAdd.map(permission =>\n          query.create({\n            type: permission.type,\n            controller: permission.controller,\n            action: permission.action,\n            enabled: isPermissionEnabled(permission, rolesMap[permission.roleId]),\n            policy: '',\n            role: permission.roleId,\n          })\n        )\n      );\n\n      await Promise.all(\n        toRemove.map(permission => {\n          const { type, controller, action, roleId: role } = permission;\n          return query.delete({ type, controller, action, role });\n        })\n      );\n    }\n  },\n\n  async initialize() {\n    const roleCount = await strapi.query('role', 'users-permissions').count();\n\n    if (roleCount === 0) {\n      await strapi.query('role', 'users-permissions').create({\n        name: 'Authenticated',\n        description: 'Default role given to authenticated user.',\n        type: 'authenticated',\n      });\n\n      await strapi.query('role', 'users-permissions').create({\n        name: 'Public',\n        description: 'Default role given to unauthenticated user.',\n        type: 'public',\n      });\n    }\n\n    return this.updatePermissions();\n  },\n\n  async updateRole(roleID, body) {\n    const [role, authenticated] = await Promise.all([\n      this.getRole(roleID, []),\n      strapi.query('role', 'users-permissions').findOne({ type: 'authenticated' }, []),\n    ]);\n\n    await strapi\n      .query('role', 'users-permissions')\n      .update({ id: roleID }, _.pick(body, ['name', 'description']));\n\n    await Promise.all(\n      Object.keys(body.permissions || {}).reduce((acc, type) => {\n        Object.keys(body.permissions[type].controllers).forEach(controller => {\n          Object.keys(body.permissions[type].controllers[controller]).forEach(action => {\n            const bodyAction = body.permissions[type].controllers[controller][action];\n            const currentAction = _.get(\n              role.permissions,\n              `${type}.controllers.${controller}.${action}`,\n              {}\n            );\n\n            if (!_.isEqual(bodyAction, currentAction)) {\n              acc.push(\n                strapi.query('permission', 'users-permissions').update(\n                  {\n                    role: roleID,\n                    type,\n                    controller,\n                    action: action.toLowerCase(),\n                  },\n                  bodyAction\n                )\n              );\n            }\n          });\n        });\n\n        return acc;\n      }, [])\n    );\n\n    // Add user to this role.\n    const newUsers = _.differenceBy(body.users, role.users, 'id');\n    await Promise.all(newUsers.map(user => this.updateUserRole(user, roleID)));\n\n    const oldUsers = _.differenceBy(role.users, body.users, 'id');\n    await Promise.all(oldUsers.map(user => this.updateUserRole(user, authenticated.id)));\n  },\n\n  async updateUserRole(user, role) {\n    return strapi.query('user', 'users-permissions').update({ id: user.id }, { role });\n  },\n\n  template(layout, data) {\n    const compiledObject = _.template(layout);\n    return compiledObject(data);\n  },\n};\n",
    "packages/strapi-provider-email-amazon-ses/lib/index.js": "'use strict';\n\nconst nodeSES = require('node-ses');\nconst { removeUndefined } = require('strapi-utils');\n\nmodule.exports = {\n  init: (providerOptions = {}, settings = {}) => {\n    var client = nodeSES.createClient({ ...providerOptions });\n\n    return {\n      send: options => {\n        return new Promise((resolve, reject) => {\n          const { from, to, cc, bcc, replyTo, subject, text, html, ...rest } = options;\n\n          let msg = {\n            from: from || settings.defaultFrom,\n            to,\n            cc,\n            bcc,\n            replyTo: replyTo || settings.defaultReplyTo,\n            subject,\n            altText: text,\n            message: html,\n            ...rest,\n          };\n          client.sendEmail(removeUndefined(msg), function(err) {\n            if (err) {\n              if (err.Message) {\n                reject(`${err.Message} ${err.Detail ? err.Detail : ''}`);\n              }\n              reject(err);\n            } else {\n              resolve();\n            }\n          });\n        });\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-email-mailgun/lib/index.js": "'use strict';\n\nconst mailgunFactory = require('mailgun-js');\nconst { removeUndefined } = require('strapi-utils');\n\nmodule.exports = {\n  init: (providerOptions = {}, settings = {}) => {\n    const mailgun = mailgunFactory({\n      mute: false,\n      ...providerOptions,\n    });\n\n    return {\n      send: options => {\n        return new Promise((resolve, reject) => {\n          const { from, to, cc, bcc, replyTo, subject, text, html, ...rest } = options;\n\n          let msg = {\n            from: from || settings.defaultFrom,\n            to,\n            cc,\n            bcc,\n            'h:Reply-To': replyTo || settings.defaultReplyTo,\n            subject,\n            text,\n            html,\n            ...rest,\n          };\n\n          mailgun.messages().send(removeUndefined(msg), function(err) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve();\n            }\n          });\n        });\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-email-sendgrid/lib/index.js": "'use strict';\n\nconst sendgrid = require('@sendgrid/mail');\nconst { removeUndefined } = require('strapi-utils');\n\nmodule.exports = {\n  init: (providerOptions = {}, settings = {}) => {\n    sendgrid.setApiKey(providerOptions.apiKey);\n\n    return {\n      send: options => {\n        return new Promise((resolve, reject) => {\n          const { from, to, cc, bcc, replyTo, subject, text, html, ...rest } = options;\n\n          let msg = {\n            from: from || settings.defaultFrom,\n            to,\n            cc,\n            bcc,\n            replyTo: replyTo || settings.defaultReplyTo,\n            subject,\n            text,\n            html,\n            ...rest,\n          };\n\n          sendgrid.send(removeUndefined(msg), function(err) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve();\n            }\n          });\n        });\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-email-sendmail/lib/index.js": "'use strict';\n\nconst sendmailFactory = require('sendmail');\nconst { removeUndefined } = require('strapi-utils');\n\nmodule.exports = {\n  init: (providerOptions = {}, settings = {}) => {\n    const sendmail = sendmailFactory({\n      silent: true,\n      ...providerOptions,\n    });\n    return {\n      send: options => {\n        return new Promise((resolve, reject) => {\n          const { from, to, cc, bcc, replyTo, subject, text, html, ...rest } = options;\n\n          let msg = {\n            from: from || settings.defaultFrom,\n            to,\n            cc,\n            bcc,\n            replyTo: replyTo || settings.defaultReplyTo,\n            subject,\n            text,\n            html,\n            ...rest,\n          };\n\n          sendmail(removeUndefined(msg), err => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve();\n            }\n          });\n        });\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-upload-aws-s3/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n/* eslint-disable no-unused-vars */\n// Public node modules.\nconst _ = require('lodash');\nconst AWS = require('aws-sdk');\n\nmodule.exports = {\n  init(config) {\n    const S3 = new AWS.S3({\n      apiVersion: '2006-03-01',\n      ...config,\n    });\n\n    return {\n      upload(file, customParams = {}) {\n        return new Promise((resolve, reject) => {\n          // upload file on S3 bucket\n          const path = file.path ? `${file.path}/` : '';\n          S3.upload(\n            {\n              Key: `${path}${file.hash}${file.ext}`,\n              Body: Buffer.from(file.buffer, 'binary'),\n              ACL: 'public-read',\n              ContentType: file.mime,\n              ...customParams,\n            },\n            (err, data) => {\n              if (err) {\n                return reject(err);\n              }\n\n              // set the bucket file url\n              file.url = data.Location;\n\n              resolve();\n            }\n          );\n        });\n      },\n      delete(file, customParams = {}) {\n        return new Promise((resolve, reject) => {\n          // delete file on S3 bucket\n          const path = file.path ? `${file.path}/` : '';\n          S3.deleteObject(\n            {\n              Key: `${path}${file.hash}${file.ext}`,\n              ...customParams,\n            },\n            (err, data) => {\n              if (err) {\n                return reject(err);\n              }\n\n              resolve();\n            }\n          );\n        });\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-upload-cloudinary/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst cloudinary = require('cloudinary').v2;\nconst intoStream = require('into-stream');\nconst { errors } = require('strapi-plugin-upload');\n\nmodule.exports = {\n  init(config) {\n    cloudinary.config(config);\n\n    return {\n      upload(file, customConfig = {}) {\n        return new Promise((resolve, reject) => {\n          const config = {\n            resource_type: 'auto',\n            public_id: file.hash,\n          };\n\n          if (file.ext) {\n            config.filename = `${file.hash}${file.ext}`;\n          }\n\n          const upload_stream = cloudinary.uploader.upload_stream(\n            { ...config, ...customConfig },\n            (err, image) => {\n              if (err) {\n                if (err.message.includes('File size too large')) {\n                  return reject(errors.entityTooLarge());\n                }\n                return reject(errors.unknownError(`Error uploading to cloudinary: ${err.message}`));\n              }\n\n              if (image.resource_type === 'video') {\n                file.previewUrl = cloudinary.url(`${image.public_id}.gif`, {\n                  video_sampling: 6,\n                  delay: 200,\n                  width: 250,\n                  crop: 'scale',\n                  resource_type: 'video',\n                });\n              }\n\n              file.url = image.secure_url;\n              file.provider_metadata = {\n                public_id: image.public_id,\n                resource_type: image.resource_type,\n              };\n              resolve();\n            }\n          );\n\n          intoStream(file.buffer).pipe(upload_stream);\n        });\n      },\n      async delete(file, customConfig = {}) {\n        try {\n          const { resource_type, public_id } = file.provider_metadata;\n          const response = await cloudinary.uploader.destroy(public_id, {\n            invalidate: true,\n            resource_type: resource_type || 'image',\n            ...customConfig,\n          });\n\n          if (response.result !== 'ok' && response.result !== 'not found') {\n            throw errors.unknownError(`Error deleting on cloudinary: ${response.result}`);\n          }\n        } catch (error) {\n          throw errors.unknownError(`Error deleting on cloudinary: ${error.message}`);\n        }\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-upload-local/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst fs = require('fs');\nconst path = require('path');\nconst { errors } = require('strapi-plugin-upload');\n\nmodule.exports = {\n  init({ sizeLimit = 1000000 } = {}) {\n    const verifySize = file => {\n      if (file.size > sizeLimit) {\n        throw errors.entityTooLarge();\n      }\n    };\n    const configPublicPath = strapi.config.get(\n      'middleware.settings.public.path',\n      strapi.config.paths.static\n    );\n\n    const uploadDir = path.resolve(strapi.dir, configPublicPath);\n\n    return {\n      upload(file) {\n        verifySize(file);\n\n        return new Promise((resolve, reject) => {\n          // write file in public/assets folder\n          fs.writeFile(\n            path.join(uploadDir, `/uploads/${file.hash}${file.ext}`),\n            file.buffer,\n            err => {\n              if (err) {\n                return reject(err);\n              }\n\n              file.url = `/uploads/${file.hash}${file.ext}`;\n\n              resolve();\n            }\n          );\n        });\n      },\n      delete(file) {\n        return new Promise((resolve, reject) => {\n          const filePath = path.join(uploadDir, `/uploads/${file.hash}${file.ext}`);\n\n          if (!fs.existsSync(filePath)) {\n            return resolve(\"File doesn't exist\");\n          }\n\n          // remove file from public/assets folder\n          fs.unlink(filePath, err => {\n            if (err) {\n              return reject(err);\n            }\n\n            resolve();\n          });\n        });\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-upload-rackspace/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst pkgcloud = require('pkgcloud');\nconst streamifier = require('streamifier');\n\nmodule.exports = {\n  init(config) {\n    const options = { container: config.container };\n    const client = pkgcloud.storage.createClient({\n      provider: 'rackspace',\n      ...config,\n    });\n\n    const remoteURL = () =>\n      new Promise((resolve, reject) => {\n        return client.getContainer(config.container, (err, res) => {\n          if (err && !res) return reject(err);\n          return resolve(res);\n        });\n      });\n\n    return {\n      upload(file) {\n        const readStream = streamifier.createReadStream(file.buffer);\n        const writeStream = client.upload({\n          ...options,\n          remote: file.hash,\n          contentType: file.mime,\n        });\n\n        return new Promise((resolve, reject) => {\n          readStream.pipe(writeStream);\n          writeStream.on('error', error => error && reject(error));\n          writeStream.on('success', result => {\n            remoteURL()\n              .then(data => {\n                resolve(\n                  Object.assign(file, {\n                    mime: result.contentType,\n                    url: `${data.cdnSslUri}/${result.name}`,\n                  })\n                );\n              })\n              .catch(err => console.error(err) && reject(err));\n          });\n        });\n      },\n      delete(file) {\n        return new Promise((resolve, reject) => {\n          client.removeFile(config.container, file.hash, error => {\n            if (error) return reject(error);\n            return resolve();\n          });\n        });\n      },\n    };\n  },\n};\n",
    "test/helpers/test-app-generator.js": "'use strict';\n\nconst path = require('path');\nconst rimraf = require('rimraf');\nconst generateNew = require('../../packages/strapi-generate-new/lib/generate-new');\n\n/**\n * Delete the testApp folder\n * @param {string} appName - name of the app / folder where the app is located\n */\nconst cleanTestApp = appName => {\n  return new Promise((resolve, reject) => {\n    rimraf(path.resolve(appName), err => {\n      if (err) reject(err);\n      resolve();\n    });\n  });\n};\n\n/**\n * Runs strapi generate new\n * @param {Object} options - Options\n * @param {string} options.appName - Name of the app that will be created (also the name of the folder)\n * @param {database} options.database - Arguments to create the testApp with the provided database params\n */\nconst generateTestApp = async ({ appName, database }) => {\n  const scope = {\n    database: {\n      settings: database,\n      options: {},\n    },\n    rootPath: path.resolve(appName),\n    name: appName,\n    // disable quickstart run app after creation\n    runQuickstartApp: false,\n    // use package version as strapiVersion (all packages have the same version);\n    strapiVersion: require('../../packages/strapi/package.json').version,\n    debug: false,\n    quick: false,\n    uuid: undefined,\n    deviceId: null,\n    // use yarn if available and --use-npm isn't true\n    useYarn: true,\n    installDependencies: false,\n    strapiDependencies: [\n      'strapi',\n      'strapi-admin',\n      'strapi-utils',\n      'strapi-plugin-content-type-builder',\n      'strapi-plugin-content-manager',\n      'strapi-plugin-users-permissions',\n      'strapi-plugin-email',\n      'strapi-plugin-upload',\n      'strapi-plugin-graphql',\n      'strapi-plugin-documentation',\n    ],\n    additionalsDependencies: {},\n  };\n\n  await generateNew(scope);\n};\n\nmodule.exports = {\n  cleanTestApp,\n  generateTestApp,\n};\n",
    "examples/getstarted/api/homepage/config/policies/test.js": "module.exports = async (ctx, next) => {\n  console.log('in test policy');\n\n  await next();\n};\n",
    "packages/strapi/lib/Strapi.js": "'use strict';\n\nconst http = require('http');\nconst path = require('path');\nconst fse = require('fs-extra');\nconst Koa = require('koa');\nconst Router = require('koa-router');\nconst _ = require('lodash');\nconst chalk = require('chalk');\nconst CLITable = require('cli-table3');\nconst { logger, models, getAbsoluteAdminUrl, getAbsoluteServerUrl } = require('strapi-utils');\nconst { createDatabaseManager } = require('strapi-database');\nconst loadConfiguration = require('./core/app-configuration');\n\nconst utils = require('./utils');\nconst loadModules = require('./core/load-modules');\nconst bootstrap = require('./core/bootstrap');\nconst initializeMiddlewares = require('./middlewares');\nconst initializeHooks = require('./hooks');\nconst createStrapiFs = require('./core/fs');\nconst createEventHub = require('./services/event-hub');\nconst createWebhookRunner = require('./services/webhook-runner');\nconst { webhookModel, createWebhookStore } = require('./services/webhook-store');\nconst { createCoreStore, coreStoreModel } = require('./services/core-store');\nconst createEntityService = require('./services/entity-service');\nconst entityValidator = require('./services/entity-validator');\nconst createTelemetry = require('./services/metrics');\nconst createUpdateNotifier = require('./utils/update-notifier');\nconst ee = require('./utils/ee');\n\n/**\n * Construct an Strapi instance.\n *\n * @constructor\n */\nclass Strapi {\n  constructor(opts = {}) {\n    this.reload = this.reload();\n\n    // Expose `koa`.\n    this.app = new Koa();\n    this.router = new Router();\n\n    this.initServer();\n\n    // Logger.\n    this.log = logger;\n\n    // Utils.\n    this.utils = {\n      models,\n    };\n\n    this.dir = opts.dir || process.cwd();\n\n    this.admin = {};\n    this.plugins = {};\n    this.config = loadConfiguration(this.dir, opts);\n    this.app.proxy = this.config.get('server.proxy');\n\n    this.isLoaded = false;\n\n    // internal services.\n    this.fs = createStrapiFs(this);\n    this.eventHub = createEventHub();\n\n    this.requireProjectBootstrap();\n\n    createUpdateNotifier(this).notify();\n  }\n\n  get EE() {\n    return ee({ dir: this.dir, logger });\n  }\n\n  handleRequest(req, res) {\n    if (!this.requestHandler) {\n      this.requestHandler = this.app.callback();\n    }\n\n    return this.requestHandler(req, res);\n  }\n\n  requireProjectBootstrap() {\n    const bootstrapPath = path.resolve(this.dir, 'config/functions/bootstrap.js');\n\n    if (fse.existsSync(bootstrapPath)) {\n      require(bootstrapPath);\n    }\n  }\n\n  logStats() {\n    const columns = Math.min(process.stderr.columns, 80) - 2;\n    console.log();\n    console.log(chalk.black.bgWhite(_.padEnd(' Project information', columns)));\n    console.log();\n\n    const infoTable = new CLITable({\n      colWidths: [20, 50],\n      chars: { mid: '', 'left-mid': '', 'mid-mid': '', 'right-mid': '' },\n    });\n\n    const isEE = strapi.EE === true && ee.isEE === true;\n\n    infoTable.push(\n      [chalk.blue('Time'), `${new Date()}`],\n      [chalk.blue('Launched in'), Date.now() - this.config.launchedAt + ' ms'],\n      [chalk.blue('Environment'), this.config.environment],\n      [chalk.blue('Process PID'), process.pid],\n      [chalk.blue('Version'), `${this.config.info.strapi} (node ${process.version})`],\n      [chalk.blue('Edition'), isEE ? 'Enterprise' : 'Community']\n    );\n\n    console.log(infoTable.toString());\n    console.log();\n    console.log(chalk.black.bgWhite(_.padEnd(' Actions available', columns)));\n    console.log();\n  }\n\n  logFirstStartupMessage() {\n    this.logStats();\n\n    console.log(chalk.bold('One more thing...'));\n    console.log(\n      chalk.grey('Create your first administrator  by going to the administration panel at:')\n    );\n    console.log();\n\n    const addressTable = new CLITable();\n\n    const adminUrl = getAbsoluteAdminUrl(strapi.config);\n    addressTable.push([chalk.bold(adminUrl)]);\n\n    console.log(`${addressTable.toString()}`);\n    console.log();\n  }\n\n  logStartupMessage() {\n    this.logStats();\n\n    console.log(chalk.bold('Welcome back!'));\n\n    if (this.config.serveAdminPanel === true) {\n      console.log(chalk.grey('To manage your project , go to the administration panel at:'));\n      const adminUrl = getAbsoluteAdminUrl(strapi.config);\n      console.log(chalk.bold(adminUrl));\n      console.log();\n    }\n\n    console.log(chalk.grey('To access the server , go to:'));\n    const serverUrl = getAbsoluteServerUrl(strapi.config);\n    console.log(chalk.bold(serverUrl));\n    console.log();\n  }\n\n  initServer() {\n    this.server = http.createServer(this.handleRequest.bind(this));\n    // handle port in use cleanly\n    this.server.on('error', err => {\n      if (err.code === 'EADDRINUSE') {\n        return this.stopWithError(`The port ${err.port} is already used by another application.`);\n      }\n\n      this.log.error(err);\n    });\n\n    // Close current connections to fully destroy the server\n    const connections = {};\n\n    this.server.on('connection', conn => {\n      const key = conn.remoteAddress + ':' + conn.remotePort;\n      connections[key] = conn;\n\n      conn.on('close', function() {\n        delete connections[key];\n      });\n    });\n\n    this.server.destroy = cb => {\n      this.server.close(cb);\n\n      for (let key in connections) {\n        connections[key].destroy();\n      }\n    };\n  }\n\n  async start(cb) {\n    try {\n      if (!this.isLoaded) {\n        await this.load();\n      }\n\n      this.app.use(this.router.routes()).use(this.router.allowedMethods());\n\n      // Launch server.\n      this.listen(cb);\n    } catch (err) {\n      this.stopWithError(err);\n    }\n  }\n\n  async destroy() {\n    if (_.has(this, 'server.destroy')) {\n      this.server.destroy();\n    }\n\n    await Promise.all(\n      Object.values(this.plugins).map(plugin => {\n        if (_.has(plugin, 'destroy') && typeof plugin.destroy === 'function') {\n          return plugin.destroy();\n        }\n      })\n    );\n\n    if (_.has(this, 'admin')) {\n      await this.admin.destroy();\n    }\n\n    this.eventHub.removeAllListeners();\n\n    if (_.has(this, 'db')) {\n      await this.db.destroy();\n    }\n\n    delete global.strapi;\n  }\n\n  /**\n   * Add behaviors to the server\n   */\n  async listen(cb) {\n    const onListen = async err => {\n      if (err) return this.stopWithError(err);\n\n      // Is the project initialised?\n      const isInitialised = await utils.isInitialised(this);\n\n      // Should the startup message be displayed?\n      const hideStartupMessage = process.env.STRAPI_HIDE_STARTUP_MESSAGE\n        ? process.env.STRAPI_HIDE_STARTUP_MESSAGE === 'true'\n        : false;\n\n      if (hideStartupMessage === false) {\n        if (!isInitialised) {\n          this.logFirstStartupMessage();\n        } else {\n          this.logStartupMessage();\n        }\n      }\n\n      // Emit started event.\n      const databaseClients = _.map(this.config.get('connections'), _.property('settings.client'));\n      await this.telemetry.send('didStartServer', { database: databaseClients });\n\n      if (cb && typeof cb === 'function') {\n        cb();\n      }\n\n      if (\n        (this.config.environment === 'development' &&\n          this.config.get('server.admin.autoOpen', true) !== false) ||\n        !isInitialised\n      ) {\n        await utils.openBrowser.call(this);\n      }\n    };\n\n    const listenSocket = this.config.get('server.socket');\n    const listenErrHandler = err => onListen(err).catch(err => this.stopWithError(err));\n\n    if (listenSocket) {\n      this.server.listen(listenSocket, listenErrHandler);\n    } else {\n      this.server.listen(\n        this.config.get('server.port'),\n        this.config.get('server.host'),\n        listenErrHandler\n      );\n    }\n  }\n\n  stopWithError(err, customMessage) {\n    this.log.debug(` Server wasn't able to start properly.`);\n    if (customMessage) {\n      this.log.error(customMessage);\n    }\n    this.log.error(err);\n    return this.stop();\n  }\n\n  stop(exitCode = 1) {\n    // Destroy server and available connections.\n    if (_.has(this, 'server.destroy')) {\n      this.server.destroy();\n    }\n\n    if (this.config.autoReload) {\n      process.send('stop');\n    }\n\n    // Kill process.\n    process.exit(exitCode);\n  }\n\n  async load() {\n    this.app.use(async (ctx, next) => {\n      if (ctx.request.url === '/_health' && ['HEAD', 'GET'].includes(ctx.request.method)) {\n        ctx.set('strapi', 'You are so French!');\n        ctx.status = 204;\n      } else {\n        await next();\n      }\n    });\n\n    const modules = await loadModules(this);\n\n    this.api = modules.api;\n    this.admin = modules.admin;\n    this.components = modules.components;\n    this.plugins = modules.plugins;\n    this.middleware = modules.middlewares;\n    this.hook = modules.hook;\n\n    await bootstrap(this);\n\n    // init webhook runner\n    this.webhookRunner = createWebhookRunner({\n      eventHub: this.eventHub,\n      logger: this.log,\n      configuration: this.config.get('server.webhooks', {}),\n    });\n\n    // Init core store\n    this.models['core_store'] = coreStoreModel(this.config);\n    this.models['strapi_webhooks'] = webhookModel(this.config);\n\n    this.db = createDatabaseManager(this);\n    await this.db.initialize();\n\n    this.store = createCoreStore({\n      environment: this.config.environment,\n      db: this.db,\n    });\n\n    this.webhookStore = createWebhookStore({ db: this.db });\n\n    await this.startWebhooks();\n\n    this.entityValidator = entityValidator;\n\n    this.entityService = createEntityService({\n      db: this.db,\n      eventHub: this.eventHub,\n      entityValidator: this.entityValidator,\n    });\n\n    this.telemetry = createTelemetry(this);\n\n    // Initialize hooks and middlewares.\n    await initializeMiddlewares.call(this);\n    await initializeHooks.call(this);\n\n    await this.runBootstrapFunctions();\n    await this.freeze();\n\n    this.isLoaded = true;\n\n    return this;\n  }\n\n  async startWebhooks() {\n    const webhooks = await this.webhookStore.findWebhooks();\n    webhooks.forEach(webhook => this.webhookRunner.add(webhook));\n  }\n\n  reload() {\n    const state = {\n      shouldReload: 0,\n    };\n\n    const reload = function() {\n      if (state.shouldReload > 0) {\n        // Reset the reloading state\n        state.shouldReload -= 1;\n        reload.isReloading = false;\n        return;\n      }\n\n      if (this.config.autoReload) {\n        this.server.close();\n        process.send('reload');\n      }\n    };\n\n    Object.defineProperty(reload, 'isWatching', {\n      configurable: true,\n      enumerable: true,\n      set: value => {\n        // Special state when the reloader is disabled temporarly (see GraphQL plugin example).\n        if (state.isWatching === false && value === true) {\n          state.shouldReload += 1;\n        }\n        state.isWatching = value;\n      },\n      get: () => {\n        return state.isWatching;\n      },\n    });\n\n    reload.isReloading = false;\n    reload.isWatching = true;\n\n    return reload;\n  }\n\n  async runBootstrapFunctions() {\n    const execBootstrap = async fn => {\n      if (!fn) return;\n\n      return fn();\n    };\n\n    // plugins bootstrap\n    const pluginBoostraps = Object.keys(this.plugins).map(plugin => {\n      return execBootstrap(_.get(this.plugins[plugin], 'config.functions.bootstrap')).catch(err => {\n        strapi.log.error(`Bootstrap function in plugin \"${plugin}\" failed`);\n        strapi.log.error(err);\n        strapi.stop();\n      });\n    });\n    await Promise.all(pluginBoostraps);\n\n    // user bootstrap\n    await execBootstrap(_.get(this.config, ['functions', 'bootstrap']));\n\n    // admin bootstrap : should always run after the others\n    const adminBootstrap = _.get(this.admin.config, 'functions.bootstrap');\n    return execBootstrap(adminBootstrap).catch(err => {\n      strapi.log.error(`Bootstrap function in admin failed`);\n      strapi.log.error(err);\n      strapi.stop();\n    });\n  }\n\n  async freeze() {\n    Object.freeze(this.config);\n    Object.freeze(this.dir);\n    Object.freeze(this.admin);\n    Object.freeze(this.plugins);\n    Object.freeze(this.api);\n  }\n\n  getModel(modelKey, plugin) {\n    return this.db.getModel(modelKey, plugin);\n  }\n\n  /**\n   * Binds queries with a specific model\n   * @param {string} entity - entity name\n   * @param {string} plugin - plugin name or null\n   */\n  query(entity, plugin) {\n    return this.db.query(entity, plugin);\n  }\n}\n\nmodule.exports = options => {\n  const strapi = new Strapi(options);\n  global.strapi = strapi;\n  return strapi;\n};\n",
    "packages/strapi/lib/commands/__tests__/admin-reset.test.js": "'use strict';\n\nconst load = jest.fn(() => mock);\nconst resetPasswordByEmail = jest.fn();\nconst admin = {\n  services: {\n    user: {\n      resetPasswordByEmail,\n    },\n  },\n};\n\nconst mock = {\n  load,\n  admin,\n};\n\njest.mock('../../index', () => {\n  return jest.fn(() => mock);\n});\n\nconst inquirer = require('inquirer');\nconst resetAdminPasswordCommand = require('../admin-reset');\n\ndescribe('admin:reset-password command', () => {\n  beforeEach(() => {\n    load.mockClear();\n    resetPasswordByEmail.mockClear();\n  });\n\n  test('resetAdminPasswordCommand accepts direct input', async () => {\n    const email = 'email@email.fr';\n    const password = 'testPasword1234';\n\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => {});\n    const consoleLog = jest.spyOn(console, 'log').mockImplementation(() => {});\n\n    await resetAdminPasswordCommand({ email, password });\n\n    expect(mockExit).toHaveBeenCalledWith(0);\n    expect(consoleLog).toHaveBeenCalled();\n    expect(load).toHaveBeenCalled();\n    expect(resetPasswordByEmail).toHaveBeenCalledWith(email, password);\n\n    mockExit.mockRestore();\n    consoleLog.mockRestore();\n  });\n\n  describe('Handles prompt input', () => {\n    test('Only prompt on TTY', async () => {\n      const tmpTTY = process.stdin.isTTY;\n      process.stdin.isTTY = false;\n\n      // throw so the code will stop executing\n      const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => {\n        throw new Error('exit');\n      });\n\n      const consoleError = jest.spyOn(console, 'error').mockImplementation(() => {});\n\n      await resetAdminPasswordCommand().catch(err => {\n        expect(err).toEqual(new Error('exit'));\n      });\n\n      expect(consoleError).toBeCalledWith('Missing required options `email` or `password`');\n      expect(mockExit).toHaveBeenCalledWith(1);\n      expect(load).not.toHaveBeenCalled();\n      expect(resetPasswordByEmail).not.toHaveBeenCalled();\n\n      process.stdin.isTTY = tmpTTY;\n      mockExit.mockRestore();\n      consoleError.mockRestore();\n    });\n\n    test('Stops if not confirmed', async () => {\n      process.stdin.isTTY = true;\n      const email = 'email@email.fr';\n      const password = 'testPasword1234';\n\n      const mockInquiry = jest\n        .spyOn(inquirer, 'prompt')\n        .mockImplementationOnce(async () => ({ email, password, confirm: false }));\n\n      // throw so the code will stop executing\n      const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => {\n        throw new Error('exit');\n      });\n\n      await resetAdminPasswordCommand().catch(err => {\n        expect(err).toEqual(new Error('exit'));\n      });\n\n      expect(mockInquiry).toHaveBeenLastCalledWith([\n        expect.objectContaining({\n          message: expect.any(String),\n          name: 'email',\n          type: 'input',\n        }),\n        expect.objectContaining({\n          message: expect.any(String),\n          name: 'password',\n          type: 'password',\n        }),\n        expect.objectContaining({\n          message: expect.any(String),\n          name: 'confirm',\n          type: 'confirm',\n        }),\n      ]);\n      expect(mockExit).toHaveBeenCalledWith(0);\n      expect(load).not.toHaveBeenCalled();\n      expect(resetPasswordByEmail).not.toHaveBeenCalled();\n\n      mockExit.mockRestore();\n      mockInquiry.mockRestore();\n    });\n\n    test('Calls the reset method with user input', async () => {\n      const email = 'email@email.fr';\n      const password = 'testPasword1234';\n\n      const mockInquiry = jest\n        .spyOn(inquirer, 'prompt')\n        .mockImplementationOnce(async () => ({ email, password, confirm: true }));\n\n      const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => {});\n      const consoleLog = jest.spyOn(console, 'log').mockImplementation(() => {});\n\n      await resetAdminPasswordCommand();\n\n      expect(mockExit).toHaveBeenCalledWith(0);\n      expect(consoleLog).toHaveBeenCalled();\n      expect(load).toHaveBeenCalled();\n      expect(resetPasswordByEmail).toHaveBeenCalledWith(email, password);\n\n      mockInquiry.mockRestore();\n      mockExit.mockRestore();\n      consoleLog.mockRestore();\n    });\n  });\n});\n",
    "packages/strapi/lib/commands/admin-reset.js": "'use strict';\n\nconst _ = require('lodash');\nconst inquirer = require('inquirer');\nconst strapi = require('../index');\n\nconst promptQuestions = [\n  { type: 'input', name: 'email', message: 'User email?' },\n  { type: 'password', name: 'password', message: 'New password?' },\n  {\n    type: 'confirm',\n    name: 'confirm',\n    message: \"Do you really want to reset this user's password?\",\n  },\n];\n\n/**\n * Reset user's password\n * @param {Object} cmdOptions - command options\n * @param {string} cmdOptions.email - user's email\n * @param {string} cmdOptions.password - user's new password\n */\nmodule.exports = async function(cmdOptions = {}) {\n  const { email, password } = cmdOptions;\n\n  if (_.isEmpty(email) && _.isEmpty(password) && process.stdin.isTTY) {\n    const inquiry = await inquirer.prompt(promptQuestions);\n\n    if (!inquiry.confirm) {\n      process.exit(0);\n    }\n\n    return changePassword(inquiry);\n  }\n\n  if (_.isEmpty(email) || _.isEmpty(password)) {\n    console.error('Missing required options `email` or `password`');\n    process.exit(1);\n  }\n\n  return changePassword({ email, password });\n};\n\nasync function changePassword({ email, password }) {\n  const app = await strapi().load();\n\n  await app.admin.services.user.resetPasswordByEmail(email, password);\n\n  console.log(`Successfully reset user's password`);\n  process.exit(0);\n}\n",
    "packages/strapi/lib/commands/configurationDump.js": "'use strict';\n\nconst fs = require('fs');\nconst strapi = require('../index');\n\nconst CHUNK_SIZE = 100;\n\n/**\n * Will dump configurations to a file or stdout\n * @param {string} file filepath to use as output\n */\nmodule.exports = async function({ file: filePath, pretty }) {\n  const output = filePath ? fs.createWriteStream(filePath) : process.stdout;\n\n  const app = await strapi().load();\n\n  const count = await app.query('core_store').count();\n\n  const exportData = [];\n\n  const pageCount = Math.ceil(count / CHUNK_SIZE);\n\n  for (let page = 0; page < pageCount; page++) {\n    const results = await app\n      .query('core_store')\n      .find({ _limit: CHUNK_SIZE, _start: page * CHUNK_SIZE, _sort: 'key' });\n\n    results\n      .filter(result => result.key.startsWith('plugin_'))\n      .forEach(result => {\n        exportData.push({\n          key: result.key,\n          value: result.value,\n          type: result.type,\n          environment: result.environment,\n          tag: result.tag,\n        });\n      });\n  }\n\n  output.write(JSON.stringify(exportData, null, pretty ? 2 : null));\n  output.write('\\n');\n  output.end();\n\n  // log success only when writting to file\n  if (filePath) {\n    console.log(`Successfully exported ${exportData.length} configuration entries`);\n  }\n  process.exit(0);\n};\n",
    "packages/strapi/lib/commands/install.js": "'use strict';\n\nconst { join } = require('path');\nconst { existsSync } = require('fs-extra');\nconst ora = require('ora');\nconst execa = require('execa');\nconst findPackagePath = require('../load/package-path');\n\nmodule.exports = async plugins => {\n  const loader = ora();\n  const dir = process.cwd();\n\n  const version = require(join(dir, 'package.json')).dependencies.strapi;\n\n  const pluginArgs = plugins.map(name => `strapi-plugin-${name}@${version}`);\n\n  try {\n    loader.start(`Installing dependencies`);\n\n    const useYarn = existsSync(join(dir, 'yarn.lock'));\n    if (useYarn) {\n      await execa('yarn', ['add', ...pluginArgs]);\n    } else {\n      await execa('npm', ['install', '--save', ...pluginArgs]);\n    }\n\n    loader.succeed();\n\n    // check if rebuild is necessary\n    let shouldRebuild = false;\n    for (let name of plugins) {\n      let pkgPath = findPackagePath(`strapi-plugin-${name}`);\n      if (existsSync(join(pkgPath, 'admin', 'src', 'index.js'))) {\n        shouldRebuild = true;\n      }\n    }\n\n    if (shouldRebuild) {\n      loader.start(`Rebuilding admin UI`);\n      await execa('npm', ['run', 'build']);\n      loader.succeed();\n    }\n  } catch (err) {\n    loader.clear();\n    console.error(err.message);\n    process.exit(1);\n  }\n};\n",
    "packages/strapi/lib/commands/uninstall.js": "'use strict';\n\nconst { join } = require('path');\nconst { existsSync, removeSync } = require('fs-extra');\nconst ora = require('ora');\nconst execa = require('execa');\nconst inquirer = require('inquirer');\nconst findPackagePath = require('../load/package-path');\n\nmodule.exports = async (plugins, { deleteFiles }) => {\n  const answers = await inquirer.prompt([\n    {\n      type: 'confirm',\n      name: 'deleteFiles',\n      message: `Do you want to delete the plugin generated files in the extensions folder ?`,\n      default: true,\n      when: !deleteFiles,\n    },\n  ]);\n\n  const loader = ora();\n  const dir = process.cwd();\n\n  const pluginArgs = plugins.map(name => `strapi-plugin-${name}`);\n\n  try {\n    // verify should rebuild before removing the pacakge\n    let shouldRebuild = false;\n    for (let name of plugins) {\n      let pkgPath = findPackagePath(`strapi-plugin-${name}`);\n      if (existsSync(join(pkgPath, 'admin', 'src', 'index.js'))) {\n        shouldRebuild = true;\n      }\n    }\n\n    loader.start(`Uninstalling dependencies`);\n\n    const useYarn = existsSync(join(dir, 'yarn.lock'));\n    if (useYarn) {\n      await execa('yarn', ['remove', ...pluginArgs]);\n    } else {\n      await execa('npm', ['remove', ...pluginArgs]);\n    }\n\n    loader.succeed();\n\n    if (deleteFiles === true || answers.deleteFiles === true) {\n      loader.start('Deleting old files');\n      for (let name of plugins) {\n        const pluginDir = join(dir, 'extensions', name);\n        if (existsSync(pluginDir)) {\n          removeSync(pluginDir);\n        }\n      }\n      loader.succeed();\n    }\n\n    if (shouldRebuild) {\n      loader.start(`Rebuilding admin UI`);\n      await execa('npm', ['run', 'build']);\n      loader.succeed();\n    }\n  } catch (err) {\n    loader.clear();\n    console.error(err.message);\n    process.exit(1);\n  }\n};\n",
    "packages/strapi/lib/core/__tests__/fs.test.js": "'use strict';\n\njest.mock('fs-extra', () => ({\n  ensureFile: jest.fn(() => Promise.resolve()),\n  writeFile: jest.fn(() => Promise.resolve()),\n}));\n\nconst path = require('path');\nconst fse = require('fs-extra');\nconst fs = require('../fs');\n\ndescribe('Strapi fs utils', () => {\n  const strapi = {\n    dir: '/tmp',\n  };\n\n  test('Provides new functions', () => {\n    const strapiFS = fs(strapi);\n\n    expect(strapiFS.writeAppFile).toBeInstanceOf(Function);\n    expect(strapiFS.writePluginFile).toBeInstanceOf(Function);\n  });\n\n  describe('Write App File', () => {\n    test('Makes sure the path exists and writes', async () => {\n      const strapiFS = fs(strapi);\n\n      const content = '';\n\n      await strapiFS.writeAppFile('test', content);\n\n      expect(fse.ensureFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test'));\n      expect(fse.writeFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test'), content);\n    });\n\n    test('Normalize the path to avoid relative access to folders in parent directories', async () => {\n      const strapiFS = fs(strapi);\n\n      const content = '';\n\n      await strapiFS.writeAppFile('../../test', content);\n\n      expect(fse.ensureFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test'));\n      expect(fse.writeFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test'), content);\n    });\n\n    test('Works with array path', async () => {\n      const strapiFS = fs(strapi);\n\n      const content = '';\n\n      await strapiFS.writeAppFile(['test', 'sub', 'path'], content);\n\n      expect(fse.ensureFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test', 'sub', 'path'));\n      expect(fse.writeFile).toHaveBeenCalledWith(\n        path.join('/', 'tmp', 'test', 'sub', 'path'),\n        content\n      );\n    });\n  });\n\n  describe('Write Plugin File', () => {\n    test('Scopes the writes in the extensions folder', async () => {\n      const strapiFS = fs(strapi);\n\n      const content = '';\n\n      strapiFS.writeAppFile = jest.fn(() => Promise.resolve());\n\n      await strapiFS.writePluginFile('users-permissions', ['test', 'sub', 'path'], content);\n\n      expect(strapiFS.writeAppFile).toHaveBeenCalledWith(\n        'extensions/users-permissions/test/sub/path',\n        content\n      );\n    });\n  });\n});\n",
    "packages/strapi/lib/core/load-admin.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst findPackagePath = require('../load/package-path');\nconst loadFiles = require('../load/load-files');\nconst loadConfig = require('../load/load-config-files');\n\nconst mergeRoutes = (a, b, key) =>\n  _.isArray(a) && _.isArray(b) && key === 'routes' ? a.concat(b) : undefined;\n\nmodule.exports = async strapi => {\n  const adminPath = findPackagePath('strapi-admin');\n  const [files, config] = await Promise.all([\n    loadFiles(adminPath, '!(config|node_modules|tests|ee|scripts)/*.*(js|json)'),\n    loadConfig(adminPath),\n  ]);\n\n  // set admin config in strapi.config.server.admin\n  const userAdminConfig = strapi.config.get('server.admin');\n  strapi.config.set('server.admin', _.merge(config.config, userAdminConfig));\n\n  // load ee files if they exist\n  let eeFiles = {};\n  let eeConfig = {};\n\n  if (process.env.STRAPI_DISABLE_EE !== 'true' && strapi.EE) {\n    const eeAdminPath = `${adminPath}/ee`;\n    [eeFiles, eeConfig] = await Promise.all([\n      loadFiles(eeAdminPath, '!(config|test)/*.*(js|json)'),\n      loadConfig(eeAdminPath),\n    ]);\n  }\n\n  return _.mergeWith({}, files, eeFiles, config, eeConfig, mergeRoutes);\n};\n",
    "packages/strapi/lib/core/load-components.js": "'use strict';\n\nconst { join } = require('path');\nconst _ = require('lodash');\nconst { exists } = require('fs-extra');\nconst loadFiles = require('../load/load-files');\n\nmodule.exports = async strapi => {\n  const componentsDir = join(strapi.dir, 'components');\n\n  if (!(await exists(componentsDir))) {\n    return {};\n  }\n\n  const map = await loadFiles(componentsDir, '*/*.*(js|json)');\n\n  return Object.keys(map).reduce((acc, category) => {\n    Object.keys(map[category]).forEach(key => {\n      const schema = map[category][key];\n\n      const filePath = join(componentsDir, category, schema.__filename__);\n\n      if (!schema.collectionName) {\n        return strapi.stopWithError(\n          `Component ${key} is missing a \"collectionName\" property.\\nVerify file ${filePath}.`\n        );\n      }\n\n      const uid = `${category}.${key}`;\n\n      acc[uid] = Object.assign(schema, {\n        __schema__: _.cloneDeep(schema),\n        uid,\n        category,\n        modelType: 'component',\n        modelName: key,\n        globalId: schema.globalId || _.upperFirst(_.camelCase(`component_${uid}`)),\n      });\n    });\n\n    return acc;\n  }, {});\n};\n",
    "packages/strapi/lib/core/load-hooks.js": "'use strict';\n\n// Dependencies.\nconst path = require('path');\nconst fs = require('fs-extra');\nconst _ = require('lodash');\nconst glob = require('../load/glob');\nconst findPackagePath = require('../load/package-path');\n\n/**\n * Load hooks\n */\nmodule.exports = async function({ installedHooks, installedPlugins, appPath }) {\n  let hooks = {};\n\n  await Promise.all([\n    loadHookDependencies(installedHooks, hooks),\n    // local middleware\n    loadLocalHooks(appPath, hooks),\n    // plugins middlewares\n    loadPluginsHooks(installedPlugins, hooks),\n    // local plugin middlewares\n    loadLocalPluginsHooks(appPath, hooks),\n  ]);\n\n  return hooks;\n};\n\nconst loadHooksInDir = async (dir, hooks) => {\n  const files = await glob('*/*(index|defaults).*(js|json)', {\n    cwd: dir,\n  });\n\n  files.forEach(f => {\n    const name = f.split('/')[0];\n    mountHooks(name, [path.resolve(dir, f)], hooks);\n  });\n};\n\nconst loadLocalHooks = (appPath, hooks) => loadHooksInDir(path.resolve(appPath, 'hooks'), hooks);\n\nconst loadPluginsHooks = async (plugins, hooks) => {\n  for (let pluginName of plugins) {\n    const dir = path.resolve(findPackagePath(`strapi-plugin-${pluginName}`), 'hooks');\n    await loadHooksInDir(dir, hooks);\n  }\n};\n\nconst loadLocalPluginsHooks = async (appPath, hooks) => {\n  const pluginsDir = path.resolve(appPath, 'plugins');\n  if (!fs.existsSync(pluginsDir)) return;\n\n  const pluginsNames = await fs.readdir(pluginsDir);\n\n  for (let pluginName of pluginsNames) {\n    // ignore files\n    const stat = await fs.stat(path.resolve(pluginsDir, pluginName));\n    if (!stat.isDirectory()) continue;\n\n    const dir = path.resolve(pluginsDir, pluginName, 'hooks');\n    await loadHooksInDir(dir, hooks);\n  }\n};\n\nconst loadHookDependencies = async (installedHooks, hooks) => {\n  for (let hook of installedHooks) {\n    const hookDir = path.dirname(require.resolve(`strapi-hook-${hook}`));\n\n    const files = await glob('*(index|defaults).*(js|json)', {\n      cwd: hookDir,\n      absolute: true,\n    });\n\n    mountHooks(hook, files, hooks);\n  }\n};\n\nconst mountHooks = (name, files, hooks) => {\n  files.forEach(file => {\n    hooks[name] = hooks[name] || { loaded: false };\n\n    let dependencies = [];\n    try {\n      dependencies = _.get(require(`strapi-hook-${name}/package.json`), 'strapi.dependencies', []);\n    } catch (err) {\n      // Silent\n    }\n\n    if (_.endsWith(file, 'index.js') && !hooks[name].load) {\n      Object.defineProperty(hooks[name], 'load', {\n        configurable: false,\n        enumerable: true,\n        get: () => require(file)(strapi),\n      });\n      hooks[name].dependencies = dependencies;\n      return;\n    }\n\n    if (_.endsWith(file, 'defaults.json')) {\n      hooks[name].defaults = require(file);\n      return;\n    }\n  });\n};\n",
    "packages/strapi/lib/core/load-middlewares.js": "'use strict';\n\n// Dependencies.\nconst path = require('path');\nconst fs = require('fs-extra');\nconst _ = require('lodash');\nconst glob = require('../load/glob');\nconst findPackagePath = require('../load/package-path');\n\n/**\n * Load middlewares\n */\nmodule.exports = async function(strapi) {\n  const { installedMiddlewares, installedPlugins, appPath } = strapi.config;\n\n  let middlewares = {};\n\n  const loaders = createLoaders(strapi);\n\n  await loaders.loadMiddlewareDependencies(installedMiddlewares, middlewares);\n  // internal middlewares\n  await loaders.loadInternalMiddlewares(middlewares);\n  // local middleware\n  await loaders.loadLocalMiddlewares(appPath, middlewares);\n  // plugins middlewares\n  await loaders.loadPluginsMiddlewares(installedPlugins, middlewares);\n  // local plugin middlewares\n  await loaders.loadLocalPluginsMiddlewares(appPath, middlewares);\n  // load admin middlwares\n  await loaders.loadAdminMiddlewares(middlewares);\n\n  return middlewares;\n};\n\n/**\n * Build loader functions\n * @param {*} strapi - strapi instance\n */\nconst createLoaders = strapi => {\n  const loadMiddlewaresInDir = async (dir, middlewares) => {\n    const files = await glob('*/*(index|defaults).*(js|json)', {\n      cwd: dir,\n    });\n\n    files.forEach(f => {\n      const name = f.split('/')[0];\n      mountMiddleware(name, [path.resolve(dir, f)], middlewares);\n    });\n  };\n\n  const loadInternalMiddlewares = middlewares =>\n    loadMiddlewaresInDir(path.resolve(__dirname, '..', 'middlewares'), middlewares);\n\n  const loadLocalMiddlewares = (appPath, middlewares) =>\n    loadMiddlewaresInDir(path.resolve(appPath, 'middlewares'), middlewares);\n\n  const loadPluginsMiddlewares = async (plugins, middlewares) => {\n    for (let pluginName of plugins) {\n      const dir = path.resolve(findPackagePath(`strapi-plugin-${pluginName}`), 'middlewares');\n      await loadMiddlewaresInDir(dir, middlewares);\n    }\n  };\n\n  const loadLocalPluginsMiddlewares = async (appPath, middlewares) => {\n    const pluginsDir = path.resolve(appPath, 'plugins');\n    if (!fs.existsSync(pluginsDir)) return;\n\n    const pluginsNames = await fs.readdir(pluginsDir);\n\n    for (let pluginFolder of pluginsNames) {\n      // ignore files\n      const stat = await fs.stat(path.resolve(pluginsDir, pluginFolder));\n      if (!stat.isDirectory()) continue;\n\n      const dir = path.resolve(pluginsDir, pluginFolder, 'middlewares');\n      await loadMiddlewaresInDir(dir, middlewares);\n    }\n  };\n\n  const loadAdminMiddlewares = async middlewares => {\n    const dir = path.resolve(findPackagePath(`strapi-admin`), 'middlewares');\n    await loadMiddlewaresInDir(dir, middlewares);\n  };\n\n  const loadMiddlewareDependencies = async (packages, middlewares) => {\n    for (let packageName of packages) {\n      const baseDir = path.dirname(require.resolve(`strapi-middleware-${packageName}`));\n      const files = await glob('*(index|defaults).*(js|json)', {\n        cwd: baseDir,\n        absolute: true,\n      });\n\n      mountMiddleware(packageName, files, middlewares);\n    }\n  };\n\n  const mountMiddleware = (name, files, middlewares) => {\n    files.forEach(file => {\n      middlewares[name] = middlewares[name] || { loaded: false };\n\n      if (_.endsWith(file, 'index.js') && !middlewares[name].load) {\n        return Object.defineProperty(middlewares[name], 'load', {\n          configurable: false,\n          enumerable: true,\n          get: () => require(file)(strapi),\n        });\n      }\n\n      if (_.endsWith(file, 'defaults.json')) {\n        middlewares[name].defaults = require(file);\n        return;\n      }\n    });\n  };\n\n  return {\n    loadInternalMiddlewares,\n    loadLocalMiddlewares,\n    loadPluginsMiddlewares,\n    loadLocalPluginsMiddlewares,\n    loadMiddlewareDependencies,\n    loadAdminMiddlewares,\n  };\n};\n",
    "packages/strapi/lib/core/load-modules.js": "/**\n * Load Modules is the root module loader.\n * This is where all the strapi enviornment is laoded\n * - APIs\n * - Plugins\n * - Hooks\n * - Middlewres\n * - Components\n * - ContentTypes\n */\n'use strict';\n\nconst _ = require('lodash');\n\nconst loadApis = require('./load-apis');\nconst loadAdmin = require('./load-admin');\nconst loadPlugins = require('./load-plugins');\nconst loadMiddlewares = require('./load-middlewares');\nconst loadExtensions = require('./load-extensions');\nconst loadHooks = require('./load-hooks');\nconst loadComponents = require('./load-components');\n\nmodule.exports = async strapi => {\n  const [api, admin, plugins, middlewares, hook, extensions, components] = await Promise.all([\n    loadApis(strapi),\n    loadAdmin(strapi),\n    loadPlugins(strapi),\n    loadMiddlewares(strapi),\n    loadHooks(strapi.config),\n    loadExtensions(strapi.config),\n    loadComponents(strapi),\n  ]);\n\n  // TODO: move this into the appropriate loaders\n\n  /**\n   * Handle plugin extensions\n   */\n  // merge extensions config folders\n  _.mergeWith(plugins, extensions.merges, (objValue, srcValue, key) => {\n    // concat routes\n    if (_.isArray(srcValue) && _.isArray(objValue) && key === 'routes') {\n      return srcValue.concat(objValue);\n    }\n  });\n\n  // overwrite plugins with extensions overwrites\n  extensions.overwrites.forEach(({ path, mod }) => {\n    _.assign(_.get(plugins, path), mod);\n  });\n\n  return {\n    api,\n    admin,\n    plugins,\n    middlewares,\n    hook,\n    extensions,\n    components,\n  };\n};\n",
    "packages/strapi/lib/core/load-plugins.js": "'use strict';\n\nconst { join } = require('path');\nconst { existsSync } = require('fs-extra');\nconst _ = require('lodash');\nconst findPackagePath = require('../load/package-path');\nconst loadFiles = require('../load/load-files');\nconst loadConfig = require('../load/load-config-files');\n\nmodule.exports = async ({ dir, config }) => {\n  const localPlugins = await loadLocalPlugins({ dir, config });\n  const plugins = await loadPlugins({\n    installedPlugins: config.installedPlugins,\n    config,\n  });\n\n  const pluginsIntersection = _.intersection(Object.keys(localPlugins), Object.keys(plugins));\n\n  if (pluginsIntersection.length > 0) {\n    throw new Error(\n      `You have some local plugins with the same name as npm installed plugins:\\n${pluginsIntersection\n        .map(p => `- ${p}`)\n        .join('\\n')}`\n    );\n  }\n\n  // check for conflicts\n  return _.merge(plugins, localPlugins);\n};\n\nconst loadLocalPlugins = async ({ dir, config }) => {\n  const pluginsDir = join(dir, 'plugins');\n\n  if (!existsSync(pluginsDir)) return {};\n\n  const [files, configs] = await Promise.all([\n    loadFiles(pluginsDir, '{*/!(config)/*.*(js|json),*/package.json}'),\n    loadConfig(pluginsDir, '*/config/**/*.+(js|json)'),\n  ]);\n  const userConfigs = Object.keys(files).reduce((acc, plugin) => {\n    acc[plugin] = { config: config.get(['plugins', plugin], {}) };\n    return acc;\n  }, {});\n  return _.merge(files, configs, userConfigs);\n};\n\nconst loadPlugins = async ({ installedPlugins, config }) => {\n  let plugins = {};\n\n  for (let plugin of installedPlugins) {\n    const pluginPath = findPackagePath(`strapi-plugin-${plugin}`);\n\n    const files = await loadFiles(\n      pluginPath,\n      '{!(config|node_modules|tests)/*.*(js|json),package.json}'\n    );\n\n    const { config: pluginConfig } = await loadConfig(pluginPath);\n\n    const userConfig = config.get(['plugins', plugin], {});\n\n    const mergedConfig = _.merge(pluginConfig, userConfig);\n\n    _.set(plugins, plugin, _.assign({}, files, { config: mergedConfig }));\n  }\n\n  return plugins;\n};\n",
    "packages/strapi/lib/core-api/__tests__/service.test.js": "'use strict';\n\nconst _ = require('lodash');\nconst createService = require('../service');\n\nconst maxLimit = 50;\nconst defaultLimit = 20;\n\n// init global strapi\nglobal.strapi = {\n  config: {\n    get(path, defaultValue) {\n      return _.get(this, path, defaultValue);\n    },\n    api: {\n      rest: {\n        defaultLimit,\n        maxLimit,\n      },\n    },\n  },\n};\n\ndescribe('Default Service', () => {\n  describe('Collection Type', () => {\n    test('Creates default actions', () => {\n      const strapi = {};\n      const model = {\n        modelName: 'testModel',\n        kind: 'collectionType',\n      };\n\n      const service = createService({ strapi, model });\n\n      expect(service).toEqual({\n        find: expect.any(Function),\n        findOne: expect.any(Function),\n        count: expect.any(Function),\n        search: expect.any(Function),\n        countSearch: expect.any(Function),\n        create: expect.any(Function),\n        update: expect.any(Function),\n        delete: expect.any(Function),\n      });\n    });\n  });\n\n  describe('Single Type', () => {\n    test('Creates default actions', () => {\n      const strapi = {};\n      const model = {\n        modelName: 'testModel',\n        kind: 'singleType',\n      };\n\n      const service = createService({ strapi, model });\n\n      expect(service).toEqual({\n        find: expect.any(Function),\n        createOrUpdate: expect.any(Function),\n        delete: expect.any(Function),\n      });\n    });\n\n    describe('Passes the logic down to the entityService', () => {\n      test('Creates data when no entity is found', async () => {\n        const strapi = {\n          entityService: {\n            find: jest.fn(() => Promise.resolve(null)),\n            create: jest.fn(() => Promise.resolve({ id: 1 })),\n          },\n        };\n\n        const model = {\n          modelName: 'testModel',\n          kind: 'singleType',\n        };\n\n        const service = createService({ strapi, model });\n\n        const input = {};\n        await service.createOrUpdate(input);\n\n        expect(strapi.entityService.find).toHaveBeenCalledWith(\n          { populate: undefined, params: { _publicationState: 'live', _limit: defaultLimit } },\n          {\n            model: 'testModel',\n          }\n        );\n\n        expect(strapi.entityService.create).toHaveBeenCalledWith(\n          { data: input },\n          {\n            model: 'testModel',\n          }\n        );\n      });\n\n      test('Updates data when entity is found', async () => {\n        const strapi = {\n          entityService: {\n            find: jest.fn(() => Promise.resolve({ id: 1 })),\n            update: jest.fn(() => Promise.resolve({ id: 1 })),\n          },\n        };\n\n        const model = {\n          modelName: 'testModel',\n          kind: 'singleType',\n        };\n\n        const service = createService({ strapi, model });\n\n        const input = {};\n        await service.createOrUpdate(input);\n\n        expect(strapi.entityService.find).toHaveBeenCalledWith(\n          { populate: undefined, params: { _publicationState: 'live', _limit: defaultLimit } },\n          {\n            model: 'testModel',\n          }\n        );\n\n        expect(strapi.entityService.update).toHaveBeenCalledWith(\n          {\n            params: { id: 1 },\n            data: input,\n          },\n          {\n            model: 'testModel',\n          }\n        );\n      });\n\n      test('Delete data when entity is found', async () => {\n        const strapi = {\n          entityService: {\n            find: jest.fn(() => Promise.resolve({ id: 1 })),\n            delete: jest.fn(() => Promise.resolve({ id: 1 })),\n          },\n        };\n\n        const model = {\n          modelName: 'testModel',\n          kind: 'singleType',\n        };\n\n        const service = createService({ strapi, model });\n\n        await service.delete();\n\n        expect(strapi.entityService.find).toHaveBeenCalledWith(\n          { populate: undefined, params: { _publicationState: 'live', _limit: defaultLimit } },\n          {\n            model: 'testModel',\n          }\n        );\n\n        expect(strapi.entityService.delete).toHaveBeenCalledWith(\n          {\n            params: { id: 1 },\n          },\n          {\n            model: 'testModel',\n          }\n        );\n      });\n    });\n  });\n});\n\ndescribe('getFetchParams', () => {\n  test.each([\n    [`0 if _limit is '0'`, { _limit: '0', maxLimit }, 0],\n    ['0 if _limit is 0', { _limit: 0, maxLimit }, 0],\n    [`0 if _limit is ''`, { _limit: '', maxLimit }, 0],\n    [`1 if _limit is '1'`, { _limit: '1', maxLimit }, 1],\n    [\n      `${maxLimit} if _limit(500) exceeds max allowed limit (${maxLimit})`,\n      { _limit: '500', maxLimit },\n      maxLimit,\n    ],\n    [\n      `${maxLimit} if _limit is set to -1 and max allowed limit is set (${maxLimit})`,\n      { _limit: '-1', maxLimit },\n      maxLimit,\n    ],\n    [`${defaultLimit} (default) if no _limit is provided`, { maxLimit }, defaultLimit],\n    [\n      `${defaultLimit} (default) if _limit is undefined`,\n      { _limit: undefined, maxLimit },\n      defaultLimit,\n    ],\n    ['1000 if _limit=1000 and no max allowed limit is set', { _limit: 1000 }, 1000],\n  ])('Sets _limit parameter to %s', (description, input, expected) => {\n    strapi.config.api.rest.maxLimit = input.maxLimit;\n    expect(createService.getFetchParams({ _limit: input._limit })).toMatchObject({\n      _limit: expected,\n    });\n  });\n});\n",
    "packages/strapi/lib/core-api/controller.js": "'use strict';\n\nconst _ = require('lodash');\nconst { parseMultipartData, sanitizeEntity } = require('strapi-utils');\n\nconst createSanitizeFn = model => data => {\n  return sanitizeEntity(data, { model: strapi.getModel(model.uid) });\n};\n\n/**\n * default bookshelf controller\n *\n */\nmodule.exports = ({ service, model }) => {\n  if (model.kind === 'singleType') {\n    return createSingleTypeController({ model, service });\n  }\n\n  return createCollectionTypeController({ model, service });\n};\n\n/**\n * Returns a single type controller to handle default core-api actions\n */\nconst createSingleTypeController = ({ model, service }) => {\n  const sanitize = createSanitizeFn(model);\n\n  return {\n    /**\n     * Retrieve single type content\n     *\n     * @return {Object|Array}\n     */\n    async find(ctx) {\n      const { query } = ctx;\n      const entity = await service.find(query);\n      return sanitize(entity);\n    },\n\n    /**\n     * create or update single type content.\n     *\n     * @return {Object}\n     */\n    async update(ctx) {\n      let entity;\n      if (ctx.is('multipart')) {\n        const { data, files } = parseMultipartData(ctx);\n        entity = await service.createOrUpdate(data, { files });\n      } else {\n        entity = await service.createOrUpdate(ctx.request.body);\n      }\n\n      return sanitize(entity);\n    },\n\n    async delete() {\n      const entity = await service.delete();\n      return sanitize(entity);\n    },\n  };\n};\n\n/**\n *\n * Returns a collection type controller to handle default core-api actions\n */\nconst createCollectionTypeController = ({ model, service }) => {\n  const sanitize = createSanitizeFn(model);\n\n  return {\n    /**\n     * Retrieve records.\n     *\n     * @return {Object|Array}\n     */\n    async find(ctx) {\n      let entities;\n      if (_.has(ctx.query, '_q')) {\n        entities = await service.search(ctx.query);\n      } else {\n        entities = await service.find(ctx.query);\n      }\n\n      return sanitize(entities);\n    },\n\n    /**\n     * Retrieve a record.\n     *\n     * @return {Object}\n     */\n    async findOne(ctx) {\n      const { query, params } = ctx;\n      const entity = await service.findOne({ ...query, id: params.id });\n\n      return sanitize(entity);\n    },\n\n    /**\n     * Count records.\n     *\n     * @return {Number}\n     */\n    count(ctx) {\n      if (_.has(ctx.query, '_q')) {\n        return service.countSearch(ctx.query);\n      }\n      return service.count(ctx.query);\n    },\n\n    /**\n     * Create a record.\n     *\n     * @return {Object}\n     */\n    async create(ctx) {\n      let entity;\n      if (ctx.is('multipart')) {\n        const { data, files } = parseMultipartData(ctx);\n        entity = await service.create(data, { files });\n      } else {\n        entity = await service.create(ctx.request.body);\n      }\n\n      return sanitize(entity);\n    },\n\n    /**\n     * Update a record.\n     *\n     * @return {Object}\n     */\n    async update(ctx) {\n      let entity;\n      if (ctx.is('multipart')) {\n        const { data, files } = parseMultipartData(ctx);\n        entity = await service.update({ id: ctx.params.id }, data, { files });\n      } else {\n        entity = await service.update({ id: ctx.params.id }, ctx.request.body);\n      }\n\n      return sanitize(entity);\n    },\n\n    /**\n     * Destroy a record.\n     *\n     * @return {Object}\n     */\n    async delete(ctx) {\n      const entity = await service.delete({ id: ctx.params.id });\n      return sanitize(entity);\n    },\n  };\n};\n",
    "packages/strapi/lib/core-api/service.js": "'use strict';\n\nconst _ = require('lodash');\nconst utils = require('strapi-utils');\nconst {\n  contentTypes: {\n    hasDraftAndPublish,\n    constants: { PUBLISHED_AT_ATTRIBUTE, DP_PUB_STATE_LIVE },\n  },\n} = require('strapi-utils');\n\n/**\n * Default limit values from config\n * @return {{maxLimit: number, defaultLimit: number}}\n */\nconst getLimitConfigDefaults = () => ({\n  defaultLimit: _.toNumber(strapi.config.get('api.rest.defaultLimit', 100)),\n  maxLimit: _.toNumber(strapi.config.get('api.rest.maxLimit')) || null,\n});\n\nconst getLimitParam = params => {\n  const { defaultLimit, maxLimit } = getLimitConfigDefaults();\n  if (params._limit === undefined) {\n    return defaultLimit;\n  }\n\n  const limit = _.toNumber(params._limit);\n  // if there is max limit set and params._limit exceeds this number, return configured max limit\n  if (maxLimit && (limit === -1 || limit > maxLimit)) {\n    return maxLimit;\n  }\n\n  return limit;\n};\n\nconst getFetchParams = (params = {}) => {\n  const defaultParams = {};\n\n  Object.assign(defaultParams, {\n    _publicationState: DP_PUB_STATE_LIVE,\n  });\n\n  return {\n    ...defaultParams,\n    ...params,\n    _limit: getLimitParam(params),\n  };\n};\n\n/**\n * default service\n *\n */\nconst createCoreService = ({ model, strapi }) => {\n  const serviceFactory =\n    model.kind === 'singleType' ? createSingleTypeService : createCollectionTypeService;\n\n  return serviceFactory({ model, strapi });\n};\n\n/**\n * Mixins\n */\nconst createUtils = ({ model }) => {\n  const { getNonWritableAttributes } = utils.contentTypes;\n\n  return {\n    sanitizeInput: data => _.omit(data, getNonWritableAttributes(model)),\n  };\n};\n\n/**\n * Returns a single type service to handle default core-api actions\n */\nconst createSingleTypeService = ({ model, strapi }) => {\n  const { modelName } = model;\n  const { sanitizeInput } = createUtils({ model });\n\n  return {\n    /**\n     * Returns single type content\n     *\n     * @return {Promise}\n     */\n    find(params, populate) {\n      return strapi.entityService.find(\n        { params: getFetchParams(params), populate },\n        { model: modelName }\n      );\n    },\n\n    /**\n     * Creates or update the single- type content\n     *\n     * @return {Promise}\n     */\n    async createOrUpdate(data, { files } = {}) {\n      const entity = await this.find();\n      const sanitizedData = sanitizeInput(data);\n\n      if (!entity) {\n        return strapi.entityService.create({ data: sanitizedData, files }, { model: modelName });\n      } else {\n        return strapi.entityService.update(\n          {\n            params: {\n              id: entity.id,\n            },\n            data: sanitizedData,\n            files,\n          },\n          { model: modelName }\n        );\n      }\n    },\n\n    /**\n     * Deletes the single type content\n     *\n     * @return {Promise}\n     */\n    async delete() {\n      const entity = await this.find();\n\n      if (!entity) return;\n\n      return strapi.entityService.delete({ params: { id: entity.id } }, { model: modelName });\n    },\n  };\n};\n\n/**\n *\n * Returns a collection type service to handle default core-api actions\n */\nconst createCollectionTypeService = ({ model, strapi }) => {\n  const { modelName } = model;\n  const { sanitizeInput } = createUtils({ model });\n\n  return {\n    /**\n     * Promise to fetch all records\n     *\n     * @return {Promise}\n     */\n    find(params, populate) {\n      return strapi.entityService.find(\n        { params: getFetchParams(params), populate },\n        { model: modelName }\n      );\n    },\n\n    /**\n     * Promise to fetch record\n     *\n     * @return {Promise}\n     */\n\n    findOne(params, populate) {\n      return strapi.entityService.findOne(\n        { params: getFetchParams(params), populate },\n        { model: modelName }\n      );\n    },\n\n    /**\n     * Promise to count record\n     *\n     * @return {Promise}\n     */\n\n    count(params) {\n      return strapi.entityService.count({ params: getFetchParams(params) }, { model: modelName });\n    },\n\n    /**\n     * Promise to add record\n     *\n     * @return {Promise}\n     */\n\n    create(data, { files } = {}) {\n      const sanitizedData = sanitizeInput(data);\n      if (hasDraftAndPublish(model)) {\n        sanitizedData[PUBLISHED_AT_ATTRIBUTE] = _.get(\n          sanitizedData,\n          PUBLISHED_AT_ATTRIBUTE,\n          new Date()\n        );\n      }\n      return strapi.entityService.create({ data: sanitizedData, files }, { model: modelName });\n    },\n\n    /**\n     * Promise to edit record\n     *\n     * @return {Promise}\n     */\n\n    update(params, data, { files } = {}) {\n      const sanitizedData = sanitizeInput(data);\n      return strapi.entityService.update(\n        { params, data: sanitizedData, files },\n        { model: modelName }\n      );\n    },\n\n    /**\n     * Promise to delete a record\n     *\n     * @return {Promise}\n     */\n\n    delete(params) {\n      return strapi.entityService.delete({ params }, { model: modelName });\n    },\n\n    /**\n     * Promise to search records\n     *\n     * @return {Promise}\n     */\n\n    search(params) {\n      return strapi.entityService.search({ params }, { model: modelName });\n    },\n\n    /**\n     * Promise to count searched records\n     *\n     * @return {Promise}\n     */\n    countSearch(params) {\n      return strapi.entityService.countSearch(\n        { params: getFetchParams(params) },\n        { model: modelName }\n      );\n    },\n  };\n};\n\nmodule.exports = createCoreService;\n\nmodule.exports.getFetchParams = getFetchParams;\n",
    "packages/strapi/lib/load/load-files.js": "'use strict';\n\nconst path = require('path');\nconst _ = require('lodash');\nconst fse = require('fs-extra');\nconst glob = require('./glob');\nconst filePathToPath = require('./filepath-to-prop-path');\n\n/**\n * Returns an Object build from a list of files matching a glob pattern in a directory\n * It builds a tree structure resembling the folder structure in dir\n * @param {string} dir - Directory to load\n * @param {string} pattern - Glob pattern to search for\n * @param {Object} options - Options\n * @param {Function} options.requireFn - Function that will require the matches files\n * @param {Function} options.shouldUseFileNameAsKey - Weather to use the filename as a key in the Object path or not\n * @param {Object} options.globArgs - extra glob function arguments\n */\nconst loadFiles = async (\n  dir,\n  pattern,\n  { requireFn = require, shouldUseFileNameAsKey = () => true, globArgs = {} } = {}\n) => {\n  const root = {};\n  const files = await glob(pattern, { cwd: dir, ...globArgs });\n\n  for (let file of files) {\n    const absolutePath = path.resolve(dir, file);\n\n    // load module\n    delete require.cache[absolutePath];\n    let mod;\n\n    if (path.extname(absolutePath) === '.json') {\n      mod = await fse.readJson(absolutePath);\n    } else {\n      mod = requireFn(absolutePath);\n    }\n\n    Object.defineProperty(mod, '__filename__', {\n      enumerable: true,\n      configurable: false,\n      writable: false,\n      value: path.basename(file),\n    });\n\n    const propPath = filePathToPath(file, shouldUseFileNameAsKey(file));\n\n    if (propPath.length === 0) _.merge(root, mod);\n    _.merge(root, _.setWith({}, propPath, mod, Object));\n  }\n\n  return root;\n};\n\nmodule.exports = loadFiles;\n",
    "packages/strapi/lib/middlewares/boom/index.js": "'use strict';\n\n/**\n * Boom hook\n */\n\n// Public node modules.\nconst _ = require('lodash');\nconst Boom = require('boom');\nconst delegate = require('delegates');\n\nconst boomMethods = [\n  'badRequest',\n  'unauthorized',\n  'paymentRequired',\n  'forbidden',\n  'notFound',\n  'methodNotAllowed',\n  'notAcceptable',\n  'proxyAuthRequired',\n  'clientTimeout',\n  'conflict',\n  'resourceGone',\n  'lengthRequired',\n  'preconditionFailed',\n  'entityTooLarge',\n  'uriTooLong',\n  'unsupportedMediaType',\n  'rangeNotSatisfiable',\n  'expectationFailed',\n  'teapot',\n  'badData',\n  'locked',\n  'failedDependency',\n  'preconditionRequired',\n  'tooManyRequests',\n  'illegal',\n  'badImplementation',\n  'notImplemented',\n  'badGateway',\n  'serverUnavailable',\n  'gatewayTimeout',\n];\n\nconst formatBoomPayload = boomError => {\n  if (!Boom.isBoom(boomError)) {\n    boomError = Boom.boomify(boomError, {\n      statusCode: boomError.status || 500,\n    });\n  }\n\n  const { output } = boomError;\n\n  if (output.statusCode < 500 && !_.isNil(boomError.data)) {\n    output.payload.data = boomError.data;\n  }\n\n  return { status: output.statusCode, body: output.payload };\n};\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    initialize() {\n      this.delegator = delegate(strapi.app.context, 'response');\n      this.createResponses();\n\n      strapi.errors = Boom;\n      strapi.app.use(async (ctx, next) => {\n        try {\n          // App logic.\n          await next();\n        } catch (error) {\n          // emit error if configured\n          if (strapi.config.get('server.emitErrors', false)) {\n            strapi.app.emit('error', error, ctx);\n          }\n\n          // Log error.\n\n          const { status, body } = formatBoomPayload(error);\n\n          if (status >= 500) {\n            strapi.log.error(error);\n          }\n\n          ctx.body = body;\n          ctx.status = status;\n        }\n      });\n\n      strapi.app.use(async (ctx, next) => {\n        await next();\n        // Empty body is considered as `notFound` response.\n        if (_.isNil(ctx.body) && _.isNil(ctx.status)) {\n          ctx.notFound();\n        }\n      });\n    },\n\n    // Custom function to avoid ctx.body repeat\n    createResponses() {\n      boomMethods.forEach(method => {\n        strapi.app.response[method] = function(msg, ...rest) {\n          const boomError = Boom[method](msg, ...rest) || {};\n\n          const { status, body } = formatBoomPayload(boomError);\n\n          // keep retro-compatibility for old error formats\n          body.message = msg || body.data || body.message;\n\n          this.body = body;\n          this.status = status;\n        };\n\n        this.delegator.method(method);\n      });\n\n      strapi.app.response.send = function(data, status = 200) {\n        this.status = status;\n        this.body = data;\n      };\n\n      strapi.app.response.created = function(data) {\n        this.status = 201;\n        this.body = data;\n      };\n\n      strapi.app.response.deleted = function(data) {\n        if (_.isNil(data)) {\n          this.status = 204;\n        } else {\n          this.status = 200;\n          this.body = data;\n        }\n      };\n\n      this.delegator\n        .method('send')\n        .method('created')\n        .method('deleted');\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/cors/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\nconst cors = require('@koa/cors');\n\nconst defaults = {\n  origin: '*',\n  maxAge: 31536000,\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS'],\n  headers: ['Content-Type', 'Authorization', 'Origin', 'Accept'],\n  keepHeadersOnError: false,\n};\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n    initialize() {\n      const {\n        origin,\n        expose,\n        maxAge,\n        credentials,\n        methods,\n        headers,\n        keepHeadersOnError,\n      } = Object.assign({}, defaults, strapi.config.get('middleware.settings.cors'));\n\n      strapi.app.use(\n        cors({\n          origin: async function(ctx) {\n            let originList;\n\n            if (typeof origin === 'function') {\n              originList = await origin(ctx);\n            } else {\n              originList = origin;\n            }\n\n            const whitelist = Array.isArray(originList) ? originList : originList.split(/\\s*,\\s*/);\n\n            const requestOrigin = ctx.accept.headers.origin;\n            if (whitelist.includes('*')) {\n              return '*';\n            }\n\n            if (!whitelist.includes(requestOrigin)) {\n              return ctx.throw(`${requestOrigin} is not a valid origin`);\n            }\n            return requestOrigin;\n          },\n          exposeHeaders: expose,\n          maxAge,\n          credentials,\n          allowMethods: methods,\n          allowHeaders: headers,\n          keepHeadersOnError,\n        })\n      );\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/csp/index.js": "'use strict';\n\nconst convert = require('koa-convert');\nconst { csp } = require('koa-lusca');\n/**\n * CSP hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        if (ctx.request.admin) return await next();\n\n        return await convert(csp(strapi.config.middleware.settings.csp))(\n          ctx,\n          next\n        );\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/hsts/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\nconst convert = require('koa-convert');\nconst { hsts } = require('koa-lusca');\n\n/**\n * HSTS hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        if (ctx.request.admin) return next();\n\n        return await convert(hsts(strapi.config.middleware.settings.hsts))(\n          ctx,\n          next\n        );\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/logger/index.js": "'use strict';\nconst chalk = require('chalk');\nconst _ = require('lodash');\n\nconst codeToColor = code => {\n  return code >= 500\n    ? chalk.red(code)\n    : code >= 400\n    ? chalk.yellow(code)\n    : code >= 300\n    ? chalk.cyan(code)\n    : code >= 200\n    ? chalk.green(code)\n    : code;\n};\n\n/**\n * Logger hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n    initialize() {\n      const { level, exposeInContext, requests } = strapi.config.middleware.settings.logger;\n\n      const logLevels = Object.keys(strapi.log.levels.values);\n\n      if (!_.includes(logLevels, level)) {\n        throw new Error(\n          \"Invalid log level set in middleware configuration. Accepted values are: '\" +\n            logLevels.join(\"', '\") +\n            \"'.\"\n        );\n      }\n\n      strapi.log.level = level;\n\n      if (exposeInContext) {\n        strapi.app.context.log = strapi.log;\n      }\n\n      const isLogLevelEnvVariableSet = _.isString(process.env.STRAPI_LOG_LEVEL);\n\n      if (isLogLevelEnvVariableSet && strapi.log.levelVal <= 20) {\n        strapi.log.debug(\n          `STRAPI_LOG_LEVEL environment variable is overridden by logger middleware. It only applies outside Strapi's middleware context.`\n        );\n      }\n\n      if (requests && strapi.log.levelVal <= 20) {\n        strapi.app.use(async (ctx, next) => {\n          const start = Date.now();\n          await next();\n          const delta = Math.ceil(Date.now() - start);\n          strapi.log.debug(`${ctx.method} ${ctx.url} (${delta} ms) ${codeToColor(ctx.status)}`);\n        });\n      }\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/p3p/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\nconst convert = require('koa-convert');\nconst { p3p } = require('koa-lusca');\n/**\n * P3P hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        if (ctx.request.admin) return next();\n\n        return await convert(p3p(strapi.config.middleware.settings.p3p))(\n          ctx,\n          next\n        );\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/parser/index.js": "'use strict';\n\nconst body = require('koa-body');\nconst qs = require('qs');\nconst { omit } = require('lodash');\n\n/**\n * Body parser hook\n */\nconst addQsParser = (app, settings) => {\n  Object.defineProperty(app.request, 'query', {\n    configurable: false,\n    enumerable: true,\n    /*\n     * Get parsed query-string.\n     */\n    get() {\n      const qstr = this.querystring;\n      const cache = (this._querycache = this._querycache || {});\n      return cache[qstr] || (cache[qstr] = qs.parse(qstr, settings));\n    },\n\n    /*\n     * Set query-string as an object.\n     */\n    set(obj) {\n      this.querystring = qs.stringify(obj);\n    },\n  });\n\n  return app;\n};\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        // disable for graphql\n        // TODO: find a better way later\n        if (ctx.url === '/graphql') {\n          return next();\n        }\n\n        try {\n          const res = await body({\n            patchKoa: true,\n            ...omit(strapi.config.middleware.settings.parser, 'queryStringParser'),\n          })(ctx, next);\n          return res;\n        } catch (e) {\n          if (e.message.includes('maxFileSize exceeded')) {\n            throw strapi.errors.entityTooLarge('FileTooBig', {\n              errors: [\n                {\n                  id: 'Upload.status.sizeLimit',\n                  message: `file is bigger than the limit size!`,\n                },\n              ],\n            });\n          }\n          throw e;\n        }\n      });\n\n      addQsParser(strapi.app, strapi.config.get('middleware.settings.parser.queryStringParser'));\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/poweredBy/index.js": "'use strict';\n\nmodule.exports = strapi => {\n  return {\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        await next();\n\n        ctx.set(\n          'X-Powered-By',\n          strapi.config.get('middleware.settings.poweredBy.value', 'Strapi <strapi.io>')\n        );\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/public/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Node.js core.\nconst fs = require('fs');\nconst path = require('path');\nconst stream = require('stream');\nconst _ = require('lodash');\nconst koaStatic = require('koa-static');\nconst utils = require('../../utils');\nconst serveStatic = require('./serve-static');\n\n/**\n * Public assets hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    async initialize() {\n      const { defaultIndex, maxAge, path: publicPath } = strapi.config.middleware.settings.public;\n      const staticDir = path.resolve(strapi.dir, publicPath || strapi.config.paths.static);\n\n      if (defaultIndex === true) {\n        const index = fs.readFileSync(path.join(__dirname, 'index.html'), 'utf8');\n\n        const serveIndexPage = async (ctx, next) => {\n          // defer rendering of strapi index page\n          await next();\n          if (ctx.body != null || ctx.status !== 404) return;\n\n          ctx.url = 'index.html';\n          const isInitialised = await utils.isInitialised(strapi);\n          const data = {\n            serverTime: new Date().toUTCString(),\n            isInitialised,\n            ..._.pick(strapi, [\n              'config.info.version',\n              'config.info.name',\n              'config.admin.url',\n              'config.server.url',\n              'config.environment',\n              'config.serveAdminPanel',\n            ]),\n          };\n          const content = _.template(index)(data);\n          const body = stream.Readable({\n            read() {\n              this.push(Buffer.from(content));\n              this.push(null);\n            },\n          });\n          // Serve static.\n          ctx.type = 'html';\n          ctx.body = body;\n        };\n\n        strapi.router.get('/', serveIndexPage);\n        strapi.router.get('/index.html', serveIndexPage);\n        strapi.router.get(\n          '/assets/images/(.*)',\n          serveStatic(path.resolve(__dirname, 'assets/images'), { maxage: maxAge, defer: true })\n        );\n      }\n\n      // serve files in public folder unless a sub router renders something else\n      strapi.router.get(\n        '/(.*)',\n        koaStatic(staticDir, {\n          maxage: maxAge,\n          defer: true,\n        })\n      );\n\n      if (!strapi.config.serveAdminPanel) return;\n\n      const buildDir = path.resolve(strapi.dir, 'build');\n      const serveAdmin = ctx => {\n        ctx.type = 'html';\n        ctx.body = fs.createReadStream(path.join(buildDir + '/index.html'));\n      };\n\n      strapi.router.get(\n        `${strapi.config.admin.path}/*`,\n        serveStatic(buildDir, { maxage: maxAge, defer: false, index: 'index.html' })\n      );\n\n      strapi.router.get(`${strapi.config.admin.path}`, serveAdmin);\n      strapi.router.get(`${strapi.config.admin.path}/*`, serveAdmin);\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/public/serve-static.js": "'use strict';\n\nconst path = require('path');\nconst koaStatic = require('koa-static');\n\n// serveStatic is not supposed to be used to serve a folder that have sub-folders\nconst serveStatic = (filesDir, koaStaticOptions = {}) => {\n  const serve = koaStatic(filesDir, koaStaticOptions);\n\n  return async (ctx, next) => {\n    const prev = ctx.path;\n    const newPath = path.basename(ctx.path);\n    ctx.path = newPath;\n    await serve(ctx, async () => {\n      ctx.path = prev;\n      await next();\n      ctx.path = newPath;\n    });\n    ctx.path = prev;\n  };\n};\n\nmodule.exports = serveStatic;\n",
    "packages/strapi/lib/middlewares/responseTime/index.js": "'use strict';\n\n/**\n * X-Response-Time hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        const start = Date.now();\n\n        await next();\n\n        const delta = Math.ceil(Date.now() - start);\n\n        ctx.set('X-Response-Time', delta + 'ms'); // eslint-disable-line prefer-template\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/responses/index.js": "'use strict';\n\nconst _ = require('lodash');\n\nmodule.exports = strapi => {\n  return {\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        await next();\n\n        const responseFn = strapi.config.get(['functions', 'responses', ctx.status]);\n        if (_.isFunction(responseFn)) {\n          await responseFn(ctx);\n        }\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/router/utils/routerChecker.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst _ = require('lodash');\n\n// Strapi utilities.\nconst { finder, policy: policyUtils } = require('strapi-utils');\n\nconst getMethod = route => _.trim(_.toLower(route.method));\nconst getEndpoint = route => _.trim(route.path);\n\nmodule.exports = strapi =>\n  function routerChecker(value, plugin) {\n    const method = getMethod(value);\n    const endpoint = getEndpoint(value);\n\n    // Define controller and action names.\n    const [controllerName, actionName] = _.trim(value.handler).split('.');\n    const controllerKey = _.toLower(controllerName);\n\n    let controller;\n\n    if (plugin) {\n      controller =\n        plugin === 'admin'\n          ? strapi.admin.controllers[controllerKey]\n          : strapi.plugins[plugin].controllers[controllerKey];\n    } else {\n      controller = strapi.controllers[controllerKey];\n    }\n\n    if (!_.isFunction(controller[actionName])) {\n      strapi.stopWithError(\n        `Error creating endpoint ${method} ${endpoint}: handler not found \"${controllerKey}.${actionName}\"`\n      );\n    }\n\n    const action = controller[actionName].bind(controller);\n\n    // Retrieve the API's name where the controller is located\n    // to access to the right validators\n    const currentApiName = finder(strapi.plugins[plugin] || strapi.api || strapi.admin, controller);\n\n    // Add the `globalPolicy`.\n    const globalPolicy = policyUtils.globalPolicy({\n      controller: controllerKey,\n      action: actionName,\n      method,\n      endpoint,\n      plugin,\n    });\n\n    // Init policies array.\n    const policies = [globalPolicy];\n\n    let policyOption = _.get(value, 'config.policies');\n\n    // Allow string instead of array of policies.\n    if (_.isString(policyOption) && !_.isEmpty(policyOption)) {\n      policyOption = [policyOption];\n    }\n\n    if (_.isArray(policyOption)) {\n      policyOption.forEach(policyName => {\n        try {\n          policies.push(policyUtils.get(policyName, plugin, currentApiName));\n        } catch (error) {\n          strapi.stopWithError(`Error creating endpoint ${method} ${endpoint}: ${error.message}`);\n        }\n      });\n    }\n\n    policies.push(async (ctx, next) => {\n      // Set body.\n      const values = await next();\n\n      if (_.isNil(ctx.body) && !_.isNil(values)) {\n        ctx.body = values;\n      }\n    });\n\n    return {\n      method,\n      endpoint,\n      policies,\n      action,\n    };\n  };\n",
    "packages/strapi/lib/middlewares/xframe/index.js": "'use strict';\n\nconst convert = require('koa-convert');\nconst { xframe } = require('koa-lusca');\n\n/**\n * CRON hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    initialize() {\n      const defaults = require('./defaults.json');\n\n      strapi.app.use(async (ctx, next) => {\n        if (ctx.request.admin) {\n          return await convert(xframe(defaults.xframe))(ctx, next);\n        }\n\n        const { enabled, value } = strapi.config.get('middleware.settings.xframe', {});\n        if (enabled) {\n          return await convert(xframe(value))(ctx, next);\n        }\n\n        await next();\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/xss/index.js": "'use strict';\n\nconst convert = require('koa-convert');\nconst { xssProtection } = require('koa-lusca');\n\nmodule.exports = strapi => {\n  return {\n    initialize() {\n      const defaults = require('./defaults.json');\n\n      strapi.app.use(async (ctx, next) => {\n        if (ctx.request.admin) {\n          return await convert(\n            xssProtection({\n              enabled: true,\n              mode: defaults.xss.mode,\n            })\n          )(ctx, next);\n        }\n\n        const xssConfig = strapi.config.get('middleware.settings.xss');\n        if (xssConfig.enabled) {\n          return await convert(xssProtection(xssConfig))(ctx, next);\n        }\n\n        await next();\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/services/__tests__/entity-service.test.js": "'use strict';\n\nconst { EventEmitter } = require('events');\nconst createEntityService = require('../entity-service');\nconst entityValidator = require('../entity-validator');\n\ndescribe('Entity service', () => {\n  global.strapi = {\n    getModel: jest.fn(() => ({})),\n    config: {\n      get() {\n        return [];\n      },\n    },\n  };\n\n  describe('Find', () => {\n    test('Returns first element for single types', async () => {\n      const data = {\n        id: 1,\n        title: 'Test',\n      };\n\n      const fakeQuery = {\n        find: jest.fn(() => Promise.resolve([data])),\n      };\n\n      const fakeDB = {\n        getModel: jest.fn(() => {\n          return { kind: 'singleType', privateAttributes: [] };\n        }),\n        query: jest.fn(() => fakeQuery),\n      };\n\n      const instance = createEntityService({\n        db: fakeDB,\n        eventHub: new EventEmitter(),\n      });\n\n      const result = await instance.find({}, { model: 'test-model' });\n\n      expect(fakeDB.getModel).toHaveBeenCalledTimes(1);\n      expect(fakeDB.getModel).toHaveBeenCalledWith('test-model');\n\n      expect(fakeDB.query).toHaveBeenCalledWith('test-model');\n      expect(fakeQuery.find).toHaveBeenCalledWith({ _limit: 1 }, undefined);\n      expect(result).toEqual(data);\n    });\n  });\n\n  describe('Create', () => {\n    test('Throws when trying to create a new single type entry if there is already one', async () => {\n      const fakeQuery = {\n        count: jest.fn(() => Promise.resolve(1)),\n      };\n\n      const fakeDB = {\n        getModel: jest.fn(() => {\n          return { kind: 'singleType', privateAttributes: [] };\n        }),\n        query: jest.fn(() => fakeQuery),\n      };\n\n      const instance = createEntityService({\n        db: fakeDB,\n        eventHub: new EventEmitter(),\n      });\n\n      await expect(instance.create({ data: {} }, { model: 'test-model' })).rejects.toThrow(\n        'Single type entry can only be created once'\n      );\n\n      expect(fakeDB.getModel).toHaveBeenCalledTimes(1);\n      expect(fakeDB.getModel).toHaveBeenCalledWith('test-model');\n\n      expect(fakeDB.query).toHaveBeenCalledWith('test-model');\n      expect(fakeQuery.count).toHaveBeenCalled();\n    });\n\n    describe('assign default values', () => {\n      let instance;\n\n      beforeAll(() => {\n        const fakeQuery = {\n          count: jest.fn(() => 0),\n          create: jest.fn(data => data),\n        };\n\n        const fakeModel = {\n          kind: 'contentType',\n          modelName: 'test-model',\n          privateAttributes: [],\n          options: {},\n          attributes: {\n            attrStringDefaultRequired: { type: 'string', default: 'default value', required: true },\n            attrStringDefault: { type: 'string', default: 'default value' },\n            attrBoolDefaultRequired: { type: 'boolean', default: true, required: true },\n            attrBoolDefault: { type: 'boolean', default: true },\n            attrIntDefaultRequired: { type: 'integer', default: 1, required: true },\n            attrIntDefault: { type: 'integer', default: 1 },\n            attrEnumDefaultRequired: {\n              type: 'enumeration',\n              enum: ['a', 'b', 'c'],\n              default: 'a',\n              required: true,\n            },\n            attrEnumDefault: {\n              type: 'enumeration',\n              enum: ['a', 'b', 'c'],\n              default: 'b',\n            },\n          },\n        };\n\n        const fakeDB = {\n          getModel: jest.fn(() => fakeModel),\n          query: jest.fn(() => fakeQuery),\n        };\n\n        instance = createEntityService({\n          db: fakeDB,\n          eventHub: new EventEmitter(),\n          entityValidator,\n        });\n      });\n\n      test('should create record with all default attributes', async () => {\n        const data = {};\n\n        await expect(instance.create({ data }, { model: 'test-model' })).resolves.toMatchObject({\n          attrStringDefaultRequired: 'default value',\n          attrStringDefault: 'default value',\n          attrBoolDefaultRequired: true,\n          attrBoolDefault: true,\n          attrIntDefaultRequired: 1,\n          attrIntDefault: 1,\n          attrEnumDefaultRequired: 'a',\n          attrEnumDefault: 'b',\n        });\n      });\n\n      test('should create record with default and required attributes', async () => {\n        const data = {\n          attrStringDefault: 'my value',\n          attrBoolDefault: false,\n          attrIntDefault: 2,\n          attrEnumDefault: 'c',\n        };\n\n        await expect(instance.create({ data }, { model: 'test-model' })).resolves.toMatchObject({\n          attrStringDefault: 'my value',\n          attrBoolDefault: false,\n          attrIntDefault: 2,\n          attrEnumDefault: 'c',\n          attrStringDefaultRequired: 'default value',\n          attrBoolDefaultRequired: true,\n          attrIntDefaultRequired: 1,\n          attrEnumDefaultRequired: 'a',\n        });\n      });\n\n      test('should create record with provided data', async () => {\n        const data = {\n          attrStringDefaultRequired: 'my value',\n          attrStringDefault: 'my value',\n          attrBoolDefaultRequired: true,\n          attrBoolDefault: true,\n          attrIntDefaultRequired: 10,\n          attrIntDefault: 10,\n          attrEnumDefaultRequired: 'c',\n          attrEnumDefault: 'a',\n        };\n\n        await expect(instance.create({ data }, { model: 'test-model' })).resolves.toMatchObject(\n          data\n        );\n      });\n    });\n  });\n});\n",
    "packages/strapi/lib/services/__tests__/entity-validator.test.js": "'use strict';\n\nconst entityValidator = require('../entity-validator');\n\ndescribe('Entity validator', () => {\n  describe('Published input', () => {\n    describe('General Errors', () => {\n      it('Throws a badRequest error on invalid input', async () => {\n        global.strapi = {\n          errors: {\n            badRequest: jest.fn(),\n          },\n        };\n\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n          },\n        };\n\n        const input = { title: 1234 };\n\n        expect.hasAssertions();\n\n        await entityValidator.validateEntityCreation(model, input).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith(\n            'ValidationError',\n            expect.any(Object)\n          );\n        });\n      });\n\n      it('Returns data on valid input', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n          },\n        };\n\n        const input = { title: 'test Title' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input);\n        expect(data).toEqual(input);\n      });\n\n      it('Returns casted data when possible', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n            number: {\n              type: 'integer',\n            },\n          },\n        };\n\n        const input = { title: 'Test', number: '123' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input);\n        expect(data).toEqual({\n          title: 'Test',\n          number: 123,\n        });\n      });\n\n      test('Throws on required not respected', async () => {\n        global.strapi = {\n          errors: {\n            badRequest: jest.fn(),\n          },\n        };\n\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n            },\n          },\n        };\n\n        expect.hasAssertions();\n\n        await entityValidator.validateEntityCreation(model, {}).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith('ValidationError', {\n            errors: { title: [expect.stringMatching('must be defined')] },\n          });\n        });\n\n        await entityValidator.validateEntityCreation(model, { title: null }).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith('ValidationError', {\n            errors: { title: [expect.stringMatching('must be defined')] },\n          });\n        });\n      });\n\n      it('Supports custom field types', async () => {\n        const model = {\n          attributes: {\n            uuid: {\n              type: 'uuid',\n            },\n          },\n        };\n\n        const input = { uuid: '2479d6d7-2497-478d-8a34-a9e8ce45f8a7' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input);\n        expect(data).toEqual({\n          uuid: '2479d6d7-2497-478d-8a34-a9e8ce45f8a7',\n        });\n      });\n    });\n\n    describe('String validator', () => {\n      test('Throws on min length not respected', async () => {\n        global.strapi = {\n          errors: {\n            badRequest: jest.fn(),\n          },\n        };\n\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              minLength: 10,\n            },\n          },\n        };\n\n        const input = { title: 'tooSmall' };\n\n        expect.hasAssertions();\n\n        await entityValidator.validateEntityCreation(model, input).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith('ValidationError', {\n            errors: { title: [expect.stringMatching('at least 10 characters')] },\n          });\n        });\n      });\n\n      test('Throws on max length not respected', async () => {\n        global.strapi = {\n          errors: {\n            badRequest: jest.fn(),\n          },\n        };\n\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              maxLength: 2,\n            },\n          },\n        };\n\n        const input = { title: 'tooLong' };\n\n        expect.hasAssertions();\n\n        await entityValidator.validateEntityCreation(model, input).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith('ValidationError', {\n            errors: { title: [expect.stringMatching('at most 2 characters')] },\n          });\n        });\n      });\n\n      test('Allows empty strings even when required', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n            },\n          },\n        };\n\n        const input = { title: '' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input);\n        expect(data).toEqual(input);\n      });\n\n      test('Assign default values', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n              default: 'New',\n            },\n            type: {\n              type: 'string',\n              default: 'test',\n            },\n            testDate: {\n              type: 'date',\n              required: true,\n              default: '2020-04-01T04:00:00.000Z',\n            },\n            testJSON: {\n              type: 'date',\n              required: true,\n              default: {\n                foo: 1,\n                bar: 2,\n              },\n            },\n          },\n        };\n\n        await expect(entityValidator.validateEntityCreation(model, {})).resolves.toMatchObject({\n          title: 'New',\n          type: 'test',\n          testDate: '2020-04-01T04:00:00.000Z',\n          testJSON: {\n            foo: 1,\n            bar: 2,\n          },\n        });\n      });\n\n      test(\"Don't assign default value if empty string\", async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n              default: 'default',\n            },\n            content: {\n              type: 'string',\n              default: 'default',\n            },\n          },\n        };\n\n        await expect(\n          entityValidator.validateEntityCreation(model, {\n            title: '',\n            content: '',\n          })\n        ).resolves.toMatchObject({\n          title: '',\n          content: '',\n        });\n      });\n    });\n  });\n\n  describe('Draft input', () => {\n    describe('General Errors', () => {\n      it('Throws a badRequest error on invalid input', async () => {\n        global.strapi = {\n          errors: {\n            badRequest: jest.fn(),\n          },\n        };\n\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n          },\n        };\n\n        const input = { title: 1234 };\n\n        expect.hasAssertions();\n\n        await entityValidator.validateEntityCreation(model, input, { isDraft: true }).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith(\n            'ValidationError',\n            expect.any(Object)\n          );\n        });\n      });\n\n      it('Returns data on valid input', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n          },\n        };\n\n        const input = { title: 'test Title' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });\n        expect(data).toEqual(input);\n      });\n\n      it('Returns casted data when possible', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n            number: {\n              type: 'integer',\n            },\n          },\n        };\n\n        const input = { title: 'Test', number: '123' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });\n        expect(data).toEqual({\n          title: 'Test',\n          number: 123,\n        });\n      });\n\n      test('Does not throws on required not respected', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n            },\n          },\n        };\n\n        expect.hasAssertions();\n\n        let data = await entityValidator.validateEntityCreation(model, {}, { isDraft: true });\n        expect(data).toEqual({});\n\n        data = await entityValidator.validateEntityCreation(\n          model,\n          { title: null },\n          { isDraft: true }\n        );\n        expect(data).toEqual({ title: null });\n      });\n\n      it('Supports custom field types', async () => {\n        const model = {\n          attributes: {\n            uuid: {\n              type: 'uuid',\n            },\n          },\n        };\n\n        const input = { uuid: '2479d6d7-2497-478d-8a34-a9e8ce45f8a7' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });\n        expect(data).toEqual({\n          uuid: '2479d6d7-2497-478d-8a34-a9e8ce45f8a7',\n        });\n      });\n    });\n\n    describe('String validator', () => {\n      test('Does not throws on min length not respected', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              minLength: 10,\n            },\n          },\n        };\n\n        const input = { title: 'tooSmall' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });\n        expect(data).toEqual(input);\n      });\n\n      test('Throws on max length not respected', async () => {\n        global.strapi = {\n          errors: {\n            badRequest: jest.fn(),\n          },\n        };\n\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              maxLength: 2,\n            },\n          },\n        };\n\n        const input = { title: 'tooLong' };\n\n        expect.hasAssertions();\n\n        await entityValidator.validateEntityCreation(model, input, { isDraft: true }).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith('ValidationError', {\n            errors: { title: [expect.stringMatching('at most 2 characters')] },\n          });\n        });\n      });\n\n      test('Allows empty strings even when required', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n          },\n        };\n\n        const input = { title: '' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });\n        expect(data).toEqual(input);\n      });\n\n      test('Assign default values', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n              default: 'New',\n            },\n            type: {\n              type: 'string',\n              default: 'test',\n            },\n            testDate: {\n              type: 'date',\n              required: true,\n              default: '2020-04-01T04:00:00.000Z',\n            },\n            testJSON: {\n              type: 'date',\n              required: true,\n              default: {\n                foo: 1,\n                bar: 2,\n              },\n            },\n          },\n        };\n\n        await expect(\n          entityValidator.validateEntityCreation(model, {}, { isDraft: true })\n        ).resolves.toMatchObject({\n          title: 'New',\n          type: 'test',\n          testDate: '2020-04-01T04:00:00.000Z',\n          testJSON: {\n            foo: 1,\n            bar: 2,\n          },\n        });\n      });\n\n      test(\"Don't assign default value if empty string\", async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n              default: 'default',\n            },\n            content: {\n              type: 'string',\n              default: 'default',\n            },\n          },\n        };\n\n        await expect(\n          entityValidator.validateEntityCreation(\n            model,\n            {\n              title: '',\n              content: '',\n            },\n            { isDraft: true }\n          )\n        ).resolves.toMatchObject({\n          title: '',\n          content: '',\n        });\n      });\n    });\n  });\n});\n",
    "packages/strapi/lib/services/core-store.js": "'use strict';\n\nconst coreStoreModel = config => ({\n  connection: config.get('database.defaultConnection'),\n  uid: 'strapi::core-store',\n  internal: true,\n  info: {\n    name: 'core_store',\n    description: '',\n  },\n  attributes: {\n    key: {\n      type: 'string',\n    },\n    value: {\n      type: 'text',\n    },\n    type: {\n      type: 'string',\n    },\n    environment: {\n      type: 'string',\n    },\n    tag: {\n      type: 'string',\n    },\n  },\n  globalId: 'StrapiConfigs',\n  collectionName: 'core_store',\n});\n\nconst createCoreStore = ({ environment: defaultEnv, db }) => {\n  return (source = {}) => {\n    async function get(params = {}) {\n      const { key, environment = defaultEnv, type = 'core', name = '', tag = '' } = Object.assign(\n        {},\n        source,\n        params\n      );\n\n      const prefix = `${type}${name ? `_${name}` : ''}`;\n\n      const where = {\n        key: `${prefix}_${key}`,\n        environment,\n        tag,\n      };\n\n      const data = await db.query('core_store').findOne(where);\n\n      if (!data) {\n        return null;\n      }\n\n      if (\n        data.type === 'object' ||\n        data.type === 'array' ||\n        data.type === 'boolean' ||\n        data.type === 'string'\n      ) {\n        try {\n          return JSON.parse(data.value);\n        } catch (err) {\n          return new Date(data.value);\n        }\n      } else if (data.type === 'number') {\n        return parseFloat(data.value);\n      } else {\n        return null;\n      }\n    }\n\n    async function set(params = {}) {\n      const { key, value, environment = defaultEnv, type, name, tag = '' } = Object.assign(\n        {},\n        source,\n        params\n      );\n\n      const prefix = `${type}${name ? `_${name}` : ''}`;\n\n      const where = {\n        key: `${prefix}_${key}`,\n        environment,\n        tag,\n      };\n\n      const data = await db.query('core_store').findOne(where);\n\n      if (data) {\n        Object.assign(data, {\n          value: JSON.stringify(value) || value.toString(),\n          type: (typeof value).toString(),\n        });\n\n        await db.query('core_store').update({ id: data.id }, data);\n      } else {\n        const data = Object.assign({}, where, {\n          value: JSON.stringify(value) || value.toString(),\n          type: (typeof value).toString(),\n          tag,\n        });\n\n        await db.query('core_store').create(data);\n      }\n    }\n\n    return {\n      get,\n      set,\n    };\n  };\n};\n\nmodule.exports = {\n  coreStoreModel,\n  createCoreStore,\n};\n",
    "packages/strapi/lib/services/entity-service.js": "'use strict';\n\nconst _ = require('lodash');\nconst {\n  sanitizeEntity,\n  webhook: webhookUtils,\n  contentTypes: contentTypesUtils,\n} = require('strapi-utils');\nconst uploadFiles = require('./utils/upload-files');\n\n// TODO: those should be strapi events used by the webhooks not the other way arround\nconst { ENTRY_CREATE, ENTRY_UPDATE, ENTRY_DELETE } = webhookUtils.webhookEvents;\n\nmodule.exports = ({ db, eventHub, entityValidator }) => ({\n  /**\n   * expose some utils so the end users can use them\n   */\n  uploadFiles,\n  /**\n   * Promise to fetch all records\n   *\n   * @return {Promise}\n   */\n  async find({ params, populate }, { model }) {\n    const { kind } = db.getModel(model);\n\n    // return first element and ignore filters\n    if (kind === 'singleType') {\n      const results = await db.query(model).find({ ...params, _limit: 1 }, populate);\n      return _.first(results) || null;\n    }\n\n    return db.query(model).find(params, populate);\n  },\n\n  findPage({ params, populate }, { model }) {\n    return db.query(model).findPage(params, populate);\n  },\n\n  findWithRelationCounts({ params, populate }, { model }) {\n    return db.query(model).findWithRelationCounts(params, populate);\n  },\n\n  /**\n   * Promise to fetch record\n   *\n   * @return {Promise}\n   */\n\n  findOne({ params, populate }, { model }) {\n    return db.query(model).findOne(params, populate);\n  },\n\n  /**\n   * Promise to count record\n   *\n   * @return {Promise}\n   */\n\n  count({ params }, { model }) {\n    return db.query(model).count(params);\n  },\n\n  /**\n   * Promise to add record\n   *\n   * @return {Promise}\n   */\n\n  async create({ data, files }, { model }) {\n    const modelDef = db.getModel(model);\n\n    if (modelDef.kind === 'singleType') {\n      // check if there is already one entry and throw\n      const count = await db.query(model).count();\n      if (count >= 1) {\n        throw new Error('Single type entry can only be created once');\n      }\n    }\n\n    const isDraft = contentTypesUtils.isDraft(data, modelDef);\n\n    const validData = await entityValidator.validateEntityCreation(modelDef, data, { isDraft });\n\n    let entry = await db.query(model).create(validData);\n\n    if (files && Object.keys(files).length > 0) {\n      await this.uploadFiles(entry, files, { model });\n      entry = await this.findOne({ params: { id: entry.id } }, { model });\n    }\n\n    eventHub.emit(ENTRY_CREATE, {\n      model: modelDef.modelName,\n      entry: sanitizeEntity(entry, { model: modelDef }),\n    });\n\n    return entry;\n  },\n\n  /**\n   * Promise to edit record\n   *\n   * @return {Promise}\n   */\n\n  async update({ params, data, files }, { model }) {\n    const modelDef = db.getModel(model);\n    const existingEntry = await db.query(model).findOne(params);\n\n    const isDraft = contentTypesUtils.isDraft(existingEntry, modelDef);\n\n    const validData = await entityValidator.validateEntityUpdate(modelDef, data, {\n      isDraft,\n    });\n\n    let entry = await db.query(model).update(params, validData);\n\n    if (files && Object.keys(files).length > 0) {\n      await this.uploadFiles(entry, files, { model });\n      entry = await this.findOne({ params: { id: entry.id } }, { model });\n    }\n\n    eventHub.emit(ENTRY_UPDATE, {\n      model: modelDef.modelName,\n      entry: sanitizeEntity(entry, { model: modelDef }),\n    });\n\n    return entry;\n  },\n\n  /**\n   * Promise to delete a record\n   *\n   * @return {Promise}\n   */\n\n  async delete({ params }, { model }) {\n    const entry = await db.query(model).delete(params);\n\n    const modelDef = db.getModel(model);\n    eventHub.emit(ENTRY_DELETE, {\n      model: modelDef.modelName,\n      entry: sanitizeEntity(entry, { model: modelDef }),\n    });\n\n    return entry;\n  },\n\n  /**\n   * Promise to search records\n   *\n   * @return {Promise}\n   */\n\n  search({ params, populate }, { model }) {\n    return db.query(model).search(params, populate);\n  },\n\n  searchWithRelationCounts({ params, populate }, { model }) {\n    return db.query(model).searchWithRelationCounts(params, populate);\n  },\n\n  searchPage({ params, populate }, { model }) {\n    return db.query(model).searchPage(params, populate);\n  },\n\n  /**\n   * Promise to count searched records\n   *\n   * @return {Promise}\n   */\n  countSearch({ params }, { model }) {\n    return db.query(model).countSearch(params);\n  },\n});\n",
    "packages/strapi/lib/services/entity-validator/index.js": "/**\n * Entity validator\n * Module that will validate input data for entity creation or edition\n */\n'use strict';\n\nconst { has, assoc, prop } = require('lodash/fp');\nconst strapiUtils = require('strapi-utils');\nconst validators = require('./validators');\n\nconst { yup, formatYupErrors } = strapiUtils;\nconst { isMediaAttribute, isScalarAttribute, getWritableAttributes } = strapiUtils.contentTypes;\n\nconst addMinMax = (attr, validator, data) => {\n  if (Number.isInteger(attr.min) && (attr.required || (Array.isArray(data) && data.length > 0))) {\n    validator = validator.min(attr.min);\n  }\n  if (Number.isInteger(attr.max)) {\n    validator = validator.max(attr.max);\n  }\n  return validator;\n};\n\nconst addRequiredValidation = createOrUpdate => (required, validator) => {\n  if (required) {\n    if (createOrUpdate === 'creation') {\n      validator = validator.notNil();\n    } else if (createOrUpdate === 'update') {\n      validator = validator.notNull();\n    }\n  } else {\n    validator = validator.nullable();\n  }\n  return validator;\n};\n\nconst addDefault = createOrUpdate => (attr, validator) => {\n  if (createOrUpdate === 'creation') {\n    if (\n      ((attr.type === 'component' && attr.repeatable) || attr.type === 'dynamiczone') &&\n      !attr.required\n    ) {\n      validator = validator.default([]);\n    } else {\n      validator = validator.default(attr.default);\n    }\n  } else {\n    validator = validator.default(undefined);\n  }\n\n  return validator;\n};\n\nconst preventCast = validator => validator.transform((val, originalVal) => originalVal);\n\nconst createComponentValidator = createOrUpdate => (attr, data, { isDraft }) => {\n  let validator;\n\n  const [model] = strapi.db.getModelsByAttribute(attr);\n  if (!model) {\n    throw new Error('Validation failed: Model not found');\n  }\n\n  if (prop('repeatable', attr) === true) {\n    validator = yup\n      .array()\n      .of(\n        yup.lazy(item => createModelValidator(createOrUpdate)(model, item, { isDraft }).notNull())\n      );\n    validator = addRequiredValidation(createOrUpdate)(true, validator);\n    validator = addMinMax(attr, validator, data);\n  } else {\n    validator = createModelValidator(createOrUpdate)(model, data, { isDraft });\n    validator = addRequiredValidation(createOrUpdate)(!isDraft && attr.required, validator);\n  }\n\n  return validator;\n};\n\nconst createDzValidator = createOrUpdate => (attr, data, { isDraft }) => {\n  let validator;\n\n  validator = yup.array().of(\n    yup.lazy(item => {\n      const model = strapi.getModel(prop('__component', item));\n      const schema = yup\n        .object()\n        .shape({\n          __component: yup\n            .string()\n            .required()\n            .oneOf(Object.keys(strapi.components)),\n        })\n        .notNull();\n\n      return model\n        ? schema.concat(createModelValidator(createOrUpdate)(model, item, { isDraft }))\n        : schema;\n    })\n  );\n  validator = addRequiredValidation(createOrUpdate)(true, validator);\n  validator = addMinMax(attr, validator, data);\n\n  return validator;\n};\n\nconst createRelationValidator = createOrUpdate => (attr, data, { isDraft }) => {\n  let validator;\n\n  if (Array.isArray(data)) {\n    validator = yup.array().of(yup.mixed());\n  } else {\n    validator = yup.mixed();\n  }\n  validator = addRequiredValidation(createOrUpdate)(!isDraft && attr.required, validator);\n\n  return validator;\n};\n\nconst createScalarAttributeValidator = createOrUpdate => (attr, { isDraft }) => {\n  let validator;\n\n  if (has(attr.type, validators)) {\n    validator = validators[attr.type](attr, { isDraft });\n  } else {\n    // No validators specified - fall back to mixed\n    validator = yup.mixed();\n  }\n\n  validator = addRequiredValidation(createOrUpdate)(!isDraft && attr.required, validator);\n\n  return validator;\n};\n\nconst createAttributeValidator = createOrUpdate => (attr, data, { isDraft }) => {\n  let validator;\n  if (isMediaAttribute(attr)) {\n    validator = yup.mixed();\n  } else if (isScalarAttribute(attr)) {\n    validator = createScalarAttributeValidator(createOrUpdate)(attr, { isDraft });\n  } else {\n    if (attr.type === 'component') {\n      validator = createComponentValidator(createOrUpdate)(attr, data, { isDraft });\n    } else if (attr.type === 'dynamiczone') {\n      validator = createDzValidator(createOrUpdate)(attr, data, { isDraft });\n    } else {\n      validator = createRelationValidator(createOrUpdate)(attr, data, { isDraft });\n    }\n\n    validator = preventCast(validator);\n  }\n\n  validator = addDefault(createOrUpdate)(attr, validator);\n\n  return validator;\n};\n\nconst createModelValidator = createOrUpdate => (model, data, { isDraft }) => {\n  const writableAttributes = model ? getWritableAttributes(model) : [];\n\n  const schema = writableAttributes.reduce((validators, attributeName) => {\n    const validator = createAttributeValidator(createOrUpdate)(\n      model.attributes[attributeName],\n      prop(attributeName, data),\n      { isDraft }\n    );\n\n    return assoc(attributeName, validator)(validators);\n  }, {});\n\n  return yup.object().shape(schema);\n};\n\nconst createValidateEntity = createOrUpdate => async (model, data, { isDraft = false } = {}) => {\n  try {\n    const validator = createModelValidator(createOrUpdate)(model, data, { isDraft }).required();\n    return await validator.validate(data, { abortEarly: false });\n  } catch (e) {\n    throw strapi.errors.badRequest('ValidationError', { errors: formatYupErrors(e) });\n  }\n};\n\nmodule.exports = {\n  validateEntityCreation: createValidateEntity('creation'),\n  validateEntityUpdate: createValidateEntity('update'),\n};\n",
    "packages/strapi/lib/services/metrics/middleware.js": "'use strict';\n\nconst createMiddleware = ({ sendEvent }) => {\n  const _state = {\n    currentDay: null,\n    counter: 0,\n  };\n\n  return async (ctx, next) => {\n    const { url, method } = ctx.request;\n\n    if (!url.includes('.') && ['GET', 'PUT', 'POST', 'DELETE'].includes(method)) {\n      const dayOfMonth = new Date().getDate();\n\n      if (dayOfMonth !== _state.currentDay) {\n        _state.currentDay = dayOfMonth;\n        _state.counter = 0;\n      }\n\n      // Send max. 1000 events per day.\n      if (_state.counter < 1000) {\n        sendEvent('didReceiveRequest', { url: ctx.request.url });\n\n        // Increase counter.\n        _state.counter++;\n      }\n    }\n\n    await next();\n  };\n};\n\nmodule.exports = createMiddleware;\n",
    "packages/strapi/lib/services/metrics/sender.js": "'use strict';\n\nconst os = require('os');\nconst _ = require('lodash');\nconst isDocker = require('is-docker');\nconst { machineIdSync } = require('node-machine-id');\nconst fetch = require('node-fetch');\nconst ciEnv = require('ci-info');\nconst ee = require('../../utils/ee');\n\nconst defaultQueryOpts = {\n  timeout: 1000,\n  headers: { 'Content-Type': 'application/json' },\n};\n\nconst ANALYTICS_URI = 'https://analytics.strapi.io';\n\n/**\n * Create a send function for event with all the necessary metadatas\n * @param {Object} strapi strapi app\n * @returns {Function} (event, payload) -> Promise{boolean}\n */\nmodule.exports = strapi => {\n  const { uuid, template } = strapi.config;\n  const deviceId = machineIdSync();\n  const isEE = strapi.EE === true && ee.isEE === true;\n\n  const anonymous_metadata = {\n    environment: strapi.config.environment,\n    os: os.type(),\n    osPlatform: os.platform(),\n    osRelease: os.release(),\n    nodeVersion: process.version,\n    docker: process.env.DOCKER || isDocker(),\n    isCI: ciEnv.isCI,\n    version: strapi.config.info.strapi,\n    strapiVersion: strapi.config.info.strapi,\n    projectType: isEE ? 'Enterprise' : 'Community',\n    template,\n  };\n\n  return async (event, payload = {}, opts = {}) => {\n    const reqParams = {\n      method: 'POST',\n      body: JSON.stringify({\n        event,\n        uuid,\n        deviceId,\n        properties: {\n          ...payload,\n          ...anonymous_metadata,\n        },\n      }),\n      ..._.merge({}, defaultQueryOpts, opts),\n    };\n\n    try {\n      const res = await fetch(`${ANALYTICS_URI}/track`, reqParams);\n      return res.ok;\n    } catch (err) {\n      return false;\n    }\n  };\n};\n",
    "packages/strapi/lib/services/utils/upload-files.js": "'use strict';\n\nconst _ = require('lodash');\n\nmodule.exports = async (entry, files, { model, source }) => {\n  const entity = strapi.getModel(model, source);\n\n  if (!_.has(strapi.plugins, 'upload')) return entry;\n\n  const uploadService = strapi.plugins.upload.services.upload;\n\n  const findModelFromUploadPath = path => {\n    if (path.length === 0) return { model, source };\n\n    let currentPath = [];\n    let tmpModel = entity;\n    let modelName = model;\n    let sourceName;\n\n    for (let i = 0; i < path.length; i++) {\n      if (!tmpModel) return {};\n      const part = path[i];\n      const attr = tmpModel.attributes[part];\n\n      currentPath.push(part);\n\n      // ignore array indexes => handled in the dynamic zone section\n      if (_.isFinite(_.toNumber(path[i]))) {\n        continue;\n      }\n\n      if (!attr) return {};\n\n      if (attr.type === 'component') {\n        modelName = attr.component;\n        tmpModel = strapi.components[attr.component];\n      } else if (attr.type === 'dynamiczone') {\n        const entryIdx = path[i + 1]; // get component index\n        const value = _.get(entry, [...currentPath, entryIdx]);\n\n        if (!value) return {};\n\n        modelName = value.__component; // get component type\n        tmpModel = strapi.components[modelName];\n      } else if (_.has(attr, 'model') || _.has(attr, 'collection')) {\n        sourceName = attr.plugin;\n        modelName = attr.model || attr.collection;\n        tmpModel = strapi.getModel(attr.model || attr.collection, source);\n      } else {\n        return {};\n      }\n    }\n\n    return { model: modelName, source: sourceName };\n  };\n\n  const doUpload = async (key, files) => {\n    const parts = key.split('.');\n    const [path, field] = [_.initial(parts), _.last(parts)];\n\n    const { model, source } = findModelFromUploadPath(path);\n\n    if (model) {\n      const id = _.get(entry, path.concat('id'));\n      return uploadService.uploadToEntity({ id, model, field }, files, source);\n    }\n  };\n\n  await Promise.all(Object.keys(files).map(key => doUpload(key, files[key])));\n};\n",
    "packages/strapi/lib/services/webhook-runner.js": "/**\n * The event hub is Strapi's event control center.\n */\n'use strict';\n\nconst debug = require('debug')('strapi');\nconst _ = require('lodash');\nconst fetch = require('node-fetch');\n\nconst WorkerQueue = require('./worker-queue');\n\nconst defaultConfiguration = {\n  defaultHeaders: {},\n};\n\nclass WebhookRunner {\n  constructor({ eventHub, logger, configuration = {} }) {\n    debug('Initialized webhook runer');\n    this.eventHub = eventHub;\n    this.logger = logger;\n    this.webhooksMap = new Map();\n    this.listeners = new Map();\n\n    if (typeof configuration !== 'object') {\n      throw new Error(\n        'Invalid configuration provided to the webhookRunner.\\nCheck your server.json -> webhooks configuration'\n      );\n    }\n\n    this.config = _.merge(defaultConfiguration, configuration);\n\n    this.queue = new WorkerQueue({ logger, concurency: 5 });\n    this.queue.subscribe(this.executeListener.bind(this));\n  }\n\n  deleteListener(event) {\n    debug(`Deleting listener for event '${event}'`);\n    if (this.listeners.has(event)) {\n      const fn = this.listeners.get(event);\n\n      this.eventHub.off(event, fn);\n      this.listeners.delete(event);\n    }\n  }\n\n  createListener(event) {\n    debug(`Creating listener for event '${event}'`);\n    if (this.listeners.has(event)) {\n      this.logger.error(\n        `The webhook runner is already listening for the event '${event}'. Did you mean to call .register() ?`\n      );\n    }\n\n    const listen = info => {\n      this.queue.enqueue({ event, info });\n    };\n\n    this.listeners.set(event, listen);\n    this.eventHub.on(event, listen);\n  }\n\n  async executeListener({ event, info }) {\n    debug(`Executing webhook for event '${event}'`);\n    const webhooks = this.webhooksMap.get(event) || [];\n    const activeWebhooks = webhooks.filter(\n      webhook => webhook.isEnabled === true\n    );\n\n    for (const webhook of activeWebhooks) {\n      await this.run(webhook, event, info).catch(error => {\n        this.logger.error('Error running webhook');\n        this.logger.error(error);\n      });\n    }\n  }\n\n  run(webhook, event, info = {}) {\n    const { url, headers } = webhook;\n\n    return fetch(url, {\n      method: 'post',\n      body: JSON.stringify({\n        event,\n        created_at: new Date(),\n        ...info,\n      }),\n      headers: {\n        ...this.config.defaultHeaders,\n        ...headers,\n        'X-Strapi-Event': event,\n        'Content-Type': 'application/json',\n      },\n      timeout: 10000,\n    })\n      .then(async res => {\n        if (res.ok) {\n          return {\n            statusCode: res.status,\n          };\n        }\n\n        return {\n          statusCode: res.status,\n          message: await res.text(),\n        };\n      })\n      .catch(err => {\n        return {\n          statusCode: 500,\n          message: err.message,\n        };\n      });\n  }\n\n  add(webhook) {\n    debug(`Registering webhook '${webhook.id}'`);\n    const { events } = webhook;\n\n    events.forEach(event => {\n      if (this.webhooksMap.has(event)) {\n        this.webhooksMap.get(event).push(webhook);\n      } else {\n        this.webhooksMap.set(event, [webhook]);\n        this.createListener(event);\n      }\n    });\n  }\n\n  update(webhook) {\n    debug(`Refreshing webhook '${webhook.id}'`);\n    this.remove(webhook);\n    this.add(webhook);\n  }\n\n  remove(webhook) {\n    debug(`Unregistering webhook '${webhook.id}'`);\n\n    this.webhooksMap.forEach((webhooks, event) => {\n      const filteredWebhooks = webhooks.filter(\n        value => value.id !== webhook.id\n      );\n\n      // Cleanup hanging listeners\n      if (filteredWebhooks.length === 0) {\n        this.webhooksMap.delete(event);\n        this.deleteListener(event);\n      } else {\n        this.webhooksMap.set(event, filteredWebhooks);\n      }\n    });\n  }\n}\n\n/**\n * Expose a factory function instead of the class\n */\nmodule.exports = function createWebhookRunner(opts) {\n  return new WebhookRunner(opts);\n};\n",
    "packages/strapi/lib/services/webhook-store.js": "/**\n * Webhook store is the implementation of webhook storage over the core_store\n */\n'use strict';\n\nconst webhookModel = config => ({\n  connection: config.get('database.defaultConnection'),\n  uid: 'strapi::webhooks',\n  internal: true,\n  globalId: 'StrapiWebhooks',\n  collectionName: 'strapi_webhooks',\n  info: {\n    name: 'Strapi webhooks',\n    description: '',\n  },\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    url: {\n      type: 'text',\n    },\n    headers: {\n      type: 'json',\n    },\n    events: {\n      type: 'json',\n    },\n    enabled: {\n      type: 'boolean',\n    },\n  },\n});\n\nconst toDBObject = data => {\n  return {\n    name: data.name,\n    url: data.url,\n    headers: data.headers,\n    events: data.events,\n    enabled: data.isEnabled,\n  };\n};\n\nconst fromDBObject = row => {\n  return {\n    id: row.id,\n    name: row.name,\n    url: row.url,\n    headers: row.headers,\n    events: row.events,\n    isEnabled: row.enabled,\n  };\n};\n\nconst createWebhookStore = ({ db }) => {\n  const webhookQueries = db.query('strapi_webhooks');\n\n  return {\n    async findWebhooks() {\n      const results = await webhookQueries.find();\n\n      return results.map(fromDBObject);\n    },\n\n    async findWebhook(id) {\n      const result = await webhookQueries.findOne({ id });\n      return result ? fromDBObject(result) : null;\n    },\n\n    createWebhook(data) {\n      return webhookQueries.create(toDBObject({ ...data, isEnabled: true })).then(fromDBObject);\n    },\n\n    async updateWebhook(id, data) {\n      const webhook = await webhookQueries.update({ id }, toDBObject(data));\n      return webhook ? fromDBObject(webhook) : null;\n    },\n\n    async deleteWebhook(id) {\n      const webhook = await webhookQueries.delete({ id });\n      return webhook ? fromDBObject(webhook) : null;\n    },\n  };\n};\n\nmodule.exports = {\n  webhookModel,\n  createWebhookStore,\n};\n",
    "packages/strapi/lib/services/worker-queue.js": "/**\n * Simple worker queue in memory\n */\n'use strict';\n\nconst debug = require('debug')('strapi');\n\nmodule.exports = class WorkerQueue {\n  constructor({ logger, concurrency = 5 } = {}) {\n    debug('Initialize worker queue');\n\n    this.logger = logger;\n    this.worker = noop;\n\n    this.concurrency = concurrency;\n    this.running = 0;\n    this.queue = [];\n  }\n\n  subscribe(worker) {\n    debug('Subscribe to worker queue');\n    this.worker = worker;\n  }\n\n  enqueue(payload) {\n    debug('Enqueue event in worker queue');\n    if (this.running < this.concurrency) {\n      this.running++;\n      this.execute(payload);\n    } else {\n      this.queue.unshift(payload);\n    }\n  }\n\n  pop() {\n    debug('Pop worker queue and execute');\n    const payload = this.queue.pop();\n\n    if (payload) {\n      this.execute(payload);\n    } else {\n      this.running--;\n    }\n  }\n\n  async execute(payload) {\n    debug('Execute worker');\n    try {\n      await this.worker(payload);\n    } catch (error) {\n      this.logger.error(error);\n    } finally {\n      this.pop();\n    }\n  }\n};\n\nfunction noop() {}\n",
    "packages/strapi/lib/utils/index.js": "'use strict';\n\n// Dependencies.\nconst { isEmpty } = require('lodash');\nconst openBrowser = require('./openBrowser');\n\nmodule.exports = {\n  /*\n   * Return false where there is no administrator, otherwise return true.\n   */\n  async isInitialised(strapi) {\n    try {\n      if (isEmpty(strapi.admin)) {\n        return true;\n      }\n\n      const numberOfAdministrators = await strapi.query('user', 'admin').find({ _limit: 1 });\n\n      return numberOfAdministrators.length > 0;\n    } catch (err) {\n      strapi.stopWithError(err);\n    }\n  },\n  openBrowser,\n};\n",
    "packages/strapi/lib/utils/openBrowser.js": "/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar execSync = require('child_process').execSync;\nvar chalk = require('chalk');\nvar spawn = require('cross-spawn');\nvar opn = require('opn');\nconst fetch = require('node-fetch');\nconst { getAbsoluteAdminUrl } = require('strapi-utils');\n\n// https://github.com/sindresorhus/opn#app\nvar OSX_CHROME = 'google chrome';\n\nconst Actions = Object.freeze({\n  NONE: 0,\n  BROWSER: 1,\n  SCRIPT: 2,\n});\n\nfunction getBrowserEnv() {\n  // Attempt to honor this environment variable.\n  // It is specific to the operating system.\n  // See https://github.com/sindresorhus/opn#app for documentation.\n  const value = process.env.BROWSER;\n  let action;\n  if (!value) {\n    // Default.\n    action = Actions.BROWSER;\n  } else if (value.toLowerCase().endsWith('.js')) {\n    action = Actions.SCRIPT;\n  } else if (value.toLowerCase() === 'none') {\n    action = Actions.NONE;\n  } else {\n    action = Actions.BROWSER;\n  }\n  return { action, value };\n}\n\nfunction executeNodeScript(scriptPath, url) {\n  const extraArgs = process.argv.slice(2);\n  const child = spawn('node', [scriptPath, ...extraArgs, url], {\n    stdio: 'inherit',\n  });\n  child.on('close', code => {\n    if (code !== 0) {\n      console.log();\n      console.log(chalk.red('The script specified as BROWSER environment variable failed.'));\n      console.log(`${chalk.cyan(scriptPath)} exited with code ${code}.`);\n      console.log();\n      return;\n    }\n  });\n  return true;\n}\n\nfunction startBrowserProcess(browser, url) {\n  // If we're on OS X, the user hasn't specifically\n  // requested a different browser, we can try opening\n  // Chrome with AppleScript. This lets us reuse an\n  // existing tab when possible instead of creating a new one.\n  const shouldTryOpenChromeWithAppleScript =\n    process.platform === 'darwin' && (typeof browser !== 'string' || browser === OSX_CHROME);\n\n  if (shouldTryOpenChromeWithAppleScript) {\n    try {\n      // Try our best to reuse existing tab\n      // on OS X Google Chrome with AppleScript\n      execSync('ps cax | grep \"Google Chrome\"');\n      execSync(`osascript resources/openChrome.applescript \"${encodeURI(url)}\"`, {\n        cwd: __dirname,\n        stdio: 'ignore',\n      });\n      return true;\n    } catch (err) {\n      strapi.log.error('Failed to open Google Chrome with AppleScript');\n    }\n  }\n\n  // Another special case: on OS X, check if BROWSER has been set to \"open\".\n  // In this case, instead of passing `open` to `opn` (which won't work),\n  // just ignore it (thus ensuring the intended behavior, i.e. opening the system browser):\n  // https://github.com/facebook/create-react-app/pull/1690#issuecomment-283518768\n  if (process.platform === 'darwin' && browser === 'open') {\n    browser = undefined;\n  }\n\n  // Fallback to opn\n  // (It will always open new tab)\n  try {\n    var options = { app: browser };\n    opn(url, options).catch(() => {}); // Prevent `unhandledRejection` error.\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nasync function pingDashboard(url, multipleTime = false) {\n  try {\n    await fetch(url, { method: 'HEAD', timeout: 300, body: null });\n    // Inform the user that we're going to open the administration panel.\n    this.log.info(' Opening the admin panel...');\n  } catch (e) {\n    if (e.code !== 'ECONNREFUSED' && e.type !== 'request-timeout') {\n      return console.error(e);\n    }\n\n    // Only display once.\n    if (!multipleTime) {\n      this.log.warn(`  The admin panel is unavailable... Impossible to open it in the browser.`);\n    }\n  }\n}\n\n/**\n * Reads the BROWSER evironment variable and decides what to do with it. Returns\n * true if it opened a browser or ran a node.js script, otherwise false.\n */\nasync function openBrowser() {\n  const url = getAbsoluteAdminUrl(strapi.config);\n\n  // Ping the dashboard to ensure it's available.\n  await pingDashboard.call(this, url);\n\n  const { action, value } = getBrowserEnv();\n  switch (action) {\n    case Actions.NONE:\n      // Special case: BROWSER=\"none\" will prevent opening completely.\n      return false;\n    case Actions.SCRIPT:\n      return executeNodeScript(value, url);\n    case Actions.BROWSER:\n      return startBrowserProcess(value, url);\n    default:\n      throw new Error('Not implemented.');\n  }\n}\n\nmodule.exports = openBrowser;\n",
    "packages/strapi/lib/utils/update-notifier/index.js": "'use strict';\n\nconst path = require('path');\nconst packageJson = require('package-json');\nconst Configstore = require('configstore');\nconst semver = require('semver');\nconst boxen = require('boxen');\nconst chalk = require('chalk');\nconst { env } = require('strapi-utils');\n\nconst pkg = require('../../../package');\n\nconst CHECK_INTERVAL = 1000 * 60 * 60 * 24 * 1; // 1 day\nconst NOTIF_INTERVAL = 1000 * 60 * 60 * 24 * 7; // 1 week\nconst boxenOptions = {\n  padding: 1,\n  margin: 1,\n  align: 'center',\n  borderColor: 'yellow',\n  borderStyle: 'round',\n};\n\nconst geUpdatetMessage = (newVersion, currentVersion) => {\n  const currentVersionLog = chalk.dim(currentVersion);\n  const newVersionLog = chalk.green(newVersion);\n  const releaseLink = chalk.bold('https://github.com/strapi/strapi/releases');\n\n  return `\nA new version of Strapi is available ${currentVersionLog}  ${newVersionLog}\nCheck out the new the releases at: ${releaseLink}\n`.trim();\n};\n\nconst createUpdateNotifier = strapi => {\n  let config = null;\n\n  try {\n    config = new Configstore(\n      pkg.name,\n      {},\n      { configPath: path.join(strapi.dir, '.strapi-updater.json') }\n    );\n  } catch {\n    // we don't have write access to the file system\n    // we silence the error\n  }\n\n  const checkUpdate = async checkInterval => {\n    const now = Date.now();\n    const lastUpdateCheck = config.get('lastUpdateCheck') || 0;\n    if (lastUpdateCheck + checkInterval > now) {\n      return;\n    }\n\n    try {\n      const res = await packageJson(pkg.name);\n      if (res.version) {\n        config.set('latest', res.version);\n        config.set('lastUpdateCheck', now);\n      }\n    } catch {\n      // silence error if offline\n    }\n  };\n\n  const display = notifInterval => {\n    const now = Date.now();\n    const latestVersion = config.get('latest');\n    const lastNotification = config.get('lastNotification') || 0;\n    if (\n      !process.stdout.isTTY ||\n      lastNotification + notifInterval > now ||\n      !semver.valid(latestVersion) ||\n      !semver.valid(pkg.version) ||\n      semver.lte(latestVersion, pkg.version)\n    ) {\n      return;\n    }\n\n    const message = boxen(geUpdatetMessage(latestVersion, pkg.version), boxenOptions);\n    config.set('lastNotification', now);\n    console.log(message);\n  };\n\n  return {\n    notify({ checkInterval = CHECK_INTERVAL, notifInterval = NOTIF_INTERVAL } = {}) {\n      if (env.bool('STRAPI_DISABLE_UPDATE_NOTIFICATION', false) || !config) {\n        return;\n      }\n      display(notifInterval);\n      checkUpdate(checkInterval); // doesn't need to await\n    },\n  };\n};\n\nmodule.exports = createUpdateNotifier;\n",
    "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompo: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithCompo = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      component: 'default.compo',\n      type: 'component',\n      required: true,\n      repeatable: true,\n    },\n  },\n  connection: 'default',\n  name: 'product-with-compo',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + compo', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompo)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: [\n        {\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-compos',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/product-with-compos',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(1);\n    expect(res.body[0]).toMatchObject(data.productsWithCompo[0]);\n    res.body.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: [\n        {\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-compos/${data.productsWithCompo[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/product-with-compos/${data.productsWithCompo[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompo[0]);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo', '0'])).toBe('compo must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: '',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: 'A very long description that exceed the min length.',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at most 10 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].name', '0'])).toBe(\n        'compo[0].name must be defined.'\n      );\n    });\n  });\n});\n",
    "packages/strapi/tests/api/basic-compo.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompo: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithCompo = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      component: 'default.compo',\n      type: 'component',\n      required: true,\n    },\n  },\n  connection: 'default',\n  name: 'product-with-compo',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + compo', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompo)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: {\n        name: 'compo name',\n        description: 'short',\n      },\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-compos',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/product-with-compos',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(1);\n    expect(res.body[0]).toMatchObject(data.productsWithCompo[0]);\n    res.body.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: {\n        name: 'compo name updated',\n        description: 'update',\n      },\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-compos/${data.productsWithCompo[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/product-with-compos/${data.productsWithCompo[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompo[0]);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.compo.0')).toBe('compo must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: '',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: 'A very long description that exceed the min length.',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at most 10 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          description: 'short',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.name', '0'])).toBe(\n        'compo.name must be defined.'\n      );\n    });\n  });\n});\n",
    "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompoAndDP: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithCompoAndDP = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      type: 'component',\n      component: 'default.compo',\n      required: true,\n      repeatable: true,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product-with-compo-and-dp',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + compo + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompoAndDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: [\n        {\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-compo-and-dps',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeISODate();\n    data.productsWithCompoAndDP.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/product-with-compo-and-dps',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(1);\n    expect(res.body[0]).toMatchObject(data.productsWithCompoAndDP[0]);\n    res.body.forEach(p => {\n      expect(p.published_at).toBeISODate();\n    });\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: [\n        {\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-compo-and-dps/${data.productsWithCompoAndDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeISODate();\n    data.productsWithCompoAndDP[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/product-with-compo-and-dps/${data.productsWithCompoAndDP[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompoAndDP[0]);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeISODate();\n    data.productsWithCompoAndDP.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo', '0'])).toBe('compo must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: '',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: 'A very long description that exceed the min length.',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at most 10 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].name', '0'])).toBe(\n        'compo[0].name must be defined.'\n      );\n    });\n  });\n});\n",
    "packages/strapi/tests/api/basic-dp-compo.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompoAndDP: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithCompoAndDP = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      type: 'component',\n      component: 'default.compo',\n      required: true,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product-with-compo-and-dp',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + compo + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompoAndDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: {\n        name: 'compo name',\n        description: 'short',\n      },\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-compo-and-dps',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeISODate();\n    data.productsWithCompoAndDP.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/product-with-compo-and-dps',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(1);\n    expect(res.body[0]).toMatchObject(data.productsWithCompoAndDP[0]);\n    res.body.forEach(p => {\n      expect(p.published_at).toBeISODate();\n    });\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: {\n        name: 'compo name updated',\n        description: 'update',\n      },\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-compo-and-dps/${data.productsWithCompoAndDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeISODate();\n    data.productsWithCompoAndDP[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/product-with-compo-and-dps/${data.productsWithCompoAndDP[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompoAndDP[0]);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeISODate();\n    data.productsWithCompoAndDP.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.compo.0')).toBe('compo must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: '',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: 'A very long description that exceed the min length.',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at most 10 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          description: 'short',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.name', '0'])).toBe(\n        'compo.name must be defined.'\n      );\n    });\n  });\n});\n",
    "packages/strapi/tests/api/basic-dp.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  products: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithDP = {\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 30,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product-with-dp',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create a product', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-dps',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeISODate();\n    data.products.push(res.body);\n  });\n\n  test('Create a product + can overwrite published_at', async () => {\n    const product = {\n      name: 'Product 2',\n      description: 'Product description',\n      published_at: '2020-08-20T10:27:55.000Z',\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-dps',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(_.omit(product, 'published_at'));\n    expect(res.body.published_at).toBeISODate();\n    expect(res.body.published_at).toBe(product.published_at);\n    data.products.push(res.body);\n  });\n\n  test('Read products', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/product-with-dps',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(2);\n    expect(res.body).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          name: 'Product 1',\n          description: 'Product description',\n        }),\n      ])\n    );\n    res.body.forEach(p => {\n      expect(p.published_at).toBeISODate();\n    });\n  });\n\n  test('Update product', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-dps/${data.products[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(_.omit(product, 'published_at'));\n    expect(res.body.id).toEqual(data.products[0].id);\n    expect(res.body.published_at).toBeISODate();\n    data.products[0] = res.body;\n  });\n\n  test('Update product + can overwrite published_at', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      published_at: '2020-08-27T09:50:50.000Z',\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-dps/${data.products[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(_.pick(data.products[0], ['name', 'description']));\n    expect(res.body.published_at).toBeISODate();\n    expect(res.body.published_at).toBe(product.published_at);\n    data.products[0] = res.body;\n  });\n\n  test('Delete product', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/product-with-dps/${data.products[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.products[0]);\n    expect(res.body.id).toEqual(data.products[0].id);\n    expect(res.body.published_at).toBeISODate();\n    data.products.shift();\n  });\n\n  describe('validators', () => {\n    test('Cannot create a product - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: '',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.description.0')).toBe(\n        'description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create a product - required', async () => {\n      const product = {\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.name.0')).toBe('name must be defined.');\n    });\n\n    test('Cannot create a product - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: \"I'm a product description that is very long. At least thirty characters.\",\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'description', '0'])).toBe(\n        'description must be at most 30 characters'\n      );\n    });\n  });\n});\n",
    "packages/strapi/tests/api/basic-dz.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nconst data = {\n  productWithDz: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithDz = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    dz: {\n      components: ['default.compo'],\n      type: 'dynamiczone',\n      required: true,\n    },\n  },\n  connection: 'default',\n  name: 'product-with-dz',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + dz', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithDz)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      dz: [\n        {\n          __component: 'default.compo',\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-dzs',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.productWithDz.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/product-with-dzs',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(1);\n    expect(res.body[0]).toMatchObject(data.productWithDz[0]);\n    res.body.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      dz: [\n        {\n          __component: 'default.compo',\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-dzs/${data.productWithDz[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productWithDz[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productWithDz[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/product-with-dzs/${data.productWithDz[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productWithDz[0]);\n    expect(res.body.id).toEqual(data.productWithDz[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productWithDz.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz', '0'])).toBe('dz must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            __component: 'default.compo',\n            name: 'compo name',\n            description: '',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].description', '0'])).toBe(\n        'dz[0].description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            __component: 'default.compo',\n            name: 'compo name',\n            description: 'A very long description that exceed the min length.',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].description', '0'])).toBe(\n        'dz[0].description must be at most 10 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            __component: 'default.compo',\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].name', '0'])).toBe(\n        'dz[0].name must be defined.'\n      );\n    });\n\n    test('Cannot create product with compo - missing __component', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            name: 'Product 1',\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].__component', '0'])).toBe(\n        'dz[0].__component is a required field'\n      );\n    });\n  });\n});\n",
    "packages/strapi/tests/api/basic.test.e2e.js": "'use strict';\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  product: [],\n};\n\nconst product = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n  },\n  connection: 'default',\n  name: 'product',\n  description: '',\n  collectionName: '',\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\ndescribe('Core API - Basic', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(product)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/products',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.product.push(res.body);\n  });\n\n  test('Read product', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/products',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(1);\n    expect(res.body).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          name: 'Product 1',\n          description: 'Product description',\n        }),\n      ])\n    );\n    res.body.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/products/${data.product[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.product[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.product[0] = res.body;\n  });\n\n  test('Delete product', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/products/${data.product[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.product[0]);\n    expect(res.body.id).toEqual(data.product[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.product.shift();\n  });\n});\n",
    "packages/strapi/tests/deepFiltering.test.e2e.js": "'use strict';\n\n// Test an API with all the possible filed types and simple filterings (no deep filtering, no relations)\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nconst data = {\n  card: [],\n  collector: [],\n};\nlet rq;\nlet strapi;\n\nconst card = {\n  name: 'card',\n  kind: 'collectionType',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst collector = {\n  name: 'collector',\n  kind: 'collectionType',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    age: {\n      type: 'integer',\n    },\n    cards: {\n      nature: 'manyWay',\n      target: 'application::card.card',\n      unique: false,\n    },\n    collector_friends: {\n      nature: 'manyWay',\n      target: '__self__',\n      unique: false,\n    },\n  },\n};\n\nconst fixtures = {\n  card: [\n    {\n      name: 'Hugo LLORIS',\n    },\n    {\n      name: 'Samuel UMTITI',\n    },\n    {\n      name: 'Lucas HERNANDEZ',\n    },\n  ],\n  collector: ({ card }) => [\n    {\n      name: 'Bernard',\n      age: 25,\n      cards: [card[0].id, card[1].id],\n    },\n    self => ({\n      name: 'Isabelle',\n      age: 55,\n      cards: [card[0].id],\n      collector_friends: [self[0].id],\n    }),\n    self => ({\n      name: 'Kenza',\n      age: 25,\n      cards: [],\n      collector_friends: [self[0].id],\n    }),\n  ],\n};\n\ndescribe('Deep Filtering API', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentTypes([card, collector])\n      .addFixtures(card.name, fixtures.card)\n      .addFixtures(collector.name, fixtures.collector)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    Object.assign(data, builder.sanitizedFixtures(strapi));\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Without search', () => {\n    describe('Filter on a manyWay relation', () => {\n      test('Should return 2 results', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'cards.name': data.card[0].name,\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(2);\n        expect(res.body[0]).toMatchObject(data.collector[0]);\n        expect(res.body[1]).toMatchObject(data.collector[1]);\n      });\n\n      test('Should return 1 result', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'cards.name': data.card[1].name,\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(1);\n        expect(res.body[0]).toMatchObject(data.collector[0]);\n      });\n    });\n\n    describe('Filter on a self manyWay relation', () => {\n      test('Should return 2 results', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'collector_friends.name': data.collector[0].name,\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(2);\n        expect(res.body).toMatchObject(data.collector.slice(1, 3));\n      });\n    });\n  });\n\n  describe('With search', () => {\n    describe('Filter on a manyWay relation', () => {\n      test('cards.name + empty search', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'cards.name': data.card[0].name,\n            _q: '',\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(2);\n        expect(res.body).toMatchObject(data.collector.slice(0, 2));\n      });\n\n      test('cards.name + _q=25', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'cards.name': data.card[0].name,\n            _q: 25,\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(1);\n        expect(res.body).toMatchObject([data.collector[0]]);\n      });\n    });\n\n    describe('Filter on a self manyWay relation', () => {\n      test('collector_friends.name + empty search', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'collector_friends.name': data.collector[0].name,\n            _q: '',\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(2);\n        expect(res.body).toMatchObject(data.collector.slice(1, 3));\n      });\n      test('collector_friends.name + search isa', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'collector_friends.name': data.collector[0].name,\n            _q: 'isa',\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(1);\n        expect(res.body).toMatchObject([data.collector[1]]);\n      });\n    });\n  });\n});\n",
    "packages/strapi/tests/endpoint.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst modelsUtils = require('../../../test/helpers/models');\n\nconst form = require('../../../test/helpers/generators');\n\nconst cleanDate = entry => {\n  delete entry.updatedAt;\n  delete entry.createdAt;\n  delete entry.created_at;\n  delete entry.updated_at;\n};\n\nconst builder = createTestBuilder();\nlet data;\nlet rq;\nlet strapi;\n\ndescribe('Create Strapi API End to End', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentTypes([form.article, form.tag, form.category, form.reference, form.product], {\n        batch: true,\n      })\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Test manyToMany relation (article - tag) with Content Manager', () => {\n    beforeAll(async () => {\n      data = {\n        articles: [],\n        tags: [],\n      };\n    });\n\n    test('Create tag1', async () => {\n      const { body } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          name: 'tag1',\n        },\n      });\n\n      data.tags.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('tag1');\n    });\n\n    test('Create tag2', async () => {\n      const { body } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          name: 'tag2',\n        },\n      });\n\n      data.tags.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('tag2');\n    });\n\n    test('Create tag3', async () => {\n      const { body } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          name: 'tag3',\n        },\n      });\n\n      data.tags.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('tag3');\n    });\n\n    test('Create article1 without relation', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'My super content 1',\n      };\n\n      const { body } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(0);\n    });\n\n    test('Create article2 with tag1', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n        tags: [data.tags[0]],\n      };\n\n      const { body } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(1);\n      expect(body.tags[0].id).toBe(data.tags[0].id);\n    });\n\n    test('Update article1 add tag2', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        tags: [data.tags[1]],\n      });\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(1);\n      expect(body.tags[0].id).toBe(data.tags[1].id);\n    });\n\n    test('Update article1 add tag1 and tag3', async () => {\n      const entry = Object.assign({}, data.articles[0]);\n      entry.tags.push(data.tags[0]);\n      entry.tags.push(data.tags[2]);\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(3);\n    });\n\n    test('Update article1 remove one tag', async () => {\n      const entry = Object.assign({}, data.articles[0]);\n      entry.tags = entry.tags.slice(1);\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(2);\n    });\n\n    test('Update article1 remove all tag', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        tags: [],\n      });\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(0);\n    });\n  });\n\n  describe('Test oneToMany - manyToOne relation (article - category) with Content Manager', () => {\n    beforeAll(() => {\n      data = {\n        articles: [],\n        categories: [],\n      };\n    });\n\n    afterAll(async () => {\n      await modelsUtils.cleanupModels(['article', 'category'], { strapi });\n    });\n\n    test('Create cat1', async () => {\n      const { body } = await rq({\n        url: '/categories',\n        method: 'POST',\n        body: {\n          name: 'cat1',\n        },\n      });\n\n      data.categories.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('cat1');\n    });\n\n    test('Create cat2', async () => {\n      const { body } = await rq({\n        url: '/categories',\n        method: 'POST',\n        body: {\n          name: 'cat2',\n        },\n      });\n\n      data.categories.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('cat2');\n    });\n\n    test('Create article1 with cat1', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'Content 1',\n        category: data.categories[0],\n      };\n\n      const { body } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.category.name).toBe(entry.category.name);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n    });\n\n    test('Update article1 with cat2', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        category: data.categories[1],\n      });\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.category.name).toBe(entry.category.name);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n    });\n\n    test('Create article2', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n      };\n\n      const { body } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n    });\n\n    test('Update article2 with cat2', async () => {\n      const entry = Object.assign({}, data.articles[1], {\n        category: data.categories[1],\n      });\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[1] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.category.name).toBe(entry.category.name);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n    });\n\n    test('Update cat1 with article1', async () => {\n      const entry = Object.assign({}, data.categories[0]);\n      entry.articles.push(data.articles[0]);\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/categories/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.categories[0] = body;\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.articles.length).toBe(1);\n      expect(body.name).toBe(entry.name);\n    });\n\n    test('Create cat3 with article1', async () => {\n      const entry = {\n        name: 'cat3',\n        articles: [data.articles[0]],\n      };\n\n      const { body } = await rq({\n        url: '/categories',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.categories.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.articles.length).toBe(1);\n      expect(body.name).toBe(entry.name);\n    });\n\n    test('Get article1 with cat3', async () => {\n      const { body } = await rq({\n        url: `/articles/${data.articles[0].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.category.id).toBe(data.categories[2].id);\n    });\n\n    test('Get article2 with cat2', async () => {\n      const { body } = await rq({\n        url: `/articles/${data.articles[1].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.category.id).toBe(data.categories[1].id);\n    });\n\n    test('Get cat1 without relations', async () => {\n      const { body } = await rq({\n        url: `/categories/${data.categories[0].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.articles.length).toBe(0);\n    });\n\n    test('Get cat2 with article2', async () => {\n      const { body } = await rq({\n        url: `/categories/${data.categories[1].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.articles.length).toBe(1);\n      expect(body.articles[0].id).toBe(data.articles[1].id);\n    });\n\n    test('Get cat3 with article1', async () => {\n      const { body } = await rq({\n        url: `/categories/${data.categories[2].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.articles.length).toBe(1);\n      expect(body.articles[0].id).toBe(data.articles[0].id);\n    });\n  });\n\n  describe('Test oneToOne relation (article - reference) with Content Manager', () => {\n    beforeAll(() => {\n      data = {\n        articles: [],\n        references: [],\n      };\n    });\n\n    afterAll(async () => {\n      await modelsUtils.cleanupModels(['article', 'reference'], { strapi });\n    });\n\n    test('Create ref1', async () => {\n      const { body } = await rq({\n        url: '/references',\n        method: 'POST',\n        body: {\n          name: 'ref1',\n        },\n      });\n\n      data.references.push(body);\n\n      expect(body.id);\n      expect(body.name).toBe('ref1');\n    });\n\n    test('Create article1', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'Content 1',\n      };\n\n      const { body } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n    });\n\n    test('Update article1 with ref1', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        reference: data.references[0].id,\n      });\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.reference.id).toBe(entry.reference);\n    });\n\n    test('Create article2 with ref1', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n        reference: data.references[0].id,\n      };\n\n      const { body } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.reference.id).toBe(entry.reference);\n    });\n  });\n\n  describe('Test oneWay relation (reference - tag) with Content Manager', () => {\n    beforeAll(() => {\n      data = {\n        tags: [],\n        references: [],\n      };\n    });\n\n    afterAll(async () => {\n      await modelsUtils.cleanupModels(['reference', 'tag'], { strapi });\n    });\n\n    test('Attach Tag to a Reference', async () => {\n      await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          name: 'tag111',\n        },\n      }).then(({ body: tagToCreate }) => {\n        data.tags.push(tagToCreate);\n\n        return rq({\n          url: '/references',\n          method: 'POST',\n          body: {\n            name: 'cat111',\n            tag: tagToCreate,\n          },\n        }).then(({ body }) => {\n          data.references.push(body);\n          expect(body.tag.id).toBe(tagToCreate.id);\n        });\n      });\n    });\n\n    test('Detach Tag to a Reference', async () => {\n      const { body: tagToCreate } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          name: 'tag111',\n        },\n      });\n\n      data.tags.push(tagToCreate);\n\n      const { body: referenceToCreate } = await rq({\n        url: '/references',\n        method: 'POST',\n        body: {\n          name: 'cat111',\n          tag: tagToCreate,\n        },\n      });\n\n      data.references.push(referenceToCreate);\n\n      expect(referenceToCreate.tag.id).toBe(tagToCreate.id);\n\n      const { body: referenceToUpdate } = await rq({\n        url: `/references/${referenceToCreate.id}`,\n        method: 'PUT',\n        body: {\n          tag: null,\n        },\n      });\n\n      expect(referenceToUpdate.tag).toBe(null);\n    });\n\n    test('Delete Tag so the relation in the Reference side should be removed', async () => {\n      const { body: tagToCreate } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          name: 'tag111',\n        },\n      });\n\n      data.tags.push(tagToCreate);\n\n      const { body: referenceToCreate } = await rq({\n        url: '/references',\n        method: 'POST',\n        body: {\n          name: 'cat111',\n          tag: tagToCreate,\n        },\n      });\n\n      data.references.push(referenceToCreate);\n\n      await rq({\n        url: `/tags/${tagToCreate.id}`,\n        method: 'DELETE',\n      });\n\n      const { body: referenceToGet } = await rq({\n        url: `/references/${referenceToCreate.id}`,\n        method: 'GET',\n      });\n\n      if (!referenceToGet.tag || Object.keys(referenceToGet.tag).length == 0) return;\n      expect(referenceToGet.tag).toBe(null);\n    });\n  });\n});\n",
    "packages/strapi/tests/filtering.test.e2e.js": "'use strict';\n\n// Test an API with all the possible filed types and simple filtering (no deep filtering, no relations)\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nconst data = { product: [] };\n\n// complete list of existing fields and tests\nconst product = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    price: {\n      type: 'float',\n    },\n    decimal_field: {\n      type: 'decimal',\n    },\n    rank: {\n      type: 'integer',\n    },\n    big_rank: {\n      type: 'biginteger',\n    },\n  },\n  connection: 'default',\n  name: 'product',\n  description: '',\n  collectionName: '',\n};\n\nconst productFixtures = [\n  {\n    name: 'Product 1',\n    description: 'Product description',\n    price: 10.99,\n    decimal_field: 42.43,\n    rank: 42,\n    big_rank: '345678912983',\n  },\n  {\n    name: 'Product 2',\n    description: 'Product description 2',\n    price: 28.31,\n    decimal_field: 91.22,\n    rank: 82,\n    big_rank: '926371623421',\n  },\n  {\n    name: 'Product 3',\n    description: 'Product description 3',\n    price: 28.31,\n    decimal_field: 12.22,\n    rank: 91,\n    big_rank: '926372323421',\n  },\n  {\n    name: 'Product 4',\n    description: 'Product description 4',\n    price: null,\n    decimal_field: 12.22,\n    rank: 99,\n    big_rank: '999999999999',\n  },\n  {\n    name: ' 5, Product 5',\n    description: '   5',\n    price: null,\n    decimal_field: 142.43,\n    rank: 142,\n    big_rank: 345678912983,\n  },\n];\n\ndescribe('Filtering API', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentType(product)\n      .addFixtures(product.name, productFixtures)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    Object.assign(data, builder.sanitizedFixtures(strapi));\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Basic filters', () => {\n    describe('Filter equals', () => {\n      test('Should be the default filter', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name: 'Product 1',\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(1);\n        expect(res.body[0]).toMatchObject(data.product[0]);\n      });\n\n      test('Should be usable with equal suffix', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_eq: 'Product 1',\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(1);\n        expect(res.body[0]).toMatchObject(data.product[0]);\n      });\n\n      test('Should return an empty array when no match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_eq: 'Product non existant',\n          },\n        });\n\n        expect(res.body).toEqual([]);\n      });\n    });\n\n    describe('Filter not equals', () => {\n      test('Should return an array with matching entities', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ne: 'Non existent product ',\n          },\n        });\n\n        expect(res.body).toEqual(\n          expect.arrayContaining(data.product.map(o => expect.objectContaining(o)))\n        );\n      });\n\n      test('Should return an empty array when no match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ne: 'Product 1',\n          },\n        });\n\n        expect(res.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });\n    });\n\n    describe('Filter null', () => {\n      test('Should return only matching items', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            price_null: true,\n          },\n        });\n\n        const matching = data.product.filter(x => x.price === null);\n        res.body.sort((a, b) => (a.id > b.id ? 1 : -1));\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(matching.length);\n        expect(res.body).toMatchObject(matching);\n        expect(res.body).toEqual(expect.arrayContaining(matching));\n      });\n\n      test('Should return three matches', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            price_null: false,\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(3);\n      });\n    });\n\n    describe('Filter contains insensitive', () => {\n      test('Should match with insensitive case', async () => {\n        const res1 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_contains: 'product',\n          },\n        });\n\n        expect(res1.body).toEqual(\n          expect.arrayContaining(data.product.map(o => expect.objectContaining(o)))\n        );\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_contains: 'PrOdUct',\n          },\n        });\n\n        expect(res1.body).toEqual(res2.body);\n      });\n\n      test('Should return an empty array on no insensitive case match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_contains: 'production',\n          },\n        });\n\n        expect(res.body).toEqual([]);\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_contains: 'ProdUctIon',\n          },\n        });\n\n        expect(res2.body).toEqual(res.body);\n      });\n    });\n\n    describe('Filter not contains insensitive', () => {\n      test('Should return an array of entities on match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ncontains: 'production',\n          },\n        });\n\n        expect(res.body).toEqual(\n          expect.arrayContaining(data.product.map(o => expect.objectContaining(o)))\n        );\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ncontains: 'ProdUctIon',\n          },\n        });\n\n        expect(res2.body).toEqual(res.body);\n      });\n\n      test('Should return an empty array when no match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ncontains: 'product',\n          },\n        });\n\n        expect(res.body).toEqual([]);\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ncontains: 'ProDuCt',\n          },\n        });\n\n        expect(res2.body).toEqual(res.body);\n      });\n    });\n\n    // FIXME: Not working on sqlite due to https://www.sqlite.org/draft/pragma.html#pragma_case_sensitive_like\n    describe('Filter contains sensitive', () => {\n      test.skip('Should return empty if the case does not match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_containss: 'product',\n          },\n        });\n\n        expect(res.body).toEqual([]);\n      });\n\n      test('Should return the entities if the case matches', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_containss: 'Product',\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n    });\n\n    // FIXME: Not working on sqlite due to https://www.sqlite.org/draft/pragma.html#pragma_case_sensitive_like\n    describe('Filter not contains sensitive', () => {\n      test.skip('Should return the entities if the case does not match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ncontainss: 'product',\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should return an empty array if the case matches', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ncontainss: 'Product',\n          },\n        });\n\n        expect(res.body).toEqual([]);\n      });\n    });\n\n    describe('Filter in', () => {\n      test('Should return the Product with a single value', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_in: 42,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should return the Product with an array of values', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_in: [42, 12],\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should return a, empty array if no values are matching', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_in: [43, 12],\n          },\n        });\n\n        expect(res.body).toEqual([]);\n      });\n    });\n\n    describe('Filter not in', () => {\n      test('Should return an array without the values matching when a single value is provided', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_nin: 42,\n          },\n        });\n\n        expect(res.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });\n\n      test('Should return an array without the values matching when an array of values is provided', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_nin: [42, 12],\n          },\n        });\n\n        expect(res.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });\n\n      test('Should return an array with values that do not match the filter', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_nin: [43, 12],\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n    });\n\n    describe('Filter greater than', () => {\n      test('Should match values only greater than', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_gt: 42,\n          },\n        });\n\n        expect(res.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_gt: 40,\n          },\n        });\n\n        expect(res2.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with integers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_gt: 40,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with float', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            price_gt: 9.3,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with decimal', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            decimal_field_gt: 1.23,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with bigintegers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            big_rank_gt: 34567891298,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n    });\n\n    describe('Filter greater than or equal', () => {\n      test('Should work correclty on equal values', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_gte: 42,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_gte: 43,\n          },\n        });\n\n        expect(res2.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with integers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_gte: 40,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with float', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            price_gte: 10.99,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with decimal', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            decimal_field_gte: 42.43,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with bigintegers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            big_rank_gte: '345678912983',\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n    });\n\n    describe('Filter less than', () => {\n      test('Should match values only less than', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_lt: 42,\n          },\n        });\n\n        expect(res.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_lt: 43,\n          },\n        });\n\n        expect(res2.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with integers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_lt: 45,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with float', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            price_lt: 21.3,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with decimal', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            decimal_field_lt: 46.23,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with bigintegers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            big_rank_lt: 3456789129812,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n    });\n\n    describe('Filter less than or equal', () => {\n      test('Should work correclty on equal values', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_lte: 52,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_lte: 21,\n          },\n        });\n\n        expect(res2.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with integers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_lte: 42,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with float', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            price_lte: 10.99,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with decimal', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            decimal_field_lte: 42.43,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with bigintegers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            big_rank_lte: '345678912983',\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n    });\n  });\n\n  describe('Or filtering', () => {\n    describe('_or filter', () => {\n      test('Supports simple or', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            _where: {\n              _or: [\n                {\n                  rank: 42,\n                },\n                {\n                  rank: 82,\n                },\n              ],\n            },\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0], data.product[1]]));\n      });\n\n      test('Supports simple or on different fields', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            _where: {\n              _or: [\n                {\n                  rank: 42,\n                },\n                {\n                  price_gt: 28,\n                },\n              ],\n            },\n          },\n        });\n\n        expect(res.body).toEqual(\n          expect.arrayContaining([data.product[0], data.product[1], data.product[2]])\n        );\n      });\n\n      test('Supports or with nested and', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            _where: {\n              _or: [\n                {\n                  rank: 42,\n                },\n                [\n                  {\n                    price_gt: 28,\n                  },\n                  {\n                    rank: 91,\n                  },\n                ],\n              ],\n            },\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0], data.product[2]]));\n      });\n\n      test('Supports or with nested or', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            _where: {\n              _or: [\n                {\n                  rank: 42,\n                },\n                [\n                  {\n                    price_gt: 28,\n                  },\n                  {\n                    _or: [\n                      {\n                        rank: 91,\n                      },\n                    ],\n                  },\n                ],\n              ],\n            },\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0], data.product[2]]));\n      });\n    });\n\n    test('Filter equals', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank: [42, 43],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter not equals', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_ne: [41, 43],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter contains insensitive', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_contains: ['Product', '1'],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter not contains insensitive', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_ncontains: ['Product', 'Non existent'],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter contains sensitive', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_containss: ['Product', 'Non existent'],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter not contains sensitive', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_ncontainss: ['product', 'Non existent'],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter greater than', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_gt: [12, 56],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter greater than or equal', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_gte: [42, 56],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter less than', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_lt: [56, 12],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter less than or equal', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_lte: [12, 42],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n  });\n\n  describe('Complexe filtering', () => {\n    test('Greater than and less than at the same time', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_lte: 42,\n          rank_gte: 42,\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n\n      res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_lt: 43,\n          rank_gt: 41,\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n\n      res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_lt: 43,\n          rank_gt: 431,\n        },\n      });\n\n      expect(res.body).toEqual([]);\n    });\n\n    test('Contains and Not contains on same column', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_contains: 'Product',\n          name_ncontains: '1',\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining(data.product.slice(1)));\n\n      res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_contains: 'Product 1',\n          name_ncontains: ['2', '3'],\n        },\n      });\n\n      expect(res.body).toEqual(expect.not.arrayContaining([data.product[1], data.product[2]]));\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n\n      res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_contains: '2',\n          name_ncontains: 'Product',\n        },\n      });\n\n      expect(res.body).toEqual([]);\n    });\n\n    test('Combined filters', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_contains: 'Product',\n          rank_lt: 45,\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n  });\n\n  describe('Sorting', () => {\n    test('Default sorting is asc', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _sort: 'rank',\n        },\n      });\n\n      expect(res.body).toEqual(\n        expect.arrayContaining(data.product.slice(0).sort((a, b) => a.rank - b.rank))\n      );\n    });\n\n    test('Simple sorting', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _sort: 'rank:asc',\n        },\n      });\n\n      expect(res.body).toEqual(\n        expect.arrayContaining(data.product.slice(0).sort((a, b) => a.rank - b.rank))\n      );\n\n      const res2 = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _sort: 'rank:desc',\n        },\n      });\n\n      expect(res2.body).toEqual(\n        expect.arrayContaining(data.product.slice(0).sort((a, b) => b.rank - a.rank))\n      );\n    });\n\n    test('Multi column sorting', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _sort: 'price:asc,rank:desc',\n        },\n      });\n\n      [data.product[3], data.product[0], data.product[2], data.product[1]].forEach(expectedPost => {\n        expect(res.body).toEqual(expect.arrayContaining([expectedPost]));\n      });\n    });\n  });\n\n  describe('Limit and offset', () => {\n    test('Limit', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _limit: 1,\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Limit with sorting', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _limit: 1,\n          _sort: 'rank:desc',\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[data.product.length - 1]]));\n    });\n\n    test('Offset', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _start: 1,\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining(data.product.slice(1)));\n    });\n\n    test('Offset with limit', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _limit: 1,\n          _start: 1,\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining(data.product.slice(1, 2)));\n    });\n  });\n\n  describe('Text query', () => {\n    test('Cyrillic query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _q: '',\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[4]]));\n    });\n\n    test('Multi word query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _q: 'Product description',\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Multi word cyrillic query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _q: '  ',\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[4]]));\n    });\n  });\n});\n",
    "packages/strapi/tests/publication-state.test.e2e.js": "'use strict';\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst fixtures = {\n  product: [\n    {\n      name: 'Bamboo Desk',\n      categories: ['Home'],\n      comp: { countries: ['France'] },\n      published_at: null,\n    },\n    {\n      name: 'Computer',\n      categories: ['Home', 'Tech'],\n      comp: { countries: ['France', 'Italy', 'Spain'] },\n      published_at: new Date(),\n    },\n    {\n      name: 'Burger Drone',\n      categories: ['Tech', 'Food'],\n      comp: { countries: ['Italy', 'Spain'] },\n      published_at: new Date(),\n    },\n  ],\n  category: [\n    { name: 'Home', published_at: null },\n    { name: 'Food', published_at: new Date() },\n    { name: 'Tech', published_at: new Date() },\n  ],\n  country: [\n    { name: 'France', published_at: new Date() },\n    { name: 'Italy', published_at: null },\n    { name: 'Spain', published_at: new Date() },\n  ],\n};\n\nconst data = { product: [], category: [], country: [] };\n\nconst pluralizedModels = {\n  product: 'products',\n  country: 'countries',\n  category: 'categories',\n};\n\nconst contentTypes = {\n  product: {\n    attributes: {\n      name: {\n        type: 'string',\n      },\n      categories: {\n        nature: 'manyWay',\n        target: 'application::category.category',\n        unique: false,\n      },\n      comp: {\n        component: 'default.comp',\n        type: 'component',\n        required: true,\n      },\n    },\n    draftAndPublish: true,\n    connection: 'default',\n    name: 'product',\n    description: '',\n    collectionName: '',\n  },\n  country: {\n    attributes: {\n      name: {\n        type: 'string',\n      },\n    },\n    draftAndPublish: true,\n    connection: 'default',\n    name: 'country',\n    description: '',\n    collectionName: '',\n  },\n  category: {\n    attributes: {\n      name: {\n        type: 'string',\n      },\n    },\n    draftAndPublish: true,\n    connection: 'default',\n    name: 'category',\n    description: '',\n    collectionName: '',\n  },\n};\n\nconst components = {\n  comp: {\n    name: 'comp',\n    attributes: {\n      countries: {\n        nature: 'manyWay',\n        target: 'application::country.country',\n      },\n    },\n  },\n};\n\nconst filterBy = (name, { mode = 'live' } = {}) => {\n  return fixtures[name].filter(item => {\n    if (['live', 'default'].includes(mode)) {\n      return item.published_at instanceof Date;\n    }\n    return true;\n  });\n};\n\nconst lengthFor = (name, { mode = 'live' } = {}) => {\n  return filterBy(name, { mode }).length;\n};\n\nconst getQueryFromMode = mode => {\n  if (['live', 'preview'].includes(mode)) {\n    return `?_publicationState=${mode}`;\n  }\n\n  return '';\n};\n\ndescribe('Publication State', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentType(contentTypes.country)\n      .addComponent(components.comp)\n      .addContentTypes([contentTypes.category, contentTypes.product])\n      .addFixtures(contentTypes.country.name, fixtures.country)\n      .addFixtures(contentTypes.category.name, fixtures.category)\n      .addFixtures(contentTypes.product.name, f =>\n        fixtures.product.map(product => ({\n          name: product.name,\n          categories: product.categories.map(name => f.category.find(cat => cat.name === name).id),\n          comp: {\n            countries: product.comp.countries.map(\n              name => f.country.find(country => country.name === name).id\n            ),\n          },\n          published_at: product.published_at,\n        }))\n      )\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    Object.assign(data, builder.sanitizedFixtures(strapi));\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe.each(['default', 'live', 'preview'])('Mode: \"%s\"', mode => {\n    describe.each(['country', 'category', 'product'])('For %s', modelName => {\n      const baseUrl = `/${pluralizedModels[modelName]}`;\n      const query = getQueryFromMode(mode);\n\n      test('Can get entries', async () => {\n        const res = await rq({ method: 'GET', url: `${baseUrl}${query}` });\n\n        expect(res.body).toHaveLength(lengthFor(modelName, { mode }));\n      });\n\n      test('Can count entries', async () => {\n        const res = await rq({ method: 'GET', url: `${baseUrl}/count${query}` });\n\n        expect(res.body).toBe(lengthFor(modelName, { mode }));\n      });\n    });\n  });\n\n  describe('Advanced checks', () => {\n    describe('Nested level of relations (live mode)', () => {\n      let products;\n      const pluralizedModelName = pluralizedModels[contentTypes.product.name];\n\n      beforeEach(async () => {\n        const res = await rq({\n          method: 'GET',\n          url: `/${pluralizedModelName}?_publicationState=live`,\n        });\n        products = res.body;\n      });\n\n      const getApiRef = id => data.product.find(product => product.id === id);\n\n      test('Payload integrity', () => {\n        expect(products).toHaveLength(lengthFor(contentTypes.product.name));\n      });\n\n      test('Root level', () => {\n        products.forEach(product => {\n          expect(product.published_at).toBeISODate();\n        });\n      });\n\n      test('First level (categories)', () => {\n        products.forEach(({ id, categories }) => {\n          const length = getApiRef(id).categories.filter(c => c.published_at !== null).length;\n          expect(categories).toHaveLength(length);\n\n          categories.forEach(category => {\n            expect(category.published_at).toBeISODate();\n          });\n        });\n      });\n\n      test('Second level through component (countries)', () => {\n        products.forEach(({ id, comp: { countries } }) => {\n          const length = getApiRef(id).comp.countries.filter(c => c.published_at !== null).length;\n          expect(countries).toHaveLength(length);\n\n          countries.forEach(country => {\n            expect(country.published_at).toBeISODate();\n          });\n        });\n      });\n    });\n  });\n});\n",
    "packages/strapi/tests/search.test.e2e.js": "'use strict';\n\n// Test an API with all the possible filed types and simple filtering (no deep filtering, no relations)\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet rq;\nlet strapi;\nlet data = {\n  bed: [],\n};\n\nconst bedModel = {\n  name: 'bed',\n  kind: 'collectionType',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    weight: {\n      type: 'decimal',\n    },\n    shortDescription: {\n      type: 'text',\n    },\n    description: {\n      type: 'richtext',\n    },\n    sku: {\n      type: 'uid',\n    },\n    savEmail: {\n      type: 'email',\n    },\n    type: {\n      enum: ['spring', 'foam', 'feather'],\n      type: 'enumeration',\n    },\n    serialNumber: {\n      type: 'biginteger',\n    },\n    peopleNumber: {\n      type: 'integer',\n    },\n    fabricThickness: {\n      type: 'float',\n    },\n  },\n};\n\nconst bedFixtures = [\n  {\n    // will have id=1\n    name: 'Sleepy Bed',\n    weight: 12.4,\n    shortDescription: 'Is a good bed to sleep in.',\n    description: '**Is a very good bed to sleep in.** We promise.',\n    sku: 'sleepybed_0152',\n    savEmail: 'sav@bed.fr',\n    type: 'foam',\n    serialNumber: 999999999999999,\n    peopleNumber: 6,\n    fabricThickness: 1.14157,\n  },\n  {\n    // will have id=2\n    name: 'Tired Bed',\n    weight: 11.1,\n    shortDescription: 'You will never wake up again.',\n    description: '**You will never wake up again.** Never.',\n    sku: 'tiredbed_0001',\n    savEmail: 'sav@sleep.fr',\n    type: 'feather',\n    serialNumber: 1111111111111111,\n    peopleNumber: 1,\n    fabricThickness: 1.0001,\n  },\n  {\n    // will have id=3\n    // other beds don't contain any 3 in order to find only Zombie Bed when searching 3\n    name: 'Zombie Bed',\n    weight: null,\n    shortDescription: null,\n    description: null,\n    sku: null,\n    savEmail: null,\n    type: null,\n    serialNumber: null,\n    peopleNumber: null,\n    fabricThickness: null,\n  },\n  {\n    // will have id=4\n    name: 'a*b_c%d\\\\e+f',\n    weight: null,\n    shortDescription: null,\n    description: null,\n    sku: null,\n    savEmail: null,\n    type: null,\n    serialNumber: null,\n    peopleNumber: null,\n    fabricThickness: null,\n  },\n  {\n    // will have id=5\n    name: 'Tired Bed',\n    weight: null,\n    shortDescription: null,\n    description: null,\n    sku: null,\n    savEmail: null,\n    type: null,\n    serialNumber: null,\n    peopleNumber: 7,\n    fabricThickness: null,\n  },\n];\n\ndescribe('Search query', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentType(bedModel)\n      .addFixtures(bedModel.name, bedFixtures)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    data.bed = builder.sanitizedFixturesFor(bedModel.name, strapi);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Without filters', () => {\n    test('search for \"id\"', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: data.bed[2].id,\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(1);\n      expect(res.body[0]).toMatchObject(data.bed[2]);\n    });\n\n    test.each(Object.keys(bedFixtures[0]))('search that target column %p', async columnName => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: bedFixtures[0][columnName],\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(1);\n      expect(res.body[0]).toMatchObject(data.bed[0]);\n    });\n\n    test('search with an empty query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: '',\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(5);\n      expect(res.body).toEqual(expect.arrayContaining(data.bed));\n    });\n\n    test('search with special characters', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: data.bed[3].name,\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(1);\n      expect(res.body[0]).toMatchObject(data.bed[3]);\n    });\n  });\n\n  describe('With filters', () => {\n    test('search with an empty query & peopleNumber > 0', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: '',\n          peopleNumber_gt: 0,\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(3);\n      expect(res.body).toMatchObject([data.bed[0], data.bed[1], data.bed[4]]);\n    });\n    test('search with an empty query & peopleNumber > 1', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: '',\n          peopleNumber_gt: 1,\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(2);\n      expect(res.body).toMatchObject([data.bed[0], data.bed[4]]);\n    });\n    test('search with an empty query & peopleNumber in [1, 6]', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds?peopleNumber=1&peopleNumber=6&_q=',\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(2);\n      expect(res.body).toMatchObject(data.bed.slice(0, 2));\n    });\n    test('search for \"Sleepy Bed\" & peopleNumber < 7', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: 'Sleepy Bed',\n          peopleNumber_lt: 7,\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(1);\n      expect(res.body).toMatchObject([data.bed[0]]);\n    });\n  });\n});\n",
    "packages/strapi/tests/single-type.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet uid = 'single-type';\nlet data = {};\n\nconst model = {\n  kind: 'singleType',\n  name: 'single-type',\n  attributes: {\n    title: {\n      type: 'string',\n    },\n  },\n};\n\ndescribe('Content Manager single types', () => {\n  beforeAll(async () => {\n    await builder.addContentType(model).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('find single type content returns 404 when not created', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(404);\n  });\n\n  test('Create content', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'PUT',\n      body: {\n        title: 'Title',\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      id: expect.anything(),\n      title: 'Title',\n    });\n\n    data.id = res.body.id;\n  });\n\n  test('Update keeps the same data id', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'PUT',\n      body: {\n        title: 'Title',\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      id: data.id,\n      title: 'Title',\n    });\n  });\n\n  test('find single type content returns an object ', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      id: expect.anything(),\n      title: 'Title',\n    });\n  });\n\n  test('Delete single type content returns an object and makes data unavailable', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'DELETE',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      id: expect.anything(),\n      title: 'Title',\n    });\n\n    const getRes = await rq({\n      url: `/${uid}`,\n      method: 'GET',\n    });\n\n    expect(getRes.statusCode).toBe(404);\n  });\n});\n",
    "packages/strapi-admin/admin/src/components/Users/ModalCreateBody/index.js": "import React, { forwardRef, useReducer, useImperativeHandle, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { BaselineAlignment, ModalSection, request } from 'strapi-helper-plugin';\nimport { FormattedMessage } from 'react-intl';\nimport { get } from 'lodash';\nimport { Padded, Text } from '@buffetjs/core';\nimport { Col, Row } from 'reactstrap';\nimport checkFormValidity from '../../../utils/checkFormValidity';\nimport SelectRoles from '../SelectRoles';\nimport form from './utils/form';\nimport schema from './utils/schema';\nimport { initialState, reducer } from './reducer';\nimport init from './init';\nimport Input from '../../SizedInput';\nimport Wrapper from './Wrapper';\nimport MagicLink from '../MagicLink';\n\n// This component accepts a ref so we can have access to the submit handler.\nconst ModalCreateBody = forwardRef(\n  ({ isDisabled, onSubmit, registrationToken, setIsSubmiting, showMagicLink }, ref) => {\n    const [reducerState, dispatch] = useReducer(reducer, initialState, init);\n    const { formErrors, modifiedData } = reducerState;\n    const buttonSubmitRef = useRef(null);\n\n    useImperativeHandle(ref, () => ({\n      submit: () => {\n        buttonSubmitRef.current.click();\n      },\n    }));\n\n    const handleChange = ({ target: { name, value } }) => {\n      dispatch({\n        type: 'ON_CHANGE',\n        keys: name,\n        value,\n      });\n    };\n\n    const handleSubmit = async e => {\n      e.persist();\n      e.preventDefault();\n      const errors = await checkFormValidity(modifiedData, schema);\n\n      if (!errors) {\n        try {\n          // Prevent user interactions until the request is completed\n          strapi.lockAppWithOverlay();\n\n          setIsSubmiting(true);\n\n          const requestURL = '/admin/users';\n          const cleanedRoles = modifiedData.roles.map(role => role.id);\n\n          const { data } = await request(requestURL, {\n            method: 'POST',\n            body: { ...modifiedData, roles: cleanedRoles },\n          });\n\n          onSubmit(e, data);\n        } catch (err) {\n          const message = get(err, ['response', 'payload', 'message'], 'An error occured');\n\n          strapi.notification.toggle({ type: 'warning', message });\n        } finally {\n          strapi.unlockApp();\n          setIsSubmiting(false);\n        }\n      }\n\n      dispatch({\n        type: 'SET_ERRORS',\n        errors: errors || {},\n      });\n    };\n\n    return (\n      <form onSubmit={handleSubmit}>\n        {showMagicLink && (\n          <>\n            <BaselineAlignment top size=\"18px\" />\n            <ModalSection>\n              <MagicLink registrationToken={registrationToken} />\n            </ModalSection>\n          </>\n        )}\n        <ModalSection>\n          <Padded top size=\"18px\">\n            <Text fontSize=\"xs\" color=\"grey\" fontWeight=\"bold\" textTransform=\"uppercase\">\n              <FormattedMessage id=\"app.components.Users.ModalCreateBody.block-title.details\">\n                {txt => txt}\n              </FormattedMessage>\n            </Text>\n          </Padded>\n        </ModalSection>\n        <ModalSection>\n          <Wrapper>\n            <Padded top size=\"20px\">\n              <Row>\n                {Object.keys(form).map((inputName, i) => (\n                  <Input\n                    key={inputName}\n                    {...form[inputName]}\n                    autoFocus={i === 0}\n                    disabled={isDisabled}\n                    error={formErrors[inputName]}\n                    name={inputName}\n                    onChange={handleChange}\n                    value={modifiedData[inputName]}\n                  />\n                ))}\n              </Row>\n            </Padded>\n          </Wrapper>\n        </ModalSection>\n        <ModalSection>\n          <Padded top size=\"3px\">\n            <Text fontSize=\"xs\" color=\"grey\" fontWeight=\"bold\" textTransform=\"uppercase\">\n              <FormattedMessage id=\"app.components.Users.ModalCreateBody.block-title.roles\">\n                {txt => txt}\n              </FormattedMessage>\n            </Text>\n          </Padded>\n        </ModalSection>\n        <ModalSection>\n          <Wrapper>\n            <Padded top size=\"12px\">\n              <Row>\n                <Col xs=\"6\">\n                  <SelectRoles\n                    isDisabled={isDisabled}\n                    name=\"roles\"\n                    onChange={handleChange}\n                    value={modifiedData.roles}\n                    error={formErrors.roles}\n                  />\n                </Col>\n              </Row>\n            </Padded>\n          </Wrapper>\n        </ModalSection>\n        <button type=\"submit\" style={{ display: 'none' }} ref={buttonSubmitRef}>\n          hidden button to use the native form event\n        </button>\n      </form>\n    );\n  }\n);\n\nModalCreateBody.defaultProps = {\n  isDisabled: false,\n  onSubmit: e => e.preventDefault(),\n  registrationToken: '',\n  setIsSubmiting: () => {},\n  showMagicLink: false,\n};\n\nModalCreateBody.propTypes = {\n  isDisabled: PropTypes.bool,\n  onSubmit: PropTypes.func,\n  registrationToken: PropTypes.string,\n  setIsSubmiting: PropTypes.func,\n  showMagicLink: PropTypes.bool,\n};\n\nexport default ModalCreateBody;\n",
    "packages/strapi-admin/admin/src/containers/Admin/index.js": "/**\n *\n * Admin\n *\n */\n\nimport React, { createRef } from 'react';\nimport PropTypes from 'prop-types';\nimport axios from 'axios';\nimport { connect } from 'react-redux';\nimport { createStructuredSelector } from 'reselect';\nimport { bindActionCreators, compose } from 'redux';\nimport { Switch, Route } from 'react-router-dom';\nimport { injectIntl } from 'react-intl';\nimport { isEmpty } from 'lodash';\n// Components from strapi-helper-plugin\nimport {\n  difference,\n  GlobalContextProvider,\n  LoadingIndicatorPage,\n  OverlayBlocker,\n  UserProvider,\n  CheckPagePermissions,\n  request,\n} from 'strapi-helper-plugin';\nimport { SETTINGS_BASE_URL, SHOW_TUTORIALS, STRAPI_UPDATE_NOTIF } from '../../config';\nimport { checkLatestStrapiVersion } from '../../utils';\n\nimport adminPermissions from '../../permissions';\nimport Header from '../../components/Header/index';\nimport NavTopRightWrapper from '../../components/NavTopRightWrapper';\nimport LeftMenu from '../LeftMenu';\nimport InstalledPluginsPage from '../InstalledPluginsPage';\nimport LocaleToggle from '../LocaleToggle';\nimport HomePage from '../HomePage';\nimport MarketplacePage from '../MarketplacePage';\nimport NotFoundPage from '../NotFoundPage';\nimport OnboardingVideos from '../Onboarding';\nimport SettingsPage from '../SettingsPage';\nimport PluginDispatcher from '../PluginDispatcher';\nimport ProfilePage from '../ProfilePage';\nimport Logout from './Logout';\nimport {\n  disableGlobalOverlayBlocker,\n  enableGlobalOverlayBlocker,\n  getInfosDataSucceeded,\n  updatePlugin,\n} from '../App/actions';\nimport makeSelecApp from '../App/selectors';\nimport {\n  getStrapiLatestReleaseSucceeded,\n  getUserPermissions,\n  getUserPermissionsError,\n  getUserPermissionsSucceeded,\n  setAppError,\n} from './actions';\nimport makeSelectAdmin from './selectors';\nimport Wrapper from './Wrapper';\nimport Content from './Content';\n\nexport class Admin extends React.Component {\n  // eslint-disable-line react/prefer-stateless-function\n\n  // Ref to access the menu API\n  menuRef = createRef();\n\n  helpers = {\n    updatePlugin: this.props.updatePlugin,\n  };\n\n  componentDidMount() {\n    this.emitEvent('didAccessAuthenticatedAdministration');\n    this.initApp();\n  }\n\n  shouldComponentUpdate(prevProps) {\n    return !isEmpty(difference(prevProps, this.props));\n  }\n\n  /* istanbul ignore next */\n  componentDidCatch(error, info) {\n    /* eslint-disable */\n    console.log('An error has occured');\n    console.log('--------------------');\n    console.log(error);\n    console.log('Here is some infos');\n    console.log(info);\n    /* eslint-enable */\n\n    // Display the error log component which is not designed yet\n    this.props.setAppError();\n  }\n\n  emitEvent = async (event, properties) => {\n    const {\n      global: { uuid },\n    } = this.props;\n\n    if (uuid) {\n      try {\n        await axios.post('https://analytics.strapi.io/track', {\n          event,\n          // PROJECT_TYPE is an env variable defined in the webpack config\n          // eslint-disable-next-line no-undef\n          properties: { ...properties, projectType: PROJECT_TYPE },\n          uuid,\n        });\n      } catch (err) {\n        // Silent\n      }\n    }\n  };\n\n  fetchAppInfo = async () => {\n    try {\n      const { data } = await request('/admin/information', { method: 'GET' });\n\n      this.props.getInfosDataSucceeded(data);\n    } catch (err) {\n      console.error(err);\n      strapi.notification.error('notification.error');\n    }\n  };\n\n  fetchStrapiLatestRelease = async () => {\n    const {\n      global: { strapiVersion },\n      getStrapiLatestReleaseSucceeded,\n    } = this.props;\n\n    if (!STRAPI_UPDATE_NOTIF) {\n      return;\n    }\n\n    try {\n      const {\n        data: { tag_name },\n      } = await axios.get('https://api.github.com/repos/strapi/strapi/releases/latest');\n      const shouldUpdateStrapi = checkLatestStrapiVersion(strapiVersion, tag_name);\n\n      getStrapiLatestReleaseSucceeded(tag_name, shouldUpdateStrapi);\n\n      const showUpdateNotif = !JSON.parse(localStorage.getItem('STRAPI_UPDATE_NOTIF'));\n\n      if (!showUpdateNotif) {\n        return;\n      }\n\n      if (shouldUpdateStrapi) {\n        strapi.notification.toggle({\n          type: 'info',\n          message: { id: 'notification.version.update.message' },\n          link: {\n            url: `https://github.com/strapi/strapi/releases/tag/${tag_name}`,\n            label: {\n              id: 'notification.version.update.link',\n            },\n          },\n          blockTransition: true,\n          onClose: () => localStorage.setItem('STRAPI_UPDATE_NOTIF', true),\n        });\n      }\n    } catch (err) {\n      // Silent\n    }\n  };\n\n  fetchUserPermissions = async (resetState = false) => {\n    const { getUserPermissions, getUserPermissionsError, getUserPermissionsSucceeded } = this.props;\n\n    if (resetState) {\n      // Show a loader\n      getUserPermissions();\n    }\n\n    try {\n      const { data } = await request('/admin/users/me/permissions', { method: 'GET' });\n\n      getUserPermissionsSucceeded(data);\n    } catch (err) {\n      console.error(err);\n      getUserPermissionsError(err);\n    }\n  };\n\n  hasApluginNotReady = props => {\n    const {\n      global: { plugins },\n    } = props;\n\n    return !Object.keys(plugins).every(plugin => plugins[plugin].isReady === true);\n  };\n\n  initApp = async () => {\n    await this.fetchAppInfo();\n    await this.fetchStrapiLatestRelease();\n    await this.fetchUserPermissions(true);\n  };\n\n  /**\n   * Display the app loader until the app is ready\n   * @returns {Boolean}\n   */\n  showLoader = () => {\n    return this.hasApluginNotReady(this.props);\n  };\n\n  renderInitializers = () => {\n    const {\n      global: { plugins },\n    } = this.props;\n\n    return Object.keys(plugins).reduce((acc, current) => {\n      const InitializerComponent = plugins[current].initializer;\n\n      if (InitializerComponent) {\n        const key = plugins[current].id;\n\n        acc.push(<InitializerComponent key={key} {...this.props} {...this.helpers} />);\n      }\n\n      return acc;\n    }, []);\n  };\n\n  renderPluginDispatcher = props => {\n    // NOTE: Send the needed props instead of everything...\n\n    return <PluginDispatcher {...this.props} {...props} {...this.helpers} />;\n  };\n\n  renderRoute = (props, Component) => <Component {...this.props} {...props} />;\n\n  render() {\n    const {\n      admin: { isLoading, shouldUpdateStrapi, userPermissions },\n      global: {\n        autoReload,\n        blockApp,\n        currentEnvironment,\n        overlayBlockerData,\n        plugins,\n        showGlobalAppBlocker,\n        strapiVersion,\n      },\n      disableGlobalOverlayBlocker,\n      enableGlobalOverlayBlocker,\n      intl: { formatMessage, locale },\n      updatePlugin,\n    } = this.props;\n\n    // We need the admin data in order to make the initializers work\n    if (this.showLoader()) {\n      return (\n        <>\n          {this.renderInitializers()}\n          <LoadingIndicatorPage />\n        </>\n      );\n    }\n\n    // Show a loader while permissions are being fetched\n    if (isLoading) {\n      return <LoadingIndicatorPage />;\n    }\n\n    return (\n      <GlobalContextProvider\n        autoReload={autoReload}\n        emitEvent={this.emitEvent}\n        currentEnvironment={currentEnvironment}\n        currentLocale={locale}\n        disableGlobalOverlayBlocker={disableGlobalOverlayBlocker}\n        enableGlobalOverlayBlocker={enableGlobalOverlayBlocker}\n        fetchUserPermissions={this.fetchUserPermissions}\n        formatMessage={formatMessage}\n        shouldUpdateStrapi={shouldUpdateStrapi}\n        menu={this.menuRef.current}\n        plugins={plugins}\n        settingsBaseURL={SETTINGS_BASE_URL || '/settings'}\n        strapiVersion={strapiVersion}\n        updatePlugin={updatePlugin}\n      >\n        <UserProvider value={userPermissions}>\n          <Wrapper>\n            <LeftMenu\n              shouldUpdateStrapi={shouldUpdateStrapi}\n              version={strapiVersion}\n              plugins={plugins}\n              ref={this.menuRef}\n            />\n            <NavTopRightWrapper>\n              {/* Injection zone not ready yet */}\n              <Logout />\n              <LocaleToggle isLogged />\n            </NavTopRightWrapper>\n            <div className=\"adminPageRightWrapper\">\n              <Header />\n              <Content>\n                <Switch>\n                  <Route path=\"/\" render={props => this.renderRoute(props, HomePage)} exact />\n                  <Route path=\"/me\" component={ProfilePage} />\n                  <Route path=\"/plugins/:pluginId\" render={this.renderPluginDispatcher} />\n                  <Route path=\"/list-plugins\" exact>\n                    <CheckPagePermissions permissions={adminPermissions.marketplace.main}>\n                      <InstalledPluginsPage />\n                    </CheckPagePermissions>\n                  </Route>\n                  <Route path=\"/marketplace\">\n                    <CheckPagePermissions permissions={adminPermissions.marketplace.main}>\n                      <MarketplacePage />\n                    </CheckPagePermissions>\n                  </Route>\n                  <Route\n                    path={`${SETTINGS_BASE_URL || '/settings'}/:settingId`}\n                    component={SettingsPage}\n                  />\n                  <Route path={SETTINGS_BASE_URL || '/settings'} component={SettingsPage} exact />\n                  <Route key=\"7\" path=\"\" component={NotFoundPage} />\n                  <Route key=\"8\" path=\"/404\" component={NotFoundPage} />\n                </Switch>\n              </Content>\n            </div>\n            <OverlayBlocker\n              key=\"overlayBlocker\"\n              isOpen={blockApp && showGlobalAppBlocker}\n              {...overlayBlockerData}\n            />\n            {SHOW_TUTORIALS && <OnboardingVideos />}\n          </Wrapper>\n        </UserProvider>\n      </GlobalContextProvider>\n    );\n  }\n}\n\nAdmin.defaultProps = {\n  intl: {\n    formatMessage: () => {},\n    locale: 'en',\n  },\n};\n\nAdmin.propTypes = {\n  admin: PropTypes.shape({\n    appError: PropTypes.bool,\n    isLoading: PropTypes.bool,\n    shouldUpdateStrapi: PropTypes.bool.isRequired,\n    userPermissions: PropTypes.array,\n  }).isRequired,\n  disableGlobalOverlayBlocker: PropTypes.func.isRequired,\n  enableGlobalOverlayBlocker: PropTypes.func.isRequired,\n  getInfosDataSucceeded: PropTypes.func.isRequired,\n  getStrapiLatestReleaseSucceeded: PropTypes.func.isRequired,\n  getUserPermissions: PropTypes.func.isRequired,\n  getUserPermissionsError: PropTypes.func.isRequired,\n  getUserPermissionsSucceeded: PropTypes.func.isRequired,\n  global: PropTypes.shape({\n    autoReload: PropTypes.bool,\n    blockApp: PropTypes.bool,\n    currentEnvironment: PropTypes.string,\n    overlayBlockerData: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n    plugins: PropTypes.object,\n    showGlobalAppBlocker: PropTypes.bool,\n    strapiVersion: PropTypes.string,\n    uuid: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n  }).isRequired,\n  intl: PropTypes.shape({\n    formatMessage: PropTypes.func,\n    locale: PropTypes.string,\n  }),\n  location: PropTypes.object.isRequired,\n  setAppError: PropTypes.func.isRequired,\n  updatePlugin: PropTypes.func.isRequired,\n};\n\nconst mapStateToProps = createStructuredSelector({\n  admin: makeSelectAdmin(),\n  global: makeSelecApp(),\n});\n\nexport function mapDispatchToProps(dispatch) {\n  return bindActionCreators(\n    {\n      disableGlobalOverlayBlocker,\n      enableGlobalOverlayBlocker,\n      getInfosDataSucceeded,\n      getStrapiLatestReleaseSucceeded,\n      getUserPermissions,\n      getUserPermissionsError,\n      getUserPermissionsSucceeded,\n      setAppError,\n      updatePlugin,\n    },\n    dispatch\n  );\n}\n\nconst withConnect = connect(mapStateToProps, mapDispatchToProps);\n\nexport default compose(injectIntl, withConnect)(Admin);\n",
    "packages/strapi-admin/admin/src/containers/App/index.js": "/**\n *\n * App.js\n *\n * This component is the skeleton around the actual pages, and should only\n * contain code that should be seen on all pages. (e.g. navigation bar)\n *\n * NOTE: while this component should technically be a stateless functional\n * component (SFC), hot reloading does not currently support SFCs. If hot\n * reloading is not a neccessity for you then you can refactor it and remove\n * the linting exception.\n */\n\nimport React, { useEffect, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { Switch, Route } from 'react-router-dom';\nimport { connect } from 'react-redux';\nimport { bindActionCreators, compose } from 'redux';\nimport { LoadingIndicatorPage, auth, request } from 'strapi-helper-plugin';\nimport GlobalStyle from '../../components/GlobalStyle';\nimport Admin from '../Admin';\nimport AuthPage from '../AuthPage';\nimport NotFoundPage from '../NotFoundPage';\n// eslint-disable-next-line import/no-cycle\nimport NotificationProvider from '../NotificationProvider';\nimport PrivateRoute from '../PrivateRoute';\nimport Theme from '../Theme';\nimport { Content, Wrapper } from './components';\nimport { getDataSucceeded } from './actions';\nimport NewNotification from '../NewNotification';\n\nfunction App(props) {\n  const getDataRef = useRef();\n  const [{ isLoading, hasAdmin }, setState] = useState({ isLoading: true, hasAdmin: false });\n  getDataRef.current = props.getDataSucceeded;\n\n  useEffect(() => {\n    const currentToken = auth.getToken();\n\n    const renewToken = async () => {\n      try {\n        const {\n          data: { token },\n        } = await request('/admin/renew-token', {\n          method: 'POST',\n          body: { token: currentToken },\n        });\n        auth.updateToken(token);\n      } catch (err) {\n        // Refresh app\n        auth.clearAppStorage();\n        window.location.reload();\n      }\n    };\n\n    if (currentToken) {\n      renewToken();\n    }\n  }, []);\n\n  useEffect(() => {\n    const getData = async () => {\n      try {\n        const { data } = await request('/admin/init', { method: 'GET' });\n\n        const { uuid } = data;\n\n        if (uuid) {\n          try {\n            fetch('https://analytics.strapi.io/track', {\n              method: 'POST',\n              body: JSON.stringify({\n                event: 'didInitializeAdministration',\n                uuid,\n              }),\n              headers: {\n                'Content-Type': 'application/json',\n              },\n            });\n          } catch (e) {\n            // Silent.\n          }\n        }\n\n        getDataRef.current(data);\n        setState({ isLoading: false, hasAdmin: data.hasAdmin });\n      } catch (err) {\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'app.containers.App.notification.error.init' },\n        });\n      }\n    };\n\n    getData();\n  }, []);\n\n  if (isLoading) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <Theme>\n      <Wrapper>\n        <GlobalStyle />\n        <NotificationProvider />\n        <NewNotification />\n        <Content>\n          <Switch>\n            <Route\n              path=\"/auth/:authType\"\n              render={routerProps => <AuthPage {...routerProps} hasAdmin={hasAdmin} />}\n              exact\n            />\n            <PrivateRoute path=\"/\" component={Admin} />\n            <Route path=\"\" component={NotFoundPage} />\n          </Switch>\n        </Content>\n      </Wrapper>\n    </Theme>\n  );\n}\n\nApp.propTypes = {\n  getDataSucceeded: PropTypes.func.isRequired,\n};\n\nexport function mapDispatchToProps(dispatch) {\n  return bindActionCreators({ getDataSucceeded }, dispatch);\n}\n\nconst withConnect = connect(null, mapDispatchToProps);\n\nexport default compose(withConnect)(App);\nexport { App };\n",
    "packages/strapi-admin/admin/src/containers/AuthPage/index.js": "import React, { useEffect, useReducer } from 'react';\nimport axios from 'axios';\nimport { camelCase, get, omit, upperFirst } from 'lodash';\nimport { Redirect, useRouteMatch, useHistory } from 'react-router-dom';\nimport { BaselineAlignment, auth, useQuery } from 'strapi-helper-plugin';\nimport { Padded } from '@buffetjs/core';\nimport PropTypes from 'prop-types';\nimport NavTopRightWrapper from '../../components/NavTopRightWrapper';\nimport PageTitle from '../../components/PageTitle';\nimport LocaleToggle from '../LocaleToggle';\nimport checkFormValidity from '../../utils/checkFormValidity';\nimport formatAPIErrors from '../../utils/formatAPIErrors';\nimport { forms } from './utils';\nimport init from './init';\nimport { initialState, reducer } from './reducer';\n\nconst AuthPage = ({ hasAdmin }) => {\n  const { push } = useHistory();\n  const {\n    params: { authType },\n  } = useRouteMatch('/auth/:authType');\n  const query = useQuery();\n  const registrationToken = query.get('registrationToken');\n  const { Component, endPoint, fieldsToDisable, fieldsToOmit, inputsPrefix, schema, ...rest } = get(\n    forms,\n    authType,\n    {}\n  );\n  const [{ formErrors, modifiedData, requestError }, dispatch] = useReducer(\n    reducer,\n    initialState,\n    init\n  );\n  const CancelToken = axios.CancelToken;\n  const source = CancelToken.source();\n\n  useEffect(() => {\n    // Cancel request on unmount\n    return () => {\n      source.cancel('Component unmounted');\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Reset the state on navigation change\n  useEffect(() => {\n    dispatch({\n      type: 'RESET_PROPS',\n    });\n  }, [authType]);\n\n  useEffect(() => {\n    if (authType === 'register') {\n      const getData = async () => {\n        try {\n          const {\n            data: { data },\n          } = await axios.get(\n            `${strapi.backendURL}/admin/registration-info?registrationToken=${registrationToken}`\n          );\n\n          if (data) {\n            dispatch({\n              type: 'SET_DATA',\n              data: { registrationToken, userInfo: data },\n            });\n          }\n        } catch (err) {\n          const errorMessage = get(err, ['response', 'data', 'message'], 'An error occured');\n\n          strapi.notification.toggle({\n            type: 'warning',\n            message: errorMessage,\n          });\n\n          // Redirect to the oops page in case of an invalid token\n          // @alexandrebodin @JAB I am not sure it is the wanted behavior\n          push(`/auth/oops?info=${encodeURIComponent(errorMessage)}`);\n        }\n      };\n\n      getData();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [authType]);\n\n  const handleChange = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: name,\n      value,\n    });\n  };\n\n  const handleSubmit = async e => {\n    e.preventDefault();\n\n    dispatch({\n      type: 'SET_ERRORS',\n      errors: {},\n    });\n\n    const errors = await checkFormValidity(modifiedData, schema);\n\n    dispatch({\n      type: 'SET_ERRORS',\n      errors: errors || {},\n    });\n\n    if (!errors) {\n      const body = omit(modifiedData, fieldsToOmit);\n      const requestURL = `/admin/${endPoint}`;\n\n      if (authType === 'login') {\n        await loginRequest(body, requestURL);\n      }\n\n      if (authType === 'register' || authType === 'register-admin') {\n        await registerRequest(body, requestURL);\n      }\n\n      if (authType === 'forgot-password') {\n        await forgotPasswordRequest(body, requestURL);\n      }\n\n      if (authType === 'reset-password') {\n        await resetPasswordRequest(body, requestURL);\n      }\n    }\n  };\n\n  const forgotPasswordRequest = async (body, requestURL) => {\n    try {\n      await axios({\n        method: 'POST',\n        url: `${strapi.backendURL}${requestURL}`,\n        data: body,\n        cancelToken: source.token,\n      });\n\n      push('/auth/forgot-password-success');\n    } catch (err) {\n      console.error(err);\n\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  const loginRequest = async (body, requestURL) => {\n    try {\n      const {\n        data: {\n          data: { token, user },\n        },\n      } = await axios({\n        method: 'POST',\n        url: `${strapi.backendURL}${requestURL}`,\n        data: body,\n        cancelToken: source.token,\n      });\n\n      auth.setToken(token, modifiedData.rememberMe);\n      auth.setUserInfo(user, modifiedData.rememberMe);\n\n      push('/');\n    } catch (err) {\n      if (err.response) {\n        const errorMessage = get(err, ['response', 'data', 'message'], 'Something went wrong');\n        const errorStatus = get(err, ['response', 'data', 'statusCode'], 400);\n\n        if (camelCase(errorMessage).toLowerCase() === 'usernotactive') {\n          push('/auth/oops');\n\n          dispatch({\n            type: 'RESET_PROPS',\n          });\n\n          return;\n        }\n\n        dispatch({\n          type: 'SET_REQUEST_ERROR',\n          errorMessage,\n          errorStatus,\n        });\n      }\n    }\n  };\n\n  const registerRequest = async (body, requestURL) => {\n    try {\n      const {\n        data: {\n          data: { token, user },\n        },\n      } = await axios({\n        method: 'POST',\n        url: `${strapi.backendURL}${requestURL}`,\n        data: body,\n        cancelToken: source.token,\n      });\n\n      auth.setToken(token, false);\n      auth.setUserInfo(user, false);\n\n      if (\n        (authType === 'register' && modifiedData.userInfo.news === true) ||\n        (authType === 'register-admin' && modifiedData.news === true)\n      ) {\n        axios({\n          method: 'POST',\n          url: 'https://analytics.strapi.io/register',\n          data: {\n            email: user.email,\n            username: user.firstname,\n          },\n        });\n      }\n      // Redirect to the homePage\n      push('/');\n    } catch (err) {\n      if (err.response) {\n        const { data } = err.response;\n        const apiErrors = formatAPIErrors(data);\n\n        dispatch({\n          type: 'SET_ERRORS',\n          errors: apiErrors,\n        });\n      }\n    }\n  };\n\n  const resetPasswordRequest = async (body, requestURL) => {\n    try {\n      const {\n        data: {\n          data: { token, user },\n        },\n      } = await axios({\n        method: 'POST',\n        url: `${strapi.backendURL}${requestURL}`,\n        data: { ...body, resetPasswordToken: query.get('code') },\n        cancelToken: source.token,\n      });\n\n      auth.setToken(token, false);\n      auth.setUserInfo(user, false);\n\n      // Redirect to the homePage\n      push('/');\n    } catch (err) {\n      if (err.response) {\n        const errorMessage = get(err, ['response', 'data', 'message'], 'Something went wrong');\n        const errorStatus = get(err, ['response', 'data', 'statusCode'], 400);\n\n        dispatch({\n          type: 'SET_REQUEST_ERROR',\n          errorMessage,\n          errorStatus,\n        });\n      }\n    }\n  };\n\n  // Redirect the user to the login page if the endpoint does not exist\n  if (!forms[authType]) {\n    return <Redirect to=\"/\" />;\n  }\n\n  // Redirect the user to the login page if there is already an admin user\n  if (hasAdmin && authType === 'register-admin') {\n    return <Redirect to=\"/\" />;\n  }\n\n  // Redirect the user to the register-admin if it is the first user\n  if (!hasAdmin && authType !== 'register-admin') {\n    return <Redirect to=\"/auth/register-admin\" />;\n  }\n\n  // Redirect the user to the homepage if he is logged in\n  if (auth.getToken()) {\n    return <Redirect to=\"/\" />;\n  }\n\n  return (\n    <>\n      <Padded bottom size=\"md\">\n        <PageTitle title={upperFirst(authType)} />\n        <NavTopRightWrapper>\n          <LocaleToggle isLogged className=\"localeDropdownMenuNotLogged\" />\n        </NavTopRightWrapper>\n        <BaselineAlignment top size=\"78px\">\n          <Component\n            {...rest}\n            fieldsToDisable={fieldsToDisable}\n            formErrors={formErrors}\n            inputsPrefix={inputsPrefix}\n            modifiedData={modifiedData}\n            onChange={handleChange}\n            onSubmit={handleSubmit}\n            requestError={requestError}\n          />\n        </BaselineAlignment>\n      </Padded>\n    </>\n  );\n};\n\nAuthPage.defaultProps = {\n  hasAdmin: false,\n};\n\nAuthPage.propTypes = {\n  hasAdmin: PropTypes.bool,\n};\n\nexport default AuthPage;\n",
    "packages/strapi-admin/admin/src/containers/HomePage/hooks.js": "import { useEffect, useState, useRef } from 'react';\nimport axios from 'axios';\n\nconst useFetch = () => {\n  const isMounted = useRef(true);\n  const [state, setState] = useState({\n    error: false,\n    isLoading: true,\n    posts: [{ link: '1' }, { link: '2' }],\n  });\n\n  useEffect(() => {\n    const CancelToken = axios.CancelToken;\n    const source = CancelToken.source();\n\n    const fetchData = async () => {\n      try {\n        const { data } = await axios.get(\n          'https://strapi.io/api/blog-posts?_limit=2&_sort=publishedAt:desc',\n          {\n            cancelToken: source.token,\n          }\n        );\n\n        const posts = data.reduce((acc, curr) => {\n          acc.push({\n            title: curr.seo.metaTitle,\n            link: curr.slug,\n            content: curr.seo.metaDescription,\n          });\n\n          return acc;\n        }, []);\n\n        setState({ isLoading: false, posts, error: false });\n      } catch (err) {\n        if (isMounted.current) {\n          setState({ isLoading: false, error: true, posts: [] });\n        }\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      isMounted.current = false;\n      source.cancel('abort');\n    };\n  }, []);\n\n  return state;\n};\n\nexport default useFetch;\n",
    "packages/strapi-admin/admin/src/containers/InstalledPluginsPage/index.js": "import React from 'react';\nimport { useGlobalContext, request } from 'strapi-helper-plugin';\nimport { Header, List } from '@buffetjs/custom';\nimport PageTitle from '../../components/PageTitle';\nimport ContainerFluid from '../../components/ContainerFluid';\nimport ListWrapper from './ListWrapper';\nimport Row from './Row';\nimport generateRows from './utils/generateRows';\n\nconst InstalledPluginsPage = () => {\n  const { formatMessage, plugins } = useGlobalContext();\n  const onConfirm = async id => {\n    try {\n      const requestUrl = `/admin/plugins/uninstall/${id}`;\n      // Force the Overlayblocker to be displayed\n      const overlayblockerParams = {\n        enabled: true,\n        title: 'app.components.ListPluginsPage.deletePlugin.title',\n        description: 'app.components.ListPluginsPage.deletePlugin.description',\n      };\n      // Lock the app\n      strapi.lockApp(overlayblockerParams);\n      const response = await request(requestUrl, { method: 'DELETE' }, overlayblockerParams);\n\n      if (response.ok) {\n        // Reload the app\n        window.location.reload();\n      }\n    } catch (err) {\n      strapi.unlockApp();\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'app.components.listPluginsPage.deletePlugin.error' },\n      });\n    }\n  };\n\n  const rows = generateRows(plugins, onConfirm);\n\n  return (\n    <div>\n      <PageTitle\n        title={formatMessage({\n          id: 'app.components.ListPluginsPage.helmet.title',\n        })}\n      />\n      <ContainerFluid>\n        <Header\n          title={{\n            label: formatMessage({\n              id: 'app.components.ListPluginsPage.title',\n            }),\n          }}\n          content={formatMessage({\n            id: 'app.components.ListPluginsPage.description',\n          })}\n        />\n        <ListWrapper>\n          <List\n            title={formatMessage(\n              { id: 'app.components.listPlugins.title.plural' },\n              { number: rows.length }\n            )}\n            items={rows}\n            customRowComponent={Row}\n          />\n        </ListWrapper>\n      </ContainerFluid>\n    </div>\n  );\n};\n\nexport default InstalledPluginsPage;\n",
    "packages/strapi-admin/admin/src/containers/LeftMenu/index.js": "/*\n *\n * LeftMenu\n *\n */\n\nimport React, {\n  forwardRef,\n  memo,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useReducer,\n} from 'react';\nimport PropTypes from 'prop-types';\nimport { useLocation } from 'react-router-dom';\n\nimport { UserContext, hasPermissions, request } from 'strapi-helper-plugin';\nimport {\n  LeftMenuLinksSection,\n  LeftMenuFooter,\n  LeftMenuHeader,\n  LinksContainer,\n} from '../../components/LeftMenu';\nimport { useSettingsMenu } from '../../hooks';\nimport { generateModelsLinks, filterLinks } from './utils';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\nimport Loader from './Loader';\nimport Wrapper from './Wrapper';\n\nconst LeftMenu = forwardRef(({ shouldUpdateStrapi, version, plugins }, ref) => {\n  const location = useLocation();\n  const permissions = useContext(UserContext);\n  const { menu: settingsMenu } = useSettingsMenu(true);\n\n  // TODO: this needs to be added to the settings API in the v4\n  const settingsLinkNotificationCount = useMemo(() => {\n    if (shouldUpdateStrapi) {\n      return 1;\n    }\n\n    return 0;\n  }, [shouldUpdateStrapi]);\n  const [\n    {\n      collectionTypesSectionLinks,\n      generalSectionLinks,\n      isLoading,\n      pluginsSectionLinks,\n      singleTypesSectionLinks,\n    },\n    dispatch,\n  ] = useReducer(reducer, initialState, () =>\n    init(initialState, plugins, settingsMenu, settingsLinkNotificationCount)\n  );\n  const generalSectionLinksFiltered = useMemo(() => filterLinks(generalSectionLinks), [\n    generalSectionLinks,\n  ]);\n  const pluginsSectionLinksFiltered = useMemo(() => filterLinks(pluginsSectionLinks), [\n    pluginsSectionLinks,\n  ]);\n\n  const singleTypesSectionLinksFiltered = useMemo(() => filterLinks(singleTypesSectionLinks), [\n    singleTypesSectionLinks,\n  ]);\n  const collectTypesSectionLinksFiltered = useMemo(() => filterLinks(collectionTypesSectionLinks), [\n    collectionTypesSectionLinks,\n  ]);\n\n  // TODO:\n  // This is making a lot of request especially for the Author role as all permissions are being sent to\n  // to the backend.\n  // We should improve this by sending one request in with all permissions in bulk using the\n  // findMatchingPermissions util from the helper plugin and the /users/me/permissions endPoint\n  const checkPermissions = async (index, permissionsToCheck) => {\n    const hasPermission = await hasPermissions(permissions, permissionsToCheck);\n\n    return { index, hasPermission };\n  };\n\n  const generateArrayOfPromises = array =>\n    array.map((_, index) => checkPermissions(index, array[index].permissions));\n\n  const getModels = async () => {\n    const requestURL = '/content-manager/content-types';\n\n    try {\n      const { data } = await request(requestURL, { method: 'GET' });\n\n      const formattedData = generateModelsLinks(data);\n\n      const collectionTypesSectionLinksArrayOfPromises = generateArrayOfPromises(\n        formattedData.collectionTypesSectionLinks\n      );\n      const collectionTypesSectionResults = await Promise.all(\n        collectionTypesSectionLinksArrayOfPromises\n      );\n\n      const singleTypesSectionLinksArrayOfPromises = generateArrayOfPromises(\n        formattedData.singleTypesSectionLinks\n      );\n      const singleTypesSectionResults = await Promise.all(singleTypesSectionLinksArrayOfPromises);\n\n      dispatch({\n        type: 'GET_MODELS_SUCCEEDED',\n        data: formattedData,\n      });\n\n      dispatch({\n        type: 'SET_LINK_PERMISSIONS',\n        data: {\n          collectionTypesSectionLinks: collectionTypesSectionResults,\n          singleTypesSectionLinks: singleTypesSectionResults,\n        },\n      });\n    } catch (err) {\n      console.error(err);\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  // Make the getModels method available for all the other plugins\n  // So they can regenerate the menu when they need\n  // It's specially used in the content type builder\n  useImperativeHandle(ref, () => ({\n    getModels,\n  }));\n\n  useEffect(() => {\n    const getLinksPermissions = async () => {\n      const generalSectionLinksArrayOfPromises = generateArrayOfPromises(generalSectionLinks);\n      const pluginsSectionLinksArrayOfPromises = generateArrayOfPromises(pluginsSectionLinks);\n\n      await getModels();\n\n      const generalSectionResults = await Promise.all(generalSectionLinksArrayOfPromises);\n      const pluginsSectionResults = await Promise.all(pluginsSectionLinksArrayOfPromises);\n\n      dispatch({\n        type: 'SET_LINK_PERMISSIONS',\n        data: {\n          generalSectionLinks: generalSectionResults,\n          pluginsSectionLinks: pluginsSectionResults,\n        },\n      });\n\n      dispatch({\n        type: 'TOGGLE_IS_LOADING',\n      });\n    };\n\n    getLinksPermissions();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [permissions]);\n\n  return (\n    <Wrapper>\n      <Loader show={isLoading} />\n      <LeftMenuHeader />\n      <LinksContainer>\n        {collectTypesSectionLinksFiltered.length > 0 && (\n          <LeftMenuLinksSection\n            section=\"collectionType\"\n            name=\"collectionType\"\n            links={collectTypesSectionLinksFiltered}\n            location={location}\n            searchable\n          />\n        )}\n        {singleTypesSectionLinksFiltered.length > 0 && (\n          <LeftMenuLinksSection\n            section=\"singleType\"\n            name=\"singleType\"\n            links={singleTypesSectionLinksFiltered}\n            location={location}\n            searchable\n          />\n        )}\n\n        {pluginsSectionLinksFiltered.length > 0 && (\n          <LeftMenuLinksSection\n            section=\"plugins\"\n            name=\"plugins\"\n            links={pluginsSectionLinksFiltered}\n            location={location}\n            searchable={false}\n            emptyLinksListMessage=\"app.components.LeftMenuLinkContainer.noPluginsInstalled\"\n          />\n        )}\n        {generalSectionLinksFiltered.length > 0 && (\n          <LeftMenuLinksSection\n            section=\"general\"\n            name=\"general\"\n            links={generalSectionLinksFiltered}\n            location={location}\n            searchable={false}\n          />\n        )}\n      </LinksContainer>\n      <LeftMenuFooter key=\"footer\" version={version} />\n    </Wrapper>\n  );\n});\n\nLeftMenu.propTypes = {\n  shouldUpdateStrapi: PropTypes.bool.isRequired,\n  version: PropTypes.string.isRequired,\n  plugins: PropTypes.object.isRequired,\n};\n\nexport default memo(LeftMenu);\n",
    "packages/strapi-admin/admin/src/containers/MarketplacePage/index.js": "import React from 'react';\nimport { LoadingIndicatorPage, useGlobalContext, request } from 'strapi-helper-plugin';\nimport { Header } from '@buffetjs/custom';\nimport { useHistory } from 'react-router-dom';\n\nimport { useFetchPluginsFromMarketPlace } from '../../hooks';\nimport PageTitle from '../../components/PageTitle';\nimport PluginCard from './PluginCard';\nimport Wrapper from './Wrapper';\n\nconst MarketPlacePage = () => {\n  const history = useHistory();\n  const { autoReload, currentEnvironment, formatMessage, plugins } = useGlobalContext();\n  const { error, isLoading, data } = useFetchPluginsFromMarketPlace();\n\n  if (isLoading || error) {\n    return <LoadingIndicatorPage />;\n  }\n\n  const handleDownloadPlugin = async pluginId => {\n    // Force the Overlayblocker to be displayed\n    const overlayblockerParams = {\n      enabled: true,\n      title: 'app.components.InstallPluginPage.Download.title',\n      description: 'app.components.InstallPluginPage.Download.description',\n    };\n    // Lock the app\n    strapi.lockApp(overlayblockerParams);\n\n    try {\n      const opts = {\n        method: 'POST',\n        body: {\n          plugin: pluginId,\n          port: window.location.port,\n        },\n      };\n      const response = await request('/admin/plugins/install', opts, overlayblockerParams);\n\n      if (response.ok) {\n        // Reload the app\n        window.location.reload();\n      }\n    } catch (err) {\n      strapi.unlockApp();\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  return (\n    <div>\n      <PageTitle\n        title={formatMessage({\n          id: 'app.components.InstallPluginPage.helmet',\n        })}\n      />\n      <Wrapper>\n        <Header\n          title={{\n            label: formatMessage({\n              id: 'app.components.InstallPluginPage.title',\n            }),\n          }}\n          content={formatMessage({\n            id: 'app.components.InstallPluginPage.description',\n          })}\n        />\n        <div className=\"row\" style={{ paddingTop: '4.1rem' }}>\n          {data.map(plugin => {\n            return (\n              <PluginCard\n                autoReload={autoReload}\n                currentEnvironment={currentEnvironment}\n                downloadPlugin={handleDownloadPlugin}\n                key={plugin.id}\n                history={history}\n                plugin={plugin}\n                showSupportUsButton={false}\n                isAlreadyInstalled={plugins[plugin.id] !== undefined}\n              />\n            );\n          })}\n        </div>\n      </Wrapper>\n    </div>\n  );\n};\n\nexport default MarketPlacePage;\n",
    "packages/strapi-admin/admin/src/containers/Onboarding/index.js": "import React, { useEffect, useReducer, memo } from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport axios from 'axios';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faQuestion, faTimes } from '@fortawesome/free-solid-svg-icons';\nimport cn from 'classnames';\nimport { useGlobalContext } from 'strapi-helper-plugin';\n\nimport formatVideoArray from './utils/formatAndStoreVideoArray';\n\nimport StaticLinks from './StaticLinks';\nimport Video from './Video';\nimport Wrapper from './Wrapper';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\n\nconst OnboardingVideos = () => {\n  const { emitEvent } = useGlobalContext();\n  const [reducerState, dispatch] = useReducer(reducer, initialState, init);\n  const { isLoading, isOpen, videos } = reducerState.toJS();\n\n  useEffect(() => {\n    const getData = async () => {\n      try {\n        const { data } = await axios.get('https://strapi.io/videos', {\n          timeout: 1000,\n        });\n        const { didWatchVideos, videos } = formatVideoArray(data);\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          didWatchVideos,\n          videos,\n        });\n      } catch (err) {\n        console.error(err);\n        dispatch({\n          type: 'HIDE_VIDEO_ONBOARDING',\n        });\n      }\n    };\n\n    getData();\n  }, []);\n\n  // Hide the player in case of request error\n  if (isLoading) {\n    return null;\n  }\n\n  const handleClick = () => {\n    const eventName = isOpen\n      ? 'didOpenGetStartedVideoContainer'\n      : 'didCloseGetStartedVideoContainer';\n\n    dispatch({ type: 'SET_IS_OPEN' });\n    emitEvent(eventName);\n  };\n  const handleClickOpenVideo = videoIndexToOpen => {\n    dispatch({\n      type: 'TOGGLE_VIDEO_MODAL',\n      videoIndexToOpen,\n    });\n  };\n  const handleUpdateVideoStartTime = (videoIndex, elapsedTime) => {\n    dispatch({\n      type: 'UPDATE_VIDEO_STARTED_TIME_AND_PLAYED_INFOS',\n      videoIndex,\n      elapsedTime,\n    });\n  };\n  const setVideoDuration = (videoIndex, duration) => {\n    dispatch({\n      type: 'SET_VIDEO_DURATION',\n      duration,\n      videoIndex,\n    });\n  };\n\n  const hasVideos = videos.length > 0;\n  const className = hasVideos ? 'visible' : 'hidden';\n\n  return (\n    <Wrapper className={className} isOpen={isOpen}>\n      <div className={cn('videosContent', isOpen ? 'shown' : 'hide')}>\n        <div className=\"videosHeader\">\n          <p>\n            <FormattedMessage id=\"app.components.Onboarding.title\" />\n          </p>\n          <p>\n            {Math.floor((videos.filter(v => v.end).length * 100) / videos.length)}\n            <FormattedMessage id=\"app.components.Onboarding.label.completed\" />\n          </p>\n        </div>\n        <ul className=\"onboardingList\">\n          {videos.map((video, index) => (\n            <Video\n              key={video.id || index}\n              id={index}\n              video={video}\n              onClick={() => handleClickOpenVideo(index)}\n              setVideoDuration={(_, duration) => {\n                setVideoDuration(index, duration);\n              }}\n              getVideoCurrentTime={(_, elapsedTime) => {\n                handleUpdateVideoStartTime(index, elapsedTime);\n              }}\n              didPlayVideo={(_, elapsedTime) => {\n                const eventName = `didPlay${index}GetStartedVideo`;\n\n                emitEvent(eventName, { timestamp: elapsedTime });\n              }}\n              didStopVideo={(_, elapsedTime) => {\n                const eventName = `didStop${index}Video`;\n\n                emitEvent(eventName, { timestamp: elapsedTime });\n              }}\n            />\n          ))}\n        </ul>\n        <StaticLinks />\n      </div>\n      <div className=\"openBtn\">\n        <button onClick={handleClick} className={isOpen ? 'active' : ''} type=\"button\">\n          <FontAwesomeIcon icon={faQuestion} />\n          <FontAwesomeIcon icon={faTimes} />\n          <span />\n        </button>\n      </div>\n    </Wrapper>\n  );\n};\n\nexport default memo(OnboardingVideos);\n",
    "packages/strapi-admin/admin/src/containers/Roles/EditPage/index.js": "import React, { useState, useRef } from 'react';\nimport { useRouteMatch } from 'react-router-dom';\nimport { get, has, isEmpty } from 'lodash';\nimport { BaselineAlignment, useGlobalContext, request, difference } from 'strapi-helper-plugin';\nimport { Header } from '@buffetjs/custom';\nimport { Padded } from '@buffetjs/core';\nimport { Formik } from 'formik';\nimport { useIntl } from 'react-intl';\nimport PageTitle from '../../../components/SettingsPageTitle';\nimport ContainerFluid from '../../../components/ContainerFluid';\nimport { Permissions, RoleForm } from '../../../components/Roles';\nimport { useFetchRole, useFetchPermissionsLayout } from '../../../hooks';\nimport { formatPermissionsToApi } from '../../../utils';\nimport schema from './utils/schema';\n\nconst EditPage = () => {\n  const { formatMessage } = useIntl();\n  const { emitEvent, settingsBaseURL } = useGlobalContext();\n  const {\n    params: { id },\n  } = useRouteMatch(`${settingsBaseURL}/roles/:id`);\n  const [isSubmiting, setIsSubmiting] = useState(false);\n  const permissionsRef = useRef();\n\n  const { isLoading: isLayoutLoading, data: permissionsLayout } = useFetchPermissionsLayout(id);\n  const {\n    role,\n    permissions: rolePermissions,\n    isLoading: isRoleLoading,\n    onSubmitSucceeded,\n  } = useFetchRole(id);\n\n  /* eslint-disable indent */\n  const headerActions = (handleSubmit, handleReset) =>\n    isLayoutLoading && isRoleLoading\n      ? []\n      : [\n          {\n            label: formatMessage({\n              id: 'app.components.Button.reset',\n              defaultMessage: 'Reset',\n            }),\n            disabled: role.code === 'strapi-super-admin',\n            onClick: () => {\n              handleReset();\n              permissionsRef.current.resetForm();\n            },\n            color: 'cancel',\n            type: 'button',\n          },\n          {\n            label: formatMessage({\n              id: 'app.components.Button.save',\n              defaultMessage: 'Save',\n            }),\n            disabled: role.code === 'strapi-super-admin',\n            onClick: handleSubmit,\n            color: 'success',\n            type: 'submit',\n            isLoading: isSubmiting,\n          },\n        ];\n  /* eslint-enable indent */\n\n  const handleEditRoleSubmit = async data => {\n    try {\n      strapi.lockAppWithOverlay();\n      setIsSubmiting(true);\n\n      const permissionsToSend = permissionsRef.current.getPermissions();\n\n      const checkConditionsDiff = () => {\n        const diff = difference(\n          get(permissionsToSend, 'contentTypesPermissions', {}),\n          get(rolePermissions, 'contentTypesPermissions', {})\n        );\n\n        if (isEmpty(diff)) {\n          return false;\n        }\n\n        return Object.keys(diff).some(key => {\n          return has(diff, [key, 'conditions']);\n        });\n      };\n\n      await request(`/admin/roles/${id}`, {\n        method: 'PUT',\n        body: data,\n      });\n\n      if (role.code !== 'strapi-super-admin' && !isEmpty(permissionsToSend)) {\n        await request(`/admin/roles/${id}/permissions`, {\n          method: 'PUT',\n          body: {\n            permissions: formatPermissionsToApi(permissionsToSend),\n          },\n        });\n\n        if (checkConditionsDiff()) {\n          emitEvent('didUpdateConditions');\n        }\n      }\n\n      permissionsRef.current.setFormAfterSubmit();\n      onSubmitSucceeded({ name: data.name, description: data.description });\n\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: 'notification.success.saved' },\n      });\n    } catch (err) {\n      console.error(err.response);\n      const message = get(err, 'response.payload.message', 'An error occured');\n\n      strapi.notification.toggle({\n        type: 'warning',\n        message,\n      });\n    } finally {\n      setIsSubmiting(false);\n      strapi.unlockApp();\n    }\n  };\n\n  return (\n    <>\n      <PageTitle name=\"Roles\" />\n      <Formik\n        enableReinitialize\n        initialValues={{\n          name: role.name,\n          description: role.description,\n        }}\n        onSubmit={handleEditRoleSubmit}\n        validationSchema={schema}\n        validateOnChange={false}\n      >\n        {({ handleSubmit, values, errors, handleReset, handleChange, handleBlur }) => (\n          <form onSubmit={handleSubmit}>\n            <ContainerFluid padding=\"0\">\n              <Header\n                title={{\n                  label: formatMessage({\n                    id: 'Settings.roles.edit.title',\n                    defaultMessage: 'Edit a role',\n                  }),\n                }}\n                content={formatMessage({\n                  id: 'Settings.roles.create.description',\n                  defaultMessage: 'Define the rights given to the role',\n                })}\n                actions={headerActions(handleSubmit, handleReset)}\n                isLoading={isLayoutLoading || isRoleLoading}\n              />\n              <BaselineAlignment top size=\"3px\" />\n              <RoleForm\n                isLoading={isRoleLoading}\n                disabled={role.code === 'strapi-super-admin'}\n                errors={errors}\n                values={values}\n                onChange={handleChange}\n                onBlur={handleBlur}\n                role={role}\n              />\n              {!isLayoutLoading && !isRoleLoading && (\n                <Padded top bottom size=\"md\">\n                  <Permissions\n                    permissionsLayout={permissionsLayout}\n                    rolePermissions={rolePermissions}\n                    role={role}\n                    ref={permissionsRef}\n                  />\n                </Padded>\n              )}\n            </ContainerFluid>\n          </form>\n        )}\n      </Formik>\n    </>\n  );\n};\n\nexport default EditPage;\n",
    "packages/strapi-admin/admin/src/containers/Users/ListPage/index.js": "import React, { useCallback, useEffect, useMemo, useReducer, useRef, useState } from 'react';\nimport {\n  BaselineAlignment,\n  useQuery,\n  request,\n  useUserPermissions,\n  LoadingIndicatorPage,\n  PopUpWarning,\n} from 'strapi-helper-plugin';\nimport { get } from 'lodash';\nimport { useHistory, useLocation } from 'react-router-dom';\nimport { Flex, Padded } from '@buffetjs/core';\nimport PageTitle from '../../../components/SettingsPageTitle';\nimport { useSettingsHeaderSearchContext } from '../../../hooks';\nimport { Footer, List, Filter, FilterPicker, SortPicker } from '../../../components/Users';\nimport adminPermissions from '../../../permissions';\nimport Header from './Header';\nimport ModalForm from './ModalForm';\nimport getFilters from './utils/getFilters';\nimport init from './init';\nimport { initialState, reducer } from './reducer';\n\nconst ListPage = () => {\n  const {\n    isLoading: isLoadingForPermissions,\n    allowedActions: { canCreate, canDelete, canRead, canUpdate },\n  } = useUserPermissions(adminPermissions.settings.users);\n  const [isWarningDeleteAllOpened, setIsWarningDeleteAllOpened] = useState(false);\n  const [isModalOpened, setIsModalOpened] = useState(false);\n  const { toggleHeaderSearch } = useSettingsHeaderSearchContext();\n  const query = useQuery();\n  const { push } = useHistory();\n  const { search } = useLocation();\n  const filters = useMemo(() => {\n    return getFilters(search);\n  }, [search]);\n\n  const [\n    {\n      data,\n      dataToDelete,\n      isLoading,\n      pagination: { total },\n      shouldRefetchData,\n      showModalConfirmButtonLoading,\n    },\n    dispatch,\n  ] = useReducer(reducer, initialState, init);\n  const pageSize = parseInt(query.get('pageSize') || 10, 10);\n  const page = parseInt(query.get('page') || 0, 10);\n  const _sort = decodeURIComponent(query.get('_sort'));\n  const _q = decodeURIComponent(query.get('_q') || '');\n  const getDataRef = useRef();\n  const listRef = useRef();\n\n  getDataRef.current = async () => {\n    if (!canRead) {\n      dispatch({\n        type: 'UNSET_IS_LOADING',\n      });\n\n      return;\n    }\n    // Show the loading state and reset the state\n    dispatch({\n      type: 'GET_DATA',\n    });\n\n    try {\n      const {\n        data: { results, pagination },\n      } = await request(`/admin/users${search}`, { method: 'GET' });\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        data: results,\n        pagination,\n      });\n    } catch (err) {\n      console.error(err.response);\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  useEffect(() => {\n    if (!isLoadingForPermissions) {\n      getDataRef.current();\n    }\n  }, [search, isLoadingForPermissions]);\n\n  useEffect(() => {\n    if (canRead) {\n      toggleHeaderSearch({ id: 'Settings.permissions.menu.link.users.label' });\n    }\n\n    return () => {\n      if (canRead) {\n        toggleHeaderSearch();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [canRead]);\n\n  const handleChangeDataToDelete = ids => {\n    dispatch({\n      type: 'ON_CHANGE_DATA_TO_DELETE',\n      dataToDelete: ids,\n    });\n  };\n\n  const handleChangeFilter = ({ filter, name, value }) => {\n    const filterName = `${name}${filter}`;\n\n    updateSearchParams(filterName, encodeURIComponent(value), true);\n  };\n\n  const handleChangeFooterParams = ({ target: { name, value } }) => {\n    let paramName = name.split('.')[1].replace('_', '');\n\n    if (paramName === 'limit') {\n      paramName = 'pageSize';\n    }\n\n    updateSearchParams(paramName, value);\n  };\n\n  const handleChangeSort = ({ target: { name, value } }) => {\n    updateSearchParams(name, value);\n  };\n\n  const handleClickDeleteFilter = ({ target: { name } }) => {\n    const currentSearch = new URLSearchParams(search);\n\n    currentSearch.delete(name);\n\n    push({ search: currentSearch.toString() });\n  };\n\n  const handleClickDelete = useCallback(id => {\n    handleToggleModal();\n\n    dispatch({\n      type: 'ON_CHANGE_DATA_TO_DELETE',\n      dataToDelete: [id],\n    });\n  }, []);\n\n  const handleCloseModal = () => {\n    // Refetch data\n    getDataRef.current();\n  };\n\n  const handleClosedModalDelete = () => {\n    if (shouldRefetchData) {\n      getDataRef.current();\n    } else {\n      // Empty the selected ids when the modal closes\n      dispatch({\n        type: 'RESET_DATA_TO_DELETE',\n      });\n\n      // Reset the list's reducer dataToDelete state using a ref so we don't need an effect\n      listRef.current.resetDataToDelete();\n    }\n  };\n\n  const handleConfirmDeleteData = useCallback(async () => {\n    dispatch({\n      type: 'ON_DELETE_USERS',\n    });\n\n    let shouldDispatchSucceededAction = false;\n\n    try {\n      await request('/admin/users/batch-delete', {\n        method: 'POST',\n        body: {\n          ids: dataToDelete,\n        },\n      });\n      shouldDispatchSucceededAction = true;\n    } catch (err) {\n      const errorMessage = get(err, 'response.payload.data', 'An error occured');\n\n      strapi.notification.toggle({\n        type: 'warning',\n        message: errorMessage,\n      });\n    }\n\n    // Only dispatch the action once\n    if (shouldDispatchSucceededAction) {\n      dispatch({\n        type: 'ON_DELETE_USERS_SUCCEEDED',\n      });\n    }\n\n    handleToggleModal();\n  }, [dataToDelete]);\n\n  const handleToggle = () => setIsModalOpened(prev => !prev);\n\n  const handleToggleModal = () => setIsWarningDeleteAllOpened(prev => !prev);\n\n  const updateSearchParams = (name, value, shouldDeleteSearch = false) => {\n    const currentSearch = new URLSearchParams(search);\n    // Update the currentSearch\n    currentSearch.set(name, value);\n\n    if (shouldDeleteSearch) {\n      currentSearch.delete('_q');\n    }\n\n    push({\n      search: currentSearch.toString(),\n    });\n  };\n\n  if (isLoadingForPermissions) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <div>\n      <PageTitle name=\"Users\" />\n      <Header\n        canCreate={canCreate}\n        canDelete={canDelete}\n        canRead={canRead}\n        count={total}\n        dataToDelete={dataToDelete}\n        onClickAddUser={handleToggle}\n        onClickDelete={handleToggleModal}\n        isLoading={isLoading}\n      />\n      {canRead && (\n        <>\n          <BaselineAlignment top size=\"1px\">\n            <Flex flexWrap=\"wrap\">\n              <SortPicker onChange={handleChangeSort} value={_sort} />\n              <Padded right size=\"10px\" />\n              <BaselineAlignment bottom size=\"6px\">\n                <FilterPicker onChange={handleChangeFilter} />\n              </BaselineAlignment>\n              <Padded right size=\"10px\" />\n              {filters.map((filter, i) => (\n                // eslint-disable-next-line react/no-array-index-key\n                <Filter key={i} {...filter} onClick={handleClickDeleteFilter} />\n              ))}\n            </Flex>\n          </BaselineAlignment>\n          <BaselineAlignment top size=\"8px\" />\n          <Padded top size=\"sm\">\n            <List\n              canDelete={canDelete}\n              canUpdate={canUpdate}\n              dataToDelete={dataToDelete}\n              isLoading={isLoading}\n              data={data}\n              onChange={handleChangeDataToDelete}\n              onClickDelete={handleClickDelete}\n              searchParam={_q}\n              filters={filters}\n              ref={listRef}\n            />\n          </Padded>\n          <Footer\n            count={total}\n            onChange={handleChangeFooterParams}\n            params={{ _limit: pageSize, _page: page }}\n          />\n        </>\n      )}\n      <ModalForm isOpen={isModalOpened} onClosed={handleCloseModal} onToggle={handleToggle} />\n      <PopUpWarning\n        isOpen={isWarningDeleteAllOpened}\n        onClosed={handleClosedModalDelete}\n        onConfirm={handleConfirmDeleteData}\n        toggleModal={handleToggleModal}\n        isConfirmButtonLoading={showModalConfirmButtonLoading}\n      />\n    </div>\n  );\n};\n\nexport default ListPage;\n",
    "packages/strapi-admin/admin/src/containers/Webhooks/EditView/index.js": "/**\n *\n * EditView\n *\n */\n\nimport React, { useEffect, useMemo, useReducer, useRef, useState } from 'react';\nimport { useHistory, useRouteMatch } from 'react-router-dom';\nimport { get, isEmpty, isEqual, omit } from 'lodash';\nimport { Header, Inputs as InputsIndex } from '@buffetjs/custom';\nimport { Play } from '@buffetjs/icons';\nimport {\n  request,\n  useGlobalContext,\n  getYupInnerErrors,\n  BackHeader,\n  LoadingIndicatorPage,\n} from 'strapi-helper-plugin';\nimport { useModels } from '../../../hooks';\nimport PageTitle from '../../../components/SettingsPageTitle';\nimport { Inputs, TriggerContainer } from '../../../components/Webhooks';\nimport reducer, { initialState } from './reducer';\nimport { cleanData, form, schema } from './utils';\nimport Wrapper from './Wrapper';\n\nfunction EditView() {\n  const { isLoading: isLoadingForModels, collectionTypes } = useModels();\n\n  const isMounted = useRef();\n  const { formatMessage } = useGlobalContext();\n  const [submittedOnce, setSubmittedOnce] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [reducerState, dispatch] = useReducer(reducer, initialState);\n  const { push, replace } = useHistory();\n  const {\n    params: { id },\n  } = useRouteMatch('/settings/webhooks/:id');\n\n  const abortController = new AbortController();\n  const { signal } = abortController;\n  const isCreating = id === 'create';\n\n  const {\n    formErrors,\n    modifiedData,\n    initialData,\n    isLoading,\n    isTriggering,\n    triggerResponse,\n  } = reducerState.toJS();\n\n  useEffect(() => {\n    isMounted.current = true;\n\n    const fetchData = async () => {\n      try {\n        const { data } = await request(`/admin/webhooks/${id}`, {\n          method: 'GET',\n        });\n\n        if (isMounted.current) {\n          dispatch({\n            type: 'GET_DATA_SUCCEEDED',\n            data,\n          });\n        }\n      } catch (err) {\n        if (isMounted.current) {\n          dispatch({ type: 'UNSET_LOADER' });\n\n          if (err.code !== 20) {\n            strapi.notification.toggle({\n              type: 'warning',\n              message: { id: 'notification.error' },\n            });\n          }\n        }\n      }\n    };\n\n    if (!isCreating) {\n      fetchData();\n    } else {\n      dispatch({ type: 'UNSET_LOADER' });\n    }\n\n    return () => {\n      isMounted.current = false;\n      abortController.abort();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [id, isCreating]);\n\n  const areActionDisabled = isEqual(initialData, modifiedData);\n\n  const isTriggerActionDisabled = isCreating || (!isCreating && !areActionDisabled) || isTriggering;\n\n  const formattedErrors = Object.keys(formErrors)\n    .filter(key => key.includes('headers'))\n    .reduce((obj, key) => {\n      obj[key] = formErrors[key];\n\n      return obj;\n    }, {});\n\n  /* eslint-disable indent */\n  const headerTitle = isCreating\n    ? formatMessage({\n        id: 'Settings.webhooks.create',\n      })\n    : initialData.name;\n\n  const headersActions = [\n    {\n      color: 'primary',\n      disabled: isTriggerActionDisabled,\n      label: formatMessage({\n        id: 'Settings.webhooks.trigger',\n      }),\n      onClick: () => handleTrigger(),\n      title: isTriggerActionDisabled\n        ? formatMessage({\n            id: 'Settings.webhooks.trigger.save',\n          })\n        : null,\n      type: 'button',\n      icon: (\n        <Play width=\"8px\" height=\"10px\" fill={isTriggerActionDisabled ? '#b4b6ba' : '#ffffff'} />\n      ),\n    },\n    {\n      color: 'cancel',\n      disabled: areActionDisabled,\n      label: formatMessage({\n        id: 'app.components.Button.reset',\n      }),\n      onClick: () => handleReset(),\n      style: {\n        paddingLeft: '20px',\n        paddingRight: '20px',\n      },\n      type: 'button',\n    },\n    {\n      color: 'success',\n      disabled: areActionDisabled,\n      label: formatMessage({\n        id: 'app.components.Button.save',\n      }),\n      isLoading: isSubmitting,\n      style: {\n        minWidth: 140,\n      },\n      type: 'submit',\n    },\n  ];\n  /* eslint-enable indent */\n\n  const headerProps = {\n    title: {\n      label: headerTitle,\n    },\n    actions: headersActions,\n  };\n\n  const checkFormErrors = async (submit = false) => {\n    try {\n      await schema.validate(modifiedData, { abortEarly: false });\n\n      if (isMounted.current) {\n        setErrors({});\n\n        if (submit) {\n          submitForm();\n        }\n      }\n    } catch (err) {\n      if (isMounted.current) {\n        setErrors(getYupInnerErrors(err));\n\n        if (submit) {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.form.error.fields' },\n          });\n        }\n      }\n    }\n  };\n\n  const createWebhooks = async () => {\n    try {\n      strapi.lockAppWithOverlay();\n      setIsSubmitting(true);\n      const { data } = await request('/admin/webhooks', {\n        method: 'POST',\n        body: cleanData(modifiedData),\n      });\n      setIsSubmitting(false);\n      dispatch({\n        type: 'SUBMIT_SUCCEEDED',\n      });\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: 'Settings.webhooks.created' },\n      });\n      replace(`/settings/webhooks/${data.id}`);\n    } catch (err) {\n      setIsSubmitting(false);\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      strapi.unlockApp();\n    }\n  };\n\n  const getErrorMessage = error => {\n    if (!error) {\n      return null;\n    }\n\n    return formatMessage({\n      id: error.id,\n    });\n  };\n\n  const goToList = () => push('/settings/webhooks');\n\n  const handleChange = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: name.split('.'),\n      value,\n    });\n\n    if (submittedOnce) {\n      if (name === 'events') {\n        resetEventsError();\n      }\n      if (name.includes('headers')) {\n        resetHeadersError(name);\n      }\n    }\n  };\n\n  const handleClick = () => {\n    dispatch({\n      type: 'ADD_NEW_HEADER',\n      keys: ['headers'],\n    });\n  };\n\n  const handleTrigger = async () => {\n    dispatch({\n      type: 'SET_IS_TRIGGERING',\n    });\n\n    try {\n      const { data } = await request(`/admin/webhooks/${id}/trigger`, {\n        method: 'POST',\n        signal,\n      });\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'TRIGGER_SUCCEEDED',\n          response: data,\n        });\n      }\n    } catch (err) {\n      if (isMounted.current) {\n        if (err.code !== 20) {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n        dispatch({\n          type: 'SET_IS_TRIGGERING',\n        });\n      }\n    }\n  };\n\n  const handleRemove = index => {\n    dispatch({\n      type: 'ON_HEADER_REMOVE',\n      index,\n    });\n\n    resetHeadersErrors();\n  };\n\n  const handleReset = () =>\n    dispatch({\n      type: 'RESET_FORM',\n    });\n\n  const handleSubmit = e => {\n    e.preventDefault();\n    setSubmittedOnce(true);\n    checkFormErrors(true);\n  };\n\n  const onCancelTrigger = () => {\n    abortController.abort();\n\n    dispatch({\n      type: 'ON_TRIGGER_CANCELED',\n    });\n  };\n\n  const resetEventsError = () => {\n    const errors = formErrors;\n    delete errors.events;\n    setErrors(errors);\n  };\n\n  const resetHeadersError = keys => {\n    const errors = formErrors;\n\n    setErrors(omit(errors, [keys]));\n  };\n\n  const resetHeadersErrors = () => {\n    const errors = formErrors;\n    const newErrors = Object.keys(errors)\n      .filter(key => !key.includes('headers'))\n      .reduce((obj, key) => {\n        obj[key] = formErrors[key];\n\n        return obj;\n      }, {});\n\n    setErrors(newErrors);\n  };\n\n  const setErrors = errors => {\n    dispatch({\n      type: 'SET_ERRORS',\n      errors,\n    });\n  };\n\n  const submitForm = () => {\n    if (!isCreating) {\n      updateWebhook();\n    } else {\n      createWebhooks();\n    }\n  };\n\n  const updateWebhook = async () => {\n    try {\n      strapi.lockAppWithOverlay();\n      setIsSubmitting(true);\n\n      const body = cleanData(modifiedData);\n      delete body.id;\n\n      await request(`/admin/webhooks/${id}`, {\n        method: 'PUT',\n        body,\n      });\n      setIsSubmitting(false);\n      dispatch({\n        type: 'SUBMIT_SUCCEEDED',\n      });\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: 'notification.form.success.fields' },\n      });\n    } catch (err) {\n      setIsSubmitting(false);\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      strapi.unlockApp();\n    }\n  };\n\n  const shouldShowDPEvents = useMemo(\n    () => collectionTypes.some(ct => ct.options.draftAndPublish === true),\n    [collectionTypes]\n  );\n\n  if (isLoading || isLoadingForModels) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <Wrapper>\n      <PageTitle name=\"Webhooks\" />\n      <BackHeader onClick={goToList} />\n      <form onSubmit={handleSubmit}>\n        <Header {...headerProps} />\n        {(isTriggering || !isEmpty(triggerResponse)) && (\n          <div className=\"trigger-wrapper\">\n            <TriggerContainer\n              isPending={isTriggering}\n              response={triggerResponse}\n              onCancel={onCancelTrigger}\n            />\n          </div>\n        )}\n        <div className=\"form-wrapper\">\n          <div className=\"form-card\">\n            <div className=\"row\">\n              {Object.keys(form).map(key => {\n                return (\n                  <div key={key} className={form[key].styleName}>\n                    <InputsIndex\n                      {...form[key]}\n                      customInputs={{\n                        headers: Inputs,\n                        events: Inputs,\n                      }}\n                      label={formatMessage({\n                        id: form[key].label,\n                      })}\n                      error={getErrorMessage(get(formErrors, key, null))}\n                      name={key}\n                      onChange={handleChange}\n                      shouldShowDPEvents={shouldShowDPEvents}\n                      validations={form[key].validations}\n                      value={modifiedData[key] || form[key].value}\n                      {...(form[key].type === 'headers' && {\n                        onClick: handleClick,\n                        onRemove: handleRemove,\n                        customError: formattedErrors,\n                      })}\n                    />\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        </div>\n      </form>\n    </Wrapper>\n  );\n}\n\nexport default EditView;\n",
    "packages/strapi-admin/admin/src/containers/Webhooks/ListView/index.js": "/**\n *\n * ListView\n *\n */\n\nimport React, { useEffect, useReducer, useRef, useState } from 'react';\nimport { useHistory, useLocation } from 'react-router-dom';\nimport { Header, List } from '@buffetjs/custom';\nimport { Button } from '@buffetjs/core';\nimport { Plus } from '@buffetjs/icons';\nimport { omit } from 'lodash';\nimport { useIntl } from 'react-intl';\nimport {\n  request,\n  ListButton,\n  PopUpWarning,\n  useUserPermissions,\n  LoadingIndicatorPage,\n} from 'strapi-helper-plugin';\nimport adminPermissions from '../../../permissions';\nimport PageTitle from '../../../components/SettingsPageTitle';\nimport { EmptyList, ListRow } from '../../../components/Webhooks';\nimport Wrapper from './Wrapper';\nimport reducer, { initialState } from './reducer';\n\nfunction ListView() {\n  const {\n    isLoading,\n    allowedActions: { canCreate, canRead, canUpdate, canDelete },\n  } = useUserPermissions(adminPermissions.settings.webhooks);\n\n  const isMounted = useRef(true);\n  const { formatMessage } = useIntl();\n  const [showModal, setShowModal] = useState(false);\n  const [reducerState, dispatch] = useReducer(reducer, initialState);\n  const { push } = useHistory();\n  const { pathname } = useLocation();\n\n  const { webhooks, webhooksToDelete, webhookToDelete } = reducerState.toJS();\n\n  useEffect(() => {\n    isMounted.current = true;\n\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    if (canRead) {\n      fetchData();\n    }\n  }, [canRead]);\n\n  const getWebhookIndex = id => webhooks.findIndex(webhook => webhook.id === id);\n\n  // New button\n  const addBtnLabel = formatMessage({\n    id: 'Settings.webhooks.list.button.add',\n  });\n\n  const newButtonProps = {\n    label: addBtnLabel,\n    onClick: () => handleGoTo('create'),\n    color: 'primary',\n    type: 'button',\n    icon: <Plus fill=\"#007eff\" width=\"11px\" height=\"11px\" />,\n    Component: props => {\n      if (canCreate) {\n        return <Button {...props} />;\n      }\n\n      return null;\n    },\n  };\n\n  // Header props\n  const actions = [\n    {\n      ...newButtonProps,\n      icon: true,\n      style: {\n        paddingLeft: 15,\n        paddingRight: 15,\n      },\n    },\n  ];\n\n  const headerProps = {\n    title: {\n      label: formatMessage({ id: 'Settings.webhooks.title' }),\n    },\n    content: formatMessage({ id: 'Settings.webhooks.list.description' }),\n    actions,\n  };\n\n  // List props\n  const rowsCount = webhooks.length;\n  const titleLabel = `${\n    rowsCount > 1\n      ? formatMessage({ id: 'Settings.webhooks.title' })\n      : formatMessage({ id: 'Settings.webhooks.singular' })\n  }`;\n  const title = `${rowsCount} ${titleLabel}`;\n\n  /* eslint-disable indent */\n  const deleteButtonProps = canDelete\n    ? {\n        color: 'delete',\n        disabled: !(webhooksToDelete.length > 0),\n        label: formatMessage({ id: 'app.utils.delete' }),\n        onClick: () => setShowModal(true),\n        type: 'button',\n      }\n    : null;\n  /* eslint-enable indent */\n\n  const listProps = {\n    title,\n    button: deleteButtonProps,\n    items: webhooks,\n  };\n\n  const fetchData = async () => {\n    try {\n      const { data } = await request('/admin/webhooks', {\n        method: 'GET',\n      });\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data,\n        });\n      }\n    } catch (err) {\n      if (isMounted.current) {\n        if (err.code !== 20) {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      }\n    }\n  };\n\n  const handleChange = (value, id) => {\n    dispatch({\n      type: 'SET_WEBHOOKS_TO_DELETE',\n      value,\n      id,\n    });\n  };\n\n  const handleConfirmDelete = () => {\n    if (webhookToDelete) {\n      handleConfirmDeleteOne();\n    } else {\n      handleConfirmDeleteAll();\n    }\n  };\n\n  const handleConfirmDeleteOne = async () => {\n    try {\n      await request(`/admin/webhooks/${webhookToDelete}`, {\n        method: 'DELETE',\n      });\n\n      dispatch({\n        type: 'WEBHOOK_DELETED',\n        index: getWebhookIndex(webhookToDelete),\n      });\n    } catch (err) {\n      if (err.code !== 20) {\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      }\n    }\n    setShowModal(false);\n  };\n\n  const handleConfirmDeleteAll = async () => {\n    const body = {\n      ids: webhooksToDelete,\n    };\n\n    try {\n      await request('/admin/webhooks/batch-delete', {\n        method: 'POST',\n        body,\n      });\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'WEBHOOKS_DELETED',\n        });\n      }\n    } catch (err) {\n      if (isMounted.current) {\n        if (err.code !== 20) {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      }\n    }\n    setShowModal(false);\n  };\n\n  const handleDeleteClick = id => {\n    setShowModal(true);\n\n    dispatch({\n      type: 'SET_WEBHOOK_TO_DELETE',\n      id,\n    });\n  };\n\n  const handleEnabledChange = async (value, id) => {\n    const webhookIndex = getWebhookIndex(id);\n\n    const initialWebhookProps = webhooks[webhookIndex];\n    const keys = [webhookIndex, 'isEnabled'];\n\n    const body = {\n      ...initialWebhookProps,\n      isEnabled: value,\n    };\n\n    delete body.id;\n\n    try {\n      dispatch({\n        type: 'SET_WEBHOOK_ENABLED',\n        keys,\n        value,\n      });\n\n      await request(`/admin/webhooks/${id}`, {\n        method: 'PUT',\n        body,\n      });\n    } catch (err) {\n      if (isMounted.current) {\n        dispatch({\n          type: 'SET_WEBHOOK_ENABLED',\n          keys,\n          value: !value,\n        });\n\n        if (err.code !== 20) {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      }\n    }\n  };\n\n  const handleGoTo = to => {\n    push(`${pathname}/${to}`);\n  };\n\n  if (isLoading) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <Wrapper>\n      <PageTitle name=\"Webhooks\" />\n      <Header {...headerProps} />\n      {canRead && (\n        <div className=\"list-wrapper\">\n          {rowsCount > 0 ? (\n            <List\n              {...listProps}\n              customRowComponent={props => {\n                return (\n                  <ListRow\n                    {...props}\n                    canUpdate={canUpdate}\n                    canDelete={canDelete}\n                    onCheckChange={handleChange}\n                    onEditClick={handleGoTo}\n                    onDeleteCLick={handleDeleteClick}\n                    onEnabledChange={handleEnabledChange}\n                    itemsToDelete={webhooksToDelete}\n                  />\n                );\n              }}\n            />\n          ) : (\n            <EmptyList />\n          )}\n          <ListButton>{canCreate && <Button {...omit(newButtonProps, 'Component')} />}</ListButton>\n        </div>\n      )}\n      <PopUpWarning\n        isOpen={showModal}\n        toggleModal={() => setShowModal(!showModal)}\n        popUpWarningType=\"danger\"\n        onConfirm={handleConfirmDelete}\n      />\n    </Wrapper>\n  );\n}\n\nexport default ListView;\n",
    "packages/strapi-admin/admin/src/hooks/useFetchPermissionsLayout/index.js": "import { useEffect, useReducer } from 'react';\nimport { request } from 'strapi-helper-plugin';\n\nimport reducer, { initialState } from './reducer';\n\nconst useFetchPermissionsLayout = () => {\n  const [{ data, error, isLoading }, dispatch] = useReducer(reducer, initialState);\n\n  useEffect(() => {\n    const getData = async () => {\n      dispatch({\n        type: 'GET_DATA',\n      });\n\n      const { data } = await request('/admin/permissions', { method: 'GET' });\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        data,\n      });\n    };\n\n    getData();\n  }, []);\n\n  return { data, error, isLoading };\n};\n\nexport default useFetchPermissionsLayout;\n",
    "packages/strapi-admin/admin/src/hooks/useFetchPluginsFromMarketPlace/index.js": "import { useEffect, useState } from 'react';\nimport axios from 'axios';\nimport { useGlobalContext } from 'strapi-helper-plugin';\n\nconst useFetchPluginsFromMarketPlace = () => {\n  const { currentLocale } = useGlobalContext();\n  const [state, setState] = useState({\n    error: false,\n    isLoading: true,\n    data: null,\n  });\n\n  useEffect(() => {\n    const CancelToken = axios.CancelToken;\n    const source = CancelToken.source();\n\n    const getData = async () => {\n      try {\n        const { data } = await axios.get('https://marketplace.strapi.io/plugins', {\n          cancelToken: source.token,\n          params: { lang: currentLocale },\n        });\n\n        setState({\n          isLoading: false,\n          data,\n          error: false,\n        });\n      } catch (err) {\n        if (axios.isCancel(err)) {\n          // Silent\n        } else {\n          // handle error\n          setState(prev => ({ ...prev, isLoading: false, error: true }));\n        }\n      }\n    };\n\n    getData();\n\n    return () => {\n      source.cancel();\n    };\n  }, [currentLocale]);\n\n  return state;\n};\n\nexport default useFetchPluginsFromMarketPlace;\n",
    "packages/strapi-admin/admin/src/hooks/useFetchRole/index.js": "import { useCallback, useReducer, useEffect } from 'react';\nimport { request } from 'strapi-helper-plugin';\n\nimport reducer, { initialState } from './reducer';\nimport { formatPermissionsFromApi } from '../../utils';\n\nconst useFetchRole = id => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  useEffect(() => {\n    if (id) {\n      fetchRole(id);\n    } else {\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        role: {},\n        permissions: {},\n      });\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [id]);\n\n  const fetchRole = async roleId => {\n    try {\n      const [{ data: role }, { data: permissions }] = await Promise.all(\n        [`roles/${roleId}`, `roles/${roleId}/permissions`].map(endPoint =>\n          request(`/admin/${endPoint}`, { method: 'GET' })\n        )\n      );\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        role,\n        permissions: formatPermissionsFromApi(permissions),\n      });\n    } catch (err) {\n      console.error(err);\n\n      dispatch({\n        type: 'GET_DATA_ERROR',\n      });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  const handleSubmitSucceeded = useCallback(data => {\n    dispatch({\n      type: 'ON_SUBMIT_SUCCEEDED',\n      ...data,\n    });\n  }, []);\n\n  return { ...state, onSubmitSucceeded: handleSubmitSucceeded };\n};\n\nexport default useFetchRole;\n",
    "packages/strapi-admin/admin/src/hooks/useModels/index.js": "import { useReducer, useEffect } from 'react';\nimport { request } from 'strapi-helper-plugin';\n\nimport reducer, { initialState } from './reducer';\n\nconst useModels = () => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  useEffect(() => {\n    fetchModels();\n  }, []);\n\n  const fetchModels = async () => {\n    dispatch({\n      type: 'GET_MODELS',\n    });\n\n    try {\n      const [{ data: components }, { data: contentTypes }] = await Promise.all(\n        ['components', 'content-types'].map(endPoint =>\n          request(`/content-manager/${endPoint}`, { method: 'GET' })\n        )\n      );\n\n      dispatch({\n        type: 'GET_MODELS_SUCCEDED',\n        contentTypes,\n        components,\n      });\n    } catch (err) {\n      dispatch({\n        type: 'GET_MODELS_ERROR',\n      });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  return {\n    ...state,\n    getData: fetchModels,\n  };\n};\n\nexport default useModels;\n",
    "packages/strapi-admin/admin/src/hooks/useRolesList/index.js": "import { useEffect, useReducer } from 'react';\nimport { request } from 'strapi-helper-plugin';\nimport { get } from 'lodash';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\n\nconst useRolesList = (shouldFetchData = true) => {\n  const [{ roles, isLoading }, dispatch] = useReducer(reducer, initialState, () =>\n    init(initialState, shouldFetchData)\n  );\n\n  useEffect(() => {\n    if (shouldFetchData) {\n      fetchRolesList();\n    }\n  }, [shouldFetchData]);\n\n  const fetchRolesList = async () => {\n    try {\n      dispatch({\n        type: 'GET_DATA',\n      });\n\n      const { data } = await request('/admin/roles', { method: 'GET' });\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        data,\n      });\n    } catch (err) {\n      const message = get(err, ['response', 'payload', 'message'], 'An error occured');\n\n      dispatch({\n        type: 'GET_DATA_ERROR',\n      });\n\n      if (message !== 'Forbidden') {\n        strapi.notification.toggle({\n          type: 'warning',\n          message,\n        });\n      }\n    }\n  };\n\n  return { roles, isLoading, getData: fetchRolesList };\n};\n\nexport default useRolesList;\n",
    "packages/strapi-admin/admin/src/hooks/useSettingsMenu/index.js": "import { useContext, useEffect, useReducer } from 'react';\nimport { useGlobalContext, hasPermissions, UserContext } from 'strapi-helper-plugin';\n\nimport reducer, { initialState } from './reducer';\nimport init from './init';\n\nconst useSettingsMenu = (noCheck = false) => {\n  const permissions = useContext(UserContext);\n  const { plugins } = useGlobalContext();\n\n  const [{ isLoading, menu }, dispatch] = useReducer(reducer, initialState, () =>\n    init(initialState, plugins)\n  );\n\n  useEffect(() => {\n    const getData = async () => {\n      const checkPermissions = async (permissionsToCheck, path) => {\n        const hasPermission = await hasPermissions(permissions, permissionsToCheck);\n\n        return { hasPermission, path };\n      };\n\n      const generateArrayOfPromises = array => {\n        return array.reduce((acc, current, sectionIndex) => {\n          const generateArrayOfPromises = array =>\n            array.map((link, index) =>\n              checkPermissions(array[index].permissions, `${sectionIndex}.links.${index}`)\n            );\n\n          return [...acc, ...generateArrayOfPromises(current.links)];\n        }, []);\n      };\n\n      const generalSectionLinksArrayOfPromises = generateArrayOfPromises(menu);\n\n      const data = await Promise.all(generalSectionLinksArrayOfPromises);\n\n      dispatch({\n        type: 'CHECK_PERMISSIONS_SUCCEEDED',\n        data,\n      });\n    };\n\n    // This hook is also used by the main LeftMenu component in order to know which sections it needs to display/hide\n    // Therefore, we don't need to make the checking all the times when the hook is used.\n    if (!noCheck) {\n      getData();\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [permissions, noCheck]);\n\n  return { isLoading, menu };\n};\n\nexport default useSettingsMenu;\n",
    "packages/strapi-admin/admin/src/hooks/useUsersForm/index.js": "import { useEffect, useReducer } from 'react';\nimport { request } from 'strapi-helper-plugin';\nimport { get, has, omit } from 'lodash';\nimport { checkFormValidity, formatAPIErrors } from '../../utils';\nimport { initialState, reducer } from './reducer';\nimport init from './init';\n\nconst useUsersForm = (endPoint, schema, cbSuccess, fieldsToPick) => {\n  const [\n    { formErrors, initialData, isLoading, modifiedData, showHeaderButtonLoader, showHeaderLoader },\n    dispatch,\n  ] = useReducer(reducer, initialState, () => init(initialState, fieldsToPick));\n\n  useEffect(() => {\n    const getData = async () => {\n      try {\n        const { data } = await request(endPoint, { method: 'GET' });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data,\n          fieldsToPick,\n        });\n      } catch (err) {\n        console.error(err.response);\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      }\n    };\n\n    if (endPoint) {\n      getData();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [endPoint]);\n\n  const handleCancel = () => {\n    dispatch({\n      type: 'ON_CANCEL',\n    });\n  };\n\n  const handleChange = ({ target: { name, value, type: inputType } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      inputType,\n      keys: name,\n      value,\n    });\n  };\n\n  const handleSubmit = async e => {\n    e.preventDefault();\n    const errors = await checkFormValidity(modifiedData, schema);\n\n    dispatch({\n      type: 'SET_ERRORS',\n      errors: errors || {},\n    });\n\n    if (!errors) {\n      try {\n        strapi.lockAppWithOverlay();\n\n        dispatch({\n          type: 'ON_SUBMIT',\n        });\n\n        const cleanedData = omit(modifiedData, ['confirmPassword', 'registrationToken']);\n\n        if (cleanedData.roles) {\n          cleanedData.roles = cleanedData.roles.map(role => role.id);\n        }\n\n        const { data } = await request(endPoint, {\n          method: 'PUT',\n          body: cleanedData,\n        });\n\n        cbSuccess(data);\n\n        dispatch({\n          type: 'ON_SUBMIT_SUCCEEDED',\n          data,\n        });\n\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: 'notification.success.saved' },\n        });\n      } catch (err) {\n        const data = get(err, 'response.payload', { data: {} });\n\n        if (has(data, 'data') && typeof data.data === 'string') {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: data.data,\n          });\n        } else {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: data.message,\n          });\n        }\n\n        const apiErrors = formatAPIErrors(data);\n\n        dispatch({\n          type: 'SET_ERRORS',\n          errors: apiErrors,\n        });\n      } finally {\n        strapi.unlockApp();\n      }\n    }\n  };\n\n  return [\n    { formErrors, initialData, isLoading, modifiedData, showHeaderButtonLoader, showHeaderLoader },\n    dispatch,\n    { handleCancel, handleChange, handleSubmit },\n  ];\n};\n\nexport default useUsersForm;\n",
    "packages/strapi-admin/admin/src/utils/checkFormValidity.js": "import { getYupInnerErrors } from 'strapi-helper-plugin';\n\nconst checkFormValidity = async (data, schema) => {\n  let errors = null;\n\n  try {\n    await schema.validate(data, { abortEarly: false });\n  } catch (err) {\n    errors = getYupInnerErrors(err);\n  }\n\n  return errors;\n};\n\nexport default checkFormValidity;\n",
    "packages/strapi-admin/config/functions/bootstrap.js": "'use strict';\n\nconst adminActions = require('../admin-actions');\nconst adminConditions = require('../admin-conditions');\n\nconst registerPermissionActions = () => {\n  const { actionProvider } = strapi.admin.services.permission;\n  actionProvider.register(adminActions.actions);\n};\n\nconst registerAdminConditions = () => {\n  const { conditionProvider } = strapi.admin.services.permission;\n  conditionProvider.registerMany(adminConditions.conditions);\n};\n\nmodule.exports = async () => {\n  registerAdminConditions();\n  registerPermissionActions();\n  await strapi.admin.services.permission.cleanPermissionInDatabase();\n  await strapi.admin.services.permission.ensureBoundPermissionsInDatabase();\n  await strapi.admin.services.user.migrateUsers();\n  await strapi.admin.services.role.createRolesIfNoneExist();\n  await strapi.admin.services.role.resetSuperAdminPermissions();\n  await strapi.admin.services.role.displayWarningIfNoSuperAdmin();\n  await strapi.admin.services.user.displayWarningIfUsersDontHaveRole();\n\n  strapi.admin.destroy = () => {\n    strapi.admin.services.permission.conditionProvider.clear();\n    strapi.admin.services.permission.actionProvider.clear();\n  };\n};\n",
    "packages/strapi-admin/controllers/Webhooks.js": "'use strict';\n\nconst _ = require('lodash');\nconst { yup, formatYupErrors, webhook: webhookUtils } = require('strapi-utils');\n\nconst urlRegex = /^(?:([a-z0-9+.-]+):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9_]-*)*[a-z\\u00a1-\\uffff0-9_]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9_]-*)*[a-z\\u00a1-\\uffff0-9_]+)*\\.?)(?::\\d{2,5})?(?:[/?#]\\S*)?$/;\n\nconst webhookValidator = yup\n  .object({\n    name: yup.string().required(),\n    url: yup\n      .string()\n      .matches(urlRegex, 'url must be a valid URL')\n      .required(),\n    headers: yup.lazy(data => {\n      if (typeof data !== 'object') {\n        return yup.object().required();\n      }\n\n      return yup\n        .object(\n          _.mapValues(data, () => {\n            yup\n              .string()\n              .min(1)\n              .required();\n          })\n        )\n        .required();\n    }),\n    events: yup\n      .array()\n      .of(\n        yup\n          .string()\n          .oneOf(_.values(webhookUtils.webhookEvents))\n          .required()\n      )\n      .min(1)\n      .required(),\n  })\n  .noUnknown();\n\nconst updateWebhookValidator = webhookValidator.shape({\n  isEnabled: yup.boolean(),\n});\n\nmodule.exports = {\n  async listWebhooks(ctx) {\n    const webhooks = await strapi.webhookStore.findWebhooks();\n    ctx.send({ data: webhooks });\n  },\n\n  async getWebhook(ctx) {\n    const { id } = ctx.params;\n    const webhook = await strapi.webhookStore.findWebhook(id);\n\n    if (!webhook) {\n      return ctx.notFound('webhook.notFound');\n    }\n\n    ctx.send({ data: webhook });\n  },\n\n  async createWebhook(ctx) {\n    const { body } = ctx.request;\n\n    try {\n      await webhookValidator.validate(body, {\n        strict: true,\n        abortEarly: false,\n      });\n    } catch (error) {\n      return ctx.badRequest('ValidationError', {\n        errors: formatYupErrors(error),\n      });\n    }\n\n    const webhook = await strapi.webhookStore.createWebhook(body);\n\n    strapi.webhookRunner.add(webhook);\n\n    ctx.created({ data: webhook });\n  },\n\n  async updateWebhook(ctx) {\n    const { id } = ctx.params;\n    const { body } = ctx.request;\n\n    try {\n      await updateWebhookValidator.validate(body, {\n        strict: true,\n        abortEarly: false,\n      });\n    } catch (error) {\n      return ctx.badRequest('ValidationError', {\n        errors: formatYupErrors(error),\n      });\n    }\n\n    const webhook = await strapi.webhookStore.findWebhook(id);\n\n    if (!webhook) {\n      return ctx.notFound('webhook.notFound');\n    }\n\n    const updatedWebhook = await strapi.webhookStore.updateWebhook(id, {\n      ...webhook,\n      ...body,\n    });\n\n    if (!updatedWebhook) {\n      return ctx.notFound('webhook.notFound');\n    }\n\n    strapi.webhookRunner.update(updatedWebhook);\n\n    ctx.send({ data: updatedWebhook });\n  },\n\n  async deleteWebhook(ctx) {\n    const { id } = ctx.params;\n    const webhook = await strapi.webhookStore.findWebhook(id);\n\n    if (!webhook) {\n      return ctx.notFound('webhook.notFound');\n    }\n\n    await strapi.webhookStore.deleteWebhook(id);\n\n    strapi.webhookRunner.remove(webhook);\n\n    ctx.body = { data: webhook };\n  },\n\n  async deleteWebhooks(ctx) {\n    const { ids } = ctx.request.body;\n\n    if (!Array.isArray(ids) || ids.length === 0) {\n      return ctx.badRequest('ids must be an array of id');\n    }\n\n    for (const id of ids) {\n      const webhook = await strapi.webhookStore.findWebhook(id);\n\n      if (!webhook) continue;\n\n      await strapi.webhookStore.deleteWebhook(id);\n      strapi.webhookRunner.remove(webhook);\n    }\n\n    ctx.send({ data: ids });\n  },\n\n  async triggerWebhook(ctx) {\n    const { id } = ctx.params;\n\n    const webhook = await strapi.webhookStore.findWebhook(id);\n\n    const response = await strapi.webhookRunner.run(webhook, 'trigger-test', {});\n\n    ctx.body = { data: response };\n  },\n};\n",
    "packages/strapi-admin/controllers/admin.js": "'use strict';\n\nconst execa = require('execa');\nconst _ = require('lodash');\n\nconst PLUGIN_NAME_REGEX = /^[A-Za-z][A-Za-z0-9-_]+$/;\n\n/**\n * Validates a plugin name format\n */\nconst isValidPluginName = plugin => {\n  return _.isString(plugin) && !_.isEmpty(plugin) && PLUGIN_NAME_REGEX.test(plugin);\n};\n\n/**\n * A set of functions called \"actions\" for `Admin`\n */\n\nmodule.exports = {\n  async init() {\n    const uuid = strapi.config.get('uuid', false);\n    const hasAdmin = await strapi.admin.services.user.exists();\n\n    return { data: { uuid, hasAdmin } };\n  },\n\n  async information() {\n    const currentEnvironment = strapi.app.env;\n    const autoReload = strapi.config.get('autoReload', false);\n    const strapiVersion = strapi.config.get('info.strapi', null);\n    const nodeVersion = process.version;\n    const communityEdition = !strapi.EE;\n\n    return {\n      data: { currentEnvironment, autoReload, strapiVersion, nodeVersion, communityEdition },\n    };\n  },\n\n  async installPlugin(ctx) {\n    try {\n      const { plugin } = ctx.request.body;\n\n      if (!isValidPluginName(plugin)) {\n        return ctx.badRequest('Invalid plugin name');\n      }\n\n      strapi.reload.isWatching = false;\n\n      strapi.log.info(`Installing ${plugin}...`);\n      await execa('npm', ['run', 'strapi', '--', 'install', plugin]);\n\n      ctx.send({ ok: true });\n\n      strapi.reload();\n    } catch (err) {\n      strapi.log.error(err);\n      strapi.reload.isWatching = true;\n      ctx.badRequest(null, [{ messages: [{ id: 'An error occurred' }] }]);\n    }\n  },\n\n  async plugins(ctx) {\n    try {\n      const plugins = Object.keys(strapi.plugins).reduce((acc, key) => {\n        acc[key] = _.get(strapi.plugins, [key, 'package', 'strapi'], {\n          name: key,\n        });\n\n        return acc;\n      }, {});\n\n      ctx.send({ plugins });\n    } catch (err) {\n      strapi.log.error(err);\n      ctx.badRequest(null, [{ messages: [{ id: 'An error occurred' }] }]);\n    }\n  },\n\n  async uninstallPlugin(ctx) {\n    try {\n      const { plugin } = ctx.params;\n\n      if (!isValidPluginName(plugin)) {\n        return ctx.badRequest('Invalid plugin name');\n      }\n\n      strapi.reload.isWatching = false;\n\n      strapi.log.info(`Uninstalling ${plugin}...`);\n      await execa('npm', ['run', 'strapi', '--', 'uninstall', plugin, '-d']);\n\n      ctx.send({ ok: true });\n\n      strapi.reload();\n    } catch (err) {\n      strapi.log.error(err);\n      strapi.reload.isWatching = true;\n      ctx.badRequest(null, [{ messages: [{ id: 'An error occurred' }] }]);\n    }\n  },\n};\n",
    "packages/strapi-admin/controllers/authenticated-user.js": "'use strict';\n\nconst { validateProfileUpdateInput } = require('../validation/user');\n\nmodule.exports = {\n  async getMe(ctx) {\n    const userInfo = strapi.admin.services.user.sanitizeUser(ctx.state.user);\n\n    ctx.body = {\n      data: userInfo,\n    };\n  },\n\n  async updateMe(ctx) {\n    const input = ctx.request.body;\n\n    try {\n      await validateProfileUpdateInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const updatedUser = await strapi.admin.services.user.updateById(ctx.state.user.id, input);\n\n    ctx.body = {\n      data: strapi.admin.services.user.sanitizeUser(updatedUser),\n    };\n  },\n\n  async getOwnPermissions(ctx) {\n    const { findUserPermissions, sanitizePermission } = strapi.admin.services.permission;\n\n    const userPermissions = await findUserPermissions(ctx.state.user);\n\n    ctx.body = {\n      data: userPermissions.map(sanitizePermission),\n    };\n  },\n};\n",
    "packages/strapi-admin/controllers/authentication.js": "'use strict';\n\nconst passport = require('koa-passport');\nconst compose = require('koa-compose');\n\nconst {\n  validateRegistrationInput,\n  validateAdminRegistrationInput,\n  validateRegistrationInfoQuery,\n  validateForgotPasswordInput,\n  validateResetPasswordInput,\n} = require('../validation/authentication');\n\nmodule.exports = {\n  login: compose([\n    (ctx, next) => {\n      return passport.authenticate('local', { session: false }, (err, user, info) => {\n        if (err) {\n          return ctx.badImplementation();\n        }\n\n        if (!user) {\n          return ctx.badRequest(info.message);\n        }\n\n        ctx.state.user = user;\n        return next();\n      })(ctx, next);\n    },\n    ctx => {\n      const { user } = ctx.state;\n\n      ctx.body = {\n        data: {\n          token: strapi.admin.services.token.createJwtToken(user),\n          user: strapi.admin.services.user.sanitizeUser(ctx.state.user), // TODO: fetch more detailed info\n        },\n      };\n    },\n  ]),\n\n  renewToken(ctx) {\n    const { token } = ctx.request.body;\n\n    if (token === undefined) {\n      return ctx.badRequest('Missing token');\n    }\n\n    const { isValid, payload } = strapi.admin.services.token.decodeJwtToken(token);\n\n    if (!isValid) {\n      return ctx.badRequest('Invalid token');\n    }\n\n    ctx.body = {\n      data: {\n        token: strapi.admin.services.token.createJwtToken({ id: payload.id }),\n      },\n    };\n  },\n\n  async registrationInfo(ctx) {\n    try {\n      await validateRegistrationInfoQuery(ctx.request.query);\n    } catch (err) {\n      return ctx.badRequest('QueryError', err);\n    }\n\n    const { registrationToken } = ctx.request.query;\n\n    const registrationInfo = await strapi.admin.services.user.findRegistrationInfo(\n      registrationToken\n    );\n\n    if (!registrationInfo) {\n      return ctx.badRequest('Invalid registrationToken');\n    }\n\n    ctx.body = { data: registrationInfo };\n  },\n\n  async register(ctx) {\n    const input = ctx.request.body;\n\n    try {\n      await validateRegistrationInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const user = await strapi.admin.services.user.register(input);\n\n    ctx.body = {\n      data: {\n        token: strapi.admin.services.token.createJwtToken(user),\n        user: strapi.admin.services.user.sanitizeUser(user),\n      },\n    };\n  },\n\n  async registerAdmin(ctx) {\n    const input = ctx.request.body;\n\n    try {\n      await validateAdminRegistrationInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const hasAdmin = await strapi.admin.services.user.exists();\n\n    if (hasAdmin) {\n      return ctx.badRequest('You cannot register a new super admin');\n    }\n\n    const superAdminRole = await strapi.admin.services.role.getSuperAdmin();\n\n    if (!superAdminRole) {\n      throw new Error(\n        \"Cannot register the first admin because the super admin role doesn't exist.\"\n      );\n    }\n\n    const user = await strapi.admin.services.user.create({\n      ...input,\n      registrationToken: null,\n      isActive: true,\n      roles: superAdminRole ? [superAdminRole.id] : [],\n    });\n\n    await strapi.telemetry.send('didCreateFirstAdmin');\n\n    ctx.body = {\n      data: {\n        token: strapi.admin.services.token.createJwtToken(user),\n        user: strapi.admin.services.user.sanitizeUser(user),\n      },\n    };\n  },\n\n  async forgotPassword(ctx) {\n    const input = ctx.request.body;\n\n    try {\n      await validateForgotPasswordInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    strapi.admin.services.auth.forgotPassword(input);\n\n    ctx.status = 204;\n  },\n\n  async resetPassword(ctx) {\n    const input = ctx.request.body;\n\n    try {\n      await validateResetPasswordInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const user = await strapi.admin.services.auth.resetPassword(input);\n\n    ctx.body = {\n      data: {\n        token: strapi.admin.services.token.createJwtToken(user),\n        user: strapi.admin.services.user.sanitizeUser(user),\n      },\n    };\n  },\n};\n",
    "packages/strapi-admin/controllers/permission.js": "'use strict';\n\nconst { validateCheckPermissionsInput } = require('../validation/permission');\nconst { formatActionsBySections, formatConditions } = require('./formatters');\n\nmodule.exports = {\n  /**\n   * Check each permissions from `request.body.permissions` and returns an array of booleans\n   * @param {KoaContext} ctx - koa context\n   */\n  async check(ctx) {\n    const { body: input } = ctx.request;\n\n    try {\n      await validateCheckPermissionsInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const checkPermissions = strapi.admin.services.permission.engine.checkMany(\n      ctx.state.userAbility\n    );\n\n    ctx.body = {\n      data: checkPermissions(input.permissions),\n    };\n  },\n\n  /**\n   * Returns every permissions, in nested format\n   * @param {KoaContext} ctx - koa context\n   */\n  async getAll(ctx) {\n    const allActions = strapi.admin.services.permission.actionProvider.getAll();\n    const conditions = strapi.admin.services.permission.conditionProvider.getAll();\n\n    ctx.body = {\n      data: {\n        conditions: formatConditions(conditions),\n        sections: formatActionsBySections(allActions),\n      },\n    };\n  },\n};\n",
    "packages/strapi-admin/controllers/role.js": "'use strict';\n\nconst { yup, formatYupErrors } = require('strapi-utils');\nconst { validateRoleUpdateInput } = require('../validation/role');\nconst { validatedUpdatePermissionsInput } = require('../validation/permission');\nconst { EDITOR_CODE, AUTHOR_CODE, SUPER_ADMIN_CODE } = require('../services/constants');\n\nmodule.exports = {\n  /**\n   * Returns on role by id\n   * @param {KoaContext} ctx - koa context\n   */\n  async findOne(ctx) {\n    const { id } = ctx.params;\n    const role = await strapi.admin.services.role.findOneWithUsersCount({ id });\n\n    if (!role) {\n      return ctx.notFound('role.notFound');\n    }\n\n    ctx.body = {\n      data: role,\n    };\n  },\n\n  /**\n   * Returns every roles\n   * @param {KoaContext} ctx - koa context\n   */\n  async findAll(ctx) {\n    const roles = await strapi.admin.services.role.findAllWithUsersCount();\n\n    ctx.body = {\n      data: roles,\n    };\n  },\n\n  /**\n   * Updates a role by id\n   * @param {KoaContext} ctx - koa context\n   */\n  async update(ctx) {\n    const { id } = ctx.params;\n\n    try {\n      await validateRoleUpdateInput(ctx.request.body);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const role = await strapi.admin.services.role.findOne({ id });\n    if (!role) {\n      return ctx.notFound('role.notFound');\n    }\n\n    if (role.code === SUPER_ADMIN_CODE) {\n      return ctx.badRequest(\"Super admin can't be edited.\");\n    }\n\n    const updatedRole = await strapi.admin.services.role.update({ id }, ctx.request.body);\n\n    const sanitizedRole = strapi.admin.services.role.sanitizeRole(updatedRole);\n\n    ctx.body = {\n      data: sanitizedRole,\n    };\n  },\n\n  /**\n   * Returns the permissions assigned to a role\n   * @param {KoaContext} ctx - koa context\n   */\n  async getPermissions(ctx) {\n    const { id } = ctx.params;\n\n    const role = await strapi.admin.services.role.findOne({ id });\n\n    if (!role) {\n      return ctx.notFound('role.notFound');\n    }\n\n    const permissions = await strapi.admin.services.permission.find({ role: role.id, _limit: -1 });\n    const sanitizedPermissions = permissions.map(\n      strapi.admin.services.permission.sanitizePermission\n    );\n\n    ctx.body = {\n      data: sanitizedPermissions,\n    };\n  },\n\n  /**\n   * Updates the permissions assigned to a role\n   * @param {KoaContext} ctx - koa context\n   */\n  async updatePermissions(ctx) {\n    const { id } = ctx.params;\n    const input = ctx.request.body;\n\n    const role = await strapi.admin.services.role.findOne({ id });\n    if (!role) {\n      return ctx.notFound('role.notFound');\n    }\n\n    try {\n      if (role.code === SUPER_ADMIN_CODE) {\n        const err = new yup.ValidationError(\"Super admin permissions can't be edited.\");\n        throw formatYupErrors(err);\n      }\n      await validatedUpdatePermissionsInput(input, role);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    let existingPermissions = strapi.admin.services.permission.actionProvider.getAllByMap();\n    let permissionsToAssign;\n    if ([EDITOR_CODE, AUTHOR_CODE].includes(role.code)) {\n      permissionsToAssign = input.permissions.filter(\n        p => existingPermissions.get(p.action).section !== 'contentTypes'\n      );\n      const modifiedPermissions = input.permissions\n        .filter(p => existingPermissions.get(p.action).section === 'contentTypes')\n        .map(p => ({\n          ...p,\n          conditions: role.code === AUTHOR_CODE ? ['admin::is-creator'] : [],\n        }));\n      permissionsToAssign.push(...modifiedPermissions);\n    } else {\n      permissionsToAssign = input.permissions;\n    }\n\n    const permissions = await strapi.admin.services.role.assignPermissions(\n      role.id,\n      permissionsToAssign\n    );\n\n    ctx.body = {\n      data: permissions,\n    };\n  },\n};\n",
    "packages/strapi-admin/controllers/user.js": "'use strict';\n\nconst _ = require('lodash');\nconst {\n  validateUserCreationInput,\n  validateUserUpdateInput,\n  validateUsersDeleteInput,\n} = require('../validation/user');\n\nmodule.exports = {\n  async create(ctx) {\n    const { body } = ctx.request;\n\n    try {\n      await validateUserCreationInput(body);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const attributes = _.pick(body, ['firstname', 'lastname', 'email', 'roles']);\n\n    const userAlreadyExists = await strapi.admin.services.user.exists({\n      email: attributes.email,\n    });\n\n    if (userAlreadyExists) {\n      return ctx.badRequest('Email already taken');\n    }\n\n    const createdUser = await strapi.admin.services.user.create(attributes);\n\n    const userInfo = strapi.admin.services.user.sanitizeUser(createdUser);\n\n    // Send 201 created\n    ctx.created({ data: userInfo });\n  },\n\n  async find(ctx) {\n    const method = _.has(ctx.query, '_q') ? 'searchPage' : 'findPage';\n\n    const { results, pagination } = await strapi.admin.services.user[method](ctx.query);\n\n    ctx.body = {\n      data: {\n        results: results.map(strapi.admin.services.user.sanitizeUser),\n        pagination,\n      },\n    };\n  },\n\n  async findOne(ctx) {\n    const { id } = ctx.params;\n\n    const user = await strapi.admin.services.user.findOne({ id });\n\n    if (!user) {\n      return ctx.notFound('User does not exist');\n    }\n\n    ctx.body = {\n      data: strapi.admin.services.user.sanitizeUser(user),\n    };\n  },\n\n  async update(ctx) {\n    const { id } = ctx.params;\n    const { body: input } = ctx.request;\n\n    try {\n      await validateUserUpdateInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    if (_.has(input, 'email')) {\n      const uniqueEmailCheck = await strapi.admin.services.user.exists({\n        id_ne: id,\n        email: input.email,\n      });\n\n      if (uniqueEmailCheck) {\n        return ctx.badRequest('A user with this email address already exists');\n      }\n    }\n\n    const updatedUser = await strapi.admin.services.user.updateById(id, input);\n\n    if (!updatedUser) {\n      return ctx.notFound('User does not exist');\n    }\n\n    ctx.body = {\n      data: strapi.admin.services.user.sanitizeUser(updatedUser),\n    };\n  },\n\n  async deleteOne(ctx) {\n    const { id } = ctx.params;\n\n    const deletedUser = await strapi.admin.services.user.deleteById(id);\n\n    if (!deletedUser) {\n      return ctx.notFound('User not found');\n    }\n\n    return ctx.deleted({\n      data: strapi.admin.services.user.sanitizeUser(deletedUser),\n    });\n  },\n\n  /**\n   * Delete several users\n   * @param {KoaContext} ctx - koa context\n   */\n  async deleteMany(ctx) {\n    const { body } = ctx.request;\n    try {\n      await validateUsersDeleteInput(body);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const users = await strapi.admin.services.user.deleteByIds(body.ids);\n    const sanitizedUsers = users.map(strapi.admin.services.user.sanitizeUser);\n\n    return ctx.deleted({\n      data: sanitizedUsers,\n    });\n  },\n};\n",
    "packages/strapi-admin/ee/admin/containers/Roles/ListPage/index.js": "import React, { useEffect, useReducer, useRef, useState } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { Button } from '@buffetjs/core';\nimport { List, Header } from '@buffetjs/custom';\nimport { Plus } from '@buffetjs/icons';\nimport matchSorter from 'match-sorter';\nimport {\n  useGlobalContext,\n  useQuery,\n  ListButton,\n  PopUpWarning,\n  request,\n  useUserPermissions,\n  LoadingIndicatorPage,\n} from 'strapi-helper-plugin';\nimport { useIntl } from 'react-intl';\nimport adminPermissions from '../../../../../admin/src/permissions';\nimport PageTitle from '../../../../../admin/src/components/SettingsPageTitle';\nimport useSettingsHeaderSearchContext from '../../../../../admin/src/hooks/useSettingsHeaderSearchContext';\nimport { EmptyRole, RoleListWrapper } from '../../../../../admin/src/components/Roles';\nimport { useRolesList } from '../../../../../admin/src/hooks';\nimport RoleRow from './RoleRow';\nimport BaselineAlignment from './BaselineAlignment';\nimport reducer, { initialState } from './reducer';\n\nconst RoleListPage = () => {\n  const { settingsBaseURL } = useGlobalContext();\n  const [isWarningDeleteAllOpened, setIsWarningDeleteAllOpenend] = useState(false);\n  const { formatMessage } = useIntl();\n  const { push } = useHistory();\n  const [{ selectedRoles, showModalConfirmButtonLoading, shouldRefetchData }, dispath] = useReducer(\n    reducer,\n    initialState\n  );\n  const {\n    isLoading: isLoadingForPermissions,\n    allowedActions: { canCreate, canDelete, canRead, canUpdate },\n  } = useUserPermissions(adminPermissions.settings.roles);\n  const { getData, roles, isLoading } = useRolesList(false);\n  const getDataRef = useRef(getData);\n  const { toggleHeaderSearch } = useSettingsHeaderSearchContext();\n  const query = useQuery();\n  const _q = decodeURIComponent(query.get('_q') || '');\n  const results = matchSorter(roles, _q, { keys: ['name', 'description'] });\n\n  useEffect(() => {\n    // Show the search bar only if the user is allowed to read\n    if (canRead) {\n      toggleHeaderSearch({ id: 'Settings.permissions.menu.link.roles.label' });\n    }\n\n    return () => {\n      if (canRead) {\n        toggleHeaderSearch();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [canRead]);\n\n  useEffect(() => {\n    if (!isLoadingForPermissions && canRead) {\n      getDataRef.current();\n    }\n  }, [isLoadingForPermissions, canRead]);\n\n  const handleClosedModal = () => {\n    if (shouldRefetchData) {\n      getData();\n    }\n\n    // Empty the selected ids when the modal closes\n    dispath({\n      type: 'RESET_DATA_TO_DELETE',\n    });\n  };\n\n  const handleConfirmDeleteData = async () => {\n    try {\n      dispath({\n        type: 'ON_REMOVE_ROLES',\n      });\n      const filteredRoles = selectedRoles.filter(currentId => {\n        const currentRole = roles.find(role => role.id === currentId);\n\n        return currentRole.usersCount === 0;\n      });\n\n      if (selectedRoles.length !== filteredRoles.length) {\n        strapi.notification.toggle({\n          type: 'info',\n          message: { id: 'Roles.ListPage.notification.delete-all-not-allowed' },\n        });\n      }\n\n      if (filteredRoles.length) {\n        await request('/admin/roles/batch-delete', {\n          method: 'POST',\n          body: {\n            ids: filteredRoles,\n          },\n        });\n\n        // Empty the selectedRolesId and set the shouldRefetchData to true so the\n        // list is updated when closing the modal\n        dispath({\n          type: 'ON_REMOVE_ROLES_SUCCEEDED',\n        });\n      }\n    } catch (err) {\n      console.error(err);\n\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      handleToggleModal();\n    }\n  };\n\n  const handleDuplicateRole = id => {\n    push(`${settingsBaseURL}/roles/duplicate/${id}`);\n  };\n\n  const handleNewRoleClick = () => push(`${settingsBaseURL}/roles/new`);\n\n  const handleRemoveRole = roleId => {\n    dispath({\n      type: 'SET_ROLE_TO_DELETE',\n      id: roleId,\n    });\n\n    handleToggleModal();\n  };\n\n  const handleRoleToggle = roleId => {\n    dispath({\n      type: 'ON_SELECTION',\n      id: roleId,\n    });\n  };\n\n  const handleToggleModal = () => setIsWarningDeleteAllOpenend(prev => !prev);\n\n  /* eslint-disable indent */\n  const headerActions = canCreate\n    ? [\n        {\n          label: formatMessage({\n            id: 'Settings.roles.list.button.add',\n            defaultMessage: 'Add new role',\n          }),\n          onClick: handleNewRoleClick,\n          color: 'primary',\n          type: 'button',\n          icon: true,\n        },\n      ]\n    : [];\n  /* eslint-enable indent */\n\n  const resultsCount = results.length;\n\n  if (isLoadingForPermissions) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <>\n      <PageTitle name=\"Roles\" />\n      <Header\n        title={{\n          label: formatMessage({\n            id: 'Settings.roles.title',\n            defaultMessage: 'roles',\n          }),\n        }}\n        content={formatMessage({\n          id: 'Settings.roles.list.description',\n          defaultMessage: 'List of roles',\n        })}\n        actions={headerActions}\n        isLoading={isLoading}\n      />\n      <BaselineAlignment />\n      {canRead && (\n        <RoleListWrapper>\n          <List\n            title={formatMessage(\n              {\n                id: `Settings.roles.list.title${resultsCount > 1 ? '.plural' : '.singular'}`,\n                defaultMessage: `{number} ${resultsCount > 1 ? 'roles' : 'role'}`,\n              },\n              { number: resultsCount }\n            )}\n            isLoading={isLoading}\n            /* eslint-disable indent */\n            button={\n              canDelete\n                ? {\n                    color: 'delete',\n                    disabled: selectedRoles.length === 0,\n                    label: formatMessage({ id: 'app.utils.delete', defaultMessage: 'Delete' }),\n                    onClick: handleToggleModal,\n                    type: 'button',\n                  }\n                : null\n            }\n            /* eslint-enable indent */\n            items={results}\n            customRowComponent={role => (\n              <RoleRow\n                canCreate={canCreate}\n                canDelete={canDelete}\n                canUpdate={canUpdate}\n                selectedRoles={selectedRoles}\n                onRoleDuplicate={handleDuplicateRole}\n                onRoleRemove={handleRemoveRole}\n                onRoleToggle={handleRoleToggle}\n                role={role}\n              />\n            )}\n          />\n          {!resultsCount && !isLoading && <EmptyRole />}\n          {canCreate && (\n            <ListButton>\n              <Button\n                onClick={handleNewRoleClick}\n                icon={<Plus fill=\"#007eff\" width=\"11px\" height=\"11px\" />}\n                label={formatMessage({\n                  id: 'Settings.roles.list.button.add',\n                  defaultMessage: 'Add new role',\n                })}\n              />\n            </ListButton>\n          )}\n        </RoleListWrapper>\n      )}\n      <PopUpWarning\n        isOpen={isWarningDeleteAllOpened}\n        onClosed={handleClosedModal}\n        onConfirm={handleConfirmDeleteData}\n        toggleModal={handleToggleModal}\n        isConfirmButtonLoading={showModalConfirmButtonLoading}\n      />\n    </>\n  );\n};\n\nexport default RoleListPage;\n",
    "packages/strapi-admin/ee/controllers/role.js": "'use strict';\n\nconst { yup, formatYupErrors } = require('strapi-utils');\nconst {\n  validateRoleCreateInput,\n  validateRoleDeleteInput,\n  validateRolesDeleteInput,\n} = require('../validation/role');\nconst { validatedUpdatePermissionsInput } = require('../validation/permission');\nconst { SUPER_ADMIN_CODE } = require('../../services/constants');\n\nmodule.exports = {\n  /**\n   * Create a new role\n   * @param {KoaContext} ctx - koa context\n   */\n  async create(ctx) {\n    try {\n      await validateRoleCreateInput(ctx.request.body);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    let role = await strapi.admin.services.role.create(ctx.request.body);\n\n    const sanitizedRole = strapi.admin.services.role.sanitizeRole(role);\n    ctx.created({ data: sanitizedRole });\n  },\n\n  /**\n   * Delete a role\n   * @param {KoaContext} ctx - koa context\n   */\n  async deleteOne(ctx) {\n    const { id } = ctx.params;\n\n    try {\n      await validateRoleDeleteInput(id);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const roles = await strapi.admin.services.role.deleteByIds([id]);\n\n    const sanitizedRole = roles.map(strapi.admin.services.role.sanitizeRole)[0] || null;\n\n    return ctx.deleted({\n      data: sanitizedRole,\n    });\n  },\n\n  /**\n   * delete several roles\n   * @param {KoaContext} ctx - koa context\n   */\n  async deleteMany(ctx) {\n    const { body } = ctx.request;\n    try {\n      await validateRolesDeleteInput(body);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const roles = await strapi.admin.services.role.deleteByIds(body.ids);\n    const sanitizedRoles = roles.map(strapi.admin.services.role.sanitizeRole);\n\n    return ctx.deleted({\n      data: sanitizedRoles,\n    });\n  },\n\n  /**\n   * Updates the permissions assigned to a role\n   * @param {KoaContext} ctx - koa context\n   */\n  async updatePermissions(ctx) {\n    const { id } = ctx.params;\n    const input = ctx.request.body;\n\n    const role = await strapi.admin.services.role.findOne({ id });\n    if (!role) {\n      return ctx.notFound('role.notFound');\n    }\n\n    try {\n      if (role.code === SUPER_ADMIN_CODE) {\n        const err = new yup.ValidationError(\"Super admin permissions can't be edited.\");\n        throw formatYupErrors(err);\n      }\n      await validatedUpdatePermissionsInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    if (!role) {\n      return ctx.notFound('role.notFound');\n    }\n\n    const permissions = await strapi.admin.services.role.assignPermissions(\n      role.id,\n      input.permissions\n    );\n\n    ctx.body = {\n      data: permissions,\n    };\n  },\n};\n",
    "packages/strapi-admin/ee/validation/role.js": "'use strict';\n\nconst { yup, formatYupErrors, stringIncludes, stringEquals } = require('strapi-utils');\n\nconst handleReject = error => Promise.reject(formatYupErrors(error));\n\nconst roleCreateSchema = yup\n  .object()\n  .shape({\n    name: yup\n      .string()\n      .min(1)\n      .required(),\n    description: yup.string().nullable(),\n  })\n  .noUnknown();\n\nconst rolesDeleteSchema = yup\n  .object()\n  .shape({\n    ids: yup\n      .array()\n      .of(yup.strapiID())\n      .min(1)\n      .required()\n      .test('no-admin-many-delete', 'You cannot delete the super admin role', async ids => {\n        const superAdminRole = await strapi.admin.services.role.getSuperAdmin();\n        return !superAdminRole || !stringIncludes(ids, superAdminRole.id);\n      }),\n  })\n  .noUnknown();\n\nconst roleDeleteSchema = yup\n  .strapiID()\n  .required()\n  .test('no-admin-single-delete', 'You cannot delete the super admin role', async function(id) {\n    const superAdminRole = await strapi.admin.services.role.getSuperAdmin();\n    return !superAdminRole || !stringEquals(id, superAdminRole.id)\n      ? true\n      : this.createError({ path: 'id', message: `You cannot delete the super admin role` });\n  });\n\nconst validateRoleCreateInput = async data => {\n  return roleCreateSchema.validate(data, { strict: true, abortEarly: false }).catch(handleReject);\n};\n\nconst validateRolesDeleteInput = async data => {\n  return rolesDeleteSchema.validate(data, { strict: true, abortEarly: false }).catch(handleReject);\n};\n\nconst validateRoleDeleteInput = async data => {\n  return roleDeleteSchema.validate(data, { strict: true, abortEarly: false }).catch(handleReject);\n};\n\nmodule.exports = {\n  validateRoleCreateInput,\n  validateRolesDeleteInput,\n  validateRoleDeleteInput,\n};\n",
    "packages/strapi-admin/middlewares/auth/index.js": "'use strict';\n\nconst passport = require('koa-passport');\nconst { Strategy: LocalStrategy } = require('passport-local');\n\nconst createLocalStrategy = strapi => {\n  return new LocalStrategy(\n    {\n      usernameField: 'email',\n      passwordField: 'password',\n      session: false,\n    },\n    function(email, password, done) {\n      return strapi.admin.services.auth\n        .checkCredentials({ email, password })\n        .then(([error, user, message]) => done(error, user, message))\n        .catch(error => done(error));\n    }\n  );\n};\n\nmodule.exports = strapi => ({\n  initialize() {\n    passport.use(createLocalStrategy(strapi));\n\n    strapi.app.use(passport.initialize());\n\n    strapi.app.use(async (ctx, next) => {\n      if (\n        ctx.request.header.authorization &&\n        ctx.request.header.authorization.split(' ')[0] === 'Bearer'\n      ) {\n        const token = ctx.request.header.authorization.split(' ')[1];\n\n        const { payload, isValid } = strapi.admin.services.token.decodeJwtToken(token);\n\n        if (isValid) {\n          // request is made by an admin\n          const admin = await strapi.query('user', 'admin').findOne({ id: payload.id }, ['roles']);\n\n          if (!admin || !(admin.isActive === true)) {\n            return ctx.forbidden('Invalid credentials');\n          }\n\n          ctx.state.admin = admin;\n          ctx.state.user = admin;\n          ctx.state.userAbility = await strapi.admin.services.permission.engine.generateUserAbility(\n            admin\n          );\n          ctx.state.isAuthenticatedAdmin = true;\n          return next();\n        }\n      }\n\n      return next();\n    });\n  },\n});\n",
    "packages/strapi-admin/services/__tests__/action-provider.test.js": "'use strict';\nconst _ = require('lodash');\nconst domain = require('../../domain/action');\nconst actionProviderService = require('../permission/action-provider');\n\ndescribe('Action Provider Service', () => {\n  beforeEach(() => {\n    global.strapi = {\n      plugins: { aPlugin: {} },\n    };\n  });\n\n  describe('settings', () => {\n    const readAction = {\n      uid: 'marketplace.read',\n      displayName: 'Can read',\n      pluginName: 'admin',\n      section: 'settings',\n      category: 'plugins and marketplace',\n      subCategory: 'marketplace',\n    };\n\n    const createAction = {\n      uid: 'marketplace.create',\n      displayName: 'Can create',\n      pluginName: 'admin',\n      section: 'settings',\n      category: 'plugins and marketplace',\n    };\n\n    test('Can register a settings action', async () => {\n      await actionProviderService.register([readAction]);\n      const createdAction = actionProviderService.get(readAction.uid, readAction.pluginName);\n\n      expect(createdAction).toMatchObject({\n        ..._.omit(readAction, ['uid']),\n        actionId: 'admin::marketplace.read',\n      });\n    });\n\n    test('Can register a settings action without subCategory', async () => {\n      await actionProviderService.register([createAction]);\n      const createdAction = actionProviderService.get(createAction.uid, createAction.pluginName);\n\n      expect(createdAction).toMatchObject({\n        ..._.omit(createAction, ['uid']),\n        actionId: 'admin::marketplace.create',\n        subCategory: 'general',\n      });\n    });\n\n    test('Can get all registered entries (array)', () => {\n      expect(actionProviderService.getAll()).toHaveLength(2);\n    });\n\n    test('Can get all registered entries (map)', () => {\n      expect(actionProviderService.getAllByMap().size).toBe(2);\n    });\n\n    test('Can get an action by its actionId', () => {\n      const actionId = 'admin::marketplace.create';\n      const expected = domain.createAction(createAction);\n      expect(actionProviderService.getByActionId(actionId)).toStrictEqual(expected);\n    });\n\n    test('Can register a settings action with a pluginName other than \"admin\"', async () => {\n      const action = {\n        uid: 'marketplace.update',\n        displayName: 'Can update',\n        pluginName: 'aPlugin',\n        section: 'settings',\n        category: 'plugins and marketplace',\n      };\n\n      await actionProviderService.register([action]);\n      const createdAction = actionProviderService.get(action.uid, action.pluginName);\n\n      expect(createdAction).toMatchObject({\n        ..._.omit(action, ['uid']),\n        actionId: 'plugins::aPlugin.marketplace.update',\n      });\n    });\n\n    test('Cannot register a settings action with a non standard name', async () => {\n      const action = {\n        uid: 'Marketplace Read',\n        displayName: 'Access the marketplace',\n        pluginName: 'aPlugin',\n        section: 'settings',\n        category: 'plugins and marketplace',\n      };\n\n      expect(() => actionProviderService.register([action])).toThrow(\n        '[0].uid: The id can only contain lowercase letters, dots and hyphens.'\n      );\n    });\n\n    test('Cannot register actions with same actionId', async () => {\n      global.strapi.stopWithError = jest.fn(() => {});\n\n      const action1 = {\n        uid: 'marketplace.delete',\n        displayName: 'Can delete',\n        pluginName: 'aPlugin',\n        section: 'settings',\n        category: 'plugins and marketplace',\n      };\n\n      const action2 = {\n        uid: action1.uid,\n        displayName: 'delete',\n        pluginName: 'aPlugin',\n        section: 'plugins',\n      };\n\n      expect(() => actionProviderService.register([action1, action2])).toThrow(\n        'Duplicated action id: plugins::aPlugin.marketplace.delete. You may want to change the actions name.'\n      );\n    });\n\n    test(\"Cannot register a settings action with a pluginName that doesn't exist\", async () => {\n      const action = {\n        uid: 'marketplace.read',\n        displayName: 'Access the marketplace',\n        pluginName: 'plugin-name-that-doesnt-exist',\n        section: 'settings',\n        category: 'plugins and marketplace',\n      };\n\n      expect(() => actionProviderService.register([action])).toThrow(\n        '[0].pluginName is not an existing plugin'\n      );\n    });\n\n    test('Cannot register a settings action without category', async () => {\n      const action = {\n        uid: 'marketplace.read',\n        displayName: 'Access the marketplace',\n        pluginName: 'admin',\n        section: 'settings',\n      };\n\n      expect(() => actionProviderService.register([action])).toThrow(\n        '[0].category is a required field'\n      );\n    });\n\n    test('Cannot register an action outside of the bootstrap function', async () => {\n      global.strapi = {\n        isLoaded: true,\n      };\n\n      expect(() => actionProviderService.register([])).toThrow(\n        `You can't register new actions outside of the bootstrap function.`\n      );\n    });\n  });\n});\n",
    "packages/strapi-admin/services/__tests__/permission.test.js": "'use strict';\n\nconst _ = require('lodash');\nconst permissionService = require('../permission');\n\ndescribe('Permission Service', () => {\n  describe('Find permissions', () => {\n    test('Find calls the right db query', async () => {\n      const find = jest.fn(() => Promise.resolve([]));\n      global.strapi = {\n        query() {\n          return { find };\n        },\n      };\n\n      await permissionService.find({ role: 1 });\n\n      expect(find).toHaveBeenCalledWith({ role: 1 }, []);\n    });\n  });\n\n  describe('Find User Permissions', () => {\n    test('Find calls the right db query', async () => {\n      const find = jest.fn(({ role_in }) => role_in);\n\n      global.strapi = {\n        query() {\n          return { find };\n        },\n      };\n\n      const rolesId = [1, 2];\n\n      const res = await permissionService.findUserPermissions({\n        roles: rolesId.map(id => ({ id })),\n      });\n\n      expect(find).toHaveBeenCalledWith({ role_in: rolesId, _limit: -1 });\n      expect(res).toStrictEqual(rolesId);\n    });\n\n    test('Returns default result when no roles provided', async () => {\n      const res = await permissionService.findUserPermissions({});\n\n      expect(res).toStrictEqual([]);\n    });\n  });\n\n  describe('Sanitize Permission', () => {\n    test('Removes unwanted properties', () => {\n      const removeUnkownConditionIds = jest.fn(() => ['cond']);\n      global.strapi = {\n        admin: { services: { condition: { removeUnkownConditionIds } } },\n      };\n      const permission = {\n        action: 'read',\n        subject: 'article',\n        fields: ['*'],\n        conditions: ['cond', 'unknown-cond'],\n        foo: 'bar',\n      };\n\n      const sanitizedPermission = permissionService.sanitizePermission(permission);\n\n      expect(sanitizedPermission.foo).toBeUndefined();\n      expect(sanitizedPermission).toMatchObject({\n        ..._.omit(permission, 'foo'),\n        conditions: ['cond'],\n      });\n    });\n  });\n\n  describe('cleanPermissionInDatabase', () => {\n    test('Remove permission that dont exist + clean fields', async () => {\n      const permsInDb = [\n        {\n          id: 1,\n          action: 'action-1',\n          fields: ['name'],\n        },\n        {\n          id: 2,\n          action: 'action-2',\n          fields: ['name'],\n        },\n        {\n          id: 3,\n          action: 'action-3',\n          subject: 'country',\n          fields: ['name'],\n        },\n        {\n          id: 4,\n          action: 'action-3',\n          subject: 'planet',\n          fields: ['name'],\n        },\n        {\n          id: 5,\n          action: 'action-1',\n          subject: 'planet',\n          fields: ['name', 'description'],\n        },\n        {\n          id: 6,\n          action: 'action-1',\n          subject: 'country',\n          fields: null,\n        },\n      ];\n\n      const permsWithCleanFields = [\n        permsInDb[0],\n        permsInDb[2],\n        { ...permsInDb[4], fields: ['name', 'galaxy'] },\n        { ...permsInDb[5], fields: ['name'] },\n      ];\n\n      const findPage = jest.fn(() =>\n        Promise.resolve({\n          results: permsInDb,\n          pagination: { total: 4 },\n        })\n      );\n      const cleanPermissionFields = jest.fn(() => permsWithCleanFields);\n      const dbDelete = jest.fn(() => Promise.resolve());\n      const update = jest.fn(() => Promise.resolve());\n      const registeredPerms = new Map();\n      registeredPerms.set('action-1', {});\n      registeredPerms.set('action-3', { subjects: ['country'] });\n      const getAllByMap = jest.fn(() => registeredPerms);\n      const prevGetAllByMap = permissionService.actionProvider.getAllByMap;\n      permissionService.actionProvider.getAllByMap = getAllByMap;\n\n      global.strapi = {\n        query: () => ({ findPage, delete: dbDelete, update }),\n        admin: { services: { 'content-type': { cleanPermissionFields } } },\n      };\n\n      await permissionService.cleanPermissionInDatabase();\n\n      expect(findPage).toHaveBeenCalledWith({ page: 1, pageSize: 200 }, []);\n      expect(update).toHaveBeenNthCalledWith(1, { id: permsInDb[4].id }, permsWithCleanFields[2]);\n      expect(update).toHaveBeenNthCalledWith(2, { id: permsInDb[5].id }, permsWithCleanFields[3]);\n      expect(getAllByMap).toHaveBeenCalledWith();\n      expect(dbDelete).toHaveBeenCalledWith({ id_in: [2, 4] });\n\n      // restauring actionProvider\n      permissionService.actionProvider.getAllByMap = prevGetAllByMap;\n    });\n  });\n});\n",
    "packages/strapi-admin/services/__tests__/role.test.js": "'use strict';\n\nconst _ = require('lodash');\nconst roleService = require('../role');\nconst { SUPER_ADMIN_CODE } = require('../constants');\n\ndescribe('Role', () => {\n  describe('create', () => {\n    test('Creates a role', async () => {\n      const dbCreate = jest.fn(role => Promise.resolve(role));\n      const dbCount = jest.fn(() => Promise.resolve(0));\n\n      global.strapi = {\n        query: () => ({ create: dbCreate, count: dbCount }),\n      };\n\n      const input = {\n        name: 'super_admin',\n        description: \"Have all permissions. Can't be delete\",\n        code: 'super-admin',\n      };\n\n      const createdRole = await roleService.create(input);\n\n      expect(dbCreate).toHaveBeenCalledWith(input);\n      expect(createdRole).toStrictEqual(input);\n    });\n  });\n  describe('findOne', () => {\n    test('Finds a role', async () => {\n      const role = {\n        id: 1,\n        name: 'super_admin',\n        description: \"Have all permissions. Can't be delete\",\n      };\n      const dbFindOne = jest.fn(({ id }) => Promise.resolve(_.find([role], { id })));\n\n      global.strapi = {\n        query: () => ({ findOne: dbFindOne }),\n      };\n\n      const foundRole = await roleService.findOne({ id: role.id });\n\n      expect(dbFindOne).toHaveBeenCalledWith({ id: role.id }, []);\n      expect(foundRole).toStrictEqual(role);\n    });\n    test('Finds a role with usersCount', async () => {\n      const role = {\n        id: 1,\n        name: 'super_admin',\n        description: \"Have all permissions. Can't be delete\",\n        usersCount: 0,\n      };\n      const dbFindOne = jest.fn(({ id }) =>\n        Promise.resolve(_.find([_.omit(role, ['usersCount'])], { id }))\n      );\n      const dbCount = jest.fn(() => Promise.resolve(0));\n      global.strapi = {\n        query: () => ({ findOne: dbFindOne, count: dbCount }),\n      };\n\n      const foundRole = await roleService.findOneWithUsersCount({ id: role.id });\n\n      expect(dbFindOne).toHaveBeenCalledWith({ id: role.id }, []);\n      expect(dbCount).toHaveBeenCalledWith({ roles: [role.id] });\n      expect(foundRole).toStrictEqual(role);\n    });\n  });\n  describe('find', () => {\n    test('Finds roles', async () => {\n      const roles = [\n        {\n          id: 1,\n          name: 'super_admin',\n          description: \"Have all permissions. Can't be delete\",\n        },\n      ];\n      const dbFind = jest.fn(() => Promise.resolve(roles));\n\n      global.strapi = {\n        query: () => ({ find: dbFind }),\n      };\n\n      const foundRoles = await roleService.find();\n\n      expect(dbFind).toHaveBeenCalledWith({}, []);\n      expect(foundRoles).toStrictEqual(roles);\n    });\n  });\n  describe('findAll', () => {\n    test('Finds all roles', async () => {\n      const roles = [\n        {\n          id: 1,\n          name: 'super_admin',\n          description: \"Have all permissions. Can't be delete\",\n          usersCount: 0,\n        },\n      ];\n      const dbFind = jest.fn(() =>\n        Promise.resolve(roles.map(role => _.omit(role, ['usersCount'])))\n      );\n      const dbCount = jest.fn(() => Promise.resolve(0));\n\n      global.strapi = {\n        query: () => ({ find: dbFind, count: dbCount }),\n      };\n\n      const foundRoles = await roleService.findAllWithUsersCount();\n\n      expect(dbFind).toHaveBeenCalledWith({ _limit: -1 }, []);\n      expect(foundRoles).toStrictEqual(roles);\n    });\n  });\n  describe('update', () => {\n    test('Updates a role', async () => {\n      const role = {\n        id: 1,\n        name: 'super_admin',\n        description: 'AAA',\n      };\n      const expectedUpdatedRole = {\n        id: 1,\n        name: 'super_admin_updated',\n        description: 'AAA_updated',\n      };\n      const dbUpdate = jest.fn(() => Promise.resolve(expectedUpdatedRole));\n      const dbCount = jest.fn(() => Promise.resolve(0));\n\n      global.strapi = {\n        query: () => ({ update: dbUpdate, count: dbCount }),\n      };\n\n      const updatedRole = await roleService.update(\n        {\n          id: role.id,\n        },\n        {\n          name: expectedUpdatedRole.name,\n          description: expectedUpdatedRole.description,\n        }\n      );\n\n      expect(dbUpdate).toHaveBeenCalledWith(\n        {\n          id: role.id,\n        },\n        {\n          name: expectedUpdatedRole.name,\n          description: expectedUpdatedRole.description,\n        }\n      );\n      expect(updatedRole).toStrictEqual(expectedUpdatedRole);\n    });\n    test('Cannot update code of super admin role', async () => {\n      const dbUpdate = jest.fn();\n      const dbFind = jest.fn(() => [{ id: '1' }]);\n      const dbFindOne = jest.fn(() => ({ id: '1', code: SUPER_ADMIN_CODE }));\n      const badRequest = jest.fn(() => {});\n\n      global.strapi = {\n        query: () => ({ find: dbFind, findOne: dbFindOne, update: dbUpdate }),\n        admin: { config: { superAdminCode: SUPER_ADMIN_CODE } },\n        errors: { badRequest },\n      };\n\n      await roleService.update({ id: 1 }, { code: 'new_code' });\n\n      expect(dbUpdate).toHaveBeenCalledWith({ id: 1 }, {});\n    });\n  });\n  describe('count', () => {\n    test('getUsersCount', async () => {\n      const roleId = 1;\n      const dbCount = jest.fn(() => Promise.resolve(0));\n      global.strapi = {\n        query: () => ({ count: dbCount }),\n      };\n\n      const usersCount = await roleService.getUsersCount(roleId);\n\n      expect(dbCount).toHaveBeenCalledWith({ roles: [roleId] });\n      expect(usersCount).toEqual(0);\n    });\n  });\n  describe('delete', () => {\n    test('Delete a role', async () => {\n      const role = {\n        id: 3,\n        name: 'admin',\n        description: 'Description',\n        users: [],\n      };\n      const dbCount = jest.fn(() => Promise.resolve(0));\n      const dbFindOne = jest.fn(() => ({ id: 1, code: SUPER_ADMIN_CODE }));\n      const dbDelete = jest.fn(() => Promise.resolve(role));\n      const dbDeleteByRolesIds = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query: () => ({ delete: dbDelete, count: dbCount, findOne: dbFindOne }),\n        admin: {\n          services: {\n            permission: { deleteByRolesIds: dbDeleteByRolesIds },\n          },\n          config: { superAdminCode: SUPER_ADMIN_CODE },\n        },\n      };\n\n      const deletedRoles = await roleService.deleteByIds([role.id]);\n\n      expect(dbCount).toHaveBeenCalledWith({ roles: [role.id] });\n      expect(dbDelete).toHaveBeenCalledWith({ id_in: [role.id] });\n      expect(deletedRoles).toStrictEqual([role]);\n    });\n    test('Delete two roles', async () => {\n      const roles = [\n        {\n          id: 1,\n          name: 'admin 1',\n          description: 'Description',\n          users: [],\n        },\n        {\n          id: 2,\n          name: 'admin 2',\n          description: 'Description',\n          users: [],\n        },\n      ];\n      const dbCount = jest.fn(() => Promise.resolve(0));\n      const dbFindOne = jest.fn(() => ({ id: 3, code: SUPER_ADMIN_CODE }));\n      const rolesIds = roles.map(r => r.id);\n      const dbDelete = jest.fn(() => Promise.resolve(roles));\n      const dbGetUsersCount = jest.fn(() => Promise.resolve(0));\n      const dbDeleteByRolesIds = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query: () => ({ delete: dbDelete, count: dbCount, findOne: dbFindOne }),\n        admin: {\n          services: {\n            permission: { deleteByRolesIds: dbDeleteByRolesIds },\n            role: { getUsersCount: dbGetUsersCount },\n          },\n          config: { superAdminCode: SUPER_ADMIN_CODE },\n        },\n      };\n\n      const deletedRoles = await roleService.deleteByIds(rolesIds);\n\n      expect(dbCount).toHaveBeenNthCalledWith(1, { roles: [rolesIds[0]] });\n      expect(dbCount).toHaveBeenNthCalledWith(2, { roles: [rolesIds[1]] });\n      expect(dbCount).toHaveBeenCalledTimes(2);\n      expect(dbDelete).toHaveBeenCalledWith({ id_in: rolesIds });\n      expect(deletedRoles).toStrictEqual(roles);\n    });\n    test('Cannot delete super admin role', async () => {\n      const dbFind = jest.fn(() => [{ id: '1' }]);\n      const dbFindOne = jest.fn(() => ({ id: '1', code: SUPER_ADMIN_CODE }));\n      const badRequest = jest.fn(() => {});\n\n      global.strapi = {\n        query: () => ({ find: dbFind, findOne: dbFindOne }),\n        admin: { config: { superAdminCode: SUPER_ADMIN_CODE } },\n        errors: { badRequest },\n      };\n\n      try {\n        await roleService.deleteByIds([1]);\n      } catch (e) {\n        // nothing\n      }\n\n      expect(badRequest).toHaveBeenCalledWith('ValidationError', {\n        ids: ['You cannot delete the super admin role'],\n      });\n    });\n  });\n  describe('Count roles', () => {\n    test('Count roles without params', async () => {\n      const count = jest.fn(() => Promise.resolve(2));\n      global.strapi = {\n        query: () => ({ count }),\n      };\n\n      const amount = await roleService.count();\n\n      expect(amount).toBe(2);\n      expect(count).toHaveBeenCalledWith({});\n    });\n\n    test('Count roles with params', async () => {\n      const count = jest.fn(() => Promise.resolve(2));\n      global.strapi = {\n        query: () => ({ count }),\n      };\n\n      const params = { foo: 'bar' };\n      const amount = await roleService.count(params);\n\n      expect(amount).toBe(2);\n      expect(count).toHaveBeenCalledWith(params);\n    });\n  });\n  describe('createRolesIfNoneExist', () => {\n    test(\"Don't create roles if one already exist\", async () => {\n      const count = jest.fn(() => Promise.resolve(1));\n      const create = jest.fn();\n      global.strapi = {\n        query: () => ({ count, create }),\n      };\n      await roleService.createRolesIfNoneExist();\n\n      expect(create).toHaveBeenCalledTimes(0);\n    });\n    test('Create 3 roles if none exist', async () => {\n      const actions = [\n        {\n          actionId: 'action-1',\n          subjects: ['country'],\n          section: 'contentTypes',\n        },\n      ];\n      const permissions = [\n        {\n          action: 'action-1',\n          subject: 'country',\n          fields: ['name'],\n          conditions: [],\n        },\n      ];\n\n      const defaultPermissions = [\n        {\n          action: 'plugins::upload.read',\n          conditions: ['admin::is-creator'],\n          fields: null,\n          subject: null,\n        },\n        {\n          action: 'plugins::upload.assets.create',\n          conditions: [],\n          fields: null,\n          subject: null,\n        },\n        {\n          action: 'plugins::upload.assets.update',\n          conditions: ['admin::is-creator'],\n          fields: null,\n          subject: null,\n        },\n        {\n          action: 'plugins::upload.assets.download',\n          conditions: [],\n          fields: null,\n          subject: null,\n        },\n        {\n          action: 'plugins::upload.assets.copy-link',\n          conditions: [],\n          fields: null,\n          subject: null,\n        },\n      ];\n\n      const count = jest.fn(() => Promise.resolve(0));\n      let id = 1;\n      const create = jest.fn(role => ({ ...role, id: id++ }));\n      const getAll = jest.fn(() => actions);\n      const createMany = jest.fn();\n      const assignARoleToAll = jest.fn();\n      const getPermissionsWithNestedFields = jest.fn(() => [...permissions]); // cloned, otherwise it is modified inside createRolesIfNoneExist()\n\n      global.strapi = {\n        query: () => ({ count, create }),\n        admin: {\n          services: {\n            permission: { actionProvider: { getAll }, createMany },\n            'content-type': { getPermissionsWithNestedFields },\n            user: { assignARoleToAll },\n          },\n        },\n      };\n      await roleService.createRolesIfNoneExist();\n\n      expect(create).toHaveBeenCalledTimes(3);\n      expect(create).toHaveBeenNthCalledWith(1, {\n        name: 'Super Admin',\n        code: 'strapi-super-admin',\n        description: 'Super Admins can access and manage all features and settings.',\n      });\n      expect(assignARoleToAll).toHaveBeenCalledWith(1);\n      expect(create).toHaveBeenNthCalledWith(2, {\n        name: 'Editor',\n        code: 'strapi-editor',\n        description: 'Editors can manage and publish contents including those of other users.',\n      });\n      expect(create).toHaveBeenNthCalledWith(3, {\n        name: 'Author',\n        code: 'strapi-author',\n        description: 'Authors can manage the content they have created.',\n      });\n      expect(getPermissionsWithNestedFields).toHaveBeenCalledWith(actions, {\n        restrictedSubjects: ['plugins::users-permissions.user'],\n      });\n      expect(createMany).toHaveBeenCalledTimes(2);\n      expect(createMany).toHaveBeenNthCalledWith(\n        1,\n        [\n          ...permissions,\n          ...defaultPermissions.map(d => ({\n            ...d,\n            conditions: [],\n          })),\n        ].map(p => ({ ...p, role: 2 }))\n      );\n\n      expect(createMany).toHaveBeenNthCalledWith(\n        2,\n        [\n          { ...permissions[0], conditions: ['admin::is-creator'] },\n          ...defaultPermissions,\n        ].map(p => ({ ...p, role: 3 }))\n      );\n    });\n  });\n  describe('displayWarningIfNoSuperAdmin', () => {\n    test('superAdmin role exists & a user is superAdmin', async () => {\n      const findOne = jest.fn(() => ({ id: 1 }));\n      const count = jest.fn(() => Promise.resolve(1));\n      const exists = jest.fn(() => Promise.resolve(true));\n      const warn = jest.fn();\n\n      global.strapi = {\n        query: () => ({ findOne, count }),\n        admin: { services: { user: { exists } } },\n        log: { warn },\n      };\n\n      await roleService.displayWarningIfNoSuperAdmin();\n\n      expect(warn).toHaveBeenCalledTimes(0);\n    });\n    test(\"superAdmin role doesn't exist\", async () => {\n      const findOne = jest.fn(() => undefined);\n      const count = jest.fn(() => Promise.resolve(0));\n      const exists = jest.fn(() => Promise.resolve(false));\n      const warn = jest.fn();\n\n      global.strapi = {\n        query: () => ({ findOne, count }),\n        admin: { services: { user: { exists } } },\n        log: { warn },\n      };\n\n      await roleService.displayWarningIfNoSuperAdmin();\n\n      expect(warn).toHaveBeenCalledWith(\"Your application doesn't have a super admin role.\");\n    });\n    test('superAdmin role exist & no user is superAdmin', async () => {\n      const findOne = jest.fn(() => ({ id: 1 }));\n      const count = jest.fn(() => Promise.resolve(0));\n      const exists = jest.fn(() => Promise.resolve(true));\n      const warn = jest.fn();\n\n      global.strapi = {\n        query: () => ({ findOne, count }),\n        admin: { services: { user: { exists } } },\n        log: { warn },\n      };\n\n      await roleService.displayWarningIfNoSuperAdmin();\n\n      expect(warn).toHaveBeenCalledWith(\"Your application doesn't have a super admin user.\");\n    });\n  });\n\n  describe('resetSuperAdminPermissions', () => {\n    test('No superAdmin role exist', async () => {\n      const getSuperAdmin = jest.fn(() => Promise.resolve(undefined));\n      const createMany = jest.fn();\n\n      global.strapi = {\n        query: () => ({ createMany }),\n        admin: { services: { role: { getSuperAdmin } } },\n      };\n\n      await roleService.resetSuperAdminPermissions();\n\n      expect(createMany).toHaveBeenCalledTimes(0);\n    });\n\n    test('Reset super admin permissions', async () => {\n      const roleId = 1;\n      const actions = [\n        {\n          actionId: 'action-1',\n          subjects: ['country'],\n          section: 'contentTypes',\n        },\n        {\n          actionId: 'action-test2',\n          subjects: ['test-subject1', 'test-subject2'],\n          section: 'settings',\n        },\n        {\n          actionId: 'action-test3',\n          subjects: null,\n          section: 'plugin',\n        },\n      ];\n      const permissions = [\n        {\n          action: 'action-1',\n          subject: 'country',\n          fields: ['name'],\n          conditions: [],\n        },\n        {\n          action: 'action-test2',\n          subject: 'test-subject1',\n          fields: null,\n          conditions: [],\n        },\n        {\n          action: 'action-test2',\n          subject: 'test-subject2',\n          fields: null,\n          conditions: [],\n        },\n        {\n          action: 'action-test3',\n          subject: null,\n          fields: null,\n          conditions: [],\n        },\n      ];\n      const getAll = jest.fn(() => actions);\n      const getAllConditions = jest.fn(() => []);\n      const find = jest.fn(() => [{ action: 'action-2', id: 2 }]);\n      const getPermissionsWithNestedFields = jest.fn(() => [\n        {\n          ...permissions[0],\n        },\n      ]); // cloned, otherwise it is modified inside resetSuperAdminPermissions()\n      const deleteByIds = jest.fn();\n      const getSuperAdmin = jest.fn(() => Promise.resolve({ id: roleId }));\n      const createMany = jest.fn(() => []);\n      const removeUnkownConditionIds = jest.fn(conds => conds);\n\n      global.strapi = {\n        admin: {\n          services: {\n            permission: {\n              createMany,\n              find,\n              actionProvider: { getAll },\n              conditionProvider: { getAll: getAllConditions },\n              deleteByIds,\n            },\n            condition: { removeUnkownConditionIds },\n            'content-type': { getPermissionsWithNestedFields },\n            role: { getSuperAdmin },\n          },\n        },\n      };\n\n      await roleService.resetSuperAdminPermissions();\n\n      expect(deleteByIds).toHaveBeenCalledWith([2]);\n      expect(createMany).toHaveBeenCalledWith(\n        expect.arrayContaining(\n          permissions.map(perm => ({\n            ...perm,\n            role: roleId,\n          }))\n        )\n      );\n    });\n  });\n\n  describe('Assign permissions', () => {\n    test('Delete previous permissions', async () => {\n      const createMany = jest.fn(() => Promise.resolve([]));\n      const getSuperAdmin = jest.fn(() => Promise.resolve({ id: 0 }));\n      const sendDidUpdateRolePermissions = jest.fn();\n      const find = jest.fn(() => Promise.resolve([{ id: 3 }]));\n      const deleteByIds = jest.fn();\n      const getAll = jest.fn(() => []);\n\n      global.strapi = {\n        admin: {\n          services: {\n            metrics: { sendDidUpdateRolePermissions },\n            permission: { find, createMany, actionProvider: { getAll }, deleteByIds },\n            role: { getSuperAdmin },\n          },\n        },\n      };\n\n      await roleService.assignPermissions(1, []);\n\n      expect(deleteByIds).toHaveBeenCalledWith([3]);\n    });\n\n    test('Create new permissions', async () => {\n      const permissions = Array(5)\n        .fill(0)\n        .map((v, i) => ({ action: `action-${i}` }));\n\n      const createMany = jest.fn(() => Promise.resolve([]));\n      const getSuperAdmin = jest.fn(() => Promise.resolve({ id: 0 }));\n      const sendDidUpdateRolePermissions = jest.fn();\n      const find = jest.fn(() => Promise.resolve([]));\n      const getAll = jest.fn(() => permissions.map(perm => ({ actionId: perm.action })));\n      const removeUnkownConditionIds = jest.fn(conds => _.intersection(conds, ['cond']));\n\n      global.strapi = {\n        admin: {\n          services: {\n            metrics: { sendDidUpdateRolePermissions },\n            role: { getSuperAdmin },\n            permission: {\n              find,\n              createMany,\n              actionProvider: { getAll },\n              conditionProvider: {\n                getAll: jest.fn(() => [{ id: 'admin::is-creator' }]),\n              },\n            },\n            condition: {\n              removeUnkownConditionIds,\n            },\n          },\n        },\n      };\n\n      const permissionsToAssign = [...permissions];\n      permissionsToAssign[4] = {\n        ...permissions[4],\n        conditions: ['cond', 'unknown-cond'],\n      };\n\n      await roleService.assignPermissions(1, permissionsToAssign);\n\n      expect(createMany).toHaveBeenCalledTimes(1);\n      expect(createMany).toHaveBeenCalledWith([\n        { action: 'action-0', conditions: [], fields: null, role: 1, subject: null },\n        { action: 'action-1', conditions: [], fields: null, role: 1, subject: null },\n        { action: 'action-2', conditions: [], fields: null, role: 1, subject: null },\n        { action: 'action-3', conditions: [], fields: null, role: 1, subject: null },\n        { action: 'action-4', conditions: ['cond'], fields: null, role: 1, subject: null },\n      ]);\n    });\n  });\n\n  describe('addPermissions', () => {\n    test('Add role to permissions and call permissions service creation method', async () => {\n      const createMany = jest.fn(() => []);\n      const roleId = 1;\n      const permissions = [\n        {\n          action: 'someAction',\n          conditions: [],\n          fields: null,\n          subject: null,\n        },\n      ];\n\n      global.strapi = {\n        admin: {\n          services: {\n            permission: {\n              createMany,\n            },\n          },\n        },\n      };\n\n      await roleService.addPermissions(roleId, permissions);\n      expect(createMany).toHaveBeenCalledWith(\n        expect.arrayContaining(\n          permissions.map(permission => ({\n            ...permission,\n            role: roleId,\n          }))\n        )\n      );\n    });\n  });\n\n  test('sanitizeRole removes users and permissions', () => {\n    const role = {\n      id: 1,\n      name: 'Some Role',\n      users: [{ id: 1 }],\n      permissions: [{ id: 1 }],\n    };\n\n    expect(roleService.sanitizeRole(role)).toEqual({\n      id: 1,\n      name: 'Some Role',\n    });\n  });\n});\n",
    "packages/strapi-admin/services/__tests__/user.test.js": "'use strict';\n\nconst _ = require('lodash');\nconst userService = require('../user');\nconst { SUPER_ADMIN_CODE } = require('../constants');\n\ndescribe('User', () => {\n  describe('sanitizeUser', () => {\n    test('Removes password and resetPasswordToken', () => {\n      const res = userService.sanitizeUser({\n        id: 1,\n        firstname: 'Test',\n        otherField: 'Hello',\n        password: '$5IAZUDB871',\n        resetPasswordToken: '3456-5678-6789-789',\n        roles: [],\n      });\n\n      expect(res).toEqual({\n        id: 1,\n        firstname: 'Test',\n        otherField: 'Hello',\n        roles: [],\n      });\n    });\n  });\n\n  describe('create', () => {\n    const count = jest.fn(() => Promise.resolve(1));\n    const sendDidInviteUser = jest.fn();\n\n    test('Creates a user by merging given and default attributes', async () => {\n      const create = jest.fn(user => Promise.resolve(user));\n      const createToken = jest.fn(() => 'token');\n      const hashPassword = jest.fn(() => Promise.resolve('123456789'));\n\n      global.strapi = {\n        admin: {\n          services: {\n            token: { createToken },\n            auth: { hashPassword },\n            role: { count },\n            metrics: { sendDidInviteUser },\n          },\n        },\n        query() {\n          return { create, count };\n        },\n      };\n\n      const input = { firstname: 'Kai', lastname: 'Doe', email: 'kaidoe@email.com' };\n      const expected = { ...input, isActive: false, roles: [], registrationToken: 'token' };\n\n      const result = await userService.create(input);\n\n      expect(create).toHaveBeenCalled();\n      expect(createToken).toHaveBeenCalled();\n      expect(result).toMatchObject(expected);\n    });\n\n    test('Creates a user and hash password if provided', async () => {\n      const create = jest.fn(user => Promise.resolve(user));\n      const createToken = jest.fn(() => 'token');\n      const hashPassword = jest.fn(() => Promise.resolve('123456789'));\n\n      global.strapi = {\n        admin: {\n          services: {\n            token: { createToken },\n            auth: { hashPassword },\n            role: { count },\n            metrics: { sendDidInviteUser },\n          },\n        },\n        query() {\n          return { create, count };\n        },\n      };\n\n      const input = {\n        firstname: 'Kai',\n        lastname: 'Doe',\n        email: 'kaidoe@email.com',\n        password: 'Pcw123',\n      };\n      const expected = {\n        ...input,\n        password: expect.any(String),\n        isActive: false,\n        roles: [],\n        registrationToken: 'token',\n      };\n\n      const result = await userService.create(input);\n\n      expect(create).toHaveBeenCalled();\n      expect(hashPassword).toHaveBeenCalledWith(input.password);\n      expect(createToken).toHaveBeenCalled();\n      expect(result).toMatchObject(expected);\n      expect(result.password !== input.password).toBe(true);\n    });\n\n    test('Creates a user by using given attributes', async () => {\n      const create = jest.fn(user => Promise.resolve(user));\n      const createToken = jest.fn(() => 'token');\n      const hashPassword = jest.fn(() => Promise.resolve('123456789'));\n\n      global.strapi = {\n        admin: {\n          services: {\n            token: { createToken },\n            auth: { hashPassword },\n            role: { count },\n            metrics: { sendDidInviteUser },\n          },\n        },\n        query() {\n          return { create, count };\n        },\n      };\n\n      const input = {\n        firstname: 'Kai',\n        lastname: 'Doe',\n        email: 'kaidoe@email.com',\n        roles: [2],\n        isActive: true,\n        registrationToken: 'another-token',\n      };\n      const expected = _.clone(input);\n      const result = await userService.create(input);\n\n      expect(result).toMatchObject(expected);\n    });\n  });\n\n  describe('Count users', () => {\n    test('Count users without params', async () => {\n      const count = jest.fn(() => Promise.resolve(2));\n      global.strapi = {\n        query: () => ({ count }),\n      };\n\n      const amount = await userService.count();\n\n      expect(amount).toBe(2);\n      expect(count).toHaveBeenCalledWith({});\n    });\n\n    test('Count users with params', async () => {\n      const count = jest.fn(() => Promise.resolve(2));\n      global.strapi = {\n        query: () => ({ count }),\n      };\n\n      const params = { foo: 'bar' };\n      const amount = await userService.count(params);\n\n      expect(amount).toBe(2);\n      expect(count).toHaveBeenCalledWith(params);\n    });\n  });\n\n  describe('update', () => {\n    test('Hash password', async () => {\n      const hash = 'aoizdnoaizndoainzodiaz';\n\n      const id = 1;\n      const input = { email: 'test@strapi.io', password: '123' };\n\n      const findOne = jest.fn((_, user) => Promise.resolve(user));\n      const update = jest.fn((_, user) => Promise.resolve(user));\n      const hashPassword = jest.fn(() => Promise.resolve(hash));\n\n      global.strapi = {\n        query() {\n          return { update, findOne };\n        },\n        admin: {\n          services: {\n            auth: { hashPassword },\n          },\n        },\n      };\n\n      const result = await userService.updateById(id, input);\n\n      expect(hashPassword).toHaveBeenCalledWith(input.password);\n      expect(update).toHaveBeenCalledWith({ id }, { email: input.email, password: hash });\n      expect(result).toEqual({\n        email: 'test@strapi.io',\n        password: 'aoizdnoaizndoainzodiaz',\n      });\n    });\n\n    test('Forwards call to the query layer', async () => {\n      const user = {\n        email: 'test@strapi.io',\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const update = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return { update, findOne };\n        },\n      };\n      const id = 1;\n      const input = { email: 'test@strapi.io' };\n      const result = await userService.updateById(id, input);\n\n      expect(update).toHaveBeenCalledWith({ id }, input);\n      expect(result).toBe(user);\n    });\n  });\n\n  describe('updateById', () => {\n    test('Cannot delete last super admin', async () => {\n      const findOne = jest.fn(() =>\n        Promise.resolve({ id: 11, roles: [{ code: SUPER_ADMIN_CODE }] })\n      );\n      const getSuperAdminWithUsersCount = jest.fn(() => Promise.resolve({ id: 1, usersCount: 1 }));\n      const badRequest = jest.fn();\n      global.strapi = {\n        query: () => ({ findOne }),\n        admin: { services: { role: { getSuperAdminWithUsersCount } } },\n        errors: { badRequest },\n      };\n      try {\n        await userService.deleteById(2);\n      } catch (e) {\n        //nothing\n      }\n\n      expect(badRequest).toHaveBeenCalledWith(\n        'ValidationError',\n        'You must have at least one user with super admin role.'\n      );\n    });\n    test('Can delete a super admin if he/she is not the last one', async () => {\n      const user = { id: 2, roles: [{ code: SUPER_ADMIN_CODE }] };\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const getSuperAdminWithUsersCount = jest.fn(() => Promise.resolve({ id: 1, usersCount: 2 }));\n      const deleteFn = jest.fn(() => user);\n      global.strapi = {\n        query: () => ({ findOne, delete: deleteFn }),\n        admin: { services: { role: { getSuperAdminWithUsersCount } } },\n      };\n\n      const res = await userService.deleteById(user.id);\n      expect(deleteFn).toHaveBeenCalledWith({ id: user.id });\n      expect(res).toEqual(user);\n    });\n  });\n\n  describe('deleteByIds', () => {\n    test('Cannot delete last super admin', async () => {\n      const count = jest.fn(() => Promise.resolve(2));\n      const getSuperAdminWithUsersCount = jest.fn(() => Promise.resolve({ id: 1, usersCount: 2 }));\n      const badRequest = jest.fn();\n      global.strapi = {\n        query: () => ({ count }),\n        admin: { services: { role: { getSuperAdminWithUsersCount } } },\n        errors: { badRequest },\n      };\n\n      try {\n        await userService.deleteByIds([2, 3]);\n      } catch (e) {\n        // nothing\n      }\n\n      expect(badRequest).toHaveBeenCalledWith(\n        'ValidationError',\n        'You must have at least one user with super admin role.'\n      );\n    });\n\n    test('Can delete a super admin if he/she is not the last one', async () => {\n      const users = [\n        { id: 2, roles: [{ code: SUPER_ADMIN_CODE }] },\n        { id: 3, roles: [{ code: SUPER_ADMIN_CODE }] },\n      ];\n      const count = jest.fn(() => Promise.resolve(users.length));\n      const getSuperAdminWithUsersCount = jest.fn(() => Promise.resolve({ id: 1, usersCount: 3 }));\n      const deleteFn = jest.fn(() => users);\n      global.strapi = {\n        query: () => ({ count, delete: deleteFn }),\n        admin: { services: { role: { getSuperAdminWithUsersCount } } },\n      };\n\n      const res = await userService.deleteByIds([2, 3]);\n      expect(deleteFn).toHaveBeenCalledWith({ id_in: [2, 3] });\n      expect(res).toEqual(users);\n    });\n  });\n\n  describe('exists', () => {\n    test('Return true if the user already exists', async () => {\n      const count = jest.fn(() => Promise.resolve(1));\n\n      global.strapi = {\n        query: () => {\n          return { count };\n        },\n      };\n\n      const result = await userService.exists();\n\n      expect(result).toBeTruthy();\n    });\n\n    test('Return false if the user does not exists', async () => {\n      const count = jest.fn(() => Promise.resolve(0));\n\n      global.strapi = {\n        query: () => {\n          return { count };\n        },\n      };\n\n      const result = await userService.exists();\n\n      expect(result).toBeFalsy();\n    });\n  });\n\n  describe('Fetch users (paginated)', () => {\n    const defaults = { page: 1, pageSize: 100 };\n\n    beforeEach(() => {\n      const fetchPage = jest.fn(({ page = defaults.page, pageSize = defaults.pageSize } = {}) => {\n        return {\n          results: Array.from({ length: pageSize }).map((_, i) => i + (page - 1) * pageSize),\n          pagination: { page, pageSize, total: page * pageSize, pageCount: page },\n        };\n      });\n\n      global.strapi = {\n        query() {\n          return { findPage: fetchPage, searchPage: fetchPage };\n        },\n      };\n    });\n\n    test('Fetch users with custom pagination', async () => {\n      const pagination = { page: 2, pageSize: 15 };\n      const foundPage = await userService.findPage(pagination);\n      const searchedPage = await userService.searchPage(pagination);\n\n      expect(foundPage.results.length).toBe(15);\n      expect(foundPage.results[0]).toBe(15);\n      expect((foundPage.pagination.total = 30));\n\n      expect(searchedPage.results.length).toBe(15);\n      expect(searchedPage.results[0]).toBe(15);\n      expect((searchedPage.pagination.total = 30));\n    });\n\n    test('Fetch users with default pagination', async () => {\n      const foundPage = await userService.findPage();\n      const searchedPage = await userService.searchPage();\n\n      expect(foundPage.results.length).toBe(100);\n      expect(foundPage.results[0]).toBe(0);\n      expect((foundPage.pagination.total = 100));\n\n      expect(searchedPage.results.length).toBe(100);\n      expect(searchedPage.results[0]).toBe(0);\n      expect((searchedPage.pagination.total = 100));\n    });\n\n    test('Fetch users with partial pagination', async () => {\n      const pagination = { page: 2 };\n      const foundPage = await userService.findPage(pagination);\n      const searchedPage = await userService.searchPage(pagination);\n\n      expect(foundPage.results.length).toBe(100);\n      expect(foundPage.results[0]).toBe(100);\n      expect((foundPage.pagination.total = 200));\n\n      expect(searchedPage.results.length).toBe(100);\n      expect(searchedPage.results[0]).toBe(100);\n      expect((searchedPage.pagination.total = 200));\n    });\n  });\n\n  describe('Fetch user', () => {\n    const user = { firstname: 'Kai', lastname: 'Doe', email: 'kaidoe@email.com' };\n\n    beforeEach(() => {\n      const findOne = jest.fn(({ id }) =>\n        Promise.resolve(\n          {\n            1: user,\n          }[id] || null\n        )\n      );\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n      };\n    });\n\n    test('Finds and returns a user by its ID', async () => {\n      const input = { id: 1 };\n      const res = await userService.findOne(input);\n\n      expect(res).not.toBeNull();\n      expect(res).toMatchObject(user);\n    });\n\n    test('Fails to find a user with provided params', async () => {\n      const input = { id: 27 };\n      const res = await userService.findOne(input);\n\n      expect(res).toBeNull();\n    });\n  });\n\n  describe('findRegistrationInfo', () => {\n    test('Returns undefined if not found', async () => {\n      const findOne = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query: () => {\n          return { findOne };\n        },\n      };\n\n      const res = await userService.findRegistrationInfo('ABCD');\n      expect(res).toBeUndefined();\n      expect(findOne).toHaveBeenCalledWith({ registrationToken: 'ABCD' });\n    });\n\n    test('Returns correct user registration info', async () => {\n      const user = {\n        email: 'test@strapi.io',\n        firstname: 'Test',\n        lastname: 'Strapi',\n        otherField: 'ignored',\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query: () => {\n          return { findOne };\n        },\n      };\n\n      const res = await userService.findRegistrationInfo('ABCD');\n\n      expect(res).toEqual({\n        email: user.email,\n        firstname: user.firstname,\n        lastname: user.lastname,\n      });\n    });\n  });\n\n  describe('register', () => {\n    test('Fails if no matching user is found', async () => {\n      const findOne = jest.fn(() => Promise.resolve(undefined));\n\n      global.strapi = {\n        query() {\n          return {\n            findOne,\n          };\n        },\n        errors: {\n          badRequest(msg) {\n            throw new Error(msg);\n          },\n        },\n      };\n\n      const input = {\n        registrationToken: '123',\n        userInfo: {\n          firstname: 'test',\n          lastname: 'Strapi',\n          password: 'Test1234',\n        },\n      };\n\n      expect(userService.register(input)).rejects.toThrowError('Invalid registration info');\n    });\n\n    test('Calls udpate service', async () => {\n      const findOne = jest.fn(() => Promise.resolve({ id: 1 }));\n      const updateById = jest.fn(user => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return {\n            findOne,\n          };\n        },\n        admin: {\n          services: {\n            user: { updateById },\n          },\n        },\n      };\n\n      const input = {\n        registrationToken: '123',\n        userInfo: {\n          firstname: 'test',\n          lastname: 'Strapi',\n          password: 'Test1234',\n        },\n      };\n\n      await userService.register(input);\n\n      expect(updateById).toHaveBeenCalledWith(\n        1,\n        expect.objectContaining({ firstname: 'test', lastname: 'Strapi', password: 'Test1234' })\n      );\n    });\n\n    test('Set user to active', async () => {\n      const findOne = jest.fn(() => Promise.resolve({ id: 1 }));\n      const updateById = jest.fn(user => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return {\n            findOne,\n          };\n        },\n        admin: {\n          services: {\n            user: { updateById },\n          },\n        },\n      };\n\n      const input = {\n        registrationToken: '123',\n        userInfo: {\n          firstname: 'test',\n          lastname: 'Strapi',\n          password: 'Test1234',\n        },\n      };\n\n      await userService.register(input);\n\n      expect(updateById).toHaveBeenCalledWith(1, expect.objectContaining({ isActive: true }));\n    });\n\n    test('Reset registrationToken', async () => {\n      const findOne = jest.fn(() => Promise.resolve({ id: 1 }));\n      const updateById = jest.fn(user => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return {\n            findOne,\n          };\n        },\n        admin: {\n          services: {\n            user: { updateById },\n          },\n        },\n      };\n\n      const input = {\n        registrationToken: '123',\n        userInfo: {\n          firstname: 'test',\n          lastname: 'Strapi',\n          password: 'Test1234',\n        },\n      };\n\n      await userService.register(input);\n\n      expect(updateById).toHaveBeenCalledWith(\n        1,\n        expect.objectContaining({ registrationToken: null })\n      );\n    });\n  });\n\n  describe('Assign a role to all', () => {\n    test('mongoose', async () => {\n      const updateMany = jest.fn();\n\n      global.strapi = {\n        query: () => ({\n          model: {\n            orm: 'mongoose',\n            updateMany,\n          },\n        }),\n      };\n\n      await userService.assignARoleToAll(3);\n\n      expect(updateMany).toHaveBeenCalledWith({}, { roles: [3] });\n    });\n\n    test('bookshelf', async () => {\n      const knexFunctions = {};\n      const select = jest.fn(() => knexFunctions);\n      const from = jest.fn(() => knexFunctions);\n      const leftJoin = jest.fn(() => knexFunctions);\n      const where = jest.fn(() => knexFunctions);\n      const pluck = jest.fn(() => [1, 2]);\n      Object.assign(knexFunctions, { select, from, leftJoin, where, pluck });\n      const into = jest.fn();\n      const insert = jest.fn(() => ({ into }));\n\n      global.strapi = {\n        connections: {\n          default: {\n            select,\n            insert,\n          },\n        },\n        query: () => ({\n          model: {\n            orm: 'bookshelf',\n            connection: 'default',\n            associations: [{ alias: 'roles', tableCollectionName: 'strapi_users_roles' }],\n            collectionName: 'strapi_administrators',\n          },\n        }),\n      };\n\n      await userService.assignARoleToAll(3);\n\n      expect(select).toHaveBeenCalledWith('strapi_administrators.id');\n      expect(from).toHaveBeenCalledWith('strapi_administrators');\n      expect(leftJoin).toHaveBeenCalledWith(\n        'strapi_users_roles',\n        'strapi_administrators.id',\n        'strapi_users_roles.user_id'\n      );\n      expect(where).toHaveBeenCalledWith('strapi_users_roles.role_id', null);\n      expect(pluck).toHaveBeenCalledWith('strapi_administrators.id');\n      expect(insert).toHaveBeenCalledWith([\n        { role_id: 3, user_id: 1 },\n        { role_id: 3, user_id: 2 },\n      ]);\n      expect(into).toHaveBeenCalledWith('strapi_users_roles');\n    });\n  });\n\n  describe('displayWarningIfUsersDontHaveRole', () => {\n    test('All users have at least one role', async () => {\n      const count = jest.fn(() => Promise.resolve(0));\n      const warn = jest.fn();\n\n      global.strapi = {\n        query: () => ({ model: { orm: 'bookshelf' }, count }),\n        log: { warn },\n      };\n\n      await userService.displayWarningIfUsersDontHaveRole();\n\n      expect(warn).toHaveBeenCalledTimes(0);\n    });\n    test('2 users have 0 roles', async () => {\n      const count = jest.fn(() => Promise.resolve(2));\n      const warn = jest.fn();\n\n      global.strapi = {\n        query: () => ({ model: { orm: 'bookshelf' }, count }),\n        log: { warn },\n      };\n\n      await userService.displayWarningIfUsersDontHaveRole();\n\n      expect(warn).toHaveBeenCalledWith(\"Some users (2) don't have any role.\");\n    });\n  });\n\n  describe('migrateUsers', () => {\n    test(\"Don't do anything if the migration has already been done\", async () => {\n      const updateMany = jest.fn();\n      const exists = jest.fn(() => Promise.resolve(true));\n\n      global.strapi = {\n        query: () => ({ model: { orm: 'mongoose' } }),\n        admin: { services: { role: { exists } } },\n      };\n\n      await userService.migrateUsers();\n\n      expect(updateMany).toHaveBeenCalledTimes(0);\n    });\n    test('Migrate for mongoose', async () => {\n      const updateMany = jest.fn();\n      const exists = jest.fn(() => Promise.resolve(false));\n\n      global.strapi = {\n        query: () => ({ model: { orm: 'mongoose', updateMany } }),\n        admin: { services: { role: { exists } } },\n      };\n\n      await userService.migrateUsers();\n\n      expect(updateMany).toHaveBeenCalledTimes(2);\n      expect(updateMany).toHaveBeenNthCalledWith(\n        1,\n        { blocked: { $in: [false, null] } },\n        { isActive: true }\n      );\n      expect(updateMany).toHaveBeenNthCalledWith(2, { blocked: true }, { isActive: false });\n    });\n    test('Migrate for bookshelf', async () => {\n      const query = jest.fn(() => ({ save }));\n      const save = jest.fn(() => Promise.resolve());\n      const exists = jest.fn(() => Promise.resolve(false));\n\n      global.strapi = {\n        query: () => ({ model: { orm: 'bookshelf', query } }),\n        admin: { services: { role: { exists } } },\n      };\n\n      await userService.migrateUsers();\n\n      expect(query).toHaveBeenCalledTimes(2);\n      expect(save).toHaveBeenCalledTimes(2);\n      expect(save).toHaveBeenNthCalledWith(\n        1,\n        { isActive: true },\n        { method: 'update', patch: true, require: false }\n      );\n      expect(save).toHaveBeenNthCalledWith(\n        2,\n        { isActive: false },\n        { method: 'update', patch: true, require: false }\n      );\n    });\n  });\n\n  describe('resetPasswordByEmail', () => {\n    test('Throws on missing user', async () => {\n      const email = 'email@email.fr';\n      const password = 'invalidpass';\n\n      const findOne = jest.fn(() => {\n        return null;\n      });\n\n      global.strapi = {\n        query() {\n          return {\n            findOne,\n          };\n        },\n      };\n\n      await expect(userService.resetPasswordByEmail(email, password)).rejects.toEqual(\n        new Error(`User not found for email: ${email}`)\n      );\n\n      expect(findOne).toHaveBeenCalledWith({ email }, undefined);\n    });\n\n    test.each(['abc', 'Abcd', 'Abcdefgh', 'Abcd123'])(\n      'Throws on invalid password',\n      async password => {\n        const email = 'email@email.fr';\n\n        const findOne = jest.fn(() => ({ id: 1 }));\n\n        global.strapi = {\n          query() {\n            return {\n              findOne,\n            };\n          },\n        };\n\n        await expect(userService.resetPasswordByEmail(email, password)).rejects.toEqual(\n          new Error(\n            'Invalid password. Expected a minimum of 8 characters with at least one number and one uppercase letter'\n          )\n        );\n\n        expect(findOne).toHaveBeenCalledWith({ email }, undefined);\n      }\n    );\n  });\n\n  test('Call the update function with the expected params', async () => {\n    const email = 'email@email.fr';\n    const password = 'Testing1234';\n    const hash = 'hash';\n    const userId = 1;\n\n    const findOne = jest.fn(() => ({ id: userId }));\n    const update = jest.fn();\n    const hashPassword = jest.fn(() => hash);\n\n    global.strapi = {\n      query() {\n        return {\n          findOne,\n          update,\n        };\n      },\n      admin: {\n        services: {\n          auth: {\n            hashPassword,\n          },\n        },\n      },\n    };\n\n    await userService.resetPasswordByEmail(email, password);\n    expect(findOne).toHaveBeenCalledWith({ email }, undefined);\n    expect(update).toHaveBeenCalledWith({ id: userId }, { password: hash });\n    expect(hashPassword).toHaveBeenCalledWith(password);\n  });\n});\n",
    "packages/strapi-admin/services/auth.js": "'use strict';\n\nconst bcrypt = require('bcryptjs');\nconst _ = require('lodash');\nconst { getAbsoluteAdminUrl } = require('strapi-utils');\n\n/**\n * hashes a password\n * @param {string} password - password to hash\n * @returns {string} hashed password\n */\nconst hashPassword = password => bcrypt.hash(password, 10);\n\n/**\n * Validate a password\n * @param {string} password\n * @param {string} hash\n * @returns {boolean} is the password valid\n */\nconst validatePassword = (password, hash) => bcrypt.compare(password, hash);\n\n/**\n * Check login credentials\n * @param {Object} options\n * @param {string} options.email\n * @param {string} options.password\n */\nconst checkCredentials = async ({ email, password }) => {\n  const user = await strapi.query('user', 'admin').findOne({ email });\n\n  if (!user || !user.password) {\n    return [null, false, { message: 'Invalid credentials' }];\n  }\n\n  const isValid = await validatePassword(password, user.password);\n\n  if (!isValid) {\n    return [null, false, { message: 'Invalid credentials' }];\n  }\n\n  if (!(user.isActive === true)) {\n    return [null, false, { message: 'User not active' }];\n  }\n\n  return [null, user];\n};\n\n/**\n * Send an email to the user if it exists or do nothing\n * @param {Object} param params\n * @param {string} param.email user email for which to reset the password\n */\nconst forgotPassword = async ({ email } = {}) => {\n  const user = await strapi.query('user', 'admin').findOne({ email, isActive: true });\n\n  if (!user) {\n    return;\n  }\n\n  const resetPasswordToken = strapi.admin.services.token.createToken();\n  await strapi.admin.services.user.updateById(user.id, { resetPasswordToken });\n\n  // Send an email to the admin.\n  const url = `${getAbsoluteAdminUrl(\n    strapi.config\n  )}/auth/reset-password?code=${resetPasswordToken}`;\n  return strapi.plugins.email.services.email\n    .sendTemplatedEmail(\n      {\n        to: user.email,\n        from: strapi.config.get('server.admin.forgotPassword.from'),\n        replyTo: strapi.config.get('server.admin.forgotPassword.replyTo'),\n      },\n      strapi.config.get('server.admin.forgotPassword.emailTemplate'),\n      {\n        url,\n        user: _.pick(user, ['email', 'firstname', 'lastname', 'username']),\n      }\n    )\n    .catch(err => {\n      // log error server side but do not disclose it to the user to avoid leaking informations\n      strapi.log.error(err);\n    });\n};\n\n/**\n * Reset a user password\n * @param {Object} param params\n * @param {string} param.resetPasswordToken token generated to request a password reset\n * @param {string} param.password new user password\n */\nconst resetPassword = async ({ resetPasswordToken, password } = {}) => {\n  const matchingUser = await strapi\n    .query('user', 'admin')\n    .findOne({ resetPasswordToken, isActive: true });\n\n  if (!matchingUser) {\n    throw strapi.errors.badRequest();\n  }\n\n  return strapi.admin.services.user.updateById(matchingUser.id, {\n    password,\n    resetPasswordToken: null,\n  });\n};\n\nmodule.exports = {\n  checkCredentials,\n  validatePassword,\n  hashPassword,\n  forgotPassword,\n  resetPassword,\n};\n",
    "packages/strapi-admin/services/metrics.js": "'use strict';\n\nconst sendDidInviteUser = async () => {\n  const numberOfUsers = await strapi.admin.services.user.count();\n  const numberOfRoles = await strapi.admin.services.role.count();\n  return strapi.telemetry.send('didInviteUser', { numberOfRoles, numberOfUsers });\n};\n\nconst sendDidUpdateRolePermissions = async () => {\n  return strapi.telemetry.send('didUpdateRolePermissions');\n};\n\nmodule.exports = {\n  sendDidInviteUser,\n  sendDidUpdateRolePermissions,\n};\n",
    "packages/strapi-admin/services/permission.js": "'use strict';\n\nconst _ = require('lodash');\nconst { flatMap, filter } = require('lodash/fp');\nconst pmap = require('p-map');\nconst { getBoundActionsBySubject, BOUND_ACTIONS_FOR_FIELDS } = require('../domain/role');\nconst { createPermission } = require('../domain/permission');\nconst createPermissionsManager = require('./permission/permissions-manager');\nconst createConditionProvider = require('./permission/condition-provider');\nconst createPermissionEngine = require('./permission/engine');\nconst actionProvider = require('./permission/action-provider');\nconst { EDITOR_CODE } = require('./constants');\n\nconst conditionProvider = createConditionProvider();\nconst engine = createPermissionEngine(conditionProvider);\n\n/**\n * Removes unwanted fields from a permission\n * @param perm\n * @returns {*}\n */\nconst sanitizePermission = perm => ({\n  ..._.pick(perm, ['id', 'action', 'subject', 'fields']),\n  conditions: strapi.admin.services.condition.removeUnkownConditionIds(perm.conditions),\n});\n\n/**\n * Delete permissions of roles in database\n * @param rolesIds ids of roles\n * @returns {Promise<array>}\n */\nconst deleteByRolesIds = rolesIds => {\n  return strapi.query('permission', 'admin').delete({ role_in: rolesIds });\n};\n\n/**\n * Delete permissions\n * @param ids ids of permissions\n * @returns {Promise<array>}\n */\nconst deleteByIds = ids => {\n  return strapi.query('permission', 'admin').delete({ id_in: ids });\n};\n\n/**\n * Create many permissions\n * @param permissions\n * @returns {Promise<*[]|*>}\n */\nconst createMany = async permissions => {\n  return strapi.query('permission', 'admin').createMany(permissions);\n};\n\n/**\n * Update a permission\n * @returns {Promise<*[]|*>}\n * @param params\n * @param attributes\n */\nconst update = async (params, attributes) => {\n  return strapi.query('permission', 'admin').update(params, attributes);\n};\n\n/**\n * Find assigned permissions in the database\n * @param params query params to find the permissions\n * @returns {Promise<array<Object>>}\n */\nconst find = (params = {}) => {\n  return strapi.query('permission', 'admin').find(params, []);\n};\n\n/**\n * Find all permissions for a user\n * @param roles\n * @returns {Promise<*[]|*>}\n */\nconst findUserPermissions = async ({ roles }) => {\n  if (!_.isArray(roles)) {\n    return [];\n  }\n\n  return strapi\n    .query('permission', 'admin')\n    .find({ role_in: roles.map(_.property('id')), _limit: -1 });\n};\n\n/**\n * Removes permissions in database that don't exist anymore\n * @returns {Promise<>}\n */\nconst cleanPermissionInDatabase = async () => {\n  const pageSize = 200;\n  let page = 0;\n  let total = 1;\n\n  while (page * pageSize < total) {\n    // First, delete permission that don't exist anymore\n    page += 1;\n    const res = await strapi.query('permission', 'admin').findPage({ page, pageSize }, []);\n    total = res.pagination.total;\n\n    const dbPermissions = res.results;\n    const allActionsMap = actionProvider.getAllByMap();\n    const permissionsToRemoveIds = dbPermissions.reduce((idsToDelete, perm) => {\n      if (\n        !allActionsMap.has(perm.action) ||\n        (Array.isArray(allActionsMap.get(perm.action).subjects) &&\n          !allActionsMap.get(perm.action).subjects.includes(perm.subject))\n      ) {\n        idsToDelete.push(perm.id);\n      }\n      return idsToDelete;\n    }, []);\n\n    const deletePromise = deleteByIds(permissionsToRemoveIds);\n\n    // Second, clean fields of permissions (add required ones, remove the non-existing anymore ones)\n    const permissionsInDb = dbPermissions.filter(perm => !permissionsToRemoveIds.includes(perm.id));\n    const permissionsWithCleanFields = strapi.admin.services['content-type'].cleanPermissionFields(\n      permissionsInDb\n    );\n\n    // Update only the ones that need to be updated\n    const permissionsNeedingToBeUpdated = _.differenceWith(\n      permissionsWithCleanFields,\n      permissionsInDb,\n      (a, b) => a.id === b.id && _.xor(a.fields, b.fields).length === 0\n    );\n    const promiseProvider = perm => update({ id: perm.id }, perm);\n\n    //Update the database\n    await Promise.all([\n      deletePromise,\n      pmap(permissionsNeedingToBeUpdated, promiseProvider, {\n        concurrency: 100,\n        stopOnError: true,\n      }),\n    ]);\n  }\n};\n\nconst ensureBoundPermissionsInDatabase = async () => {\n  if (strapi.EE) {\n    return;\n  }\n\n  const contentTypes = Object.values(strapi.contentTypes);\n  const editorRole = await strapi.query('role', 'admin').findOne({ code: EDITOR_CODE }, []);\n\n  if (_.isNil(editorRole)) {\n    return;\n  }\n\n  for (const contentType of contentTypes) {\n    const boundActions = getBoundActionsBySubject(editorRole, contentType.uid);\n    const permissions = await strapi.query('permission', 'admin').find(\n      {\n        subject: contentType.uid,\n        action_in: boundActions,\n        role: editorRole.id,\n      },\n      []\n    );\n\n    if (permissions.length === 0) {\n      return;\n    }\n\n    const fields = _.flow(flatMap('fields'), filter(_.negate(_.isNil)), _.uniq)(permissions);\n\n    // Handle the scenario where permissions are missing\n\n    const missingActions = _.difference(boundActions, _.map(permissions, 'action'));\n\n    if (missingActions.length > 0) {\n      const permissions = missingActions.map(action =>\n        createPermission({\n          action,\n          subject: contentType.uid,\n          role: editorRole.id,\n          fields: BOUND_ACTIONS_FOR_FIELDS.includes(action) ? fields : null,\n        })\n      );\n\n      await createMany(permissions);\n    }\n  }\n};\n\nmodule.exports = {\n  createMany,\n  find,\n  deleteByRolesIds,\n  deleteByIds,\n  sanitizePermission,\n  findUserPermissions,\n  actionProvider,\n  createPermissionsManager,\n  engine,\n  conditionProvider,\n  cleanPermissionInDatabase,\n  ensureBoundPermissionsInDatabase,\n};\n",
    "packages/strapi-admin/services/role.js": "'use strict';\n\nconst _ = require('lodash');\nconst { set } = require('lodash/fp');\nconst { generateTimestampCode, stringIncludes } = require('strapi-utils');\nconst { createPermission } = require('../domain/permission');\nconst { validatePermissionsExist } = require('../validation/permission');\nconst { SUPER_ADMIN_CODE } = require('./constants');\n\nconst ACTIONS = {\n  publish: 'plugins::content-manager.explorer.publish',\n};\n\nconst sanitizeRole = role => {\n  return _.omit(role, ['users', 'permissions']);\n};\n\nconst fieldsToCompare = ['action', 'subject', 'fields', 'conditions'];\n\nconst getPermissionWithSortedFields = perm => {\n  const sortedPerm = _.cloneDeep(perm);\n  if (Array.isArray(sortedPerm.fields)) {\n    sortedPerm.fields.sort();\n  }\n  return sortedPerm;\n};\n\nconst arePermissionsEqual = (perm1, perm2) =>\n  _.isEqual(\n    _.pick(getPermissionWithSortedFields(perm1), fieldsToCompare),\n    _.pick(getPermissionWithSortedFields(perm2), fieldsToCompare)\n  );\n\n/**\n * Create and save a role in database\n * @param attributes A partial role object\n * @returns {Promise<role>}\n */\nconst create = async attributes => {\n  const alreadyExists = await exists({ name: attributes.name });\n\n  if (alreadyExists) {\n    throw strapi.errors.badRequest('ValidationError', {\n      name: [`The name must be unique and a role with name \\`${attributes.name}\\` already exists.`],\n    });\n  }\n\n  const autoGeneratedCode = `${_.kebabCase(attributes.name)}-${generateTimestampCode()}`;\n\n  const rolesWithCode = {\n    ...attributes,\n    code: attributes.code || autoGeneratedCode,\n  };\n\n  return strapi.query('role', 'admin').create(rolesWithCode);\n};\n\n/**\n * Find a role in database\n * @param params query params to find the role\n * @param populate\n * @returns {Promise<role>}\n */\nconst findOne = (params = {}, populate = []) => {\n  return strapi.query('role', 'admin').findOne(params, populate);\n};\n\n/**\n * Find a role in database with usersCounts\n * @param params query params to find the role\n * @param populate\n * @returns {Promise<role>}\n */\nconst findOneWithUsersCount = async (params = {}, populate = []) => {\n  const role = await strapi.query('role', 'admin').findOne(params, populate);\n\n  if (role) {\n    role.usersCount = await getUsersCount(role.id);\n  }\n\n  return role;\n};\n\n/**\n * Find roles in database\n * @param params query params to find the roles\n * @param populate\n * @returns {Promise<array>}\n */\nconst find = (params = {}, populate = []) => {\n  return strapi.query('role', 'admin').find(params, populate);\n};\n\n/**\n * Find all roles in database\n * @returns {Promise<array>}\n */\nconst findAllWithUsersCount = async (populate = []) => {\n  const roles = await strapi.query('role', 'admin').find({ _limit: -1 }, populate);\n  for (let role of roles) {\n    role.usersCount = await getUsersCount(role.id);\n  }\n\n  return roles;\n};\n\n/**\n * Update a role in database\n * @param params query params to find the role to update\n * @param attributes A partial role object\n * @returns {Promise<role>}\n */\nconst update = async (params, attributes) => {\n  const sanitizedAttributes = _.omit(attributes, ['code']);\n\n  if (_.has(params, 'id') && _.has(sanitizedAttributes, 'name')) {\n    const alreadyExists = await exists({\n      name: sanitizedAttributes.name,\n      id_ne: params.id,\n    });\n    if (alreadyExists) {\n      throw strapi.errors.badRequest('ValidationError', {\n        name: [\n          `The name must be unique and a role with name \\`${sanitizedAttributes.name}\\` already exists.`,\n        ],\n      });\n    }\n  }\n\n  return strapi.query('role', 'admin').update(params, sanitizedAttributes);\n};\n\n/**\n * Check if a role exists in database\n * @param params query params to find the role\n * @returns {Promise<boolean>}\n */\nconst exists = async params => {\n  const foundCount = await strapi.query('role', 'admin').count(params);\n\n  return foundCount > 0;\n};\n\n/**\n * Count the number of roles based on search params\n * @param params params used for the query\n * @returns {Promise<number>}\n */\nconst count = async (params = {}) => {\n  return strapi.query('role', 'admin').count(params);\n};\n\n/**\n * Delete roles in database if they have no user assigned\n * @param ids query params to find the roles\n * @returns {Promise<array>}\n */\nconst deleteByIds = async (ids = []) => {\n  const superAdminRole = await getSuperAdmin();\n  if (superAdminRole && stringIncludes(ids, superAdminRole.id)) {\n    throw strapi.errors.badRequest('ValidationError', {\n      ids: ['You cannot delete the super admin role'],\n    });\n  }\n\n  for (let roleId of ids) {\n    const usersCount = await getUsersCount(roleId);\n    if (usersCount !== 0) {\n      throw strapi.errors.badRequest('ValidationError', {\n        ids: ['Some roles are still assigned to some users.'],\n      });\n    }\n  }\n\n  await strapi.admin.services.permission.deleteByRolesIds(ids);\n\n  let deletedRoles = await strapi.query('role', 'admin').delete({ id_in: ids });\n\n  if (!Array.isArray(deletedRoles)) {\n    deletedRoles = [deletedRoles];\n  }\n\n  return deletedRoles;\n};\n\n/** Count the number of users for some roles\n * @returns {Promise<number>}\n * @param roleId\n */\nconst getUsersCount = async roleId => {\n  return strapi.query('user', 'admin').count({ roles: [roleId] });\n};\n\n/** Returns admin role\n * @returns {Promise<role>}\n */\nconst getSuperAdmin = () => findOne({ code: SUPER_ADMIN_CODE });\n\n/** Returns admin role with userCount\n * @returns {Promise<role>}\n */\nconst getSuperAdminWithUsersCount = () => findOneWithUsersCount({ code: SUPER_ADMIN_CODE });\n\n/** Create superAdmin, Author and Editor role is no role already exist\n * @returns {Promise<>}\n */\nconst createRolesIfNoneExist = async () => {\n  const someRolesExist = await exists();\n  if (someRolesExist) {\n    return;\n  }\n\n  const allActions = strapi.admin.services.permission.actionProvider.getAll();\n  const contentTypesActions = allActions.filter(a => a.section === 'contentTypes');\n\n  // create 3 roles\n  const superAdminRole = await create({\n    name: 'Super Admin',\n    code: 'strapi-super-admin',\n    description: 'Super Admins can access and manage all features and settings.',\n  });\n\n  await strapi.admin.services.user.assignARoleToAll(superAdminRole.id);\n\n  const editorRole = await create({\n    name: 'Editor',\n    code: 'strapi-editor',\n    description: 'Editors can manage and publish contents including those of other users.',\n  });\n\n  const authorRole = await create({\n    name: 'Author',\n    code: 'strapi-author',\n    description: 'Authors can manage the content they have created.',\n  });\n\n  // create content-type permissions for each role\n  const editorPermissions = strapi.admin.services['content-type'].getPermissionsWithNestedFields(\n    contentTypesActions,\n    {\n      restrictedSubjects: ['plugins::users-permissions.user'],\n    }\n  );\n\n  const authorPermissions = editorPermissions\n    .filter(({ action }) => action !== ACTIONS.publish)\n    .map(set('conditions', ['admin::is-creator']));\n\n  editorPermissions.push(...getDefaultPluginPermissions());\n  authorPermissions.push(...getDefaultPluginPermissions({ isAuthor: true }));\n\n  // assign permissions to roles\n  await addPermissions(editorRole.id, editorPermissions);\n  await addPermissions(authorRole.id, authorPermissions);\n};\n\nconst getDefaultPluginPermissions = ({ isAuthor = false } = {}) => {\n  const conditions = isAuthor ? ['admin::is-creator'] : null;\n\n  // add plugin permissions for each role\n  return [\n    { action: 'plugins::upload.read', conditions },\n    { action: 'plugins::upload.assets.create' },\n    { action: 'plugins::upload.assets.update', conditions },\n    { action: 'plugins::upload.assets.download' },\n    { action: 'plugins::upload.assets.copy-link' },\n  ].map(createPermission);\n};\n\n/** Display a warning if the role superAdmin doesn't exist\n *  or if the role is not assigned to at least one user\n * @returns {Promise<>}\n */\nconst displayWarningIfNoSuperAdmin = async () => {\n  const superAdminRole = await getSuperAdminWithUsersCount();\n  const someUsersExists = await strapi.admin.services.user.exists();\n  if (!superAdminRole) {\n    strapi.log.warn(\"Your application doesn't have a super admin role.\");\n  } else if (someUsersExists && superAdminRole.usersCount === 0) {\n    strapi.log.warn(\"Your application doesn't have a super admin user.\");\n  }\n};\n\n/**\n * Assign permissions to a role\n * @param {string|int} roleId - role ID\n * @param {Array<Permission{action,subject,fields,conditions}>} permissions - permissions to assign to the role\n */\nconst assignPermissions = async (roleId, permissions = []) => {\n  try {\n    await validatePermissionsExist(permissions);\n  } catch (err) {\n    throw strapi.errors.badRequest('ValidationError', err);\n  }\n\n  const superAdmin = await strapi.admin.services.role.getSuperAdmin();\n  const isSuperAdmin = superAdmin && superAdmin.id === roleId;\n\n  const permissionsWithRole = permissions.map(permission =>\n    createPermission({\n      ...permission,\n      conditions: strapi.admin.services.condition.removeUnkownConditionIds(permission.conditions),\n      role: roleId,\n    })\n  );\n\n  const existingPermissions = await strapi.admin.services.permission.find({\n    role: roleId,\n    _limit: -1,\n  });\n  const permissionsToAdd = _.differenceWith(\n    permissionsWithRole,\n    existingPermissions,\n    arePermissionsEqual\n  );\n  const permissionsToDelete = _.differenceWith(\n    existingPermissions,\n    permissionsWithRole,\n    arePermissionsEqual\n  );\n  const permissionsToReturn = _.differenceBy(existingPermissions, permissionsToDelete, 'id');\n\n  if (permissionsToDelete.length > 0) {\n    await strapi.admin.services.permission.deleteByIds(permissionsToDelete.map(p => p.id));\n  }\n\n  if (permissionsToAdd.length > 0) {\n    const createdPermissions = await addPermissions(roleId, permissionsToAdd);\n    permissionsToReturn.push(...createdPermissions.map(p => ({ ...p, role: p.role.id })));\n  }\n\n  if (!isSuperAdmin && (permissionsToAdd.length || permissionsToDelete.length)) {\n    await strapi.admin.services.metrics.sendDidUpdateRolePermissions();\n  }\n\n  return permissionsToReturn;\n};\n\nconst addPermissions = async (roleId, permissions) => {\n  const permissionsWithRole = permissions.map(set('role', roleId));\n\n  return strapi.admin.services.permission.createMany(permissionsWithRole);\n};\n\n/**\n * Reset super admin permissions (giving it all permissions)\n * @returns {Promise<>}\n */\nconst resetSuperAdminPermissions = async () => {\n  const superAdminRole = await strapi.admin.services.role.getSuperAdmin();\n  if (!superAdminRole) {\n    return;\n  }\n\n  const allActions = strapi.admin.services.permission.actionProvider.getAll();\n  const contentTypesActions = allActions.filter(a => a.section === 'contentTypes');\n\n  const permissions = strapi.admin.services['content-type'].getPermissionsWithNestedFields(\n    contentTypesActions\n  );\n\n  const otherActions = allActions.filter(a => a.section !== 'contentTypes');\n  otherActions.forEach(action => {\n    if (action.subjects) {\n      const newPerms = action.subjects.map(subject =>\n        createPermission({ action: action.actionId, subject })\n      );\n      permissions.push(...newPerms);\n    } else {\n      permissions.push(createPermission({ action: action.actionId }));\n    }\n  });\n\n  await assignPermissions(superAdminRole.id, permissions);\n};\n\nmodule.exports = {\n  sanitizeRole,\n  create,\n  findOne,\n  findOneWithUsersCount,\n  find,\n  findAllWithUsersCount,\n  update,\n  exists,\n  count,\n  deleteByIds,\n  getUsersCount,\n  getSuperAdmin,\n  getSuperAdminWithUsersCount,\n  createRolesIfNoneExist,\n  displayWarningIfNoSuperAdmin,\n  addPermissions,\n  assignPermissions,\n  resetSuperAdminPermissions,\n};\n",
    "packages/strapi-admin/services/user.js": "'use strict';\n\nconst _ = require('lodash');\nconst { stringIncludes } = require('strapi-utils');\nconst { createUser, hasSuperAdminRole } = require('../domain/user');\nconst { password: passwordValidator } = require('../validation/common-validators');\nconst { SUPER_ADMIN_CODE } = require('./constants');\n\nconst sanitizeUserRoles = role => _.pick(role, ['id', 'name', 'description', 'code']);\n\n/**\n * Remove private user fields\n * @param {Object} user - user to sanitize\n */\nconst sanitizeUser = user => {\n  return {\n    ..._.omit(user, ['password', 'resetPasswordToken', 'roles']),\n    roles: user.roles && user.roles.map(sanitizeUserRoles),\n  };\n};\n\n/**\n * Create and save a user in database\n * @param attributes A partial user object\n * @returns {Promise<user>}\n */\nconst create = async attributes => {\n  const userInfo = {\n    registrationToken: strapi.admin.services.token.createToken(),\n    ...attributes,\n  };\n\n  if (_.has(attributes, 'password')) {\n    userInfo.password = await strapi.admin.services.auth.hashPassword(attributes.password);\n  }\n\n  const user = createUser(userInfo);\n  const createdUser = await strapi.query('user', 'admin').create(user);\n\n  await strapi.admin.services.metrics.sendDidInviteUser();\n\n  return createdUser;\n};\n\n/**\n * Update a user in database\n * @param id query params to find the user to update\n * @param attributes A partial user object\n * @returns {Promise<user>}\n */\nconst updateById = async (id, attributes) => {\n  // Check at least one super admin remains\n  if (_.has(attributes, 'roles')) {\n    const lastAdminUser = await isLastSuperAdminUser(id);\n    const superAdminRole = await strapi.admin.services.role.getSuperAdminWithUsersCount();\n    const willRemoveSuperAdminRole = !stringIncludes(attributes.roles, superAdminRole.id);\n\n    if (lastAdminUser && willRemoveSuperAdminRole) {\n      throw strapi.errors.badRequest(\n        'ValidationError',\n        'You must have at least one user with super admin role.'\n      );\n    }\n  }\n\n  // cannot disable last super admin\n  if (attributes.isActive === false) {\n    const lastAdminUser = await isLastSuperAdminUser(id);\n    if (lastAdminUser) {\n      throw strapi.errors.badRequest(\n        'ValidationError',\n        'You must have at least one active user with super admin role.'\n      );\n    }\n  }\n\n  // hash password if a new one is sent\n  if (_.has(attributes, 'password')) {\n    const hashedPassword = await strapi.admin.services.auth.hashPassword(attributes.password);\n\n    return strapi.query('user', 'admin').update(\n      { id },\n      {\n        ...attributes,\n        password: hashedPassword,\n      }\n    );\n  }\n\n  return strapi.query('user', 'admin').update({ id }, attributes);\n};\n\n/**\n * Reset a user password by email. (Used in admin:reset CLI)\n * @param {string} email - user email\n * @param {string} password - new password\n */\nconst resetPasswordByEmail = async (email, password) => {\n  const user = await findOne({ email });\n\n  if (!user) {\n    throw new Error(`User not found for email: ${email}`);\n  }\n\n  try {\n    await passwordValidator.validate(password);\n  } catch (error) {\n    throw new Error(\n      'Invalid password. Expected a minimum of 8 characters with at least one number and one uppercase letter'\n    );\n  }\n\n  await updateById(user.id, { password });\n};\n\n/**\n * Check if a user is the last super admin\n * @param {int|string} userId user's id to look for\n */\nconst isLastSuperAdminUser = async userId => {\n  const user = await findOne({ id: userId }, ['roles']);\n  const superAdminRole = await strapi.admin.services.role.getSuperAdminWithUsersCount();\n\n  return superAdminRole.usersCount === 1 && hasSuperAdminRole(user);\n};\n\n/**\n * Check if a user with specific attributes exists in the database\n * @param attributes A partial user object\n * @returns {Promise<boolean>}\n */\nconst exists = async (attributes = {}) => {\n  return (await strapi.query('user', 'admin').count(attributes)) > 0;\n};\n\n/**\n * Returns a user registration info\n * @param {string} registrationToken - a user registration token\n * @returns {Promise<registrationInfo>} - Returns user email, firstname and lastname\n */\nconst findRegistrationInfo = async registrationToken => {\n  const user = await strapi.query('user', 'admin').findOne({ registrationToken });\n\n  if (!user) {\n    return undefined;\n  }\n\n  return _.pick(user, ['email', 'firstname', 'lastname']);\n};\n\n/**\n * Registers a user based on a registrationToken and some informations to update\n * @param {Object} params\n * @param {Object} params.registrationToken registration token\n * @param {Object} params.userInfo user info\n */\nconst register = async ({ registrationToken, userInfo }) => {\n  const matchingUser = await strapi.query('user', 'admin').findOne({ registrationToken });\n\n  if (!matchingUser) {\n    throw strapi.errors.badRequest('Invalid registration info');\n  }\n\n  return strapi.admin.services.user.updateById(matchingUser.id, {\n    password: userInfo.password,\n    firstname: userInfo.firstname,\n    lastname: userInfo.lastname,\n    registrationToken: null,\n    isActive: true,\n  });\n};\n\n/**\n * Find one user\n */\nconst findOne = async (params, populate) => {\n  return strapi.query('user', 'admin').findOne(params, populate);\n};\n\n/** Find many users (paginated)\n * @param query\n * @returns {Promise<user>}\n */\nconst findPage = async query => {\n  return strapi.query('user', 'admin').findPage(query);\n};\n\n/** Search for many users (paginated)\n * @param query\n * @returns {Promise<user>}\n */\nconst searchPage = async query => {\n  return strapi.query('user', 'admin').searchPage(query);\n};\n\n/** Delete a user\n * @param id id of the user to delete\n * @returns {Promise<user>}\n */\nconst deleteById = async id => {\n  // Check at least one super admin remains\n  const userToDelete = await strapi.query('user', 'admin').findOne({ id }, ['roles']);\n  if (userToDelete) {\n    if (userToDelete.roles.some(r => r.code === SUPER_ADMIN_CODE)) {\n      const superAdminRole = await strapi.admin.services.role.getSuperAdminWithUsersCount();\n      if (superAdminRole.usersCount === 1) {\n        throw strapi.errors.badRequest(\n          'ValidationError',\n          'You must have at least one user with super admin role.'\n        );\n      }\n    }\n  } else {\n    return null;\n  }\n\n  return strapi.query('user', 'admin').delete({ id });\n};\n\n/** Delete a user\n * @param ids ids of the users to delete\n * @returns {Promise<user>}\n */\nconst deleteByIds = async ids => {\n  // Check at least one super admin remains\n  const superAdminRole = await strapi.admin.services.role.getSuperAdminWithUsersCount();\n  const nbOfSuperAdminToDelete = await strapi\n    .query('user', 'admin')\n    .count({ id_in: ids, roles: [superAdminRole.id] });\n  if (superAdminRole.usersCount === nbOfSuperAdminToDelete) {\n    throw strapi.errors.badRequest(\n      'ValidationError',\n      'You must have at least one user with super admin role.'\n    );\n  }\n\n  return strapi.query('user', 'admin').delete({ id_in: ids });\n};\n\n/** Count the users that don't have any associated roles\n * @returns {Promise<number>}\n */\nconst countUsersWithoutRole = async () => {\n  const userModel = strapi.query('user', 'admin').model;\n  let count;\n\n  if (userModel.orm === 'bookshelf') {\n    count = await strapi.query('user', 'admin').count({ roles_null: true });\n  } else if (userModel.orm === 'mongoose') {\n    count = await strapi.query('user', 'admin').model.countDocuments({\n      $or: [{ roles: { $exists: false } }, { roles: { $size: 0 } }],\n    });\n  } else {\n    const allRoles = await strapi.query('role', 'admin').find({ _limit: -1 });\n    count = await strapi.query('user', 'admin').count({\n      roles_nin: allRoles.map(r => r.id),\n    });\n  }\n\n  return count;\n};\n\n/**\n * Count the number of users based on search params\n * @param params params used for the query\n * @returns {Promise<number>}\n */\nconst count = async (params = {}) => {\n  return strapi.query('user', 'admin').count(params);\n};\n\n/** Assign some roles to several users\n * @returns {undefined}\n */\nconst assignARoleToAll = async roleId => {\n  const userModel = strapi.query('user', 'admin').model;\n\n  if (userModel.orm === 'bookshelf') {\n    const assocTable = userModel.associations.find(a => a.alias === 'roles').tableCollectionName;\n    const userTable = userModel.collectionName;\n    const knex = strapi.connections[userModel.connection];\n    const usersIds = await knex\n      .select(`${userTable}.id`)\n      .from(userTable)\n      .leftJoin(assocTable, `${userTable}.id`, `${assocTable}.user_id`)\n      .where(`${assocTable}.role_id`, null)\n      .pluck(`${userTable}.id`);\n\n    if (usersIds.length > 0) {\n      const newRelations = usersIds.map(userId => ({ user_id: userId, role_id: roleId }));\n      await knex.insert(newRelations).into(assocTable);\n    }\n  } else if (userModel.orm === 'mongoose') {\n    await strapi.query('user', 'admin').model.updateMany({}, { roles: [roleId] });\n  }\n};\n\n/** Display a warning if some users don't have at least one role\n * @returns {Promise<>}\n */\nconst displayWarningIfUsersDontHaveRole = async () => {\n  const count = await countUsersWithoutRole();\n\n  if (count > 0) {\n    strapi.log.warn(`Some users (${count}) don't have any role.`);\n  }\n};\n\nconst migrateUsers = async () => {\n  const someRolesExist = await strapi.admin.services.role.exists();\n  if (someRolesExist) {\n    return;\n  }\n\n  const userModel = strapi.query('user', 'admin').model;\n\n  if (userModel.orm === 'bookshelf') {\n    await userModel\n      .query(qb => qb.where('blocked', false).orWhere('blocked', null))\n      .save({ isActive: true }, { method: 'update', patch: true, require: false });\n    await userModel\n      .query(qb => qb.where('blocked', true))\n      .save({ isActive: false }, { method: 'update', patch: true, require: false });\n  } else if (userModel.orm === 'mongoose') {\n    await userModel.updateMany({ blocked: { $in: [false, null] } }, { isActive: true });\n    await userModel.updateMany({ blocked: true }, { isActive: false });\n  }\n};\n\nmodule.exports = {\n  create,\n  updateById,\n  exists,\n  findRegistrationInfo,\n  register,\n  sanitizeUser,\n  findOne,\n  findPage,\n  searchPage,\n  deleteById,\n  deleteByIds,\n  countUsersWithoutRole,\n  count,\n  assignARoleToAll,\n  displayWarningIfUsersDontHaveRole,\n  migrateUsers,\n  resetPasswordByEmail,\n};\n",
    "packages/strapi-admin/tests/admin-auth.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createStrapiInstance, superAdmin } = require('../../../test/helpers/strapi');\nconst { createUtils } = require('../../../test/helpers/utils');\n\nconst edition = process.env.STRAPI_DISABLE_EE === 'true' ? 'CE' : 'EE';\n\nlet internals = {\n  role: null,\n};\n\ndescribe('Admin Auth End to End', () => {\n  let rq;\n  let strapi;\n  let utils;\n\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    utils = createUtils(strapi);\n\n    if (edition === 'EE') {\n      internals.role = await utils.createRole({\n        name: 'auth_test_role',\n        description: 'Only used for auth crud test (e2e)',\n      });\n    } else {\n      internals.role = await utils.getSuperAdminRole();\n    }\n  }, 60000);\n\n  afterAll(async () => {\n    if (edition === 'EE') {\n      await utils.deleteRolesById([internals.role.id]);\n    }\n\n    await strapi.destroy();\n  }, 60000);\n\n  describe('Login', () => {\n    test('Can connect successfully', async () => {\n      const res = await rq({\n        url: '/admin/login',\n        method: 'POST',\n        body: superAdmin.loginInfo,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toMatchObject({\n        token: expect.any(String),\n        user: {\n          firstname: expect.stringOrNull(),\n          lastname: expect.stringOrNull(),\n          username: expect.stringOrNull(),\n          email: expect.any(String),\n          isActive: expect.any(Boolean),\n        },\n      });\n    });\n\n    test('Fails on invalid password', async () => {\n      const res = await rq({\n        url: '/admin/login',\n        method: 'POST',\n        body: {\n          ...superAdmin.loginInfo,\n          password: 'wrongPassword',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'Invalid credentials',\n      });\n    });\n\n    test('Fails on invalid email', async () => {\n      const res = await rq({\n        url: '/admin/login',\n        method: 'POST',\n        body: {\n          email: 'non-existent-user@strapi.io',\n          password: 'pcw123',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'Invalid credentials',\n      });\n    });\n\n    test('Fails on missing credentials', async () => {\n      const res = await rq({\n        url: '/admin/login',\n        method: 'POST',\n        body: {\n          email: 'non-existent-user@strapi.io',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'Missing credentials',\n      });\n    });\n  });\n\n  describe('Renew token', () => {\n    test('Renew token', async () => {\n      const authRes = await rq({\n        url: '/admin/login',\n        method: 'POST',\n        body: superAdmin.loginInfo,\n      });\n\n      expect(authRes.statusCode).toBe(200);\n      const { token } = authRes.body.data;\n\n      const res = await rq({\n        url: '/admin/renew-token',\n        method: 'POST',\n        body: {\n          token,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toEqual({\n        token: expect.any(String),\n      });\n    });\n\n    test('Fails on invalid token', async () => {\n      const res = await rq({\n        url: '/admin/renew-token',\n        method: 'POST',\n        body: {\n          token: 'invalid-token',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'Invalid token',\n      });\n    });\n\n    test('Fails on missing token', async () => {\n      const res = await rq({\n        url: '/admin/renew-token',\n        method: 'POST',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'Missing token',\n      });\n    });\n  });\n\n  describe('GET /registration-info', () => {\n    const registrationToken = 'foobar';\n    let user;\n\n    beforeAll(async () => {\n      const userInfo = {\n        email: 'test@strapi.io',\n        firstname: 'test',\n        lastname: 'strapi',\n        roles: [internals.role.id],\n        registrationToken,\n        isActive: false,\n      };\n\n      user = await utils.createUser(userInfo);\n    });\n\n    afterAll(async () => {\n      await utils.deleteUserById(user.id);\n    });\n\n    test('Returns registration info', async () => {\n      const res = await rq({\n        url: `/admin/registration-info?registrationToken=${registrationToken}`,\n        method: 'GET',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          email: user.email,\n          firstname: user.firstname,\n          lastname: user.lastname,\n        },\n      });\n    });\n\n    test('Fails on missing registration token', async () => {\n      const res = await rq({\n        url: '/admin/registration-info',\n        method: 'GET',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'QueryError',\n        data: {\n          registrationToken: ['registrationToken is a required field'],\n        },\n      });\n    });\n\n    test('Fails on invalid registration token. Without too much info', async () => {\n      const res = await rq({\n        url: '/admin/registration-info?registrationToken=ABCD',\n        method: 'GET',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'Invalid registrationToken',\n      });\n    });\n  });\n\n  describe('GET /register', () => {\n    let user;\n\n    beforeEach(async () => {\n      const userInfo = {\n        email: 'test@strapi.io',\n        firstname: 'test',\n        lastname: 'strapi',\n        registrationToken: 'foobar',\n      };\n\n      user = await utils.createUser(userInfo);\n    });\n\n    afterEach(async () => {\n      await utils.deleteUserById(user.id);\n    });\n\n    test('Fails on missing payload', async () => {\n      const res = await rq({\n        url: '/admin/register',\n        method: 'POST',\n        body: {\n          userInfo: {},\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          registrationToken: ['registrationToken is a required field'],\n\n          'userInfo.firstname': ['userInfo.firstname is a required field'],\n          'userInfo.lastname': ['userInfo.lastname is a required field'],\n          'userInfo.password': ['userInfo.password is a required field'],\n        },\n      });\n    });\n\n    test('Fails on invalid password', async () => {\n      const res = await rq({\n        url: '/admin/register',\n        method: 'POST',\n        body: {\n          registrationToken: user.registrationToken,\n          userInfo: {\n            firstname: 'test',\n            lastname: 'Strapi',\n            password: '123',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          'userInfo.password': ['userInfo.password must contain at least one uppercase character'],\n        },\n      });\n    });\n\n    test('Registers user correctly', async () => {\n      const userRegistrationInfo = {\n        firstname: 'test',\n        lastname: 'Strapi',\n        password: '1Test2azda3',\n      };\n\n      const res = await rq({\n        url: '/admin/register',\n        method: 'POST',\n        body: {\n          registrationToken: user.registrationToken,\n          userInfo: userRegistrationInfo,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toMatchObject({\n        token: expect.any(String),\n        user: {\n          email: user.email,\n          firstname: 'test',\n          lastname: 'Strapi',\n        },\n      });\n\n      expect(res.body.data.user.password === userRegistrationInfo.password).toBe(false);\n    });\n  });\n\n  describe('GET /register-admin', () => {\n    test('Fails on missing payload', async () => {\n      const res = await rq({\n        url: '/admin/register-admin',\n        method: 'POST',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          email: ['email is a required field'],\n          firstname: ['firstname is a required field'],\n          lastname: ['lastname is a required field'],\n          password: ['password is a required field'],\n        },\n      });\n    });\n\n    test('Fails on invalid password', async () => {\n      const res = await rq({\n        url: '/admin/register-admin',\n        method: 'POST',\n        body: {\n          email: 'test@strapi.io',\n          firstname: 'test',\n          lastname: 'Strapi',\n          password: '123',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          password: ['password must contain at least one uppercase character'],\n        },\n      });\n    });\n\n    test('Fails if already a user', async () => {\n      const userInfo = {\n        email: 'test-admin@strapi.io',\n        firstname: 'test',\n        lastname: 'Strapi',\n        password: '1Test2azda3',\n      };\n\n      const res = await rq({\n        url: '/admin/register-admin',\n        method: 'POST',\n        body: userInfo,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'You cannot register a new super admin',\n      });\n    });\n  });\n\n  describe('POST /forgot-password', () => {\n    test('Always returns en empty response', async () => {\n      const res = await rq({\n        url: '/admin/forgot-password',\n        method: 'POST',\n        body: {\n          email: 'admin@strapi.io',\n        },\n      });\n\n      expect(res.statusCode).toBe(204);\n      expect(res.body).toStrictEqual({});\n\n      const nonExistentRes = await rq({\n        url: '/admin/forgot-password',\n        method: 'POST',\n        body: {\n          email: 'email-do-not-exist@strapi.io',\n        },\n      });\n\n      expect(nonExistentRes.statusCode).toBe(204);\n      expect(nonExistentRes.body).toStrictEqual({});\n    });\n  });\n});\n",
    "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest, createRequest } = require('../../../test/helpers/request');\n\ndescribe('Authenticated User', () => {\n  let rq;\n  let strapi;\n\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  describe('GET /users/me', () => {\n    test('Returns sanitized user info', async () => {\n      const res = await rq({\n        url: '/admin/users/me',\n        method: 'GET',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toMatchObject({\n        id: expect.anything(),\n        firstname: expect.stringOrNull(),\n        lastname: expect.stringOrNull(),\n        username: expect.stringOrNull(),\n        email: expect.any(String),\n        isActive: expect.any(Boolean),\n      });\n    });\n\n    test('Returns forbidden on unauthenticated query', async () => {\n      const req = createRequest({ strapi });\n      const res = await req({\n        url: '/admin/users/me',\n        method: 'GET',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(403);\n    });\n  });\n\n  describe('PUT /users/me', () => {\n    test('Returns forbidden on unauthenticated query', async () => {\n      const req = createRequest({ strapi });\n      const res = await req({\n        url: '/admin/users/me',\n        method: 'PUT',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(403);\n    });\n\n    test('Fails when trying to edit roles', async () => {\n      const res = await rq({\n        url: '/admin/users/me',\n        method: 'PUT',\n        body: {\n          roles: [1],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n      });\n    });\n\n    test('Fails when trying to edit isActive', async () => {\n      const res = await rq({\n        url: '/admin/users/me',\n        method: 'PUT',\n        body: {\n          isActive: 12,\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n      });\n    });\n\n    test('Fails when trying to set invalid inputs', async () => {\n      const res = await rq({\n        url: '/admin/users/me',\n        method: 'PUT',\n        body: {\n          isActive: 12,\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n      });\n    });\n\n    test('Allows edition of names', async () => {\n      const input = {\n        firstname: 'newFirstName',\n        lastname: 'newLastaName',\n      };\n\n      const res = await rq({\n        url: '/admin/users/me',\n        method: 'PUT',\n        body: input,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toMatchObject({\n        id: expect.anything(),\n        email: expect.any(String),\n        firstname: input.firstname,\n        lastname: input.lastname,\n        username: expect.stringOrNull(),\n        isActive: expect.any(Boolean),\n        roles: expect.arrayContaining([]),\n      });\n    });\n  });\n});\n",
    "packages/strapi-admin/tests/admin-permission.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\n\ndescribe('Role CRUD End to End', () => {\n  let rq;\n  let strapi;\n\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  test('Can get the existing permissions', async () => {\n    let res = await rq({\n      url: '/admin/permissions',\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(200);\n\n    // Data is sorted to avoid error with snapshot when the data is not in the same order\n    const sortedData = _.cloneDeep(res.body.data);\n    Object.keys(sortedData.sections).forEach(sectionName => {\n      sortedData.sections[sectionName] = _.sortBy(sortedData.sections[sectionName], ['action']);\n    });\n    sortedData.conditions = sortedData.conditions.sort();\n    expect(sortedData).toMatchSnapshot();\n  });\n});\n",
    "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js": "'use strict';\n\nconst { prop } = require('lodash/fp');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createRequest, createAuthRequest } = require('../../../test/helpers/request');\nconst { createUtils } = require('../../../test/helpers/utils');\n\nconst edition = process.env.STRAPI_DISABLE_EE === 'true' ? 'CE' : 'EE';\n\nif (edition === 'EE') {\n  describe('Admin Permissions - Conditions', () => {\n    let strapi;\n    let utils;\n    const builder = createTestBuilder();\n    let requests = {\n      public: null,\n      admin: null,\n    };\n\n    const localTestData = {\n      models: {\n        article: {\n          name: 'article',\n          attributes: {\n            title: {\n              type: 'string',\n            },\n            price: {\n              type: 'integer',\n            },\n          },\n        },\n      },\n      entry: {\n        name: 'Test Article',\n        price: 999,\n      },\n      role: {\n        name: 'foobar',\n        description: 'A dummy test role',\n      },\n      permissions: [\n        {\n          action: 'plugins::content-manager.explorer.create',\n          subject: 'application::article.article',\n          fields: null,\n          conditions: [],\n        },\n        {\n          action: 'plugins::content-manager.explorer.read',\n          subject: 'application::article.article',\n          fields: null,\n          conditions: ['admin::has-same-role-as-creator'],\n        },\n        {\n          action: 'plugins::content-manager.explorer.delete',\n          subject: 'application::article.article',\n          fields: null,\n          conditions: ['admin::is-creator'],\n        },\n      ],\n      userPassword: 'fooBar42',\n      users: [\n        { firstname: 'Alice', lastname: 'Foo', email: 'alice.foo@test.com' },\n        { firstname: 'Bob', lastname: 'Bar', email: 'bob.bar@test.com' },\n      ],\n    };\n\n    const createFixtures = async () => {\n      // Login with admin and init admin tools\n      requests.admin = await createAuthRequest({ strapi });\n      requests.public = createRequest({ strapi });\n\n      // Create the foobar role\n      const role = await utils.createRole(localTestData.role);\n\n      // Assign permissions to the foobar role\n      const permissions = await utils.assignPermissionsToRole(role.id, localTestData.permissions);\n      Object.assign(role, { permissions });\n\n      // Create users with the new role & create associated auth requests\n      const users = [];\n\n      for (let i = 0; i < localTestData.users.length; ++i) {\n        const userFixture = localTestData.users[i];\n        const userAttributes = {\n          ...userFixture,\n          password: localTestData.userPassword,\n          roles: [role.id],\n        };\n\n        const createdUser = await utils.createUser(userAttributes);\n\n        requests[createdUser.id] = await createAuthRequest({ strapi, userInfo: createdUser });\n\n        users.push(createdUser);\n      }\n\n      // Update the local data store\n      Object.assign(localTestData, { role, permissions, users });\n    };\n\n    const getUserRequest = idx => requests[localTestData.users[idx].id];\n    const getModelName = () => localTestData.models.article.name;\n\n    const deleteFixtures = async () => {\n      // Delete users\n      const usersId = localTestData.users.map(prop('id'));\n      await utils.deleteUsersById(usersId);\n\n      // Delete the foobar role\n      await utils.deleteRolesById([localTestData.role.id]);\n    };\n\n    beforeAll(async () => {\n      await builder.addContentType(localTestData.models.article).build();\n\n      strapi = await createStrapiInstance();\n      utils = createUtils(strapi);\n\n      await createFixtures();\n    }, 60000);\n\n    afterAll(async () => {\n      await deleteFixtures();\n      await strapi.destroy();\n      await builder.cleanup();\n    }, 60000);\n\n    test('User A can create an entry', async () => {\n      const rq = getUserRequest(0);\n      const modelName = getModelName();\n      const res = await rq({\n        method: 'POST',\n        url: `/content-manager/collection-types/application::${modelName}.${modelName}`,\n        body: localTestData.entry,\n      });\n\n      expect(res.statusCode).toBe(200);\n      localTestData.entry = res.body;\n    });\n\n    test('User A can read its entry', async () => {\n      const { id } = localTestData.entry;\n      const modelName = getModelName();\n      const rq = getUserRequest(0);\n      const res = await rq({\n        method: 'GET',\n        url: `/content-manager/collection-types/application::${modelName}.${modelName}/${id}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(localTestData.entry);\n    });\n\n    test('User B can read the entry created by user A', async () => {\n      const { id } = localTestData.entry;\n      const modelName = getModelName();\n      const rq = getUserRequest(1);\n      const res = await rq({\n        method: 'GET',\n        url: `/content-manager/collection-types/application::${modelName}.${modelName}/${id}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(localTestData.entry);\n    });\n\n    test('User B cannot delete the entry created by user A', async () => {\n      const { id } = localTestData.entry;\n      const modelName = getModelName();\n      const rq = getUserRequest(1);\n      const res = await rq({\n        method: 'DELETE',\n        url: `/content-manager/collection-types/application::${modelName}.${modelName}/${id}`,\n      });\n\n      expect(res.statusCode).toBe(403);\n    });\n\n    test('User A can delete its entry', async () => {\n      const { id } = localTestData.entry;\n      const modelName = getModelName();\n      const rq = getUserRequest(0);\n      const res = await rq({\n        method: 'DELETE',\n        url: `/content-manager/collection-types/application::${modelName}.${modelName}/${id}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(localTestData.entry);\n    });\n  });\n} else {\n  describe('Admin Permissions - Conditions ', () => {\n    test.skip('Only in EE', () => {});\n  });\n}\n",
    "packages/strapi-admin/tests/admin-role.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst edition = process.env.STRAPI_DISABLE_EE === 'true' ? 'CE' : 'EE';\nconst sortPermissionArray = arr => _.sortBy(arr, ['action', 'subject']);\n\nconst data = {\n  rolesWithUsers: [],\n  rolesWithoutUsers: [],\n  users: [],\n  deleteRolesIds: [],\n  superAdminRole: undefined,\n  authorRole: undefined,\n  editorRole: undefined,\n};\n\nconst omitTimestamps = obj => _.omit(obj, ['updatedAt', 'createdAt', 'updated_at', 'created_at']);\n\ndescribe('Role CRUD End to End', () => {\n  let rq;\n  let strapi;\n\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  describe('Default roles', () => {\n    test('Default roles are created', async () => {\n      const defaultsRoles = [\n        {\n          name: 'Super Admin',\n          code: 'strapi-super-admin',\n          description: 'Super Admins can access and manage all features and settings.',\n          usersCount: 1,\n        },\n        {\n          name: 'Editor',\n          code: 'strapi-editor',\n          description: 'Editors can manage and publish contents including those of other users.',\n          usersCount: 0,\n        },\n        {\n          name: 'Author',\n          code: 'strapi-author',\n          description: 'Authors can manage the content they have created.',\n          usersCount: 0,\n        },\n      ];\n\n      const res = await rq({\n        url: '/admin/roles',\n        method: 'GET',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toHaveLength(3);\n      expect(res.body.data).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining(defaultsRoles[0]),\n          expect.objectContaining(defaultsRoles[1]),\n          expect.objectContaining(defaultsRoles[2]),\n        ])\n      );\n      data.superAdminRole = res.body.data.find(r => r.code === 'strapi-super-admin');\n      data.authorRole = res.body.data.find(r => r.code === 'strapi-author');\n      data.editorRole = res.body.data.find(r => r.code === 'strapi-editor');\n    });\n\n    test('Author have admin::is-creator condition for every permission', async () => {\n      const res = await rq({\n        url: `/admin/roles/${data.authorRole.id}/permissions`,\n        method: 'GET',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data)).toBe(true);\n      expect(res.body.data).toHaveLength(5);\n      res.body.data\n        .filter(p => !p.action.includes('plugins::upload'))\n        .forEach(permission => {\n          expect(permission.conditions).toEqual(['admin::is-creator']);\n        });\n    });\n\n    test(\"Editor's permissions don't have any conditions\", async () => {\n      const res = await rq({\n        url: `/admin/roles/${data.editorRole.id}/permissions`,\n        method: 'GET',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data)).toBe(true);\n      expect(res.body.data).toHaveLength(5);\n      res.body.data\n        .filter(p => !p.action.includes('plugins::upload'))\n        .forEach(permission => {\n          expect(permission.conditions).toEqual([]);\n        });\n    });\n\n    if (edition === 'EE') {\n      const newPermissions = [\n        {\n          action: 'plugins::users-permissions.roles.update',\n        },\n        {\n          action: 'plugins::content-manager.explorer.create',\n          subject: 'plugins::users-permissions.user',\n          fields: ['username'],\n          conditions: ['admin::is-creator'],\n        },\n      ];\n\n      test('Conditions of editors and author can be modified', async () => {\n        let res = await rq({\n          url: `/admin/roles/${data.editorRole.id}/permissions`,\n          method: 'PUT',\n          body: { permissions: newPermissions },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toHaveLength(2);\n        expect(res.body).toEqual({\n          data: expect.arrayContaining([\n            expect.objectContaining({\n              action: 'plugins::users-permissions.roles.update',\n              conditions: [],\n            }),\n            expect.objectContaining({\n              action: 'plugins::content-manager.explorer.create',\n              subject: 'plugins::users-permissions.user',\n              fields: ['username'],\n              conditions: ['admin::is-creator'],\n            }),\n          ]),\n        });\n\n        res = await rq({\n          url: `/admin/roles/${data.authorRole.id}/permissions`,\n          method: 'PUT',\n          body: { permissions: newPermissions },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toHaveLength(2);\n        expect(res.body).toEqual({\n          data: expect.arrayContaining([\n            expect.objectContaining({\n              action: 'plugins::users-permissions.roles.update',\n              conditions: [],\n            }),\n            expect.objectContaining({\n              action: 'plugins::content-manager.explorer.create',\n              subject: 'plugins::users-permissions.user',\n              fields: ['username'],\n              conditions: ['admin::is-creator'],\n            }),\n          ]),\n        });\n      });\n    } else if (edition === 'CE') {\n      const newPermissions = [\n        {\n          action: 'plugins::users-permissions.roles.update',\n        },\n        {\n          action: 'plugins::users-permissions.roles.read',\n          conditions: ['admin::is-creator'],\n        },\n        {\n          action: 'plugins::content-manager.explorer.create',\n          subject: 'plugins::users-permissions.user',\n          fields: ['username'],\n          conditions: ['admin::is-creator'],\n        },\n        {\n          action: 'plugins::content-manager.explorer.update',\n          subject: 'plugins::users-permissions.user',\n          fields: ['username'],\n          conditions: ['admin::is-creator'],\n        },\n        {\n          action: 'plugins::content-manager.explorer.delete',\n          subject: 'plugins::users-permissions.user',\n          fields: null,\n          conditions: ['admin::is-creator'],\n        },\n        {\n          action: 'plugins::content-manager.explorer.read',\n          subject: 'plugins::users-permissions.user',\n          fields: ['username'],\n          conditions: ['admin::is-creator'],\n        },\n      ];\n\n      test(\"Conditions of editors and author can't be modified\", async () => {\n        let res = await rq({\n          url: `/admin/roles/${data.editorRole.id}/permissions`,\n          method: 'PUT',\n          body: { permissions: newPermissions },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toHaveLength(6);\n        expect(res.body).toEqual({\n          data: expect.arrayContaining(\n            newPermissions\n              .slice(3, 6)\n              .map(p => ({ ...p, conditions: [] }))\n              .map(expect.objectContaining)\n          ),\n        });\n\n        res = await rq({\n          url: `/admin/roles/${data.authorRole.id}/permissions`,\n          method: 'PUT',\n          body: { permissions: newPermissions },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toHaveLength(6);\n        expect(res.body).toEqual({\n          data: expect.arrayContaining(\n            newPermissions\n              .slice(3, 6)\n              .map(p => ({ ...p, conditions: ['admin::is-creator'] }))\n              .map(expect.objectContaining)\n          ),\n        });\n      });\n    }\n  });\n\n  if (edition === 'EE') {\n    describe('Create some roles', () => {\n      const rolesToCreate = [\n        [{ name: 'new role 0', description: 'description' }],\n        [{ name: 'new role 1', description: 'description' }],\n        [{ name: 'new role 2', description: 'description' }],\n        [{ name: 'new role 3', description: 'description' }],\n        [{ name: 'new role 4', description: 'description' }],\n        [{ name: 'new role 5', description: 'description' }],\n      ];\n      test.each(rolesToCreate)('can create %p', async role => {\n        let res = await rq({\n          url: '/admin/roles',\n          method: 'POST',\n          body: role,\n        });\n\n        expect(res.statusCode).toBe(201);\n        expect(res.body.data).toMatchObject({\n          id: expect.anything(),\n          name: role.name,\n          description: role.description,\n        });\n        data.rolesWithoutUsers.push(res.body.data);\n      });\n      test('Cannot create a role already existing', async () => {\n        const role = _.pick(data.rolesWithoutUsers[0], ['name', 'description']);\n        const res = await rq({\n          url: '/admin/roles',\n          method: 'POST',\n          body: role,\n        });\n\n        expect(res.statusCode).toBe(400);\n        expect(res.body.data).toMatchObject({\n          name: [`The name must be unique and a role with name \\`${role.name}\\` already exists.`],\n        });\n      });\n      test('Can create a user with a role', async () => {\n        const user = {\n          email: 'new-user@strapi.io',\n          firstname: 'New',\n          lastname: 'User',\n          roles: [data.rolesWithoutUsers[5].id],\n        };\n\n        const res = await rq({\n          url: '/admin/users',\n          method: 'POST',\n          body: user,\n        });\n\n        expect(res.statusCode).toBe(201);\n\n        data.users.push(res.body.data);\n        data.rolesWithUsers.push(data.rolesWithoutUsers[5]);\n        data.rolesWithoutUsers.splice(5, 1);\n      });\n    });\n\n    describe('Find a role', () => {\n      test('Can find a role successfully', async () => {\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}`,\n          method: 'GET',\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toMatchObject({\n          id: data.rolesWithoutUsers[0].id,\n          name: data.rolesWithoutUsers[0].name,\n          description: data.rolesWithoutUsers[0].description,\n          usersCount: 0,\n          code: expect.anything(),\n        });\n        expect(res.body.data.code.startsWith('new-role-0')).toBe(true);\n      });\n    });\n\n    describe('Find all roles', () => {\n      test('Can find all roles successfully', async () => {\n        const expectedRolesWithoutUser = data.rolesWithoutUsers.map(r => ({ ...r, usersCount: 0 }));\n        const expectedRolesWithUser = data.rolesWithUsers.map(r => ({ ...r, usersCount: 1 }));\n        const expectedRoles = expectedRolesWithoutUser.concat(expectedRolesWithUser);\n\n        const res = await rq({\n          url: '/admin/roles',\n          method: 'GET',\n        });\n\n        expect(res.statusCode).toBe(200);\n        expectedRoles.forEach(role => {\n          expect(res.body.data).toEqual(\n            expect.arrayContaining([\n              expect.objectContaining({\n                id: role.id,\n                name: role.name,\n                description: role.description,\n                usersCount: role.usersCount,\n                code: expect.anything(),\n              }),\n            ])\n          );\n        });\n      });\n    });\n\n    describe('Update a role', () => {\n      test('Can update name and description of a role successfully', async () => {\n        const updates = {\n          name: 'new name - Cannot update the name of a role',\n          description: 'new description - Can update a role successfully',\n        };\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}`,\n          method: 'PUT',\n          body: updates,\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(omitTimestamps(res.body.data)).toMatchObject({\n          ...omitTimestamps(data.rolesWithoutUsers[0]),\n          ...updates,\n        });\n        data.rolesWithoutUsers[0] = res.body.data;\n      });\n\n      test('Can update description of a role successfully', async () => {\n        const updates = {\n          name: 'new name - Cannot update the name of a role',\n          description: 'new description - Can update description of a role successfully',\n        };\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}`,\n          method: 'PUT',\n          body: updates,\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(omitTimestamps(res.body.data)).toMatchObject({\n          ...omitTimestamps(data.rolesWithoutUsers[0]),\n          ...updates,\n        });\n        data.rolesWithoutUsers[0] = res.body.data;\n      });\n\n      test('Cannot update the name of a role if already exists', async () => {\n        const updates = {\n          name: data.rolesWithoutUsers[0].name,\n          description: 'new description - Cannot update the name of a role if already exists',\n        };\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[1].id}`,\n          method: 'PUT',\n          body: updates,\n        });\n\n        expect(res.statusCode).toBe(400);\n        expect(res.body.data).toMatchObject({\n          name: [\n            `The name must be unique and a role with name \\`${data.rolesWithoutUsers[0].name}\\` already exists.`,\n          ],\n        });\n      });\n\n      test('Cannot update super admin role', async () => {\n        const updates = {\n          name: 'new name - Cannot update the name of a role',\n          description: 'new description - Can update a role successfully',\n        };\n        const res = await rq({\n          url: `/admin/roles/${data.superAdminRole.id}`,\n          method: 'PUT',\n          body: updates,\n        });\n\n        expect(res.statusCode).toBe(400);\n      });\n    });\n\n    describe('Delete roles', () => {\n      describe('batch-delete', () => {\n        test(\"Don't delete the roles if some still have assigned users\", async () => {\n          const roles = [data.rolesWithUsers[0], data.rolesWithUsers[0]];\n          const rolesIds = roles.map(r => r.id);\n          let res = await rq({\n            url: '/admin/roles/batch-delete',\n            method: 'POST',\n            body: { ids: rolesIds },\n          });\n\n          expect(res.statusCode).toBe(400);\n          expect(res.body.data).toMatchObject({\n            ids: ['Some roles are still assigned to some users.'],\n          });\n\n          for (let role of roles) {\n            res = await rq({\n              url: `/admin/roles/${role.id}`,\n              method: 'GET',\n            });\n            expect(res.statusCode).toBe(200);\n            expect(res.body.data).toMatchObject(role);\n          }\n        });\n\n        test('Can delete a role', async () => {\n          let res = await rq({\n            url: '/admin/roles/batch-delete',\n            method: 'POST',\n            body: { ids: [data.rolesWithoutUsers[0].id] },\n          });\n          expect(res.statusCode).toBe(200);\n          expect(res.body.data).toMatchObject([data.rolesWithoutUsers[0]]);\n\n          res = await rq({\n            url: `/admin/roles/${data.rolesWithoutUsers[0].id}`,\n            method: 'GET',\n          });\n          expect(res.statusCode).toBe(404);\n\n          data.deleteRolesIds.push(data.rolesWithoutUsers[0].id);\n          data.rolesWithoutUsers.shift();\n        });\n\n        test('Can delete two roles', async () => {\n          const roles = data.rolesWithoutUsers.slice(0, 2);\n          const rolesIds = roles.map(r => r.id);\n\n          let res = await rq({\n            url: '/admin/roles/batch-delete',\n            method: 'POST',\n            body: { ids: rolesIds },\n          });\n          expect(res.statusCode).toBe(200);\n          expect(res.body.data).toMatchObject(roles);\n\n          for (let roleId of rolesIds) {\n            res = await rq({\n              url: `/admin/roles/${roleId}`,\n              method: 'GET',\n            });\n            expect(res.statusCode).toBe(404);\n            data.deleteRolesIds.push(data.rolesWithoutUsers[0].id);\n            data.rolesWithoutUsers.shift();\n          }\n        });\n      });\n\n      describe('simple delete', () => {\n        test('Can delete a role', async () => {\n          let res = await rq({\n            url: `/admin/roles/${data.rolesWithoutUsers[0].id}`,\n            method: 'DELETE',\n          });\n          expect(res.statusCode).toBe(200);\n          expect(res.body.data).toMatchObject(data.rolesWithoutUsers[0]);\n\n          res = await rq({\n            url: `/admin/roles/${data.rolesWithoutUsers[0].id}`,\n            method: 'GET',\n          });\n          expect(res.statusCode).toBe(404);\n\n          data.deleteRolesIds.push(data.rolesWithoutUsers[0].id);\n          data.rolesWithoutUsers.shift();\n        });\n\n        test(\"Don't delete a role if it still has assigned users\", async () => {\n          let res = await rq({\n            url: `/admin/roles/${data.rolesWithUsers[0].id}`,\n            method: 'DELETE',\n          });\n\n          expect(res.statusCode).toBe(400);\n          expect(res.body.data).toMatchObject({\n            ids: ['Some roles are still assigned to some users.'],\n          });\n\n          res = await rq({\n            url: `/admin/roles/${data.rolesWithUsers[0].id}`,\n            method: 'GET',\n          });\n          expect(res.statusCode).toBe(200);\n          expect(res.body.data).toMatchObject(data.rolesWithUsers[0]);\n        });\n\n        test(\"Can't delete super admin role\", async () => {\n          let res = await rq({\n            url: `/admin/roles/${data.superAdminRole.id}`,\n            method: 'DELETE',\n          });\n\n          expect(res.statusCode).toBe(400);\n          expect(res.body.data).toMatchObject({\n            id: ['You cannot delete the super admin role'],\n          });\n\n          res = await rq({\n            url: `/admin/roles/${data.rolesWithUsers[0].id}`,\n            method: 'GET',\n          });\n          expect(res.statusCode).toBe(200);\n          expect(res.body.data).toMatchObject(data.rolesWithUsers[0]);\n        });\n      });\n    });\n\n    describe(\"Roles don't exist\", () => {\n      test(\"Cannot update a role if it doesn't exist\", async () => {\n        const updates = {\n          name: \"new name - Cannot update a role if it doesn't exist\",\n          description: \"new description - Cannot update a role if it doesn't exist\",\n        };\n        const res = await rq({\n          url: `/admin/roles/${data.deleteRolesIds[0]}`,\n          method: 'PUT',\n          body: updates,\n        });\n\n        expect(res.statusCode).toBe(404);\n        expect(res.body).toMatchObject({\n          statusCode: 404,\n          error: 'Not Found',\n          message: 'role.notFound',\n        });\n      });\n\n      test(\"Simple delete - No error if deleting a role that doesn't exist\", async () => {\n        const res = await rq({\n          url: `/admin/roles/${data.deleteRolesIds[0]}`,\n          method: 'DELETE',\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toEqual(null);\n      });\n      test(\"Batch Delete - No error if deleting a role that doesn't exist\", async () => {\n        const res = await rq({\n          url: '/admin/roles/batch-delete',\n          method: 'POST',\n          body: { ids: [data.deleteRolesIds[0]] },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toEqual([]);\n      });\n    });\n\n    describe('get & update Permissions', () => {\n      test('get permissions on empty role', async () => {\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}/permissions`,\n          method: 'GET',\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toEqual({\n          data: [],\n        });\n      });\n\n      test('assign permissions on role', async () => {\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}/permissions`,\n          method: 'PUT',\n          body: {\n            permissions: [\n              {\n                action: 'plugins::users-permissions.roles.update',\n              },\n              {\n                action: 'plugins::content-manager.explorer.create',\n                subject: 'plugins::users-permissions.user',\n                fields: ['username'],\n                conditions: ['admin::is-creator'],\n              },\n            ],\n          },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data.length > 0).toBe(true);\n        res.body.data.forEach(permission => {\n          expect(permission).toMatchObject({\n            id: expect.anything(),\n            action: expect.any(String),\n            subject: expect.stringOrNull(),\n          });\n\n          if (permission.conditions.length > 0) {\n            expect(permission.conditions).toEqual(expect.arrayContaining([expect.any(String)]));\n          }\n          if (permission.fields && permission.fields.length > 0) {\n            expect(permission.fields).toEqual(expect.arrayContaining([expect.any(String)]));\n          }\n        });\n      });\n\n      test('assign permissions on role with an unknown condition', async () => {\n        const permissions = [\n          {\n            action: 'plugins::users-permissions.roles.update',\n          },\n          {\n            action: 'plugins::content-manager.explorer.create',\n            subject: 'plugins::users-permissions.user',\n            fields: ['username'],\n            conditions: ['admin::is-creator'],\n          },\n        ];\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}/permissions`,\n          method: 'PUT',\n          body: {\n            permissions: [\n              permissions[0],\n              {\n                ...permissions[1],\n                conditions: [...permissions[1].conditions, 'unknown-condition'],\n              },\n            ],\n          },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data.length > 0).toBe(true);\n        expect(sortPermissionArray(res.body.data)).toMatchObject(\n          sortPermissionArray(\n            permissions.map(perm => ({ subject: null, fields: null, conditions: [], ...perm }))\n          )\n        );\n      });\n\n      test(\"can't assign non-existing permissions on role\", async () => {\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}/permissions`,\n          method: 'PUT',\n          body: {\n            permissions: [\n              {\n                action: 'non.existing.action',\n              },\n            ],\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n        expect(res.body).toMatchObject({\n          statusCode: 400,\n          error: 'Bad Request',\n          message: 'ValidationError',\n          data: { permissions: ['[0] is not an existing permission action'] },\n        });\n      });\n\n      test('get permissions role', async () => {\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}/permissions`,\n          method: 'GET',\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data.length > 0).toBe(true);\n        res.body.data.forEach(permission => {\n          expect(permission).toMatchObject({\n            id: expect.anything(),\n            action: expect.any(String),\n            subject: expect.stringOrNull(),\n          });\n\n          if (permission.conditions.length > 0) {\n            expect(permission.conditions).toEqual(expect.arrayContaining([expect.any(String)]));\n          }\n          if (permission.fields && permission.fields.length > 0) {\n            expect(permission.fields).toEqual(expect.arrayContaining([expect.any(String)]));\n          }\n        });\n      });\n    });\n  }\n\n  if (edition === 'CE') {\n    describe('Cannot create a new role', () => {\n      test('Cannot create a role successfully', async () => {\n        const role = {\n          name: 'new role',\n          description: 'Description of new role',\n        };\n\n        const res = await rq({\n          url: '/admin/roles',\n          method: 'POST',\n          body: role,\n        });\n\n        expect(res.statusCode).toBe(405);\n      });\n    });\n  }\n});\n",
    "packages/strapi-admin/tests/admin-user.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createUtils } = require('../../../test/helpers/utils');\n\nconst edition = process.env.STRAPI_DISABLE_EE === 'true' ? 'CE' : 'EE';\n\nconst omitTimestamps = obj => _.omit(obj, ['updatedAt', 'createdAt', 'updated_at', 'created_at']);\n\n/**\n * == Test Suite Overview ==\n *\n * N   Description\n * -------------------------------------------\n * 1.  Creates a user (wrong body)\n * 2.  Creates a user (successfully)\n * 3.  Creates users with superAdmin role (success)\n * 4.  Updates a user (wrong body)\n * 5.  Updates a user (successfully)\n * 6.  Finds a user (successfully)\n * 7.  Finds a list of users (contains user)\n * 8.  Deletes a user (successfully)\n * 9.  Deletes a user (not found)\n * 10. Deletes 2 super admin users (successfully)\n * 11. Deletes a super admin user (successfully)\n * 12. Deletes last super admin user (bad request)\n * 13. Deletes last super admin user in batch (bad request)\n * 14. Updates a user (not found)\n * 15. Finds a user (not found)\n * 16. Finds a list of users (missing user)\n */\n\ndescribe('Admin User CRUD (e2e)', () => {\n  let rq;\n  let utils;\n  let strapi;\n\n  // Local test data used across the test suite\n  let testData = {\n    firstSuperAdminUser: undefined,\n    otherSuperAdminUsers: [],\n    user: undefined,\n    role: undefined,\n    superAdminRole: undefined,\n  };\n\n  const createUserRole = async () =>\n    utils.createRole({\n      name: 'user_test_role',\n      description: 'Only used for user crud test (e2e)',\n    });\n\n  // Initialization Actions\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    utils = createUtils(strapi);\n\n    if (edition === 'EE') {\n      testData.role = await createUserRole();\n    } else {\n      testData.role = await utils.getSuperAdminRole();\n    }\n\n    testData.firstSuperAdminUser = rq.getLoggedUser();\n    testData.superAdminRole = await utils.getSuperAdminRole();\n  }, 60000);\n\n  // Cleanup actions\n  afterAll(async () => {\n    if (edition === 'EE') {\n      await utils.deleteRolesById([testData.role.id]);\n    }\n    await strapi.destroy();\n  }, 60000);\n\n  test('1. Creates a user (wrong body)', async () => {\n    const body = {\n      firstname: 'user_tests-firstname',\n      lastname: 'user_tests-lastname',\n      roles: [testData.role.id],\n    };\n\n    const res = await rq({\n      url: '/admin/users',\n      method: 'POST',\n      body,\n    });\n\n    expect(res.statusCode).toBe(400);\n    expect(res.body).toMatchObject({\n      statusCode: 400,\n      error: 'Bad Request',\n      message: 'ValidationError',\n      data: {\n        email: ['email is a required field'],\n      },\n    });\n  });\n\n  test('2. Creates a user (successfully)', async () => {\n    const body = {\n      email: 'user-tests@strapi-e2e.com',\n      firstname: 'user_tests-firstname',\n      lastname: 'user_tests-lastname',\n      roles: [testData.role.id],\n    };\n\n    const res = await rq({\n      url: '/admin/users',\n      method: 'POST',\n      body,\n    });\n\n    expect(res.statusCode).toBe(201);\n    expect(res.body.data).not.toBeNull();\n\n    // Using the created user as an example for the rest of the tests\n    testData.user = res.body.data;\n  });\n\n  test('3. Creates users with superAdmin role (success)', async () => {\n    const getBody = index => {\n      return {\n        email: `user-tests${index}@strapi-e2e.com`,\n        firstname: 'user_tests-firstname',\n        lastname: 'user_tests-lastname',\n        roles: [testData.superAdminRole.id],\n      };\n    };\n\n    for (let i = 0; i < 3; i++) {\n      const res = await rq({\n        url: '/admin/users',\n        method: 'POST',\n        body: getBody(i),\n      });\n\n      expect(res.statusCode).toBe(201);\n      expect(res.body.data).not.toBeNull();\n\n      testData.otherSuperAdminUsers.push(res.body.data);\n    }\n  });\n\n  test('4. Updates a user (wrong body)', async () => {\n    const body = {\n      email: 42,\n    };\n\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'PUT',\n      body,\n    });\n\n    expect(res.statusCode).toBe(400);\n    expect(res.body).toMatchObject({\n      statusCode: 400,\n      error: 'Bad Request',\n      message: 'ValidationError',\n      data: {\n        email: ['email must be a `string` type, but the final value was: `42`.'],\n      },\n    });\n  });\n\n  test('5. Updates a user (successfully)', async () => {\n    const body = {\n      firstname: 'foobar',\n    };\n\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'PUT',\n      body,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).not.toBeNull();\n    expect(omitTimestamps(res.body.data)).toMatchObject({\n      ...omitTimestamps(testData.user),\n      ...body,\n    });\n\n    // Update the local copy of the user\n    testData.user = res.body.data;\n  });\n\n  test('6. Finds a user (successfully)', async () => {\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject(testData.user);\n  });\n\n  describe('7. Finds a list of users (contains user)', () => {\n    const expectedBodyFormat = () => ({\n      data: {\n        pagination: {\n          page: 1,\n          pageSize: expect.any(Number),\n          pageCount: expect.any(Number),\n          total: expect.any(Number),\n        },\n        results: expect.any(Array),\n      },\n    });\n\n    test('7.1. Using findPage', async () => {\n      const res = await rq({\n        url: `/admin/users?email=${testData.user.email}`,\n        method: 'GET',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(expectedBodyFormat());\n      expect(res.body.data.results).toContainEqual(testData.user);\n    });\n\n    test('7.2. Using searchPage', async () => {\n      const res = await rq({\n        url: `/admin/users?_q=${testData.user.email}`,\n        method: 'GET',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(expectedBodyFormat());\n      expect(res.body.data.results).toContainEqual(testData.user);\n    });\n  });\n\n  test('8. Deletes a user (successfully)', async () => {\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'DELETE',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject(testData.user);\n  });\n\n  test('9. Deletes a user (not found)', async () => {\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'DELETE',\n    });\n\n    expect(res.statusCode).toBe(404);\n  });\n\n  test('10. Deletes 2 super admin users (successfully)', async () => {\n    const users = testData.otherSuperAdminUsers.splice(0, 2);\n    const res = await rq({\n      url: `/admin/users/batch-delete`,\n      method: 'POST',\n      body: {\n        ids: users.map(u => u.id),\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject(users);\n  });\n\n  test('11. Deletes a super admin user (successfully)', async () => {\n    const user = testData.otherSuperAdminUsers.pop();\n    const res = await rq({\n      url: `/admin/users/${user.id}`,\n      method: 'DELETE',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject(user);\n  });\n\n  test('12. Deletes last super admin user (bad request)', async () => {\n    const res = await rq({\n      url: `/admin/users/${testData.firstSuperAdminUser.id}`,\n      method: 'DELETE',\n    });\n\n    expect(res.statusCode).toBe(400);\n    expect(res.body).toMatchObject({\n      statusCode: 400,\n      error: 'Bad Request',\n      message: 'ValidationError',\n      data: 'You must have at least one user with super admin role.',\n    });\n  });\n\n  test('13. Deletes last super admin user in batch (bad request)', async () => {\n    const res = await rq({\n      url: `/admin/users/batch-delete`,\n      method: 'POST',\n      body: {\n        ids: [testData.firstSuperAdminUser.id],\n      },\n    });\n\n    expect(res.statusCode).toBe(400);\n    expect(res.body).toMatchObject({\n      statusCode: 400,\n      error: 'Bad Request',\n      message: 'ValidationError',\n      data: 'You must have at least one user with super admin role.',\n    });\n  });\n\n  test('14. Updates a user (not found)', async () => {\n    const body = {\n      lastname: 'doe',\n    };\n\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'PUT',\n      body,\n    });\n\n    expect(res.statusCode).toBe(404);\n    expect(res.body).toMatchObject({\n      error: 'Not Found',\n      message: 'entry.notFound',\n      statusCode: 404,\n    });\n  });\n\n  test('15. Finds a user (not found)', async () => {\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(404);\n    expect(res.body).toMatchObject({\n      error: 'Not Found',\n      message: 'User does not exist',\n      statusCode: 404,\n    });\n  });\n\n  test('16. Finds a list of users (missing user)', async () => {\n    const res = await rq({\n      url: `/admin/users?email=${testData.user.email}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject({\n      pagination: {\n        page: 1,\n        pageSize: expect.any(Number),\n        pageCount: expect.any(Number),\n        total: expect.any(Number),\n      },\n      results: expect.any(Array),\n    });\n    expect(res.body.data.results).toHaveLength(0);\n  });\n});\n",
    "packages/strapi-admin/validation/permission.js": "'use strict';\n\nconst _ = require('lodash');\nconst { yup, formatYupErrors } = require('strapi-utils');\nconst { AUTHOR_CODE, PUBLISH_ACTION } = require('../services/constants');\nconst {\n  BOUND_ACTIONS_FOR_FIELDS,\n  BOUND_ACTIONS,\n  getBoundActionsBySubject,\n} = require('../domain/role');\nconst validators = require('./common-validators');\n\nconst handleReject = error => Promise.reject(formatYupErrors(error));\n\n// validatedUpdatePermissionsInput\n\nconst actionFieldsAreEqual = (a, b) => {\n  const aFields = a.fields || [];\n  const bFields = b.fields || [];\n\n  return _.isEqual(aFields.sort(), bFields.sort());\n};\n\nconst haveSameFieldsAsOtherActions = (a, i, allActions) =>\n  allActions.slice(i + 1).every(b => actionFieldsAreEqual(a, b));\n\nconst checkPermissionsAreBound = role =>\n  function(permissions) {\n    const permsBySubject = _.groupBy(\n      permissions.filter(perm => BOUND_ACTIONS.includes(perm.action)),\n      'subject'\n    );\n\n    for (const [subject, perms] of Object.entries(permsBySubject)) {\n      const boundActions = getBoundActionsBySubject(role, subject);\n      const missingActions =\n        _.xor(\n          perms.map(p => p.action),\n          boundActions\n        ).length !== 0;\n      if (missingActions) return false;\n\n      const permsBoundByFields = perms.filter(p => BOUND_ACTIONS_FOR_FIELDS.includes(p.action));\n      const everyActionsHaveSameFields = _.every(permsBoundByFields, haveSameFieldsAsOtherActions);\n      if (!everyActionsHaveSameFields) return false;\n    }\n\n    return true;\n  };\n\nconst noPublishPermissionForAuthorRole = role =>\n  function(permissions) {\n    const isAuthor = role.code === AUTHOR_CODE;\n    const hasPublishPermission = permissions.some(perm => perm.action === PUBLISH_ACTION);\n\n    return !(isAuthor && hasPublishPermission);\n  };\n\nconst getUpdatePermissionsSchemas = role => [\n  validators.updatePermissions,\n  yup.object().shape({ permissions: actionsExistSchema.clone() }),\n  yup.object().shape({\n    permissions: yup\n      .array()\n      .test(\n        'author-no-publish',\n        'The author role cannot have the publish permission.',\n        noPublishPermissionForAuthorRole(role)\n      ),\n  }),\n  yup.object().shape({\n    permissions: yup\n      .array()\n      .test(\n        'are-bond',\n        'Permissions have to be defined all together for a subject field or not at all',\n        checkPermissionsAreBound(role)\n      ),\n  }),\n];\n\nconst checkPermissionsSchema = yup.object().shape({\n  permissions: yup.array().of(\n    yup\n      .object()\n      .shape({\n        action: yup.string().required(),\n        subject: yup.string(),\n        field: yup.string(),\n      })\n      .noUnknown()\n  ),\n});\n\nconst validateCheckPermissionsInput = data => {\n  return checkPermissionsSchema\n    .validate(data, { strict: true, abortEarly: false })\n    .catch(handleReject);\n};\n\nconst validatedUpdatePermissionsInput = async (permissions, role) => {\n  try {\n    const schemas = getUpdatePermissionsSchemas(role);\n    for (const schema of schemas) {\n      await schema.validate(permissions, { strict: true, abortEarly: false });\n    }\n  } catch (e) {\n    return handleReject(e);\n  }\n};\n\n// validatePermissionsExist\n\nconst checkPermissionsExist = function(permissions) {\n  const existingActions = strapi.admin.services.permission.actionProvider.getAll();\n  const failIndex = permissions.findIndex(\n    permission =>\n      !existingActions.some(\n        action =>\n          action.actionId === permission.action &&\n          (action.section !== 'contentTypes' || action.subjects.includes(permission.subject))\n      )\n  );\n\n  return failIndex === -1\n    ? true\n    : this.createError({\n        path: 'permissions',\n        message: `[${failIndex}] is not an existing permission action`,\n      });\n};\n\nconst actionsExistSchema = yup\n  .array()\n  .of(\n    yup.object().shape({\n      conditions: yup.array().of(yup.string()),\n    })\n  )\n  .test('actions-exist', '', checkPermissionsExist);\n\nconst validatePermissionsExist = data => {\n  return actionsExistSchema.validate(data, { strict: true, abortEarly: false }).catch(handleReject);\n};\n\n// exports\n\nmodule.exports = {\n  validatedUpdatePermissionsInput,\n  validatePermissionsExist,\n  validateCheckPermissionsInput,\n};\n",
    "packages/strapi-connector-bookshelf/lib/build-database-schema.js": "'use strict';\n\nconst _ = require('lodash');\nconst { singular } = require('pluralize');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\n\nconst { storeDefinition, getColumnsWhereDefinitionChanged } = require('./utils/store-definition');\nconst { getManyRelations } = require('./utils/associations');\nconst createMigrationRunner = require('./migrations/create-migration-runner');\nconst draftPublishMigration = require('./migrations/draft-publish-migration');\n\nconst migrateSchemas = async ({ ORM, loadedModel, definition, connection, model }, context) => {\n  // Add created_at and updated_at field if timestamp option is true\n  if (loadedModel.hasTimestamps) {\n    definition.attributes[loadedModel.hasTimestamps[0]] = { type: 'currentTimestamp' };\n    definition.attributes[loadedModel.hasTimestamps[1]] = { type: 'currentTimestamp' };\n  }\n\n  // Equilize tables\n  if (connection.options && connection.options.autoMigration !== false) {\n    await createOrUpdateTable(\n      {\n        table: loadedModel.tableName,\n        attributes: definition.attributes,\n        definition,\n        ORM,\n        model,\n      },\n      context\n    );\n  }\n\n  // Equilize polymorphic relations\n  const morphRelations = definition.associations.filter(association => {\n    return association.nature.toLowerCase().includes('morphto');\n  });\n\n  for (const morphRelation of morphRelations) {\n    const attributes = {\n      [`${loadedModel.tableName}_id`]: { type: definition.primaryKeyType },\n      [`${morphRelation.alias}_id`]: { type: definition.primaryKeyType },\n      [`${morphRelation.alias}_type`]: { type: 'text' },\n      [definition.attributes[morphRelation.alias].filter]: { type: 'text' },\n      order: { type: 'integer' },\n    };\n\n    if (connection.options && connection.options.autoMigration !== false) {\n      await createOrUpdateTable(\n        {\n          table: `${loadedModel.tableName}_morph`,\n          attributes,\n          definition,\n          ORM,\n          model,\n        },\n        context\n      );\n    }\n  }\n\n  // Equilize many to many relations\n  const manyRelations = getManyRelations(definition);\n\n  for (const manyRelation of manyRelations) {\n    const { plugin, collection, via, dominant, alias } = manyRelation;\n\n    if (dominant) {\n      const targetCollection = strapi.db.getModel(collection, plugin);\n\n      const targetAttr = via\n        ? targetCollection.attributes[via]\n        : {\n            attribute: singular(definition.collectionName),\n            column: definition.primaryKey,\n          };\n\n      const defAttr = definition.attributes[alias];\n\n      const targetCol = `${targetAttr.attribute}_${targetAttr.column}`;\n      let rootCol = `${defAttr.attribute}_${defAttr.column}`;\n\n      // manyWay with same CT\n      if (rootCol === targetCol) {\n        rootCol = `related_${rootCol}`;\n      }\n\n      const attributes = {\n        [targetCol]: { type: targetCollection.primaryKeyType },\n        [rootCol]: { type: definition.primaryKeyType },\n      };\n\n      const table = manyRelation.tableCollectionName;\n      if (connection.options && connection.options.autoMigration !== false) {\n        await createOrUpdateTable({ table, attributes, definition, ORM, model }, context);\n      }\n    }\n  }\n\n  // Remove from attributes (auto handled by bookshlef and not displayed on ctb)\n  if (loadedModel.hasTimestamps) {\n    delete definition.attributes[loadedModel.hasTimestamps[0]];\n    delete definition.attributes[loadedModel.hasTimestamps[1]];\n  }\n};\n\nconst getColumnInfo = async (columnName, tableName, ORM) => {\n  const exists = await ORM.knex.schema.hasColumn(tableName, columnName);\n\n  return {\n    columnName,\n    exists,\n  };\n};\n\nconst isColumn = ({ definition, attribute, name }) => {\n  if (!_.has(attribute, 'type')) {\n    const relation = definition.associations.find(association => {\n      return association.alias === name;\n    });\n\n    if (!relation) return false;\n\n    if (['oneToOne', 'manyToOne', 'oneWay'].includes(relation.nature)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (['component', 'dynamiczone'].includes(attribute.type)) {\n    return false;\n  }\n\n  return true;\n};\n\nconst uniqueColName = (table, key) => `${table}_${key}_unique`;\n\nconst buildColType = ({ name, attribute, table, tableExists = false, definition, ORM }) => {\n  if (!attribute.type) {\n    const relation = definition.associations.find(association => association.alias === name);\n\n    if (['oneToOne', 'manyToOne', 'oneWay'].includes(relation.nature)) {\n      return buildColType({\n        name,\n        attribute: { type: definition.primaryKeyType },\n        table,\n        tableExists,\n        definition,\n        ORM,\n      });\n    }\n\n    return null;\n  }\n\n  // allow custom data type for a column\n  if (_.has(attribute, 'columnType')) {\n    return table.specificType(name, attribute.columnType);\n  }\n\n  switch (attribute.type) {\n    case 'uuid':\n      return table.uuid(name);\n    case 'uid': {\n      table.unique(name);\n      return table.string(name);\n    }\n    case 'richtext':\n    case 'text':\n      return table.text(name, 'longtext');\n    case 'json':\n      return definition.client === 'pg' ? table.jsonb(name) : table.text(name, 'longtext');\n    case 'enumeration':\n    case 'string':\n    case 'password':\n    case 'email':\n      return table.string(name);\n    case 'integer':\n      return table.integer(name);\n    case 'biginteger':\n      return table.bigInteger(name);\n    case 'float':\n      return table.double(name);\n    case 'decimal':\n      return table.decimal(name, 10, 2);\n    case 'date':\n      return table.date(name);\n    case 'time':\n      return table.time(name, 3);\n    case 'datetime':\n      return table.datetime(name);\n    case 'timestamp':\n      return table.timestamp(name);\n    case 'currentTimestamp': {\n      const col = table.timestamp(name);\n\n      if (definition.client !== 'sqlite3' && tableExists) {\n        return col;\n      }\n\n      return col.defaultTo(ORM.knex.fn.now());\n    }\n    case 'boolean':\n      return table.boolean(name);\n    default:\n      return null;\n  }\n};\n\n// Equilize database tables\nconst createOrUpdateTable = async ({ table, attributes, definition, ORM, model }, context) => {\n  const tableExists = await ORM.knex.schema.hasTable(table);\n\n  const createIdType = table => {\n    if (definition.primaryKeyType === 'uuid' && definition.client === 'pg') {\n      return table\n        .specificType('id', 'uuid DEFAULT uuid_generate_v4()')\n        .notNullable()\n        .primary();\n    }\n\n    return table.increments('id');\n  };\n\n  const createColumns = (tbl, columns, opts = {}) => {\n    const { tableExists, alter = false } = opts;\n\n    Object.keys(columns).forEach(key => {\n      const attribute = columns[key];\n\n      const col = buildColType({\n        name: key,\n        attribute,\n        table: tbl,\n        tableExists,\n        definition,\n        ORM,\n      });\n      if (!col) return;\n\n      if (attribute.required === true) {\n        if (\n          (definition.client !== 'sqlite3' || !tableExists) &&\n          !contentTypesUtils.hasDraftAndPublish(model) && // no require constraint to allow drafts\n          definition.modelType !== 'component' // no require constraint to allow components in drafts\n        ) {\n          col.notNullable();\n        }\n      } else {\n        col.nullable();\n      }\n\n      if (attribute.unique === true) {\n        if (definition.client !== 'sqlite3' || !tableExists) {\n          tbl.unique(key, uniqueColName(table, key));\n        }\n      }\n\n      if (alter) {\n        col.alter();\n      }\n    });\n  };\n\n  const alterColumns = (tbl, columns, opts = {}) => {\n    return createColumns(tbl, columns, { ...opts, alter: true });\n  };\n\n  const createTable = (table, { trx = ORM.knex, ...opts } = {}) => {\n    return trx.schema.createTable(table, tbl => {\n      createIdType(tbl);\n      createColumns(tbl, attributes, { ...opts, tableExists: false });\n    });\n  };\n\n  if (!tableExists) {\n    await createTable(table);\n    return;\n  }\n\n  const attributesNames = Object.keys(attributes);\n\n  // Fetch existing column\n  const columnsInfo = await Promise.all(\n    attributesNames.map(attributeName => getColumnInfo(attributeName, table, ORM))\n  );\n  const nameOfColumnsToAdd = columnsInfo.filter(info => !info.exists).map(info => info.columnName);\n\n  const columnsToAdd = _.pick(attributes, nameOfColumnsToAdd);\n\n  // Generate and execute query to add missing column\n  if (Object.keys(columnsToAdd).length > 0) {\n    await ORM.knex.schema.table(table, tbl => {\n      createColumns(tbl, columnsToAdd, { tableExists });\n    });\n  }\n\n  const attrsNameWithoutTimestamps = attributesNames.filter(\n    columnName => !(definition.options.timestamps || []).includes(columnName)\n  );\n\n  const columnsToAlter = await getColumnsWhereDefinitionChanged(\n    attrsNameWithoutTimestamps,\n    definition,\n    ORM\n  );\n\n  const shouldRebuild =\n    columnsToAlter.length > 0 || (definition.client === 'sqlite3' && context.recreateSqliteTable);\n\n  if (shouldRebuild) {\n    switch (definition.client) {\n      case 'sqlite3': {\n        const tmpTable = `tmp_${table}`;\n\n        const rebuildTable = async trx => {\n          await trx.schema.renameTable(table, tmpTable);\n\n          // drop possible conflicting indexes\n          await Promise.all(\n            attributesNames.map(key =>\n              trx.raw('DROP INDEX IF EXISTS ??', uniqueColName(table, key))\n            )\n          );\n\n          // create the table\n          await createTable(table, { trx });\n\n          const attrs = attributesNames.filter(attributeName =>\n            isColumn({\n              definition,\n              attribute: attributes[attributeName],\n              name: attributeName,\n            })\n          );\n\n          const allAttrs = ['id', ...attrs];\n\n          await trx.insert(qb => qb.select(allAttrs).from(tmpTable)).into(table);\n          await trx.schema.dropTableIfExists(tmpTable);\n        };\n\n        try {\n          await ORM.knex.transaction(trx => rebuildTable(trx));\n        } catch (err) {\n          if (err.message.includes('UNIQUE constraint failed')) {\n            strapi.log.error(\n              `Unique constraint fails, make sure to update your data and restart to apply the unique constraint.\\n\\t- ${err.stack}`\n            );\n          } else {\n            strapi.log.error(`Migration failed`);\n            strapi.log.error(err);\n          }\n\n          return false;\n        }\n        break;\n      }\n      default: {\n        const alterTable = async trx => {\n          await Promise.all(\n            columnsToAlter.map(col => {\n              return ORM.knex.schema\n                .alterTable(table, tbl => {\n                  tbl.dropUnique(col, uniqueColName(table, col));\n                })\n                .catch(() => {});\n            })\n          );\n          await trx.schema.alterTable(table, tbl => {\n            alterColumns(tbl, _.pick(attributes, columnsToAlter), {\n              tableExists,\n            });\n          });\n        };\n\n        try {\n          await ORM.knex.transaction(trx => alterTable(trx));\n        } catch (err) {\n          if (err.code === '23505' && definition.client === 'pg') {\n            strapi.log.error(\n              `Unique constraint fails, make sure to update your data and restart to apply the unique constraint.\\n\\t- ${err.message}\\n\\t- ${err.detail}`\n            );\n          } else if (definition.client === 'mysql' && err.errno === 1062) {\n            strapi.log.error(\n              `Unique constraint fails, make sure to update your data and restart to apply the unique constraint.\\n\\t- ${err.sqlMessage}`\n            );\n          } else {\n            strapi.log.error(`Migration failed`);\n            strapi.log.error(err);\n          }\n\n          return false;\n        }\n      }\n    }\n  }\n};\n\nconst migrationRunner = createMigrationRunner(migrateSchemas, {\n  hooks: [draftPublishMigration],\n});\n\nmodule.exports = async ({ ORM, loadedModel, definition, connection, model }) => {\n  // run migrations\n  await migrationRunner.run({ ORM, loadedModel, definition, connection, model });\n\n  // store new definitions\n  await storeDefinition(definition, ORM);\n};\n",
    "packages/strapi-connector-bookshelf/lib/generate-component-relations.js": "'use strict';\n\nconst pluralize = require('pluralize');\n\nconst { getComponentAttributes } = require('./utils/attributes');\n\nconst createComponentModels = async ({ model, definition, ORM, GLOBALS }) => {\n  const { collectionName, primaryKey } = definition;\n\n  const componentAttributes = getComponentAttributes(definition);\n\n  if (componentAttributes.length > 0) {\n    // create component model\n    const joinTable = `${collectionName}_components`;\n    const joinColumn = `${pluralize.singular(collectionName)}_${primaryKey}`;\n\n    const relatedComponents = componentAttributes\n      .map(key => {\n        const attr = definition.attributes[key];\n        const { type } = attr;\n\n        switch (type) {\n          case 'component': {\n            const { component } = attr;\n            return strapi.components[component];\n          }\n          case 'dynamiczone': {\n            const { components } = attr;\n            return components.map(component => strapi.components[component]);\n          }\n          default: {\n            throw new Error(`Invalid type for attribute ${key}: ${type}`);\n          }\n        }\n      })\n      .reduce((acc, arr) => acc.concat(arr), []);\n\n    const joinModel = ORM.Model.extend({\n      requireFetch: false,\n      tableName: joinTable,\n      component() {\n        return this.morphTo(\n          'component',\n          ...relatedComponents.map(component => GLOBALS[component.globalId])\n        );\n      },\n    });\n\n    joinModel.foreignKey = joinColumn;\n    definition.componentsJoinModel = joinModel;\n\n    componentAttributes.forEach(name => {\n      model[name] = function relation() {\n        return this.hasMany(joinModel, joinColumn).query(qb => {\n          qb.where('field', name)\n            .whereIn(\n              'component_type',\n              relatedComponents.map(component => component.collectionName)\n            )\n            .orderBy('order');\n        });\n      };\n    });\n  }\n};\n\nconst createComponentJoinTables = async ({ definition, ORM }) => {\n  const { collectionName, primaryKey } = definition;\n\n  const componentAttributes = getComponentAttributes(definition);\n\n  if (componentAttributes.length > 0) {\n    const joinTable = `${collectionName}_components`;\n    const joinColumn = `${pluralize.singular(collectionName)}_${primaryKey}`;\n\n    if (await ORM.knex.schema.hasTable(joinTable)) return;\n\n    await ORM.knex.schema.createTable(joinTable, table => {\n      table.increments();\n      table.string('field').notNullable();\n      table\n        .integer('order')\n        .unsigned()\n        .notNullable();\n      table.string('component_type').notNullable();\n      table.integer('component_id').notNullable();\n      table\n        .integer(joinColumn)\n        .unsigned()\n        .notNullable();\n\n      table\n        .foreign(joinColumn, `${joinColumn}_fk`)\n        .references(primaryKey)\n        .inTable(collectionName)\n        .onDelete('CASCADE');\n    });\n  }\n};\n\nmodule.exports = {\n  createComponentModels,\n  createComponentJoinTables,\n};\n",
    "packages/strapi-connector-bookshelf/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Core\nconst path = require('path');\nconst fs = require('fs');\n// Public node modules.\nconst _ = require('lodash');\nconst bookshelf = require('bookshelf');\n\n// Local helpers.\nconst relations = require('./relations');\nconst buildQuery = require('./buildQuery');\nconst mountModels = require('./mount-models');\nconst getQueryParams = require('./get-query-params');\nconst queries = require('./queries');\nconst initKnex = require('./knex');\n\n/**\n * Bookshelf hook\n */\n\n/**\n * Default options\n */\n\nconst defaults = {\n  defaultConnection: 'default',\n  host: 'localhost',\n};\n\nconst isBookshelfConnection = ({ connector }) => connector === 'bookshelf';\n\nmodule.exports = function(strapi) {\n  const { connections } = strapi.config;\n  const bookshelfConnections = Object.keys(connections).filter(key =>\n    isBookshelfConnection(connections[key])\n  );\n\n  function initialize() {\n    initKnex(strapi);\n\n    const GLOBALS = {};\n\n    const connectionsPromises = bookshelfConnections.map(connectionName => {\n      const connection = connections[connectionName];\n\n      _.defaults(connection.settings, strapi.config.hook.settings.bookshelf);\n\n      // Create Bookshelf instance for this connection.\n      const ORM = new bookshelf(strapi.connections[connectionName]);\n\n      const initFunctionPath = path.resolve(\n        strapi.config.appPath,\n        'config',\n        'functions',\n        'bookshelf.js'\n      );\n\n      if (fs.existsSync(initFunctionPath)) {\n        require(initFunctionPath)(ORM, connection);\n      }\n\n      const ctx = {\n        GLOBALS,\n        connection,\n        ORM,\n      };\n\n      return mountConnection(connectionName, ctx);\n    });\n\n    return Promise.all(connectionsPromises);\n  }\n\n  async function mountConnection(connectionName, ctx) {\n    if (strapi.models['core_store'].connection === connectionName) {\n      await mountCoreStore(ctx);\n    }\n\n    const finalizeMountings = await Promise.all([\n      mountComponents(connectionName, ctx),\n      mountApis(connectionName, ctx),\n      mountAdmin(connectionName, ctx),\n      mountPlugins(connectionName, ctx),\n    ]);\n\n    for (const finalizeMounting of _.flattenDeep(finalizeMountings)) {\n      await finalizeMounting();\n    }\n  }\n\n  function mountCoreStore(ctx) {\n    return mountModels(\n      {\n        models: {\n          core_store: strapi.models['core_store'],\n        },\n        target: strapi.models,\n      },\n      ctx,\n      { selfFinalize: true }\n    );\n  }\n\n  function mountComponents(connectionName, ctx) {\n    const options = {\n      models: _.pickBy(strapi.components, ({ connection }) => connection === connectionName),\n      target: strapi.components,\n    };\n\n    return mountModels(options, ctx);\n  }\n\n  function mountApis(connectionName, ctx) {\n    const options = {\n      models: _.pickBy(\n        strapi.models,\n        ({ connection }, name) => connection === connectionName && name !== 'core_store'\n      ),\n      target: strapi.models,\n    };\n\n    return mountModels(options, ctx);\n  }\n\n  function mountAdmin(connectionName, ctx) {\n    const options = {\n      models: _.pickBy(strapi.admin.models, ({ connection }) => connection === connectionName),\n      target: strapi.admin.models,\n    };\n\n    return mountModels(options, ctx);\n  }\n\n  function mountPlugins(connectionName, ctx) {\n    return Promise.all(\n      Object.keys(strapi.plugins).map(name => {\n        const plugin = strapi.plugins[name];\n        return mountModels(\n          {\n            models: _.pickBy(plugin.models, ({ connection }) => connection === connectionName),\n            target: plugin.models,\n          },\n          ctx\n        );\n      })\n    );\n  }\n\n  async function destroy() {\n    await Promise.all(bookshelfConnections.map(connName => strapi.connections[connName].destroy()));\n  }\n\n  return {\n    defaults,\n    initialize,\n    getQueryParams,\n    buildQuery,\n    queries,\n    destroy,\n    ...relations,\n    get defaultTimestamps() {\n      return ['created_at', 'updated_at'];\n    },\n  };\n};\n",
    "packages/strapi-connector-bookshelf/lib/migrations/create-migration-runner.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst createMigrationRunner = (migrationFunction, { hooks = [] } = {}, context = {}) => {\n  const beforeHook = async (options, context) => {\n    for (const migration of hooks) {\n      if (_.isFunction(migration.before)) {\n        await migration.before(options, context);\n      }\n    }\n  };\n\n  const afterHook = async (options, context) => {\n    for (const migration of hooks.slice(0).reverse()) {\n      if (_.isFunction(migration.after)) {\n        await migration.after(options, context);\n      }\n    }\n  };\n\n  const run = async options => {\n    await beforeHook(options, context);\n    await migrationFunction(options, context);\n    await afterHook(options, context);\n  };\n\n  return {\n    run,\n  };\n};\n\nmodule.exports = createMigrationRunner;\n",
    "packages/strapi-connector-bookshelf/lib/migrations/draft-publish-migration.js": "'use strict';\n\nconst _ = require('lodash');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\n\nconst { PUBLISHED_AT_ATTRIBUTE } = contentTypesUtils.constants;\nconst { getDefinitionFromStore } = require('../utils/store-definition');\n\nconst getDraftAndPublishMigrationWay = async ({ definition, ORM }) => {\n  const previousDefRow = await getDefinitionFromStore(definition, ORM);\n  const previousDef = JSON.parse(_.get(previousDefRow, 'value', null));\n  const previousDraftAndPublish = contentTypesUtils.hasDraftAndPublish(previousDef);\n  const actualDraftAndPublish = contentTypesUtils.hasDraftAndPublish(definition);\n\n  if (previousDraftAndPublish === actualDraftAndPublish) {\n    return 'none';\n  }\n  if (!previousDraftAndPublish && actualDraftAndPublish) {\n    return 'enable';\n  }\n  if (previousDraftAndPublish && !actualDraftAndPublish) {\n    return 'disable';\n  }\n};\n\nconst before = async ({ definition, ORM }, context) => {\n  const way = await getDraftAndPublishMigrationWay({ definition, ORM });\n\n  if (way === 'disable') {\n    const publishedAtColumnExists = await ORM.knex.schema.hasColumn(\n      definition.collectionName,\n      PUBLISHED_AT_ATTRIBUTE\n    );\n\n    if (publishedAtColumnExists) {\n      await ORM.knex(definition.collectionName)\n        .delete()\n        .where(PUBLISHED_AT_ATTRIBUTE, null);\n\n      if (definition.client === 'sqlite3') {\n        // Bug when droping column with sqlite3 https://github.com/knex/knex/issues/631\n        // Need to recreate the table\n        context.recreateSqliteTable = true;\n      } else {\n        await ORM.knex.schema.table(definition.collectionName, table => {\n          table.dropColumn(PUBLISHED_AT_ATTRIBUTE);\n        });\n      }\n    }\n  }\n};\n\nconst after = async ({ definition, ORM }) => {\n  const way = await getDraftAndPublishMigrationWay({ definition, ORM });\n\n  if (way === 'enable') {\n    const now = new Date();\n    let publishedAtValue = now;\n    if (_.get(definition, 'options.timestamps', false)) {\n      const createdAtColumn = _.get(definition, 'options.timestamps.0', 'created_at');\n      publishedAtValue = ORM.knex.ref(createdAtColumn);\n    }\n    await ORM.knex(definition.collectionName)\n      .update({ [PUBLISHED_AT_ATTRIBUTE]: publishedAtValue })\n      .where(PUBLISHED_AT_ATTRIBUTE, null);\n\n    await ORM.knex(definition.collectionName) // in case some created_at were null\n      .update({ [PUBLISHED_AT_ATTRIBUTE]: now })\n      .where(PUBLISHED_AT_ATTRIBUTE, null);\n  }\n};\n\nmodule.exports = {\n  before,\n  after,\n};\n",
    "packages/strapi-connector-bookshelf/lib/mount-models.js": "'use strict';\nconst _ = require('lodash');\nconst { singular } = require('pluralize');\n\nconst { models: utilsModels, contentTypes: contentTypesUtils } = require('strapi-utils');\nconst relations = require('./relations');\nconst buildDatabaseSchema = require('./build-database-schema');\nconst {\n  createComponentJoinTables,\n  createComponentModels,\n} = require('./generate-component-relations');\nconst { createParser } = require('./parser');\nconst { createFormatter } = require('./formatter');\nconst populateFetch = require('./populate');\n\nconst {\n  PUBLISHED_AT_ATTRIBUTE,\n  CREATED_BY_ATTRIBUTE,\n  UPDATED_BY_ATTRIBUTE,\n} = contentTypesUtils.constants;\n\nconst PIVOT_PREFIX = '_pivot_';\n\nconst getDatabaseName = connection => {\n  const dbName = _.get(connection.settings, 'database');\n  const dbSchema = _.get(connection.settings, 'schema', 'public');\n  switch (_.get(connection.settings, 'client')) {\n    case 'sqlite3':\n      return 'main';\n    case 'pg':\n      return `${dbName}.${dbSchema}`;\n    case 'mysql':\n      return dbName;\n    default:\n      return dbName;\n  }\n};\n\nconst isARelatedField = (morphAttrInfo, attr) => {\n  const samePlugin =\n    morphAttrInfo.plugin === attr.plugin || (_.isNil(morphAttrInfo.plugin) && _.isNil(attr.plugin));\n  const sameModel = [attr.model, attr.collection].includes(morphAttrInfo.model);\n  const isMorph = attr.via === morphAttrInfo.name;\n\n  return isMorph && sameModel && samePlugin;\n};\n\nconst getRelatedFieldsOfMorphModel = morphAttrInfo => morphModel => {\n  const relatedFields = _.reduce(\n    morphModel.attributes,\n    (fields, attr, attrName) => {\n      return isARelatedField(morphAttrInfo, attr) ? fields.concat(attrName) : fields;\n    },\n    []\n  );\n\n  return { collectionName: morphModel.collectionName, relatedFields };\n};\n\nmodule.exports = async ({ models, target }, ctx, { selfFinalize = false } = {}) => {\n  const { GLOBALS, connection, ORM } = ctx;\n\n  // Parse every authenticated model.\n  const updateModel = async model => {\n    const definition = models[model];\n\n    if (!definition.uid.startsWith('strapi::') && definition.modelType !== 'component') {\n      if (contentTypesUtils.hasDraftAndPublish(definition)) {\n        definition.attributes[PUBLISHED_AT_ATTRIBUTE] = {\n          type: 'datetime',\n          configurable: false,\n        };\n      }\n\n      const isPrivate = !_.get(definition, 'options.populateCreatorFields', false);\n\n      definition.attributes[CREATED_BY_ATTRIBUTE] = {\n        model: 'user',\n        plugin: 'admin',\n        configurable: false,\n        writable: false,\n        private: isPrivate,\n      };\n\n      definition.attributes[UPDATED_BY_ATTRIBUTE] = {\n        model: 'user',\n        plugin: 'admin',\n        configurable: false,\n        writable: false,\n        private: isPrivate,\n      };\n    }\n\n    definition.globalName = _.upperFirst(_.camelCase(definition.globalId));\n    definition.associations = [];\n\n    // Define local GLOBALS to expose every models in this file.\n    GLOBALS[definition.globalId] = {};\n\n    // Add some information about ORM & client connection & tableName\n    definition.orm = 'bookshelf';\n    definition.databaseName = getDatabaseName(connection);\n    definition.client = _.get(connection.settings, 'client');\n    definition.primaryKey = 'id';\n    definition.primaryKeyType = 'integer';\n\n    target[model].allAttributes = { ...definition.attributes };\n\n    const createdAtCol = _.get(definition, 'options.timestamps.0', 'created_at');\n    const updatedAtCol = _.get(definition, 'options.timestamps.1', 'updated_at');\n    if (_.get(definition, 'options.timestamps', false)) {\n      _.set(definition, 'options.timestamps', [createdAtCol, updatedAtCol]);\n      target[model].allAttributes[createdAtCol] = { type: 'timestamp' };\n      target[model].allAttributes[updatedAtCol] = { type: 'timestamp' };\n    } else {\n      _.set(definition, 'options.timestamps', false);\n    }\n\n    // Register the final model for Bookshelf.\n    const loadedModel = _.assign(\n      {\n        requireFetch: false,\n        tableName: definition.collectionName,\n        hasTimestamps: definition.options.timestamps,\n        associations: [],\n        defaults: Object.keys(definition.attributes).reduce((acc, current) => {\n          if (definition.attributes[current].type && definition.attributes[current].default) {\n            acc[current] = definition.attributes[current].default;\n          }\n\n          return acc;\n        }, {}),\n      },\n      definition.options\n    );\n\n    const componentAttributes = Object.keys(definition.attributes).filter(key =>\n      ['component', 'dynamiczone'].includes(definition.attributes[key].type)\n    );\n\n    if (_.isString(_.get(connection, 'options.pivot_prefix'))) {\n      loadedModel.toJSON = function(options = {}) {\n        const { shallow = false, omitPivot = false } = options;\n        const attributes = this.serialize(options);\n\n        if (!shallow) {\n          const pivot = this.pivot && !omitPivot && this.pivot.attributes;\n\n          // Remove pivot attributes with prefix.\n          _.keys(pivot).forEach(key => delete attributes[`${PIVOT_PREFIX}${key}`]);\n\n          // Add pivot attributes without prefix.\n          const pivotAttributes = _.mapKeys(\n            pivot,\n            (value, key) => `${connection.options.pivot_prefix}${key}`\n          );\n\n          return Object.assign({}, attributes, pivotAttributes);\n        }\n\n        return attributes;\n      };\n    }\n\n    await createComponentModels({\n      model: loadedModel,\n      definition,\n      ORM,\n      GLOBALS,\n    });\n\n    // Add every relationships to the loaded model for Bookshelf.\n    // Basic attributes don't need this-- only relations.\n    Object.keys(definition.attributes).forEach(name => {\n      const details = definition.attributes[name];\n      if (details.type !== undefined) {\n        return;\n      }\n\n      const { nature, verbose } =\n        utilsModels.getNature({\n          attribute: details,\n          attributeName: name,\n          modelName: model.toLowerCase(),\n        }) || {};\n\n      // Build associations key\n      utilsModels.defineAssociations(model.toLowerCase(), definition, details, name);\n\n      let globalId;\n      const globalName = details.model || details.collection || '';\n\n      // Exclude polymorphic association.\n      if (globalName !== '*') {\n        globalId = strapi.db.getModel(globalName.toLowerCase(), details.plugin).globalId;\n      }\n\n      switch (verbose) {\n        case 'hasOne': {\n          const target = details.plugin\n            ? strapi.plugins[details.plugin].models[details.model]\n            : strapi.models[details.model];\n\n          const FK = _.findKey(target.attributes, details => {\n            if (\n              _.has(details, 'model') &&\n              details.model === model &&\n              _.has(details, 'via') &&\n              details.via === name\n            ) {\n              return details;\n            }\n          });\n\n          const columnName = _.get(target.attributes, [FK, 'columnName'], FK);\n\n          loadedModel[name] = function() {\n            return this.hasOne(GLOBALS[globalId], columnName);\n          };\n          break;\n        }\n        case 'hasMany': {\n          const columnName = details.plugin\n            ? _.get(\n                strapi.plugins,\n                [\n                  details.plugin,\n                  'models',\n                  details.collection,\n                  'attributes',\n                  details.via,\n                  'columnName',\n                ],\n                details.via\n              )\n            : _.get(\n                strapi.models,\n                [model.collection, 'attributes', details.via, 'columnName'],\n                details.via\n              );\n\n          // Set this info to be able to see if this field is a real database's field.\n          details.isVirtual = true;\n\n          loadedModel[name] = function() {\n            return this.hasMany(GLOBALS[globalId], columnName);\n          };\n          break;\n        }\n        case 'belongsTo': {\n          loadedModel[name] = function() {\n            return this.belongsTo(GLOBALS[globalId], _.get(details, 'columnName', name));\n          };\n          break;\n        }\n        case 'belongsToMany': {\n          const targetModel = strapi.db.getModel(details.collection, details.plugin);\n\n          // Force singular foreign key\n          details.attribute = singular(details.collection);\n          details.column = 'id';\n\n          // Set this info to be able to see if this field is a real database's field.\n          details.isVirtual = true;\n\n          if (nature === 'manyWay') {\n            const joinTableName =\n              details.collectionName || `${definition.collectionName}__${_.snakeCase(name)}`;\n\n            const foreignKey = `${singular(definition.collectionName)}_${definition.primaryKey}`;\n\n            let otherKey = `${details.attribute}_${details.column}`;\n\n            if (otherKey === foreignKey) {\n              otherKey = `related_${otherKey}`;\n              details.attribute = `related_${details.attribute}`;\n            }\n\n            loadedModel[name] = function() {\n              const targetBookshelfModel = GLOBALS[globalId];\n              let collection = this.belongsToMany(\n                targetBookshelfModel,\n                joinTableName,\n                foreignKey,\n                otherKey\n              );\n\n              if (Array.isArray(details.withPivot)) {\n                return collection.withPivot(details.withPivot);\n              }\n\n              return collection;\n            };\n          } else {\n            const joinTableName = utilsModels.getCollectionName(\n              targetModel.attributes[details.via],\n              details\n            );\n\n            const relationship = targetModel.attributes[details.via];\n\n            // Define PK column\n            relationship.attribute = singular(relationship.collection);\n            relationship.column = definition.primaryKey;\n\n            // Sometimes the many-to-many relationships\n            // is on the same keys on the same models (ex: `friends` key in model `User`)\n            if (\n              `${details.attribute}_${details.column}` ===\n              `${relationship.attribute}_${relationship.column}`\n            ) {\n              relationship.attribute = singular(details.via);\n            }\n\n            loadedModel[name] = function() {\n              const targetBookshelfModel = GLOBALS[globalId];\n\n              const foreignKey = `${relationship.attribute}_${relationship.column}`;\n              const otherKey = `${details.attribute}_${details.column}`;\n\n              let collection = this.belongsToMany(\n                targetBookshelfModel,\n                joinTableName,\n                foreignKey,\n                otherKey\n              );\n\n              if (Array.isArray(details.withPivot)) {\n                return collection.withPivot(details.withPivot);\n              }\n\n              return collection;\n            };\n          }\n\n          break;\n        }\n        case 'morphOne': {\n          const model = details.plugin\n            ? strapi.plugins[details.plugin].models[details.model]\n            : strapi.models[details.model];\n\n          const globalId = `${model.collectionName}_morph`;\n          const filter = _.get(model, ['attributes', details.via, 'filter'], 'field');\n\n          loadedModel[name] = function() {\n            return this.morphOne(\n              GLOBALS[globalId],\n              details.via,\n              `${definition.collectionName}`\n            ).query(qb => {\n              qb.where(filter, name);\n            });\n          };\n          break;\n        }\n        case 'morphMany': {\n          const collection = details.plugin\n            ? strapi.plugins[details.plugin].models[details.collection]\n            : strapi.models[details.collection];\n\n          const globalId = `${collection.collectionName}_morph`;\n          const filter = _.get(model, ['attributes', details.via, 'filter'], 'field');\n\n          loadedModel[name] = function() {\n            return this.morphMany(\n              GLOBALS[globalId],\n              details.via,\n              `${definition.collectionName}`\n            ).query(qb => {\n              qb.where(filter, name).orderBy('order');\n            });\n          };\n          break;\n        }\n        case 'belongsToMorph':\n        case 'belongsToManyMorph': {\n          const association = _.find(definition.associations, { alias: name });\n          const morphAttrInfo = {\n            plugin: definition.plugin,\n            model: definition.modelName,\n            name,\n          };\n          const morphModelsAndFields = association.related.map(\n            getRelatedFieldsOfMorphModel(morphAttrInfo)\n          );\n\n          // Define new model.\n          const options = {\n            requireFetch: false,\n            tableName: `${definition.collectionName}_morph`,\n            [definition.collectionName]: function() {\n              return this.belongsTo(\n                GLOBALS[definition.globalId],\n                `${definition.collectionName}_id`\n              );\n            },\n            related: function() {\n              return this.morphTo(\n                name,\n                ...association.related.map(morphModel => [\n                  GLOBALS[morphModel.globalId],\n                  morphModel.collectionName,\n                ])\n              );\n            },\n          };\n\n          GLOBALS[options.tableName] = ORM.Model.extend(options);\n\n          // Set polymorphic table name to the main model.\n          target[model].morph = GLOBALS[options.tableName];\n\n          // Hack Bookshelf to create a many-to-many polymorphic association.\n          // Upload has many Upload_morph that morph to different model.\n          const populateFn = qb => {\n            qb.where(qb => {\n              for (const modelAndFields of morphModelsAndFields) {\n                qb.orWhere(qb => {\n                  qb.where({ related_type: modelAndFields.collectionName }).whereIn(\n                    'field',\n                    modelAndFields.relatedFields\n                  );\n                });\n              }\n            });\n          };\n\n          loadedModel[name] = function() {\n            if (verbose === 'belongsToMorph') {\n              return this.hasOne(\n                GLOBALS[options.tableName],\n                `${definition.collectionName}_id`\n              ).query(populateFn);\n            }\n\n            return this.hasMany(\n              GLOBALS[options.tableName],\n              `${definition.collectionName}_id`\n            ).query(populateFn);\n          };\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n    });\n\n    // Call this callback function after we are done parsing\n    // all attributes for relationships-- see below.\n\n    const parseValue = createParser();\n    try {\n      // External function to map key that has been updated with `columnName`\n      const mapper = (params = {}) => {\n        Object.keys(params).map(key => {\n          const attr = definition.attributes[key] || {};\n\n          params[key] = parseValue(attr.type, params[key]);\n        });\n\n        return _.mapKeys(params, (value, key) => {\n          const attr = definition.attributes[key] || {};\n\n          return _.isPlainObject(attr) && _.isString(attr['columnName']) ? attr['columnName'] : key;\n        });\n      };\n\n      // Extract association except polymorphic.\n      const associations = definition.associations.filter(\n        association => association.nature.toLowerCase().indexOf('morph') === -1\n      );\n      // Extract polymorphic association.\n      const polymorphicAssociations = definition.associations.filter(\n        association => association.nature.toLowerCase().indexOf('morph') !== -1\n      );\n\n      // Update serialize to reformat data for polymorphic associations.\n      loadedModel.serialize = function(options) {\n        const attrs = _.clone(this.attributes);\n\n        if (options && options.shallow) {\n          return attrs;\n        }\n\n        const relations = this.relations;\n\n        componentAttributes.forEach(key => {\n          if (!_.has(relations, key)) return;\n\n          const attr = definition.attributes[key];\n          const { type } = attr;\n\n          switch (type) {\n            case 'component': {\n              const { repeatable } = attr;\n\n              const components = relations[key].toJSON().map(el => el.component);\n\n              attrs[key] = repeatable === true ? components : _.first(components) || null;\n\n              break;\n            }\n            case 'dynamiczone': {\n              attrs[key] = relations[key].toJSON().map(el => {\n                const componentKey = Object.keys(strapi.components).find(\n                  key => strapi.components[key].collectionName === el.component_type\n                );\n\n                return {\n                  __component: strapi.components[componentKey].uid,\n                  ...el.component,\n                };\n              });\n\n              break;\n            }\n            default: {\n              throw new Error(`Invalid type for attribute ${key}: ${type}`);\n            }\n          }\n        });\n\n        polymorphicAssociations.map(association => {\n          // Retrieve relation Bookshelf object.\n          const relation = relations[association.alias];\n\n          if (relation) {\n            // Extract raw JSON data.\n            attrs[association.alias] = relation.toJSON ? relation.toJSON(options) : relation;\n\n            // Retrieve opposite model.\n            const model = strapi.db.getModel(\n              association.collection || association.model,\n              association.plugin\n            );\n\n            // Reformat data by bypassing the many-to-many relationship.\n            switch (association.nature) {\n              case 'oneToManyMorph':\n                attrs[association.alias] = attrs[association.alias][model.collectionName] || null;\n                break;\n              case 'manyToManyMorph':\n                attrs[association.alias] = attrs[association.alias].map(\n                  rel => rel[model.collectionName]\n                );\n                break;\n              case 'oneMorphToOne': {\n                const obj = attrs[association.alias];\n\n                if (obj === undefined || obj === null) {\n                  break;\n                }\n\n                const contentType = strapi.db.getModelByCollectionName(\n                  obj[`${association.alias}_type`]\n                );\n\n                attrs[association.alias] = {\n                  __contentType: contentType ? contentType.globalId : null,\n                  ...obj.related,\n                };\n\n                break;\n              }\n              case 'manyMorphToOne':\n              case 'manyMorphToMany':\n                attrs[association.alias] = attrs[association.alias].map(obj => {\n                  const contentType = strapi.db.getModelByCollectionName(\n                    obj[`${association.alias}_type`]\n                  );\n\n                  return {\n                    __contentType: contentType ? contentType.globalId : null,\n                    ...obj.related,\n                  };\n                });\n                break;\n              default:\n            }\n          }\n        });\n\n        associations.map(association => {\n          const relation = relations[association.alias];\n\n          if (relation) {\n            // Extract raw JSON data.\n            attrs[association.alias] = relation.toJSON ? relation.toJSON(options) : relation;\n          }\n        });\n\n        return attrs;\n      };\n\n      // Initialize lifecycle callbacks.\n      loadedModel.initialize = function() {\n        // Load bookshelf plugin arguments from model options\n        this.constructor.__super__.initialize.apply(this, arguments);\n\n        this.on('fetching fetching:collection', (instance, attrs, options) => {\n          populateFetch(definition, options);\n        });\n\n        this.on('saving', (instance, attrs) => {\n          instance.attributes = _.assign(instance.attributes, mapper(attrs));\n        });\n\n        const formatValue = createFormatter(definition.client);\n        function formatEntry(entry) {\n          Object.keys(entry.attributes).forEach(key => {\n            if (key.startsWith('_strapi_tmp_')) {\n              delete entry.attributes[key];\n              return;\n            }\n            const attr = definition.attributes[key] || {};\n            entry.attributes[key] = formatValue(attr, entry.attributes[key]);\n          });\n        }\n\n        this.on('saved fetched fetched:collection', instance => {\n          if (Array.isArray(instance.models)) {\n            instance.models.forEach(entry => formatEntry(entry));\n          } else {\n            formatEntry(instance);\n          }\n        });\n      };\n\n      loadedModel.hidden = _.keys(\n        _.keyBy(\n          _.filter(definition.attributes, (value, key) => {\n            if (\n              _.has(value, 'columnName') &&\n              !_.isEmpty(value.columnName) &&\n              value.columnName !== key\n            ) {\n              return true;\n            }\n          }),\n          'columnName'\n        )\n      );\n      GLOBALS[definition.globalId] = ORM.Model.extend(loadedModel);\n\n      // Expose ORM functions through the `strapi.models[xxx]`\n      // or `strapi.plugins[xxx].models[yyy]` object.\n      target[model] = _.assign(GLOBALS[definition.globalId], target[model]);\n\n      // Push attributes to be aware of model schema.\n      target[model]._attributes = definition.attributes;\n      target[model].updateRelations = relations.update;\n      target[model].deleteRelations = relations.deleteRelations;\n      target[model].privateAttributes = contentTypesUtils.getPrivateAttributes(target[model]);\n\n      return async () => {\n        try {\n          await buildDatabaseSchema({\n            ORM,\n            definition,\n            loadedModel,\n            connection,\n            model: target[model],\n          });\n\n          await createComponentJoinTables({ definition, ORM });\n        } catch (err) {\n          if (['ER_TOO_LONG_IDENT'].includes(err.code)) {\n            strapi.stopWithError(\n              err,\n              `A table name is too long. If it is the name of a join table automatically generated by Strapi, you can customise it by adding \\`collectionName: \"customName\"\\` in the corresponding model's attribute.\n    When this happens on a manyToMany relation, make sure to set this parameter on the dominant side of the relation (e.g: where \\`dominant: true\\` is set)`\n            );\n          }\n\n          strapi.stopWithError(err);\n        }\n      };\n    } catch (err) {\n      if (err instanceof TypeError || err instanceof ReferenceError) {\n        strapi.stopWithError(err, `Impossible to register the '${model}' model.`);\n      }\n\n      strapi.stopWithError(err);\n    }\n  };\n\n  const finalizeUpdates = [];\n  for (const model of _.keys(models)) {\n    const finalizeUpdate = await updateModel(model);\n    finalizeUpdates.push(finalizeUpdate);\n  }\n\n  if (selfFinalize) {\n    for (const finalizeUpdate of finalizeUpdates) {\n      await finalizeUpdate();\n    }\n    return [];\n  }\n\n  return finalizeUpdates;\n};\n",
    "packages/strapi-connector-bookshelf/lib/queries.js": "'use strict';\n/**\n * Implementation of model queries for bookshelf\n */\n\nconst _ = require('lodash');\nconst { omit } = require('lodash/fp');\nconst pmap = require('p-map');\nconst { convertRestQueryParams, buildQuery, escapeQuery } = require('strapi-utils');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\nconst { singular } = require('pluralize');\nconst { handleDatabaseError } = require('./utils/errors');\n\nconst { PUBLISHED_AT_ATTRIBUTE } = contentTypesUtils.constants;\nconst pickCountFilters = omit(['sort', 'limit', 'start']);\n\nmodule.exports = function createQueryBuilder({ model, strapi }) {\n  /* Utils */\n  // association key\n  const assocKeys = model.associations.map(ast => ast.alias);\n  // component keys\n  const componentKeys = Object.keys(model.attributes).filter(key => {\n    return ['dynamiczone', 'component'].includes(model.attributes[key].type);\n  });\n\n  const timestamps = _.get(model, ['options', 'timestamps'], []);\n  const hasDraftAndPublish = contentTypesUtils.hasDraftAndPublish(model);\n\n  // Returns an object with relation keys only to create relations in DB\n  const pickRelations = attributes => {\n    return _.pick(attributes, assocKeys);\n  };\n\n  // keys to exclude to get attribute keys\n  const excludedKeys = assocKeys.concat(componentKeys);\n  // Returns an object without relational keys to persist in DB\n  const selectAttributes = attributes => {\n    return _.pickBy(attributes, (value, key) => {\n      if (Array.isArray(timestamps) && timestamps.includes(key)) {\n        return false;\n      }\n\n      return !excludedKeys.includes(key) && _.has(model.allAttributes, key);\n    });\n  };\n\n  const wrapTransaction = (fn, { transacting } = {}) => {\n    const db = strapi.connections[model.connection];\n\n    if (transacting) return fn(transacting);\n    return db.transaction(trx => fn(trx));\n  };\n\n  const wrapErrors = fn => async (...args) => {\n    try {\n      return await fn(...args);\n    } catch (error) {\n      return handleDatabaseError(error);\n    }\n  };\n\n  /**\n   * Find one entry based on params\n   */\n  async function findOne(params, populate, { transacting } = {}) {\n    const entries = await find({ ...params, _limit: 1 }, populate, { transacting });\n    return entries[0] || null;\n  }\n\n  /**\n   * Find multiple entries based on params\n   */\n  function find(params, populate, { transacting } = {}) {\n    const filters = convertRestQueryParams(params);\n    const query = buildQuery({ model, filters });\n\n    return model\n      .query(query)\n      .fetchAll({\n        withRelated: populate,\n        transacting,\n        publicationState: filters.publicationState,\n      })\n      .then(results => results.toJSON());\n  }\n\n  /**\n   * Count entries based on filters\n   */\n  function count(params = {}) {\n    const filters = pickCountFilters(convertRestQueryParams(params));\n\n    return model\n      .query(buildQuery({ model, filters }))\n      .count()\n      .then(Number);\n  }\n\n  async function create(attributes, { transacting } = {}) {\n    const relations = pickRelations(attributes);\n    const data = { ...selectAttributes(attributes) };\n\n    if (hasDraftAndPublish) {\n      data[PUBLISHED_AT_ATTRIBUTE] = _.has(attributes, PUBLISHED_AT_ATTRIBUTE)\n        ? attributes[PUBLISHED_AT_ATTRIBUTE]\n        : new Date();\n    }\n\n    const runCreate = async trx => {\n      // Create entry with no-relational data.\n      const entry = await model.forge(data).save(null, { transacting: trx });\n      const isDraft = contentTypesUtils.isDraft(entry.toJSON(), model);\n      await createComponents(entry, attributes, { transacting: trx, isDraft });\n\n      return model.updateRelations({ id: entry.id, values: relations }, { transacting: trx });\n    };\n\n    return wrapTransaction(runCreate, { transacting });\n  }\n\n  async function update(params, attributes, { transacting } = {}) {\n    const entry = await model.where(params).fetch({ transacting });\n\n    if (!entry) {\n      const err = new Error('entry.notFound');\n      err.status = 404;\n      throw err;\n    }\n\n    // Extract attributes related to relational data.\n    const relations = pickRelations(attributes);\n    const data = selectAttributes(attributes);\n\n    const runUpdate = async trx => {\n      const updatedEntry =\n        Object.keys(data).length > 0\n          ? await entry.save(data, {\n              transacting: trx,\n              method: 'update',\n              patch: true,\n            })\n          : entry;\n\n      await updateComponents(updatedEntry, attributes, { transacting: trx });\n\n      if (Object.keys(relations).length > 0) {\n        return model.updateRelations({ id: entry.id, values: relations }, { transacting: trx });\n      }\n\n      return findOne(params, null, { transacting: trx });\n    };\n\n    return wrapTransaction(runUpdate, { transacting });\n  }\n\n  async function deleteOne(id, { transacting } = {}) {\n    const entry = await model.where({ [model.primaryKey]: id }).fetch({ transacting });\n\n    if (!entry) {\n      const err = new Error('entry.notFound');\n      err.status = 404;\n      throw err;\n    }\n\n    await model.deleteRelations(id, { transacting });\n\n    const runDelete = async trx => {\n      await deleteComponents(entry, { transacting: trx });\n      await model.where({ id: entry.id }).destroy({ transacting: trx, require: false });\n      return entry.toJSON();\n    };\n\n    return wrapTransaction(runDelete, { transacting });\n  }\n\n  async function deleteMany(params, { transacting } = {}) {\n    if (params[model.primaryKey]) {\n      const entries = await find({ ...params, _limit: 1 }, null, { transacting });\n      if (entries.length > 0) {\n        return deleteOne(entries[0][model.primaryKey], { transacting });\n      }\n      return null;\n    }\n\n    const paramsWithDefaults = _.defaults(params, { _limit: -1 });\n    const entries = await find(paramsWithDefaults, null, { transacting });\n    return pmap(entries, entry => deleteOne(entry.id, { transacting }), {\n      concurrency: 100,\n      stopOnError: true,\n    });\n  }\n\n  function search(params, populate) {\n    const filters = convertRestQueryParams(_.omit(params, '_q'));\n\n    return model\n      .query(qb => qb.where(buildSearchQuery({ model, params })))\n      .query(buildQuery({ model, filters }))\n      .fetchAll({ withRelated: populate })\n      .then(results => results.toJSON());\n  }\n\n  function countSearch(params) {\n    const countParams = omit(['_q'], params);\n    const filters = pickCountFilters(convertRestQueryParams(countParams));\n\n    return model\n      .query(qb => qb.where(buildSearchQuery({ model, params })))\n      .query(buildQuery({ model, filters }))\n      .count()\n      .then(Number);\n  }\n\n  async function createComponents(entry, attributes, { transacting, isDraft }) {\n    if (componentKeys.length === 0) return;\n\n    const joinModel = model.componentsJoinModel;\n    const { foreignKey } = joinModel;\n\n    const createComponentAndLink = async ({ componentModel, value, key, order }) => {\n      return strapi\n        .query(componentModel.uid)\n        .create(value, { transacting })\n        .then(component => {\n          return joinModel.forge().save(\n            {\n              [foreignKey]: entry.id,\n              component_type: componentModel.collectionName,\n              component_id: component.id,\n              field: key,\n              order,\n            },\n            { transacting }\n          );\n        });\n    };\n\n    for (let key of componentKeys) {\n      const attr = model.attributes[key];\n      const { type } = attr;\n\n      switch (type) {\n        case 'component': {\n          const { component, required = false, repeatable = false } = attr;\n          const componentModel = strapi.components[component];\n\n          if (!isDraft && required === true && !_.has(attributes, key)) {\n            const err = new Error(`Component ${key} is required`);\n            err.status = 400;\n            throw err;\n          }\n\n          if (!_.has(attributes, key)) continue;\n\n          const componentValue = attributes[key];\n\n          if (repeatable === true) {\n            await Promise.all(\n              componentValue.map((value, idx) =>\n                createComponentAndLink({\n                  componentModel,\n                  value,\n                  key,\n                  order: idx + 1,\n                })\n              )\n            );\n          } else {\n            if (componentValue === null) continue;\n            await createComponentAndLink({\n              componentModel,\n              key,\n              value: componentValue,\n              order: 1,\n            });\n          }\n          break;\n        }\n        case 'dynamiczone': {\n          const { required = false } = attr;\n\n          if (!isDraft && required === true && !_.has(attributes, key)) {\n            const err = new Error(`Dynamiczone ${key} is required`);\n            err.status = 400;\n            throw err;\n          }\n\n          if (!_.has(attributes, key)) continue;\n\n          const dynamiczoneValues = attributes[key];\n\n          await Promise.all(\n            dynamiczoneValues.map((value, idx) => {\n              const component = value.__component;\n              const componentModel = strapi.components[component];\n              return createComponentAndLink({\n                componentModel,\n                value: _.omit(value, ['__component']),\n                key,\n                order: idx + 1,\n              });\n            })\n          );\n          break;\n        }\n      }\n    }\n  }\n\n  async function updateComponents(entry, attributes, { transacting }) {\n    if (componentKeys.length === 0) return;\n\n    const joinModel = model.componentsJoinModel;\n    const { foreignKey } = joinModel;\n\n    const updateOrCreateComponentAndLink = async ({ componentModel, key, value, order }) => {\n      // check if value has an id then update else create\n      if (_.has(value, componentModel.primaryKey)) {\n        return strapi\n          .query(componentModel.uid)\n          .update(\n            {\n              [componentModel.primaryKey]: value[componentModel.primaryKey],\n            },\n            value,\n            { transacting }\n          )\n          .then(component => {\n            return joinModel\n              .where({\n                [foreignKey]: entry.id,\n                component_type: componentModel.collectionName,\n                component_id: component.id,\n                field: key,\n              })\n              .save(\n                {\n                  order,\n                },\n                { transacting, patch: true, require: false }\n              );\n          });\n      }\n      // create\n      return strapi\n        .query(componentModel.uid)\n        .create(value, { transacting })\n        .then(component => {\n          return joinModel.forge().save(\n            {\n              [foreignKey]: entry.id,\n              component_type: componentModel.collectionName,\n              component_id: component.id,\n              field: key,\n              order,\n            },\n            { transacting }\n          );\n        });\n    };\n\n    for (let key of componentKeys) {\n      // if key isn't present then don't change the current component data\n      if (!_.has(attributes, key)) continue;\n\n      const attr = model.attributes[key];\n      const { type } = attr;\n\n      switch (type) {\n        case 'component': {\n          const { component, repeatable = false } = attr;\n\n          const componentModel = strapi.components[component];\n\n          const componentValue = attributes[key];\n\n          if (repeatable === true) {\n            await deleteOldComponents(entry, componentValue, {\n              key,\n              joinModel,\n              componentModel,\n              transacting,\n            });\n\n            await Promise.all(\n              componentValue.map((value, idx) => {\n                return updateOrCreateComponentAndLink({\n                  componentModel,\n                  key,\n                  value,\n                  order: idx + 1,\n                });\n              })\n            );\n          } else {\n            await deleteOldComponents(entry, componentValue, {\n              key,\n              joinModel,\n              componentModel,\n              transacting,\n            });\n\n            if (componentValue === null) continue;\n\n            await updateOrCreateComponentAndLink({\n              componentModel,\n              key,\n              value: componentValue,\n              order: 1,\n            });\n          }\n\n          break;\n        }\n        case 'dynamiczone': {\n          const dynamiczoneValues = attributes[key];\n\n          await deleteDynamicZoneOldComponents(entry, dynamiczoneValues, {\n            key,\n            joinModel,\n            transacting,\n          });\n\n          await Promise.all(\n            dynamiczoneValues.map((value, idx) => {\n              const component = value.__component;\n              const componentModel = strapi.components[component];\n              return updateOrCreateComponentAndLink({\n                componentModel,\n                value: _.omit(value, ['__component']),\n                key,\n                order: idx + 1,\n              });\n            })\n          );\n          break;\n        }\n      }\n    }\n    return;\n  }\n\n  async function deleteDynamicZoneOldComponents(entry, values, { key, joinModel, transacting }) {\n    const idsToKeep = values.reduce((acc, value) => {\n      const component = value.__component;\n      const componentModel = strapi.components[component];\n      if (_.has(value, componentModel.primaryKey)) {\n        acc.push({\n          id: value[componentModel.primaryKey].toString(),\n          component: componentModel,\n        });\n      }\n\n      return acc;\n    }, []);\n\n    const allIds = await joinModel\n      .query(qb => {\n        qb.where(joinModel.foreignKey, entry.id).andWhere('field', key);\n      })\n      .fetchAll({ transacting })\n      .map(el => {\n        const componentKey = Object.keys(strapi.components).find(\n          key => strapi.components[key].collectionName === el.get('component_type')\n        );\n\n        return {\n          id: el.get('component_id').toString(),\n          component: strapi.components[componentKey],\n        };\n      });\n\n    // verify the provided ids are related to this entity.\n    idsToKeep.forEach(({ id, component }) => {\n      if (!allIds.find(el => el.id === id && el.component.uid === component.uid)) {\n        const err = new Error(\n          `Some of the provided components in ${key} are not related to the entity`\n        );\n        err.status = 400;\n        throw err;\n      }\n    });\n\n    const idsToDelete = allIds.reduce((acc, { id, component }) => {\n      if (!idsToKeep.find(el => el.id === id && el.component.uid === component.uid)) {\n        acc.push({\n          id,\n          component,\n        });\n      }\n      return acc;\n    }, []);\n\n    if (idsToDelete.length > 0) {\n      await joinModel\n        .query(qb => {\n          qb.where('field', key);\n          qb.where(qb => {\n            idsToDelete.forEach(({ id, component }) => {\n              qb.orWhere(qb => {\n                qb.where('component_id', id).andWhere('component_type', component.collectionName);\n              });\n            });\n          });\n        })\n        .destroy({ transacting });\n\n      for (const idToDelete of idsToDelete) {\n        const { id, component } = idToDelete;\n        const model = strapi.query(component.uid);\n        await model.delete({ [model.primaryKey]: id }, { transacting });\n      }\n    }\n  }\n\n  async function deleteOldComponents(\n    entry,\n    componentValue,\n    { key, joinModel, componentModel, transacting }\n  ) {\n    const componentArr = Array.isArray(componentValue) ? componentValue : [componentValue];\n\n    const idsToKeep = componentArr\n      .filter(el => _.has(el, componentModel.primaryKey))\n      .map(el => el[componentModel.primaryKey].toString());\n\n    const allIds = await joinModel\n      .where({\n        [joinModel.foreignKey]: entry.id,\n        field: key,\n      })\n      .fetchAll({ transacting })\n      .map(el => el.get('component_id').toString());\n\n    // verify the provided ids are related to this entity.\n    idsToKeep.forEach(id => {\n      if (!allIds.includes(id)) {\n        const err = new Error(\n          `Some of the provided components in ${key} are not related to the entity`\n        );\n        err.status = 400;\n        throw err;\n      }\n    });\n\n    const idsToDelete = _.difference(allIds, idsToKeep);\n    if (idsToDelete.length > 0) {\n      await joinModel\n        .query(qb => qb.whereIn('component_id', idsToDelete).andWhere('field', key))\n        .destroy({ transacting, require: false });\n\n      await strapi\n        .query(componentModel.uid)\n        .delete({ [`${componentModel.primaryKey}_in`]: idsToDelete }, { transacting });\n    }\n  }\n\n  async function deleteComponents(entry, { transacting }) {\n    if (componentKeys.length === 0) return;\n\n    const joinModel = model.componentsJoinModel;\n    const { foreignKey } = joinModel;\n\n    for (let key of componentKeys) {\n      const attr = model.attributes[key];\n      const { type } = attr;\n\n      switch (type) {\n        case 'component': {\n          const { component } = attr;\n\n          const componentModel = strapi.components[component];\n\n          const ids = await joinModel\n            .where({\n              [foreignKey]: entry.id,\n              field: key,\n            })\n            .fetchAll({ transacting })\n            .map(el => el.get('component_id'));\n\n          await strapi\n            .query(componentModel.uid)\n            .delete({ [`${componentModel.primaryKey}_in`]: ids }, { transacting });\n\n          await joinModel\n            .where({\n              [foreignKey]: entry.id,\n              field: key,\n            })\n            .destroy({ transacting, require: false });\n          break;\n        }\n        case 'dynamiczone': {\n          const { components } = attr;\n\n          const componentJoins = await joinModel\n            .where({\n              [foreignKey]: entry.id,\n              field: key,\n            })\n            .fetchAll({ transacting })\n            .map(el => ({\n              id: el.get('component_id'),\n              componentType: el.get('component_type'),\n            }));\n\n          for (const compo of components) {\n            const { uid, collectionName } = strapi.components[compo];\n            const model = strapi.query(uid);\n\n            const toDelete = componentJoins.filter(el => el.componentType === collectionName);\n\n            if (toDelete.length > 0) {\n              await model.delete(\n                {\n                  [`${model.primaryKey}_in`]: toDelete.map(el => el.id),\n                },\n                { transacting }\n              );\n            }\n          }\n\n          await joinModel\n            .where({\n              [foreignKey]: entry.id,\n              field: key,\n            })\n            .destroy({ transacting, require: false });\n\n          break;\n        }\n      }\n    }\n  }\n\n  async function fetchRelationCounters(attribute, entitiesIds = []) {\n    const assoc = model.associations.find(assoc => assoc.alias === attribute);\n    const assocModel = strapi.db.getModelByAssoc(assoc);\n    const knex = strapi.connections[model.connection];\n    const targetAttribute = assocModel.attributes[assoc.via];\n\n    switch (assoc.nature) {\n      case 'oneToMany': {\n        return knex\n          .select()\n          .column({ id: assoc.via, count: knex.raw('count(*)') })\n          .from(assocModel.collectionName)\n          .whereIn(assoc.via, entitiesIds)\n          .groupBy(assoc.via);\n      }\n      case 'manyWay': {\n        const column = `${singular(model.collectionName)}_${model.primaryKey}`;\n        return knex\n          .select()\n          .column({ id: column, count: knex.raw('count(*)') })\n          .from(assoc.tableCollectionName)\n          .whereIn(column, entitiesIds)\n          .groupBy(column);\n      }\n      case 'manyToMany': {\n        const column = `${targetAttribute.attribute}_${targetAttribute.column}`;\n        return knex\n          .select()\n          .column({ id: column, count: knex.raw('count(*)') })\n          .from(assoc.tableCollectionName)\n          .whereIn(column, entitiesIds)\n          .groupBy(column);\n      }\n      default: {\n        return [];\n      }\n    }\n  }\n\n  return {\n    findOne,\n    find,\n    create: wrapErrors(create),\n    update: wrapErrors(update),\n    delete: deleteMany,\n    count,\n    search,\n    countSearch,\n    fetchRelationCounters,\n  };\n};\n\n/**\n * util to build search query\n * @param {*} model\n * @param {*} params\n */\nconst buildSearchQuery = ({ model, params }) => qb => {\n  const query = params._q;\n\n  const associations = model.associations.map(x => x.alias);\n  const stringTypes = ['string', 'text', 'uid', 'email', 'enumeration', 'richtext'];\n  const numberTypes = ['biginteger', 'integer', 'decimal', 'float'];\n\n  const searchColumns = Object.keys(model._attributes)\n    .filter(attribute => !associations.includes(attribute))\n    .filter(attribute => stringTypes.includes(model._attributes[attribute].type));\n\n  if (!_.isNaN(_.toNumber(query))) {\n    const numberColumns = Object.keys(model._attributes)\n      .filter(attribute => !associations.includes(attribute))\n      .filter(attribute => numberTypes.includes(model._attributes[attribute].type));\n    searchColumns.push(...numberColumns);\n  }\n\n  if ([...numberTypes, ...stringTypes].includes(model.primaryKeyType)) {\n    searchColumns.push(model.primaryKey);\n  }\n\n  // Search in columns with text using index.\n  switch (model.client) {\n    case 'pg':\n      searchColumns.forEach(attr =>\n        qb.orWhereRaw(\n          `\"${model.collectionName}\".\"${attr}\"::text ILIKE ?`,\n          `%${escapeQuery(query, '*%\\\\')}%`\n        )\n      );\n      break;\n    case 'sqlite3':\n      searchColumns.forEach(attr =>\n        qb.orWhereRaw(\n          `\"${model.collectionName}\".\"${attr}\" LIKE ? ESCAPE '\\\\'`,\n          `%${escapeQuery(query, '*%\\\\')}%`\n        )\n      );\n      break;\n    case 'mysql':\n      searchColumns.forEach(attr =>\n        qb.orWhereRaw(\n          `\\`${model.collectionName}\\`.\\`${attr}\\` LIKE ?`,\n          `%${escapeQuery(query, '*%\\\\')}%`\n        )\n      );\n      break;\n  }\n};\n",
    "packages/strapi-connector-bookshelf/lib/relations.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst _ = require('lodash');\n\n// Utils\nconst {\n  models: { getValuePrimaryKey },\n} = require('strapi-utils');\n\nconst transformToArrayID = array => {\n  if (_.isArray(array)) {\n    return array\n      .map(value => _.get(value, 'id') || value)\n      .filter(n => n)\n      .map(val => _.toString(val));\n  }\n\n  return transformToArrayID([array]);\n};\n\nconst removeUndefinedKeys = obj => _.pickBy(obj, _.negate(_.isUndefined));\n\nconst addRelationMorph = async (model, { params, transacting } = {}) => {\n  return await model.morph.forge().save(\n    {\n      [`${model.collectionName}_id`]: params.id,\n      [`${params.alias}_id`]: params.refId,\n      [`${params.alias}_type`]: params.ref,\n      field: params.field,\n      order: params.order,\n    },\n    { transacting }\n  );\n};\n\nconst removeRelationMorph = async (model, { params, transacting } = {}) => {\n  return await model.morph\n    .forge()\n    .where(\n      _.omitBy(\n        {\n          [`${model.collectionName}_id`]: params.id,\n          [`${params.alias}_id`]: params.refId,\n          [`${params.alias}_type`]: params.ref,\n          field: params.field,\n        },\n        _.isUndefined\n      )\n    )\n    .destroy({\n      require: false,\n      transacting,\n    });\n};\n\nmodule.exports = {\n  async findOne(params, populate, { transacting } = {}) {\n    const record = await this.forge({\n      [this.primaryKey]: getValuePrimaryKey(params, this.primaryKey),\n    }).fetch({\n      transacting,\n      withRelated: populate,\n    });\n\n    const data = record ? record.toJSON() : record;\n\n    // Retrieve data manually.\n    if (_.isEmpty(populate)) {\n      const arrayOfPromises = this.associations\n        .filter(association => ['manyMorphToOne', 'manyMorphToMany'].includes(association.nature))\n        .map(() => {\n          return this.morph\n            .forge()\n            .where({\n              [`${this.collectionName}_id`]: getValuePrimaryKey(params, this.primaryKey),\n            })\n            .fetchAll({\n              transacting,\n            });\n        });\n\n      const related = await Promise.all(arrayOfPromises);\n\n      related.forEach((value, index) => {\n        data[this.associations[index].alias] = value ? value.toJSON() : value;\n      });\n    }\n\n    return data;\n  },\n\n  async update(params, { transacting } = {}) {\n    const relationUpdates = [];\n    const primaryKeyValue = getValuePrimaryKey(params, this.primaryKey);\n    const response = await module.exports.findOne.call(this, params, null, {\n      transacting,\n    });\n\n    // Only update fields which are on this document.\n    const values = Object.keys(removeUndefinedKeys(params.values)).reduce((acc, current) => {\n      const property = params.values[current];\n      const association = this.associations.filter(x => x.alias === current)[0];\n      const details = this._attributes[current];\n\n      if (!association && _.get(details, 'isVirtual') !== true) {\n        return _.set(acc, current, property);\n      }\n\n      const assocModel = strapi.db.getModel(details.model || details.collection, details.plugin);\n\n      switch (association.nature) {\n        case 'oneWay': {\n          return _.set(acc, current, _.get(property, assocModel.primaryKey, property));\n        }\n        case 'oneToOne': {\n          if (response[current] === property) return acc;\n\n          if (_.isNull(property)) {\n            const updatePromise = assocModel\n              .where({\n                [assocModel.primaryKey]: getValuePrimaryKey(\n                  response[current],\n                  assocModel.primaryKey\n                ),\n              })\n              .save(\n                { [details.via]: null },\n                {\n                  method: 'update',\n                  patch: true,\n                  require: false,\n                  transacting,\n                }\n              );\n\n            relationUpdates.push(updatePromise);\n            return _.set(acc, current, null);\n          }\n\n          // set old relations to null\n          const updateLink = this.where({ [current]: property })\n            .save(\n              { [current]: null },\n              {\n                method: 'update',\n                patch: true,\n                require: false,\n                transacting,\n              }\n            )\n            .then(() => {\n              return assocModel.where({ [this.primaryKey]: property }).save(\n                { [details.via]: primaryKeyValue },\n                {\n                  method: 'update',\n                  patch: true,\n                  require: false,\n                  transacting,\n                }\n              );\n            });\n\n          // set new relation\n          relationUpdates.push(updateLink);\n          return _.set(acc, current, property);\n        }\n        case 'oneToMany': {\n          // receive array of ids or array of objects with ids\n\n          // set relation to null for all the ids not in the list\n          const currentIds = response[current];\n          const toRemove = _.differenceWith(currentIds, property, (a, b) => {\n            return `${a[assocModel.primaryKey] || a}` === `${b[assocModel.primaryKey] || b}`;\n          });\n\n          const updatePromise = assocModel\n            .where(\n              assocModel.primaryKey,\n              'in',\n              toRemove.map(val => val[assocModel.primaryKey] || val)\n            )\n            .save(\n              { [details.via]: null },\n              {\n                method: 'update',\n                patch: true,\n                require: false,\n                transacting,\n              }\n            )\n            .then(() => {\n              return assocModel\n                .where(\n                  assocModel.primaryKey,\n                  'in',\n                  property.map(val => val[assocModel.primaryKey] || val)\n                )\n                .save(\n                  { [details.via]: primaryKeyValue },\n                  {\n                    method: 'update',\n                    patch: true,\n                    require: false,\n                    transacting,\n                  }\n                );\n            });\n\n          relationUpdates.push(updatePromise);\n          return acc;\n        }\n        case 'manyToOne': {\n          return _.set(acc, current, _.get(property, assocModel.primaryKey, property));\n        }\n        case 'manyWay':\n        case 'manyToMany': {\n          const storedValue = transformToArrayID(response[current]);\n          const currentValue = transformToArrayID(params.values[current]);\n\n          const toAdd = _.difference(currentValue, storedValue);\n          const toRemove = _.difference(storedValue, currentValue);\n\n          const collection = this.forge({\n            [this.primaryKey]: primaryKeyValue,\n          })[association.alias]();\n\n          const updatePromise = collection\n            .detach(toRemove, { transacting })\n            .then(() => collection.attach(toAdd, { transacting }));\n\n          relationUpdates.push(updatePromise);\n          return acc;\n        }\n        // media -> model\n        case 'manyMorphToMany':\n        case 'manyMorphToOne': {\n          // Update the relational array.\n          const refs = params.values[current];\n\n          if (Array.isArray(refs) && refs.length === 0) {\n            // clear related\n            relationUpdates.push(\n              removeRelationMorph(this, { params: { id: primaryKeyValue }, transacting })\n            );\n            break;\n          }\n\n          refs.forEach(obj => {\n            const targetModel = strapi.db.getModel(\n              obj.ref,\n              obj.source !== 'content-manager' ? obj.source : null\n            );\n\n            const reverseAssoc = targetModel.associations.find(assoc => assoc.alias === obj.field);\n\n            // Remove existing relationship because only one file\n            // can be related to this field.\n            if (reverseAssoc && reverseAssoc.nature === 'oneToManyMorph') {\n              relationUpdates.push(\n                removeRelationMorph(this, {\n                  params: {\n                    alias: association.alias,\n                    ref: targetModel.collectionName,\n                    refId: obj.refId,\n                    field: obj.field,\n                  },\n                  transacting,\n                }).then(() =>\n                  addRelationMorph(this, {\n                    params: {\n                      id: response[this.primaryKey],\n                      alias: association.alias,\n                      ref: targetModel.collectionName,\n                      refId: obj.refId,\n                      field: obj.field,\n                      order: 1,\n                    },\n                    transacting,\n                  })\n                )\n              );\n\n              return;\n            }\n\n            const addRelation = async () => {\n              const maxOrder = await this.morph\n                .query(qb => {\n                  qb.max('order as order').where({\n                    [`${association.alias}_id`]: obj.refId,\n                    [`${association.alias}_type`]: targetModel.collectionName,\n                    field: obj.field,\n                  });\n                })\n                .fetch({ transacting });\n\n              const { order = 0 } = maxOrder.toJSON();\n\n              await addRelationMorph(this, {\n                params: {\n                  id: response[this.primaryKey],\n                  alias: association.alias,\n                  ref: targetModel.collectionName,\n                  refId: obj.refId,\n                  field: obj.field,\n                  order: order + 1,\n                },\n                transacting,\n              });\n            };\n\n            relationUpdates.push(addRelation());\n          });\n          break;\n        }\n        // model -> media\n        case 'oneToManyMorph':\n        case 'manyToManyMorph': {\n          const currentValue = transformToArrayID(params.values[current]);\n\n          const model = strapi.db.getModel(details.collection || details.model, details.plugin);\n\n          const promise = removeRelationMorph(model, {\n            params: {\n              alias: association.via,\n              ref: this.collectionName,\n              refId: response.id,\n              field: association.alias,\n            },\n            transacting,\n          }).then(() => {\n            return Promise.all(\n              currentValue.map((id, idx) => {\n                return addRelationMorph(model, {\n                  params: {\n                    id,\n                    alias: association.via,\n                    ref: this.collectionName,\n                    refId: response.id,\n                    field: association.alias,\n                    order: idx + 1,\n                  },\n                  transacting,\n                });\n              })\n            );\n          });\n\n          relationUpdates.push(promise);\n\n          break;\n        }\n        case 'oneMorphToOne':\n        case 'oneMorphToMany': {\n          break;\n        }\n        default:\n      }\n\n      return acc;\n    }, {});\n\n    await Promise.all(relationUpdates);\n\n    delete values[this.primaryKey];\n    if (!_.isEmpty(values)) {\n      await this.forge({\n        [this.primaryKey]: getValuePrimaryKey(params, this.primaryKey),\n      }).save(values, {\n        patch: true,\n        transacting,\n      });\n    }\n\n    const result = await this.forge({\n      [this.primaryKey]: getValuePrimaryKey(params, this.primaryKey),\n    }).fetch({\n      transacting,\n    });\n\n    return result && result.toJSON ? result.toJSON() : result;\n  },\n\n  deleteRelations(id, { transacting }) {\n    const values = {};\n\n    this.associations.map(association => {\n      switch (association.nature) {\n        case 'oneWay':\n        case 'oneToOne':\n        case 'manyToOne':\n        case 'oneToManyMorph':\n          values[association.alias] = null;\n          break;\n        case 'manyWay':\n        case 'oneToMany':\n        case 'manyToMany':\n        case 'manyToManyMorph':\n        case 'manyMorphToMany':\n        case 'manyMorphToOne':\n          values[association.alias] = [];\n          break;\n        default:\n      }\n    });\n\n    return this.updateRelations({ [this.primaryKey]: id, values }, { transacting });\n  },\n};\n",
    "packages/strapi-connector-bookshelf/lib/utils/connectivity.js": "'use strict';\n\n// Public node modules\nconst inquirer = require('inquirer');\n\nconst hasResults = rows => {\n  if (!rows || rows.length === 0) return true;\n  return false;\n};\n\nconst checkDatabaseIsEmpty = {\n  postgres: client =>\n    client\n      .select('tablename')\n      .from('pg_tables')\n      .where('schemaname', 'public')\n      .then(hasResults),\n\n  mysql: (client, { database }) =>\n    client\n      .select()\n      .from('information_schema.tables')\n      .where('table_schema', database)\n      .then(hasResults),\n\n  sqlite: client =>\n    client\n      .select()\n      .from('sqlite_master')\n      .then(hasResults),\n};\n\nmodule.exports = async ({ scope, connection }) => {\n  const knex = require('knex');\n\n  const { settings } = connection;\n  const client = knex({\n    client: settings.client,\n    connection: Object.assign({}, settings, {\n      user: settings.username,\n    }),\n    useNullAsDefault: true,\n  });\n\n  const destroyClientAndThrow = err => {\n    return client.destroy().then(\n      () => {\n        throw err;\n      },\n      () => {\n        throw err;\n      }\n    );\n  };\n\n  await client.raw('select 1+1 as result').catch(destroyClientAndThrow);\n\n  return checkDatabaseIsEmpty[settings.client](client, settings)\n    .then(isEmpty => {\n      if (isEmpty) return;\n      if (scope.dbforce) return;\n\n      console.log();\n      console.error(\n        'It seems that your database is not empty.\\nStrapi automatically creates tables and columns which might corrupt the data already present in your database.'\n      );\n\n      return inquirer\n        .prompt([\n          {\n            type: 'confirm',\n            name: 'confirm',\n            message: `Are you sure you want to continue with the ${settings.database} database:`,\n          },\n        ])\n        .then(({ confirm }) => {\n          // send restart flag to retry\n          if (!confirm) return { shouldRetry: true };\n        });\n    })\n    .then(res => client.destroy().then(() => res))\n    .catch(destroyClientAndThrow);\n};\n",
    "packages/strapi-connector-bookshelf/lib/utils/store-definition.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst formatDefinitionToStore = definition =>\n  JSON.stringify(\n    _.pick(definition, ['uid', 'collectionName', 'kind', 'info', 'options', 'attributes'])\n  );\n\nconst getDefinitionFromStore = async (definition, ORM) => {\n  const coreStoreExists = await ORM.knex.schema.hasTable('core_store');\n\n  if (!coreStoreExists) {\n    return undefined;\n  }\n\n  const def = await strapi.models['core_store']\n    .forge({ key: `model_def_${definition.uid}` })\n    .fetch();\n\n  return def ? def.toJSON() : undefined;\n};\n\nconst storeDefinition = async (definition, ORM) => {\n  const defToStore = formatDefinitionToStore(definition);\n  const existingDef = await getDefinitionFromStore(definition, ORM);\n\n  const defData = {\n    key: `model_def_${definition.uid}`,\n    type: 'object',\n    value: defToStore,\n  };\n\n  if (existingDef) {\n    return strapi.models['core_store'].forge({ id: existingDef.id }).save(defData);\n  }\n\n  return strapi.models['core_store'].forge(defData).save();\n};\n\nconst getColumnsWhereDefinitionChanged = async (columnsName, definition, ORM) => {\n  const previousDefinitionRow = await getDefinitionFromStore(definition, ORM);\n  const previousDefinition = JSON.parse(_.get(previousDefinitionRow, 'value', null));\n\n  return columnsName.filter(columnName => {\n    const previousAttribute = _.get(previousDefinition, ['attributes', columnName], null);\n    const actualAttribute = _.get(definition, ['attributes', columnName], null);\n\n    return !_.isEqual(previousAttribute, actualAttribute);\n  });\n};\n\nmodule.exports = {\n  storeDefinition,\n  getDefinitionFromStore,\n  getColumnsWhereDefinitionChanged,\n};\n",
    "packages/strapi-connector-mongoose/lib/database-migration.js": "'use strict';\n\nconst _ = require('lodash');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\n\nconst { PUBLISHED_AT_ATTRIBUTE } = contentTypesUtils.constants;\nconst { getDefinitionFromStore } = require('./utils/store-definition');\n\nconst getDraftAndPublishMigrationWay = async (definition, ORM) => {\n  const previousDefRow = await getDefinitionFromStore(definition, ORM);\n  const previousDef = JSON.parse(_.get(previousDefRow, 'value', null));\n  const previousDraftAndPublish = contentTypesUtils.hasDraftAndPublish(previousDef);\n  const actualDraftAndPublish = contentTypesUtils.hasDraftAndPublish(definition);\n\n  if (!previousDefRow || previousDraftAndPublish === actualDraftAndPublish) {\n    return 'none';\n  }\n  if (!previousDraftAndPublish && actualDraftAndPublish) {\n    return 'enable';\n  }\n  if (previousDraftAndPublish && !actualDraftAndPublish) {\n    return 'disable';\n  }\n};\n\nconst migrateDraftAndPublish = async ({ definition, model, ORM }) => {\n  let way = await getDraftAndPublishMigrationWay(definition, ORM);\n\n  if (way === 'enable') {\n    const createdAtCol = _.get(definition, 'timestamps.createdAt', 'createdAt');\n    await model\n      .aggregate([\n        {\n          $addFields: {\n            [PUBLISHED_AT_ATTRIBUTE]: { $ifNull: [`$${createdAtCol}`, new Date()] },\n          },\n        },\n        {\n          $out: definition.collectionName,\n        },\n      ])\n      .exec();\n  } else if (way === 'disable') {\n    await model.deleteMany({ [PUBLISHED_AT_ATTRIBUTE]: null });\n    await model.updateMany({}, { $unset: { [PUBLISHED_AT_ATTRIBUTE]: '' } }, { strict: false });\n  }\n};\n\nmodule.exports = {\n  migrateDraftAndPublish,\n};\n",
    "packages/strapi-connector-mongoose/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst path = require('path');\nconst fs = require('fs');\nconst url = require('url');\nconst _ = require('lodash');\nconst mongoose = require('mongoose');\nrequire('mongoose-long')(mongoose);\n\nconst Mongoose = mongoose.Mongoose;\n\nconst relations = require('./relations');\nconst buildQuery = require('./buildQuery');\nconst getQueryParams = require('./get-query-params');\nconst mountModels = require('./mount-models');\nconst queries = require('./queries');\n\n/**\n * Mongoose hook\n */\n\nconst defaults = {\n  defaultConnection: 'default',\n  host: 'localhost',\n  port: 27017,\n  database: 'strapi',\n  authenticationDatabase: '',\n  ssl: false,\n  debug: false,\n};\n\nconst isMongooseConnection = ({ connector }) => connector === 'mongoose';\n\nconst createConnectionURL = opts => {\n  const { protocol, auth, host, port } = opts;\n\n  return {\n    toString() {\n      return `${protocol}://${auth}${host}${port}/`;\n    },\n  };\n};\n\nmodule.exports = function(strapi) {\n  const { connections } = strapi.config;\n  const mongooseConnections = Object.keys(connections).filter(key =>\n    isMongooseConnection(connections[key])\n  );\n\n  function initialize() {\n    const connectionsPromises = mongooseConnections.map(async connectionName => {\n      const connection = connections[connectionName];\n      const instance = new Mongoose();\n\n      _.defaults(connection.settings, strapi.config.hook.settings.mongoose);\n\n      const {\n        uri,\n        host,\n        port,\n        username,\n        password,\n        database,\n        srv,\n        useUnifiedTopology,\n      } = connection.settings;\n\n      // eslint-disable-next-line node/no-deprecated-api\n      const uriOptions = uri ? url.parse(uri, true).query : {};\n      const { authenticationDatabase, ssl, debug } = _.defaults(\n        connection.options,\n        uriOptions,\n        strapi.config.hook.settings.mongoose\n      );\n      const isSrv = srv === true || srv === 'true';\n\n      // Connect to mongo database\n      const connectOptions = {};\n\n      if (!_.isEmpty(username)) {\n        connectOptions.user = username;\n\n        if (!_.isEmpty(password)) {\n          connectOptions.pass = password;\n        }\n      }\n\n      if (!_.isEmpty(authenticationDatabase)) {\n        connectOptions.authSource = authenticationDatabase;\n      }\n\n      connectOptions.ssl = ssl === true || ssl === 'true';\n      connectOptions.useNewUrlParser = true;\n      connectOptions.dbName = database;\n      connectOptions.useCreateIndex = true;\n      connectOptions.useUnifiedTopology = useUnifiedTopology || true;\n\n      try {\n        const connectionURL = createConnectionURL({\n          protocol: `mongodb${isSrv ? '+srv' : ''}`,\n          port: isSrv ? '' : `:${port}`,\n          host,\n          auth: username ? `${username}:${encodeURIComponent(password)}@` : '',\n        });\n\n        const connectionString = uri || connectionURL.toString();\n\n        await instance.connect(connectionString, connectOptions);\n      } catch (error) {\n        const err = new Error(`Error connecting to the Mongo database. ${error.message}`);\n        delete err.stack;\n        throw err;\n      }\n\n      try {\n        const { version } = await instance.connection.db.admin().serverInfo();\n        instance.mongoDBVersion = version;\n      } catch {\n        instance.mongoDBVersion = null;\n      }\n\n      const initFunctionPath = path.resolve(\n        strapi.config.appPath,\n        'config',\n        'functions',\n        'mongoose.js'\n      );\n\n      if (fs.existsSync(initFunctionPath)) {\n        require(initFunctionPath)(instance, connection);\n      }\n\n      instance.set('debug', debug === true || debug === 'true');\n      instance.set('useFindAndModify', false);\n\n      const ctx = {\n        instance,\n        connection,\n      };\n\n      _.set(strapi, `connections.${connectionName}`, instance);\n\n      return Promise.all([\n        mountComponents(connectionName, ctx),\n        mountApis(connectionName, ctx),\n        mountAdmin(connectionName, ctx),\n        mountPlugins(connectionName, ctx),\n      ]);\n    });\n\n    return Promise.all(connectionsPromises);\n  }\n\n  function mountComponents(connectionName, ctx) {\n    const options = {\n      models: _.pickBy(strapi.components, ({ connection }) => connection === connectionName),\n      target: strapi.components,\n    };\n\n    return mountModels(options, ctx);\n  }\n\n  function mountApis(connectionName, ctx) {\n    const options = {\n      models: _.pickBy(strapi.models, ({ connection }) => connection === connectionName),\n      target: strapi.models,\n    };\n\n    return mountModels(options, ctx);\n  }\n\n  function mountAdmin(connectionName, ctx) {\n    const options = {\n      models: _.pickBy(strapi.admin.models, ({ connection }) => connection === connectionName),\n      target: strapi.admin.models,\n    };\n\n    return mountModels(options, ctx);\n  }\n\n  function mountPlugins(connectionName, ctx) {\n    return Promise.all(\n      Object.keys(strapi.plugins).map(name => {\n        const plugin = strapi.plugins[name];\n        return mountModels(\n          {\n            models: _.pickBy(plugin.models, ({ connection }) => connection === connectionName),\n            target: plugin.models,\n          },\n          ctx\n        );\n      })\n    );\n  }\n\n  async function destroy() {\n    await Promise.all(\n      mongooseConnections.map(connName => {\n        const mongooseConnection = strapi.connections[connName];\n\n        if (\n          mongooseConnection instanceof Mongoose &&\n          mongooseConnection.connection.readyState === 1\n        ) {\n          mongooseConnection.disconnect();\n        }\n      })\n    );\n  }\n\n  return {\n    defaults,\n    initialize,\n    getQueryParams,\n    destroy,\n    buildQuery,\n    queries,\n    ...relations,\n    get defaultTimestamps() {\n      return ['createdAt', 'updatedAt'];\n    },\n  };\n};\n",
    "packages/strapi-connector-mongoose/lib/queries.js": "'use strict';\n/**\n * Implementation of model queries for mongo\n */\n\nconst _ = require('lodash');\nconst { prop, omit } = require('lodash/fp');\nconst { convertRestQueryParams, buildQuery } = require('strapi-utils');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\nconst mongoose = require('mongoose');\n\nconst populateQueries = require('./utils/populate-queries');\n\nconst { PUBLISHED_AT_ATTRIBUTE, DP_PUB_STATES } = contentTypesUtils.constants;\nconst { findComponentByGlobalId } = require('./utils/helpers');\nconst { handleDatabaseError } = require('./utils/errors');\n\nconst hasPK = (obj, model) => _.has(obj, model.primaryKey) || _.has(obj, 'id');\nconst getPK = (obj, model) => (_.has(obj, model.primaryKey) ? obj[model.primaryKey] : obj.id);\nconst pickCountFilters = omit(['sort', 'limit', 'start']);\n\nmodule.exports = ({ model, strapi }) => {\n  const assocKeys = model.associations.map(ast => ast.alias);\n  const componentKeys = Object.keys(model.attributes).filter(key =>\n    ['component', 'dynamiczone'].includes(model.attributes[key].type)\n  );\n  const hasDraftAndPublish = contentTypesUtils.hasDraftAndPublish(model);\n\n  const excludedKeys = assocKeys.concat(componentKeys);\n\n  const defaultPopulate = (options = {}) =>\n    model.associations\n      .filter(ast => ast.autoPopulate !== false)\n      .map(ast => {\n        const assocModel = strapi.db.getModelByAssoc(ast);\n        const populate = {\n          path: ast.alias,\n          options: { publicationState: options.publicationState },\n        };\n\n        if (\n          contentTypesUtils.hasDraftAndPublish(assocModel) &&\n          DP_PUB_STATES.includes(options.publicationState)\n        ) {\n          populate.match = _.merge(\n            populate.match,\n            populateQueries.publicationState[options.publicationState]\n          );\n        }\n\n        return populate;\n      });\n\n  const pickRelations = values => {\n    return _.pick(values, assocKeys);\n  };\n\n  const omitExernalValues = values => {\n    return _.omit(values, excludedKeys);\n  };\n\n  const wrapErrors = fn => async (...args) => {\n    try {\n      return await fn(...args);\n    } catch (error) {\n      return handleDatabaseError(error);\n    }\n  };\n\n  async function createComponents(entry, values, { isDraft, session = null } = {}) {\n    if (componentKeys.length === 0) return;\n\n    for (let key of componentKeys) {\n      const attr = model.attributes[key];\n      const { type } = attr;\n\n      if (type === 'component') {\n        const { component, required = false, repeatable = false } = attr;\n\n        const componentModel = strapi.components[component];\n\n        if (!isDraft && required === true && !_.has(values, key)) {\n          const err = new Error(`Component ${key} is required`);\n          err.status = 400;\n          throw err;\n        }\n\n        if (!_.has(values, key)) continue;\n\n        const componentValue = values[key];\n\n        if (repeatable === true) {\n          const components = await Promise.all(\n            componentValue.map(value => {\n              return strapi.query(component).create(value, { session });\n            })\n          );\n\n          const componentsArr = components.map(componentEntry => ({\n            kind: componentModel.globalId,\n            ref: componentEntry.id,\n          }));\n\n          entry[key] = componentsArr;\n          await entry.save({ session });\n        } else {\n          if (componentValue === null) continue;\n\n          const componentEntry = await strapi.query(component).create(componentValue, { session });\n          entry[key] = [\n            {\n              kind: componentModel.globalId,\n              ref: componentEntry.id,\n            },\n          ];\n          await entry.save({ session });\n        }\n      }\n\n      if (type === 'dynamiczone') {\n        const { required = false } = attr;\n\n        if (!isDraft && required === true && !_.has(values, key)) {\n          const err = new Error(`Dynamiczone ${key} is required`);\n          err.status = 400;\n          throw err;\n        }\n\n        if (!_.has(values, key)) continue;\n\n        const dynamiczoneValues = values[key];\n\n        const dynamiczones = await Promise.all(\n          dynamiczoneValues.map(value => {\n            const component = value.__component;\n            return strapi\n              .query(component)\n              .create(value, { session })\n              .then(entity => {\n                return {\n                  __component: value.__component,\n                  entity,\n                };\n              });\n          })\n        );\n\n        const componentsArr = dynamiczones.map(({ __component, entity }) => {\n          const componentModel = strapi.components[__component];\n\n          return {\n            kind: componentModel.globalId,\n            ref: entity.id,\n          };\n        });\n\n        entry[key] = componentsArr;\n        await entry.save({ session });\n      }\n    }\n  }\n\n  async function updateComponents(entry, values, { session = null } = {}) {\n    if (componentKeys.length === 0) return;\n\n    const updateOrCreateComponent = async ({ componentUID, value }) => {\n      // check if value has an id then update else create\n      const query = strapi.query(componentUID);\n      if (hasPK(value, query.model)) {\n        return query.update(\n          {\n            [query.model.primaryKey]: getPK(value, query.model),\n          },\n          value,\n          { session }\n        );\n      }\n      return query.create(value, { session });\n    };\n\n    for (let key of componentKeys) {\n      // if key isn't present then don't change the current component data\n      if (!_.has(values, key)) continue;\n\n      const attr = model.attributes[key];\n      const { type } = attr;\n\n      if (type === 'component') {\n        const { component: componentUID, repeatable = false } = attr;\n\n        const componentModel = strapi.components[componentUID];\n        const componentValue = values[key];\n\n        if (repeatable === true) {\n          await deleteOldComponents(entry, componentValue, {\n            key,\n            componentModel,\n            session,\n          });\n\n          const components = await Promise.all(\n            componentValue.map(value => updateOrCreateComponent({ componentUID, value }))\n          );\n          const componentsArr = components.map(component => ({\n            kind: componentModel.globalId,\n            ref: component.id,\n          }));\n\n          entry[key] = componentsArr;\n          await entry.save({ session });\n        } else {\n          await deleteOldComponents(entry, componentValue, {\n            key,\n            componentModel,\n            session,\n          });\n\n          if (componentValue === null) continue;\n\n          const component = await updateOrCreateComponent({\n            componentUID,\n            value: componentValue,\n          });\n\n          entry[key] = [\n            {\n              kind: componentModel.globalId,\n              ref: component.id,\n            },\n          ];\n          await entry.save({ session });\n        }\n      }\n\n      if (type === 'dynamiczone') {\n        const dynamiczoneValues = values[key];\n\n        await deleteDynamicZoneOldComponents(entry, dynamiczoneValues, {\n          key,\n          session,\n        });\n\n        const dynamiczones = await Promise.all(\n          dynamiczoneValues.map(value => {\n            const componentUID = value.__component;\n            return updateOrCreateComponent({ componentUID, value }).then(entity => {\n              return {\n                componentUID,\n                entity,\n              };\n            });\n          })\n        );\n\n        const componentsArr = dynamiczones.map(({ componentUID, entity }) => {\n          const componentModel = strapi.components[componentUID];\n\n          return {\n            kind: componentModel.globalId,\n            ref: entity.id,\n          };\n        });\n\n        entry[key] = componentsArr;\n        await entry.save({ session });\n      }\n    }\n    return;\n  }\n\n  async function deleteDynamicZoneOldComponents(entry, values, { key, session = null }) {\n    const idsToKeep = values.reduce((acc, value) => {\n      const component = value.__component;\n      const componentModel = strapi.components[component];\n      if (hasPK(value, componentModel)) {\n        acc.push({\n          id: getPK(value, componentModel).toString(),\n          componentUID: componentModel.uid,\n        });\n      }\n\n      return acc;\n    }, []);\n\n    const allIds = []\n      .concat(entry[key] || [])\n      .filter(el => el.ref)\n      .map(el => ({\n        id: el.ref._id.toString(),\n        componentUID: findComponentByGlobalId(el.kind).uid,\n      }));\n\n    // verify the provided ids are realted to this entity.\n    idsToKeep.forEach(({ id, componentUID }) => {\n      if (!allIds.find(el => el.id === id && el.componentUID === componentUID)) {\n        const err = new Error(\n          `Some of the provided components in ${key} are not related to the entity`\n        );\n        err.status = 400;\n        throw err;\n      }\n    });\n\n    const idsToDelete = allIds.reduce((acc, { id, componentUID }) => {\n      if (!idsToKeep.find(el => el.id === id && el.componentUID === componentUID)) {\n        acc.push({\n          id,\n          componentUID,\n        });\n      }\n      return acc;\n    }, []);\n\n    if (idsToDelete.length > 0) {\n      const deleteMap = idsToDelete.reduce((map, { id, componentUID }) => {\n        if (!_.has(map, componentUID)) {\n          map[componentUID] = [id];\n          return map;\n        }\n\n        map[componentUID].push(id);\n        return map;\n      }, {});\n\n      await Promise.all(\n        Object.keys(deleteMap).map(componentUID => {\n          return strapi\n            .query(componentUID)\n            .delete({ [`${model.primaryKey}_in`]: deleteMap[componentUID] }, { session });\n        })\n      );\n    }\n  }\n\n  async function deleteOldComponents(\n    entry,\n    componentValue,\n    { key, componentModel, session = null }\n  ) {\n    const componentArr = Array.isArray(componentValue) ? componentValue : [componentValue];\n\n    const idsToKeep = componentArr\n      .filter(val => hasPK(val, componentModel))\n      .map(val => getPK(val, componentModel));\n\n    const allIds = []\n      .concat(entry[key] || [])\n      .filter(el => el.ref)\n      .map(el => el.ref._id);\n\n    // verify the provided ids are related to this entity.\n    idsToKeep.forEach(id => {\n      if (allIds.findIndex(currentId => currentId.toString() === id.toString()) === -1) {\n        const err = new Error(\n          `Some of the provided components in ${key} are not related to the entity`\n        );\n        err.status = 400;\n        throw err;\n      }\n    });\n\n    const idsToDelete = allIds.reduce((acc, id) => {\n      if (idsToKeep.includes(id.toString())) return acc;\n      return acc.concat(id);\n    }, []);\n\n    if (idsToDelete.length > 0) {\n      await strapi\n        .query(componentModel.uid)\n        .delete({ [`${model.primaryKey}_in`]: idsToDelete }, { session });\n    }\n  }\n\n  async function deleteComponents(entry, { session = null } = {}) {\n    if (componentKeys.length === 0) return;\n\n    for (let key of componentKeys) {\n      const attr = model.attributes[key];\n      const { type } = attr;\n\n      if (type === 'component') {\n        const { component } = attr;\n        const componentModel = strapi.components[component];\n\n        if (Array.isArray(entry[key]) && entry[key].length > 0) {\n          const idsToDelete = entry[key].map(el => el.ref);\n          await strapi\n            .query(componentModel.uid)\n            .delete({ [`${model.primaryKey}_in`]: idsToDelete }, { session });\n        }\n      }\n\n      if (type === 'dynamiczone') {\n        if (Array.isArray(entry[key]) && entry[key].length > 0) {\n          const idsToDelete = entry[key].map(el => ({\n            componentUID: findComponentByGlobalId(el.kind).uid,\n            id: el.ref,\n          }));\n\n          const deleteMap = idsToDelete.reduce((map, { id, componentUID }) => {\n            if (!_.has(map, componentUID)) {\n              map[componentUID] = [id];\n              return map;\n            }\n\n            map[componentUID].push(id);\n            return map;\n          }, {});\n\n          await Promise.all(\n            Object.keys(deleteMap).map(componentUID => {\n              return strapi.query(componentUID).delete(\n                {\n                  [`${model.primaryKey}_in`]: deleteMap[componentUID],\n                },\n                { session }\n              );\n            })\n          );\n        }\n      }\n    }\n  }\n\n  function find(params, populate, { session = null } = {}) {\n    const filters = convertRestQueryParams(params);\n    const populateOpt = populate || defaultPopulate({ publicationState: filters.publicationState });\n\n    return buildQuery({\n      model,\n      filters,\n      populate: populateOpt,\n      session,\n    }).then(results => results.map(result => (result ? result.toObject() : null)));\n  }\n\n  async function findOne(params, populate, { session = null } = {}) {\n    const entries = await find({ ...params, _limit: 1 }, populate, { session });\n    return entries[0] || null;\n  }\n\n  function count(params, { session = null } = {}) {\n    const filters = pickCountFilters(convertRestQueryParams(params));\n\n    return buildQuery({ model, filters, session }).count();\n  }\n\n  async function create(values, { session = null } = {}) {\n    // Extract values related to relational data.\n    const relations = pickRelations(values);\n    const data = omitExernalValues(values);\n\n    if (hasDraftAndPublish) {\n      data[PUBLISHED_AT_ATTRIBUTE] = _.has(values, PUBLISHED_AT_ATTRIBUTE)\n        ? values[PUBLISHED_AT_ATTRIBUTE]\n        : new Date();\n    }\n\n    /*\n      Create entry with no-relational data.\n      Note that it is mongoose requirement that you **must** pass an array as\n      the first parameter to `create()` if you want to specify options.\n      https://mongoosejs.com/docs/api.html#model_Model.create\n    */\n    const [entry] = await model.create([data], { session });\n    const isDraft = contentTypesUtils.isDraft(entry, model);\n    await createComponents(entry, values, { session, isDraft });\n\n    // Create relational data and return the entry.\n    return model.updateRelations(\n      {\n        [model.primaryKey]: getPK(entry, model),\n        values: relations,\n      },\n      { session }\n    );\n  }\n\n  async function update(params, values, { session = null } = {}) {\n    const entry = await model.findOne(params).session(session);\n\n    if (!entry) {\n      const err = new Error('entry.notFound');\n      err.status = 404;\n      throw err;\n    }\n\n    // Extract values related to relational data.\n    const relations = pickRelations(values);\n    const data = omitExernalValues(values);\n\n    // update components first in case it fails don't update the entity\n    await updateComponents(entry, values, { session });\n    // Update entry with no-relational data.\n    await entry.updateOne(data, { session });\n\n    // Update relational data and return the entry.\n    return model.updateRelations(Object.assign(params, { values: relations }), { session });\n  }\n\n  async function deleteMany(params, { session = null } = {}) {\n    if (params[model.primaryKey]) {\n      const entries = await find({ ...params, _limit: 1 }, null, { session });\n      if (entries.length > 0) {\n        return deleteOne(entries[0][model.primaryKey], { session });\n      }\n      return null;\n    }\n\n    const entries = await find(params, null, { session });\n    return Promise.all(entries.map(entry => deleteOne(entry[model.primaryKey], { session })));\n  }\n\n  async function deleteOne(id, { session = null } = {}) {\n    const entry = await model\n      .findOneAndRemove({ [model.primaryKey]: id }, { session })\n      .populate(defaultPopulate());\n\n    if (!entry) {\n      const err = new Error('entry.notFound');\n      err.status = 404;\n      throw err;\n    }\n\n    await deleteComponents(entry, { session });\n\n    await model.deleteRelations(entry, { session });\n\n    return entry.toObject ? entry.toObject() : null;\n  }\n\n  function search(params, populate, { session = null } = {}) {\n    const filters = convertRestQueryParams(_.omit(params, '_q'));\n    const populateOpt = populate || defaultPopulate({ publicationState: filters.publicationState });\n\n    return buildQuery({\n      model,\n      filters,\n      searchParam: params._q,\n      populate: populateOpt,\n      session,\n    }).then(results => results.map(result => (result ? result.toObject() : null)));\n  }\n\n  function countSearch(params, { session = null } = {}) {\n    const countParams = omit(['_q'], params);\n    const filters = pickCountFilters(convertRestQueryParams(countParams));\n\n    return buildQuery({\n      model,\n      filters,\n      searchParam: params._q,\n      session,\n    }).count();\n  }\n\n  async function fetchRelationCounters(attribute, entitiesIds = []) {\n    const assoc = model.associations.find(assoc => assoc.alias === attribute);\n\n    switch (prop('nature', assoc)) {\n      case 'oneToMany': {\n        const assocModel = strapi.db.getModelByAssoc(assoc);\n        return assocModel\n          .aggregate()\n          .match({ [assoc.via]: { $in: entitiesIds.map(mongoose.Types.ObjectId) } })\n          .group({\n            _id: `$${assoc.via}`,\n            count: { $sum: 1 },\n          })\n          .project({ _id: 0, id: '$_id', count: 1 });\n      }\n      case 'manyWay': {\n        return model\n          .aggregate()\n          .match({ [model.primaryKey]: { $in: entitiesIds.map(mongoose.Types.ObjectId) } })\n          .project({ _id: 0, id: '$_id', count: { $size: { $ifNull: [`$${assoc.alias}`, []] } } });\n      }\n      case 'manyToMany': {\n        if (assoc.dominant) {\n          return model\n            .aggregate()\n            .match({ [model.primaryKey]: { $in: entitiesIds.map(mongoose.Types.ObjectId) } })\n            .project({\n              _id: 0,\n              id: '$_id',\n              count: { $size: { $ifNull: [`$${assoc.alias}`, []] } },\n            });\n        }\n        const assocModel = strapi.db.getModelByAssoc(assoc);\n        return assocModel\n          .aggregate()\n          .match({ [assoc.via]: { $in: entitiesIds.map(mongoose.Types.ObjectId) } })\n          .unwind(assoc.via)\n          .group({ _id: `$${assoc.via}`, count: { $sum: 1 } })\n          .project({ _id: 0, id: '$_id', count: 1 });\n      }\n      default: {\n        return [];\n      }\n    }\n  }\n\n  return {\n    findOne,\n    find,\n    create: wrapErrors(create),\n    update: wrapErrors(update),\n    delete: deleteMany,\n    count,\n    search,\n    countSearch,\n    fetchRelationCounters,\n  };\n};\n",
    "packages/strapi-connector-mongoose/lib/relations.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst _ = require('lodash');\nconst mongoose = require('mongoose');\n\n// Utils\nconst {\n  models: { getValuePrimaryKey },\n} = require('strapi-utils');\n\nconst transformToArrayID = (array, pk) => {\n  if (_.isArray(array)) {\n    return array\n      .map(value => value && (getValuePrimaryKey(value, pk) || value))\n      .filter(n => n)\n      .map(val => _.toString(val));\n  }\n\n  return transformToArrayID([array]);\n};\n\nconst removeUndefinedKeys = (obj = {}) => _.pickBy(obj, _.negate(_.isUndefined));\n\nconst addRelationMorph = async (model, params, { session = null } = {}) => {\n  const { id, alias, refId, ref, field, filter } = params;\n\n  await model.updateMany(\n    {\n      [model.primaryKey]: id,\n    },\n    {\n      $push: {\n        [alias]: {\n          ref: new mongoose.Types.ObjectId(refId),\n          kind: ref,\n          [filter]: field,\n        },\n      },\n    },\n    { session }\n  );\n};\n\nconst removeRelationMorph = async (model, params, { session = null } = {}) => {\n  const { alias } = params;\n\n  let opts;\n  // if entry id is provided simply query it\n  if (params.id) {\n    opts = {\n      _id: params.id,\n    };\n  } else {\n    opts = {\n      [alias]: {\n        $elemMatch: {\n          ref: params.refId,\n          kind: params.ref,\n          [params.filter]: params.field,\n        },\n      },\n    };\n  }\n\n  await model.updateMany(\n    opts,\n    {\n      $pull: {\n        [alias]: {\n          ref: params.refId,\n          kind: params.ref,\n          [params.filter]: params.field,\n        },\n      },\n    },\n    { session }\n  );\n};\n\nmodule.exports = {\n  async update(params, { session = null } = {}) {\n    const relationUpdates = [];\n    const populate = this.associations.map(x => x.alias);\n    const primaryKeyValue = getValuePrimaryKey(params, this.primaryKey);\n\n    const entry = await this.findOne({ [this.primaryKey]: primaryKeyValue })\n      .session(session)\n      .populate(populate)\n      .lean();\n\n    // Only update fields which are on this document.\n    const values = Object.keys(removeUndefinedKeys(params.values)).reduce((acc, attribute) => {\n      const currentValue = entry[attribute];\n      const newValue = params.values[attribute];\n\n      const association = this.associations.find(x => x.alias === attribute);\n\n      const details = this._attributes[attribute];\n\n      // set simple attributes\n      if (!association && _.get(details, 'isVirtual') !== true) {\n        return _.set(acc, attribute, newValue);\n      }\n\n      const assocModel = strapi.db.getModel(details.model || details.collection, details.plugin);\n\n      switch (association.nature) {\n        case 'oneWay': {\n          return _.set(acc, attribute, _.get(newValue, assocModel.primaryKey, newValue));\n        }\n        case 'oneToOne': {\n          // if value is the same don't do anything\n          if (currentValue === newValue) return acc;\n\n          // if the value is null, set field to null on both sides\n          if (_.isNull(newValue)) {\n            const updatePromise = assocModel.updateOne(\n              {\n                [assocModel.primaryKey]: getValuePrimaryKey(currentValue, assocModel.primaryKey),\n              },\n              { [details.via]: null },\n              { session }\n            );\n\n            relationUpdates.push(updatePromise);\n            return _.set(acc, attribute, null);\n          }\n\n          // set old relations to null\n          const updateLink = this.updateOne(\n            { [attribute]: new mongoose.Types.ObjectId(newValue) },\n            { [attribute]: null },\n            { session }\n          ).then(() => {\n            return assocModel.updateOne(\n              {\n                [this.primaryKey]: new mongoose.Types.ObjectId(newValue),\n              },\n              { [details.via]: primaryKeyValue },\n              { session }\n            );\n          });\n\n          // set new relation\n          relationUpdates.push(updateLink);\n          return _.set(acc, attribute, newValue);\n        }\n        case 'oneToMany': {\n          // set relation to null for all the ids not in the list\n          const attributeIds = currentValue;\n          const toRemove = _.differenceWith(attributeIds, newValue, (a, b) => {\n            return `${a[assocModel.primaryKey] || a}` === `${b[assocModel.primaryKey] || b}`;\n          });\n\n          const updatePromise = assocModel\n            .updateMany(\n              {\n                [assocModel.primaryKey]: {\n                  $in: toRemove.map(\n                    val => new mongoose.Types.ObjectId(val[assocModel.primaryKey] || val)\n                  ),\n                },\n              },\n              { [details.via]: null },\n              { session }\n            )\n            .then(() => {\n              return assocModel.updateMany(\n                {\n                  [assocModel.primaryKey]: {\n                    $in: newValue.map(\n                      val => new mongoose.Types.ObjectId(val[assocModel.primaryKey] || val)\n                    ),\n                  },\n                },\n                { [details.via]: primaryKeyValue },\n                { session }\n              );\n            });\n\n          relationUpdates.push(updatePromise);\n          return acc;\n        }\n        case 'manyToOne': {\n          return _.set(acc, attribute, _.get(newValue, assocModel.primaryKey, newValue));\n        }\n        case 'manyWay':\n        case 'manyToMany': {\n          if (association.dominant) {\n            return _.set(\n              acc,\n              attribute,\n              newValue ? newValue.map(val => val[assocModel.primaryKey] || val) : newValue\n            );\n          }\n\n          const updatePomise = assocModel\n            .updateMany(\n              {\n                [assocModel.primaryKey]: {\n                  $in: currentValue.map(\n                    val => new mongoose.Types.ObjectId(val[assocModel.primaryKey] || val)\n                  ),\n                },\n              },\n              {\n                $pull: {\n                  [association.via]: new mongoose.Types.ObjectId(primaryKeyValue),\n                },\n              },\n              { session }\n            )\n            .then(() => {\n              return assocModel.updateMany(\n                {\n                  [assocModel.primaryKey]: {\n                    $in: newValue\n                      ? newValue.map(\n                          val => new mongoose.Types.ObjectId(val[assocModel.primaryKey] || val)\n                        )\n                      : newValue,\n                  },\n                },\n                {\n                  $addToSet: { [association.via]: [primaryKeyValue] },\n                },\n                { session }\n              );\n            });\n\n          relationUpdates.push(updatePomise);\n          return acc;\n        }\n        // media -> model\n        case 'manyMorphToMany':\n        case 'manyMorphToOne': {\n          newValue.forEach(obj => {\n            const refModel = strapi.db.getModel(obj.ref, obj.source);\n\n            const createRelation = () => {\n              return addRelationMorph(\n                this,\n                {\n                  id: entry[this.primaryKey],\n                  alias: association.alias,\n                  ref: obj.kind || refModel.globalId,\n                  refId: new mongoose.Types.ObjectId(obj.refId),\n                  field: obj.field,\n                  filter: association.filter,\n                },\n                { session }\n              );\n            };\n\n            // Clear relations to refModel\n            const reverseAssoc = refModel.associations.find(assoc => assoc.alias === obj.field);\n            if (reverseAssoc && reverseAssoc.nature === 'oneToManyMorph') {\n              relationUpdates.push(\n                removeRelationMorph(\n                  this,\n                  {\n                    alias: association.alias,\n                    ref: obj.kind || refModel.globalId,\n                    refId: new mongoose.Types.ObjectId(obj.refId),\n                    field: obj.field,\n                    filter: association.filter,\n                  },\n                  { session }\n                )\n                  .then(createRelation)\n                  .then(() => {\n                    // set field inside refModel\n                    return refModel.updateMany(\n                      {\n                        [refModel.primaryKey]: new mongoose.Types.ObjectId(obj.refId),\n                      },\n                      {\n                        [obj.field]: new mongoose.Types.ObjectId(entry[this.primaryKey]),\n                      },\n                      { session }\n                    );\n                  })\n              );\n            } else {\n              relationUpdates.push(\n                createRelation().then(() => {\n                  // push to field inside refModel\n                  return refModel.updateMany(\n                    {\n                      [refModel.primaryKey]: new mongoose.Types.ObjectId(obj.refId),\n                    },\n                    {\n                      $push: { [obj.field]: new mongoose.Types.ObjectId(entry[this.primaryKey]) },\n                    },\n                    { session }\n                  );\n                })\n              );\n            }\n          });\n          break;\n        }\n        // model -> media\n        case 'oneToManyMorph':\n        case 'manyToManyMorph': {\n          // Compare array of ID to find deleted files.\n          const currentIds = transformToArrayID(currentValue, this.primaryKey);\n          const newIds = transformToArrayID(newValue, this.primaryKey);\n\n          const toAdd = _.difference(newIds, currentIds);\n          const toRemove = _.difference(currentIds, newIds);\n\n          const model = strapi.db.getModel(details.model || details.collection, details.plugin);\n\n          if (!Array.isArray(newValue)) {\n            _.set(acc, attribute, newIds[0]);\n          } else {\n            _.set(acc, attribute, newIds);\n          }\n\n          const addPromise = Promise.all(\n            toAdd.map(id => {\n              return addRelationMorph(\n                model,\n                {\n                  id,\n                  alias: association.via,\n                  ref: this.globalId,\n                  refId: entry._id,\n                  field: association.alias,\n                  filter: association.filter,\n                },\n                { session }\n              );\n            })\n          );\n\n          relationUpdates.push(addPromise);\n\n          toRemove.forEach(id => {\n            relationUpdates.push(\n              removeRelationMorph(\n                model,\n                {\n                  id,\n                  alias: association.via,\n                  ref: this.globalId,\n                  refId: entry._id,\n                  field: association.alias,\n                  filter: association.filter,\n                },\n                { session }\n              )\n            );\n          });\n          break;\n        }\n        case 'oneMorphToOne':\n        case 'oneMorphToMany':\n          break;\n        default:\n      }\n\n      return acc;\n    }, {});\n\n    // Update virtuals fields.\n    await Promise.all(relationUpdates).then(() =>\n      this.updateOne({ [this.primaryKey]: primaryKeyValue }, values, {\n        strict: false,\n        session,\n      })\n    );\n\n    const updatedEntity = await this.findOne({\n      [this.primaryKey]: primaryKeyValue,\n    })\n      .session(session)\n      .populate(populate);\n\n    return updatedEntity && updatedEntity.toObject ? updatedEntity.toObject() : updatedEntity;\n  },\n\n  deleteRelations(entry, { session = null } = {}) {\n    const primaryKeyValue = entry[this.primaryKey];\n\n    return Promise.all(\n      this.associations.map(async association => {\n        const { nature, via, dominant } = association;\n\n        // TODO: delete all the ref to the model\n\n        switch (nature) {\n          case 'oneWay':\n          case 'manyWay': {\n            return;\n          }\n          case 'oneToMany':\n          case 'oneToOne': {\n            if (!via) {\n              return;\n            }\n\n            const targetModel = strapi.db.getModel(\n              association.model || association.collection,\n              association.plugin\n            );\n\n            return targetModel.updateMany({ [via]: primaryKeyValue }, { [via]: null }, { session });\n          }\n          case 'manyToMany':\n          case 'manyToOne': {\n            if (!via || dominant) {\n              return;\n            }\n\n            const targetModel = strapi.db.getModel(\n              association.model || association.collection,\n              association.plugin\n            );\n\n            return targetModel.updateMany(\n              { [via]: primaryKeyValue },\n              { $pull: { [via]: primaryKeyValue } },\n              { session }\n            );\n          }\n          case 'oneToManyMorph':\n          case 'manyToManyMorph': {\n            // delete relation inside of the ref model\n\n            const targetModel = strapi.db.getModel(\n              association.model || association.collection,\n              association.plugin\n            );\n\n            // ignore them ghost relations\n            if (!targetModel) return;\n\n            const element = {\n              ref: primaryKeyValue,\n              kind: this.globalId,\n              [association.filter]: association.alias,\n            };\n\n            return targetModel.updateMany(\n              { [via]: { $elemMatch: element } },\n              { $pull: { [via]: element } },\n              { session }\n            );\n          }\n          case 'manyMorphToMany':\n          case 'manyMorphToOne': {\n            // delete relation inside of the ref model\n            // console.log(entry[association.alias]);\n\n            if (Array.isArray(entry[association.alias])) {\n              return Promise.all(\n                entry[association.alias].map(val => {\n                  const targetModel = strapi.db.getModelByGlobalId(val.kind);\n\n                  // ignore them ghost relations\n                  if (!targetModel) return;\n\n                  const field = val[association.filter];\n                  const reverseAssoc = targetModel.associations.find(\n                    assoc => assoc.alias === field\n                  );\n\n                  if (reverseAssoc && reverseAssoc.nature === 'oneToManyMorph') {\n                    return targetModel.updateMany(\n                      {\n                        [targetModel.primaryKey]: val.ref && (val.ref._id || val.ref),\n                      },\n                      {\n                        [field]: null,\n                      },\n                      { session }\n                    );\n                  }\n\n                  return targetModel.updateMany(\n                    {\n                      [targetModel.primaryKey]: val.ref && (val.ref._id || val.ref),\n                    },\n                    {\n                      $pull: { [field]: primaryKeyValue },\n                    },\n                    { session }\n                  );\n                })\n              );\n            }\n\n            return;\n          }\n          case 'oneMorphToOne':\n          case 'oneMorphToMany': {\n            return;\n          }\n        }\n      })\n    );\n  },\n};\n",
    "packages/strapi-connector-mongoose/lib/utils/store-definition.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst formatDefinitionToStore = definition =>\n  JSON.stringify(\n    _.pick(definition, ['uid', 'collectionName', 'kind', 'info', 'options', 'attributes'])\n  );\n\n// Using MongoDB instead of Mongoose since this function\n// may be called before the model 'core_store' is instanciated\nconst getDefinitionFromStore = async (definition, ORM) =>\n  ORM.connection.db.collection('core_store').findOne({ key: `model_def_${definition.uid}` });\n\n// Using MongoDB instead of Mongoose since this function\n// may be called before the model 'core_store' is instanciated\nconst storeDefinition = async (definition, ORM) => {\n  const defToStore = formatDefinitionToStore(definition);\n\n  await ORM.connection.db.collection('core_store').updateOne(\n    {\n      key: `model_def_${definition.uid}`,\n    },\n    {\n      $set: {\n        key: `model_def_${definition.uid}`,\n        type: 'object',\n        value: defToStore,\n        environment: '',\n        tag: '',\n      },\n    },\n    {\n      upsert: true,\n    }\n  );\n};\n\nconst didDefinitionChange = async (definition, ORM) => {\n  const previousDefRow = await getDefinitionFromStore(definition, ORM);\n  const previousDefJSON = _.get(previousDefRow, 'value', null);\n  const actualDefJSON = formatDefinitionToStore(definition);\n\n  return previousDefJSON !== actualDefJSON;\n};\n\nmodule.exports = {\n  didDefinitionChange,\n  storeDefinition,\n  getDefinitionFromStore,\n};\n",
    "packages/strapi-database/lib/connector-registry.js": "'use strict';\n/**\n * Database connector registry\n */\n\nconst _ = require('lodash');\nconst requireConnector = require('./require-connector');\n\nconst createConnectorRegistry = ({ defaultConnection, connections }) => {\n  const _connectors = new Map();\n\n  return {\n    /**\n     * Load connector modules\n     */\n    load() {\n      for (const connection of Object.values(connections)) {\n        const { connector } = connection;\n        if (!_connectors.has(connector)) {\n          _connectors.set(connector, requireConnector(connector)(strapi));\n        }\n      }\n    },\n\n    /**\n     * Initialize connectors\n     */\n    async initialize() {\n      for (const connector of _connectors.values()) {\n        await connector.initialize();\n      }\n    },\n\n    getAll() {\n      return Array.from(_connectors.values());\n    },\n\n    get(key) {\n      return _connectors.get(key);\n    },\n\n    set(key, val) {\n      _connectors.set(key, val);\n      return this;\n    },\n\n    get default() {\n      const defaultConnector = connections[defaultConnection].connector;\n      return _connectors.get(defaultConnector);\n    },\n\n    getByConnection(connection) {\n      if (!_.has(connections, connection)) {\n        throw new Error('Trying to access a connector for an unknown connection');\n      }\n\n      const connectorKey = connections[connection].connector;\n      return _connectors.get(connectorKey);\n    },\n  };\n};\n\nmodule.exports = createConnectorRegistry;\n",
    "packages/strapi-database/lib/database-manager.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createQuery } = require('./queries');\nconst createConnectorRegistry = require('./connector-registry');\nconst constants = require('./constants');\nconst { validateModelSchemas } = require('./validation');\n\nclass DatabaseManager {\n  constructor(strapi) {\n    this.strapi = strapi;\n\n    this.initialized = false;\n\n    this.connectors = createConnectorRegistry({\n      connections: strapi.config.get('database.connections'),\n      defaultConnection: strapi.config.get('database.defaultConnection'),\n    });\n\n    this.queries = new Map();\n    this.models = new Map();\n  }\n\n  async initialize() {\n    if (this.initialized === true) {\n      throw new Error('Database manager already initialized');\n    }\n\n    this.initialized = true;\n\n    this.connectors.load();\n\n    validateModelSchemas({ strapi: this.strapi, manager: this });\n\n    await this.connectors.initialize();\n\n    this.initializeModelsMap();\n\n    return this;\n  }\n\n  async destroy() {\n    await Promise.all(this.connectors.getAll().map(connector => connector.destroy()));\n  }\n\n  initializeModelsMap() {\n    Object.keys(this.strapi.models).forEach(modelKey => {\n      const model = this.strapi.models[modelKey];\n      this.models.set(model.uid, model);\n    });\n\n    Object.keys(this.strapi.admin.models).forEach(modelKey => {\n      const model = this.strapi.admin.models[modelKey];\n      this.models.set(model.uid, model);\n    });\n\n    Object.keys(this.strapi.plugins).forEach(pluginKey => {\n      Object.keys(this.strapi.plugins[pluginKey].models).forEach(modelKey => {\n        const model = this.strapi.plugins[pluginKey].models[modelKey];\n        this.models.set(model.uid, model);\n      });\n    });\n  }\n\n  query(entity, plugin) {\n    if (!entity) {\n      throw new Error(`argument entity is required`);\n    }\n\n    const normalizedName = entity.toLowerCase();\n\n    // get by uid or name / plugin\n    const model = this.models.has(entity)\n      ? this.models.get(entity)\n      : this.getModel(normalizedName, plugin);\n\n    if (!model) {\n      throw new Error(`The model ${entity} can't be found.`);\n    }\n\n    if (this.queries.has(model.uid)) {\n      return this.queries.get(model.uid);\n    }\n\n    const connectorQuery = this.connectors\n      .get(model.orm)\n      .queries({ model, modelKey: model.modelName, strapi });\n\n    const query = createQuery({\n      connectorQuery,\n      model,\n    });\n\n    this.queries.set(model.uid, query);\n    return query;\n  }\n\n  getModel(name, plugin) {\n    const key = _.toLower(name);\n\n    if (this.models.has(key)) return this.models.get(key);\n\n    if (plugin === 'admin') {\n      return _.get(strapi.admin, ['models', key]);\n    }\n\n    if (plugin) {\n      return _.get(strapi.plugins, [plugin, 'models', key]);\n    }\n\n    return _.get(strapi, ['models', key]) || _.get(strapi, ['components', key]);\n  }\n\n  getModelByAssoc(assoc) {\n    return this.getModel(assoc.collection || assoc.model, assoc.plugin);\n  }\n\n  getModelByCollectionName(collectionName) {\n    return Array.from(this.models.values()).find(model => {\n      return model.collectionName === collectionName;\n    });\n  }\n\n  getModelByGlobalId(globalId) {\n    return Array.from(this.models.values()).find(model => {\n      return model.globalId === globalId;\n    });\n  }\n\n  getModelsByAttribute(attr) {\n    if (attr.type === 'component') {\n      return [this.getModel(attr.component)];\n    }\n    if (attr.type === 'dynamiczone') {\n      return attr.components.map(compoName => this.getModel(compoName));\n    }\n    if (attr.model || attr.collection) {\n      return [this.getModelByAssoc(attr)];\n    }\n\n    return [];\n  }\n\n  getModelsByPluginName(pluginName) {\n    if (!pluginName) {\n      return strapi.models;\n    }\n\n    return pluginName === 'admin' ? strapi.admin.models : strapi.plugins[pluginName].models;\n  }\n\n  getReservedNames() {\n    return {\n      models: constants.RESERVED_MODEL_NAMES,\n      attributes: [\n        ...constants.RESERVED_ATTRIBUTE_NAMES,\n        ...(strapi.db.connectors.default.defaultTimestamps || []),\n      ],\n    };\n  }\n}\n\nfunction createDatabaseManager(strapi) {\n  return new DatabaseManager(strapi);\n}\n\nmodule.exports = {\n  createDatabaseManager,\n};\n",
    "packages/strapi-database/lib/queries/__tests__/paginated-queries.test.js": "'use strict';\n\nconst {\n  createFindPageQuery,\n  createSearchPageQuery,\n  createPaginatedQuery,\n  getPaginationInfos,\n} = require('../paginated-queries');\n\ndescribe('Paginated Queries', () => {\n  describe('createPaginatedQuery', () => {\n    test('Successfully create a paginated query based on given fetch and count', async () => {\n      const fetch = jest.fn(() => [1, 2]);\n      const count = jest.fn(() => 2);\n\n      const paginatedQuery = createPaginatedQuery({ fetch, count });\n\n      const data = await paginatedQuery({});\n\n      expect(fetch).toHaveBeenCalled();\n      expect(count).toHaveBeenCalled();\n      expect(data).toMatchObject({\n        results: [1, 2],\n        pagination: {\n          page: 1,\n          pageSize: 100,\n          total: 2,\n          pageCount: 1,\n        },\n      });\n    });\n\n    test('Use custom pagination options to find a specific page', async () => {\n      const fetch = jest.fn(() => [5, 6]);\n      const count = jest.fn(() => 6);\n\n      const paginatedQuery = createPaginatedQuery({ fetch, count });\n\n      const data = await paginatedQuery({ page: 2, pageSize: 4 });\n\n      expect(fetch).toHaveBeenCalled();\n      expect(count).toHaveBeenCalled();\n      expect(data).toMatchObject({\n        results: [5, 6],\n        pagination: {\n          page: 2,\n          pageSize: 4,\n          total: 6,\n          pageCount: 2,\n        },\n      });\n    });\n  });\n\n  describe('createFindPageQuery', () => {\n    test('Successfully create a findPage query based on given find and count', async () => {\n      const find = jest.fn(() => [1, 2]);\n      const count = jest.fn(() => 2);\n\n      const paginatedQuery = createFindPageQuery({ find, count });\n\n      const data = await paginatedQuery({});\n\n      expect(find).toHaveBeenCalled();\n      expect(count).toHaveBeenCalled();\n      expect(data).toMatchObject({\n        results: [1, 2],\n        pagination: {\n          page: 1,\n          pageSize: 100,\n          total: 2,\n          pageCount: 1,\n        },\n      });\n    });\n  });\n\n  describe('createSearchPageQuery', () => {\n    test('Successfully create a searchPage query based on given search and countSearch', async () => {\n      const search = jest.fn(() => [1, 2]);\n      const countSearch = jest.fn(() => 2);\n\n      const paginatedQuery = createSearchPageQuery({ search, countSearch });\n\n      const data = await paginatedQuery({});\n\n      expect(search).toHaveBeenCalled();\n      expect(countSearch).toHaveBeenCalled();\n      expect(data).toMatchObject({\n        results: [1, 2],\n        pagination: {\n          page: 1,\n          pageSize: 100,\n          total: 2,\n          pageCount: 1,\n        },\n      });\n    });\n  });\n\n  describe('getPaginationInfos', () => {\n    test('Incomplete last page', async () => {\n      const queryParams = { page: 2, pageSize: 6 };\n      const count = jest.fn(() => 8);\n\n      const pagination = await getPaginationInfos(queryParams, count);\n\n      expect(count).toHaveBeenCalled();\n      expect(pagination).toEqual({\n        page: 2,\n        pageSize: 6,\n        total: 8,\n        pageCount: 2,\n      });\n    });\n\n    test('Complete last page', async () => {\n      const queryParams = { page: 2, pageSize: 6 };\n      const count = jest.fn(() => 18);\n\n      const pagination = await getPaginationInfos(queryParams, count);\n\n      expect(count).toHaveBeenCalled();\n      expect(pagination).toEqual({\n        page: 2,\n        pageSize: 6,\n        total: 18,\n        pageCount: 3,\n      });\n    });\n  });\n});\n",
    "packages/strapi-database/lib/queries/helpers.js": "'use strict';\n\nconst { replaceIdByPrimaryKey } = require('../utils/primary-key');\nconst { executeBeforeLifecycle, executeAfterLifecycle } = require('../utils/lifecycles');\n\nconst withLifecycles = ({ query, model, fn }) => async (params, ...rest) => {\n  // substitute id for primaryKey value in params\n  const newParams = replaceIdByPrimaryKey(params, model);\n  const queryArguments = [newParams, ...rest];\n\n  // execute before hook\n  await executeBeforeLifecycle(query, model, ...queryArguments);\n\n  // execute query\n  const result = await fn(...queryArguments);\n\n  // execute after hook with result and arguments\n  await executeAfterLifecycle(query, model, result, ...queryArguments);\n\n  // return result\n  return result;\n};\n\n// wraps a connectorQuery call with:\n// - param substitution\n// - lifecycle hooks\nconst createQueryWithLifecycles = ({ query, model, connectorQuery }) => {\n  return withLifecycles({\n    query,\n    model,\n    fn: (...queryParameters) => connectorQuery[query](...queryParameters),\n  });\n};\n\nmodule.exports = { withLifecycles, createQueryWithLifecycles };\n",
    "packages/strapi-database/lib/queries/paginated-queries.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst createPaginatedQuery = ({ fetch, count }) => async (queryParams, ...args) => {\n  const params = _.omit(queryParams, ['page', 'pageSize']);\n  const pagination = await getPaginationInfos(queryParams, count);\n\n  Object.assign(params, paginationToQueryParams(pagination));\n\n  const results = await fetch(params, ...args);\n\n  return { results, pagination };\n};\n\nconst createSearchPageQuery = ({ search, countSearch }) =>\n  createPaginatedQuery({ fetch: search, count: countSearch });\n\nconst createFindPageQuery = ({ find, count }) => createPaginatedQuery({ fetch: find, count });\n\nconst getPaginationInfos = async (queryParams, count) => {\n  const { page, pageSize, ...params } = withDefaultPagination(queryParams);\n\n  const total = await count(params);\n\n  return {\n    page,\n    pageSize,\n    pageCount: Math.ceil(total / pageSize),\n    total,\n  };\n};\n\nconst withDefaultPagination = params => {\n  const { page = 1, pageSize = 100, ...rest } = params;\n\n  return {\n    page: parseInt(page),\n    pageSize: parseInt(pageSize),\n    ...rest,\n  };\n};\n\nconst paginationToQueryParams = ({ page, pageSize }) => ({\n  _start: Math.max(page - 1, 0) * pageSize,\n  _limit: pageSize,\n});\n\nmodule.exports = {\n  getPaginationInfos,\n  withDefaultPagination,\n  createPaginatedQuery,\n  createFindPageQuery,\n  createSearchPageQuery,\n};\n",
    "packages/strapi-database/lib/queries/relations-counts-queries.js": "'use strict';\n\nconst { prop, assoc } = require('lodash/fp');\nconst { MANY_RELATIONS } = require('strapi-utils').relations.constants;\n\nconst createRelationsCountsQuery = ({ model, fn, connectorQuery }) => {\n  // fetch counter map\n  const fetchCounters = async (...args) => {\n    const results = await connectorQuery.fetchRelationCounters(...args);\n    return results.reduce((map, { id, count }) => assoc(id, Number(count), map), {});\n  };\n\n  return async function(params, populate) {\n    const xManyAssocs = [];\n    const xToOnePopulate = [];\n\n    model.associations\n      .filter(assoc => !populate || populate.includes(assoc.alias))\n      .forEach(assoc => {\n        if (MANY_RELATIONS.includes(assoc.nature)) {\n          xManyAssocs.push(assoc);\n        } else {\n          xToOnePopulate.push(assoc.alias);\n        }\n      });\n\n    const { results, pagination } = await fn(params, xToOnePopulate);\n    const resultsIds = results.map(prop('id'));\n\n    const counters = await Promise.all(\n      xManyAssocs.map(async ({ alias }) => ({\n        field: alias,\n        counts: await fetchCounters(alias, resultsIds),\n      }))\n    );\n\n    results.forEach(entity => {\n      counters.forEach(({ field, counts }) => {\n        entity[field] = { count: counts[entity.id] || 0 };\n      });\n    });\n\n    return {\n      results,\n      pagination,\n    };\n  };\n};\n\nmodule.exports = {\n  createRelationsCountsQuery,\n};\n",
    "packages/strapi-database/tests/migration-draft-publish.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst modelsUtils = require('../../../test/helpers/models');\n\nlet builder;\nlet strapi;\nlet rq;\nlet data = {\n  dogs: [],\n};\nconst dogModel = {\n  draftAndPublish: false,\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    code: {\n      type: 'string',\n      unique: true,\n    },\n  },\n  connection: 'default',\n  name: 'dog',\n  description: '',\n  collectionName: '',\n};\n\nconst dogs = [\n  {\n    name: 'Nelson',\n    code: '1',\n  },\n  {\n    name: 'Atos',\n    code: '2',\n  },\n];\n\nconst restart = async () => {\n  await strapi.destroy();\n  strapi = await createStrapiInstance();\n  rq = await createAuthRequest({ strapi });\n};\n\nconst sortDogs = dogs => _.sortBy(dogs, 'name');\n\ndescribe('Migration - draft and publish', () => {\n  describe.each([\n    ['without table modifications', {}, {}],\n    ['with table modifications', { town: { type: 'string' } }, { color: { type: 'string' } }],\n  ])('%p', (testName, tableModification1, tableModification2) => {\n    beforeAll(async () => {\n      builder = createTestBuilder();\n\n      await builder\n        .addContentType(dogModel)\n        .addFixtures(dogModel.name, dogs)\n        .build();\n\n      strapi = await createStrapiInstance();\n      rq = await createAuthRequest({ strapi });\n\n      data.dogs = sortDogs(builder.sanitizedFixturesFor(dogModel.name, strapi));\n    }, 60000);\n\n    afterAll(async () => {\n      await strapi.destroy();\n      await builder.cleanup();\n    }, 60000);\n\n    describe('Enabling D&P on a content-type', () => {\n      test('No published_at before enabling the feature', async () => {\n        let { body } = await rq({\n          url: '/content-manager/collection-types/application::dog.dog',\n          method: 'GET',\n        });\n\n        expect(body.results.length).toBe(2);\n\n        const sortedBody = sortDogs(body.results);\n\n        sortedBody.forEach((dog, index) => {\n          expect(dog).toMatchObject(data.dogs[index]);\n          expect(dog.published_at).toBeUndefined();\n        });\n      });\n\n      test('Published_at is equal to created_at after enabling the feature', async () => {\n        const schema = await modelsUtils.getContentTypeSchema(dogModel.name, { strapi });\n\n        await modelsUtils.modifyContentType(\n          {\n            ...schema,\n            attributes: _.merge(schema.attributes, tableModification1),\n            draftAndPublish: true,\n          },\n          { strapi }\n        );\n\n        await restart();\n\n        let { body } = await rq({\n          method: 'GET',\n          url: '/content-manager/collection-types/application::dog.dog',\n        });\n\n        expect(body.results.length).toBe(2);\n\n        const sortedBody = sortDogs(body.results);\n\n        sortedBody.forEach((dog, index) => {\n          expect(dog).toMatchObject(data.dogs[index]);\n          expect(dog.published_at).toBe(dog.createdAt || dog.created_at);\n          expect(!isNaN(new Date(dog.published_at).valueOf())).toBe(true);\n        });\n\n        data.dogs = sortedBody;\n      }, 60000);\n    });\n\n    describe('Disabling D&P on a content-type', () => {\n      test('No published_at after disabling the feature + draft removed', async () => {\n        const res = await rq({\n          method: 'POST',\n          url: `/content-manager/collection-types/application::dog.dog/${data.dogs[1].id}/actions/unpublish`,\n        });\n\n        data.dogs[1] = res.body;\n\n        const schema = await modelsUtils.getContentTypeSchema(dogModel.name, { strapi });\n\n        await modelsUtils.modifyContentType(\n          {\n            ...schema,\n            draftAndPublish: false,\n            attributes: _.merge(schema.attributes, tableModification2),\n          },\n          { strapi }\n        );\n\n        await restart();\n\n        // drafts should have been deleted with the migration, so we remove them\n        data.dogs = data.dogs.filter(dog => !_.isNil(dog.published_at));\n\n        let { body } = await rq({\n          url: '/content-manager/collection-types/application::dog.dog',\n          method: 'GET',\n        });\n\n        expect(body.results.length).toBe(1);\n        expect(body.results[0]).toMatchObject(_.pick(data.dogs[0], ['name']));\n        expect(body.results[0].published_at).toBeUndefined();\n      }, 60000);\n\n      test('Unique constraint is kept after disabling the feature', async () => {\n        const dogToCreate = { code: 'sameCode' };\n\n        let res = await rq({\n          method: 'POST',\n          url: `/content-manager/collection-types/application::dog.dog/`,\n          body: dogToCreate,\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject(dogToCreate);\n\n        data.dogs.push(res.body);\n\n        res = await rq({\n          method: 'POST',\n          url: `/content-manager/collection-types/application::dog.dog/`,\n          body: dogToCreate,\n        });\n\n        expect(res.statusCode).toBe(400);\n      });\n    });\n  });\n});\n",
    "packages/strapi-database/tests/migration-required-attribute.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst modelsUtils = require('../../../test/helpers/models');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  dogs: [],\n};\n\nconst dogModel = {\n  draftAndPublish: false,\n  attributes: {\n    name: {\n      type: 'string',\n      required: false,\n    },\n  },\n  connection: 'default',\n  name: 'dog',\n  description: '',\n  collectionName: '',\n};\n\nconst dogs = [\n  {\n    name: null,\n  },\n  {\n    name: 'Atos',\n  },\n];\n\nconst restart = async () => {\n  await strapi.destroy();\n  strapi = await createStrapiInstance();\n  rq = await createAuthRequest({ strapi });\n};\n\ndescribe('Migration - required attribute', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentType(dogModel)\n      .addFixtures(dogModel.name, dogs)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    data.dogs = builder.sanitizedFixturesFor(dogModel.name, strapi);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  });\n\n  describe('Required: false -> true', () => {\n    test('Can be null before migration', async () => {\n      let { body } = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::dog.dog',\n      });\n      expect(body.results.length).toBe(2);\n      const dogWithNameNull = body.results.find(dog => dog.name === null);\n      expect(dogWithNameNull).toBeTruthy();\n    });\n\n    test('Cannot create an entry with null after migration', async () => {\n      // remove null values otherwise the migration would fail\n\n      const { body } = await rq({\n        method: 'PUT',\n        url: `/content-manager/collection-types/application::dog.dog/${data.dogs[0].id}`,\n        body: { name: 'Nelson' },\n      });\n      data.dogs[0] = body;\n\n      // migration\n      const schema = await modelsUtils.getContentTypeSchema(dogModel.name, { strapi });\n      schema.attributes.name.required = true;\n\n      await modelsUtils.modifyContentType(schema, { strapi });\n      await restart();\n\n      // Try to create an entry with null\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::dog.dog',\n        body: { name: null },\n      });\n      expect(res.body.message).toBe('ValidationError');\n    }, 60000);\n  });\n\n  describe('Required: true -> false', () => {\n    test('Can create an entry with null after migration', async () => {\n      // migration\n      const schema = await modelsUtils.getContentTypeSchema(dogModel.name, { strapi });\n      schema.attributes.name.required = false;\n\n      await modelsUtils.modifyContentType(schema, { strapi });\n      await restart();\n\n      // Try to create an entry with null\n      const res = await rq({\n        url: `/content-manager/collection-types/application::dog.dog`,\n        method: 'POST',\n        body: { name: null },\n      });\n\n      expect(res.body).toMatchObject({ name: null });\n      data.dogs.push(res.body);\n    }, 60000);\n  });\n});\n",
    "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst modelsUtils = require('../../../test/helpers/models');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  dogs: [],\n};\n\nconst dogModel = {\n  draftAndPublish: false,\n  attributes: {\n    name: {\n      type: 'string',\n      unique: false,\n    },\n  },\n  connection: 'default',\n  name: 'dog',\n  description: '',\n  collectionName: '',\n};\n\nconst dogs = [\n  {\n    name: 'Atos',\n  },\n  {\n    name: 'Atos',\n  },\n];\n\nconst restart = async () => {\n  await strapi.destroy();\n  strapi = await createStrapiInstance();\n  rq = await createAuthRequest({ strapi });\n};\n\ndescribe('Migration - unique attribute', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentType(dogModel)\n      .addFixtures(dogModel.name, dogs)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    data.dogs = builder.sanitizedFixturesFor(dogModel.name, strapi);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Unique: false -> true', () => {\n    test('Can have duplicates before migration', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::dog.dog',\n        method: 'GET',\n      });\n      expect(body.results.length).toBe(2);\n      expect(body.results[0].name).toEqual(body.results[1].name);\n    });\n\n    test('Cannot create a duplicated entry after migration', async () => {\n      // remove duplicated values otherwise the migration would fail\n      const { body } = await rq({\n        url: `/content-manager/collection-types/application::dog.dog/${data.dogs[0].id}`,\n        method: 'PUT',\n        body: { name: 'Nelson' },\n      });\n      data.dogs[0] = body;\n\n      // migration\n      const schema = await modelsUtils.getContentTypeSchema(dogModel.name, { strapi });\n      schema.attributes.name.unique = true;\n      await modelsUtils.modifyContentType(schema, { strapi });\n\n      await restart();\n\n      // Try to create a duplicated entry\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::dog.dog',\n        body: { name: data.dogs[0].name },\n      });\n      expect(res.statusCode).toBe(400);\n    }, 60000);\n  });\n\n  describe('Unique: true -> false', () => {\n    test('Can create a duplicated entry after migration', async () => {\n      // migration\n      const schema = await modelsUtils.getContentTypeSchema(dogModel.name, { strapi });\n      schema.attributes.name.unique = false;\n      await modelsUtils.modifyContentType(schema, { strapi });\n\n      await restart();\n\n      // Try to create a duplicated entry\n      const res = await rq({\n        url: `/content-manager/collection-types/application::dog.dog`,\n        method: 'POST',\n        body: { name: data.dogs[0].name },\n      });\n\n      expect(res.body).toMatchObject({ name: data.dogs[0].name });\n      data.dogs.push(res.body);\n    }, 60000);\n  });\n});\n",
    "packages/strapi-generate-new/lib/create-cli-db-project.js": "'use strict';\n\nconst { merge } = require('lodash');\n\nconst { trackUsage } = require('./utils/usage');\nconst defaultConfigs = require('./utils/db-configs');\nconst clientDependencies = require('./utils/db-client-dependencies');\nconst createProject = require('./create-project');\n\nmodule.exports = async scope => {\n  console.log('Creating a project from the database CLI arguments.');\n  await trackUsage({ event: 'didChooseCustomDatabase', scope });\n\n  const client = scope.database.settings.client;\n  const configuration = {\n    client,\n    connection: merge({}, defaultConfigs[client] || {}, scope.database),\n    dependencies: clientDependencies({ scope, client }),\n  };\n  return createProject(scope, configuration);\n};\n",
    "packages/strapi-generate-new/lib/create-customized-project.js": "'use strict';\n\nconst { join } = require('path');\nconst fse = require('fs-extra');\nconst inquirer = require('inquirer');\nconst execa = require('execa');\nconst { merge, pick } = require('lodash');\n\nconst stopProcess = require('./utils/stop-process');\nconst { trackUsage } = require('./utils/usage');\nconst defaultConfigs = require('./utils/db-configs');\nconst clientDependencies = require('./utils/db-client-dependencies');\nconst dbQuestions = require('./utils/db-questions');\nconst createProject = require('./create-project');\n\nmodule.exports = async scope => {\n  await trackUsage({ event: 'didChooseCustomDatabase', scope });\n\n  const configuration = await askDbInfosAndTest(scope).catch(error => {\n    return trackUsage({ event: 'didNotConnectDatabase', scope, error }).then(\n      () => {\n        throw error;\n      }\n    );\n  });\n\n  console.log();\n  console.log('Creating a project with custom database options.');\n  await trackUsage({ event: 'didConnectDatabase', scope });\n  return createProject(scope, configuration);\n};\n\nconst MAX_RETRIES = 5;\nasync function askDbInfosAndTest(scope) {\n  let retries = 0;\n\n  async function loop() {\n    // else ask for the client name\n    const { client, connection } = await askDatabaseInfos(scope);\n\n    const configuration = {\n      client,\n      connection,\n      dependencies: clientDependencies({ scope, client }),\n    };\n\n    return testDatabaseConnection({\n      scope,\n      configuration,\n    })\n      .then(result => {\n        if (\n          result &&\n          result.shouldRetry === true &&\n          retries < MAX_RETRIES - 1\n        ) {\n          console.log('Retrying...');\n          retries++;\n          return loop();\n        }\n      })\n      .then(\n        () => fse.remove(scope.tmpPath),\n        err => {\n          return fse.remove(scope.tmpPath).then(() => {\n            throw err;\n          });\n        }\n      )\n      .then(() => configuration)\n      .catch(err => {\n        if (retries < MAX_RETRIES - 1) {\n          console.log();\n          console.log(` Connection test failed: ${err.message}`);\n          console.log();\n\n          if (scope.debug) {\n            console.log('Full error log:');\n            console.log(err);\n          }\n\n          console.log('Retrying...');\n          retries++;\n          return loop();\n        }\n\n        console.log(err);\n        stopProcess(\n          ` Could not connect to your database after ${MAX_RETRIES} tries. Try to check your database configuration an retry.`\n        );\n      });\n  }\n\n  return loop();\n}\n\nasync function testDatabaseConnection({ scope, configuration }) {\n  const { client } = configuration;\n\n  if (client === 'sqlite') return;\n\n  await installDatabaseTestingDep({\n    scope,\n    configuration,\n  });\n\n  const connectivityFile = join(\n    scope.tmpPath,\n    'node_modules',\n    `strapi-connector-${configuration.connection.connector}`,\n    'lib',\n    'utils',\n    'connectivity.js'\n  );\n\n  const tester = require(connectivityFile);\n  return tester({ scope, connection: configuration.connection });\n}\n\nconst SETTINGS_FIELDS = [\n  'database',\n  'host',\n  'srv',\n  'port',\n  'username',\n  'password',\n  'filename',\n];\n\nconst OPTIONS_FIELDS = ['authenticationDatabase'];\n\nasync function askDatabaseInfos(scope) {\n  const { client } = await inquirer.prompt([\n    {\n      type: 'list',\n      name: 'client',\n      message: 'Choose your default database client',\n      choices: ['sqlite', 'postgres', 'mysql', 'mongo'],\n      default: 'sqlite',\n    },\n  ]);\n\n  const responses = await inquirer.prompt(\n    dbQuestions[client].map(q => q({ scope, client }))\n  );\n\n  const connection = merge({}, defaultConfigs[client] || {}, {\n    settings: pick(responses, SETTINGS_FIELDS),\n    options: pick(responses, OPTIONS_FIELDS),\n  });\n\n  if (responses.ssl === true) {\n    if (client === 'mongo') {\n      connection.options.ssl = true;\n    } else {\n      connection.settings.ssl = true;\n    }\n  }\n\n  return {\n    client,\n    connection,\n  };\n}\n\nasync function installDatabaseTestingDep({ scope, configuration }) {\n  let packageManager = scope.useYarn ? 'yarnpkg' : 'npm';\n  let cmd = scope.useYarn\n    ? ['--cwd', scope.tmpPath, 'add']\n    : ['install', '--prefix', scope.tmpPath];\n\n  // Manually create the temp directory for yarn\n  if (scope.useYarn) {\n    await fse.ensureDir(scope.tmpPath);\n  }\n\n  const deps = Object.keys(configuration.dependencies).map(dep => {\n    return `${dep}@${configuration.dependencies[dep]}`;\n  });\n\n  await execa(packageManager, cmd.concat(deps));\n}\n",
    "packages/strapi-generate-new/lib/create-project.js": "'use strict';\n\nconst { join } = require('path');\nconst fse = require('fs-extra');\nconst chalk = require('chalk');\nconst execa = require('execa');\nconst ora = require('ora');\nconst _ = require('lodash');\n\nconst stopProcess = require('./utils/stop-process');\nconst { trackUsage, captureStderr } = require('./utils/usage');\nconst mergeTemplate = require('./utils/merge-template.js');\n\nconst packageJSON = require('./resources/json/package.json');\nconst createDatabaseConfig = require('./resources/templates/database.js');\nconst createServerConfig = require('./resources/templates/server.js');\n\nmodule.exports = async function createProject(scope, { client, connection, dependencies }) {\n  console.log('Creating files.');\n\n  const { rootPath } = scope;\n  const resources = join(__dirname, 'resources');\n\n  try {\n    // copy files\n    await fse.copy(join(resources, 'files'), rootPath);\n\n    // copy dot files\n    const dotFiles = await fse.readdir(join(resources, 'dot-files'));\n    await Promise.all(\n      dotFiles.map(name => {\n        return fse.copy(join(resources, 'dot-files', name), join(rootPath, `.${name}`));\n      })\n    );\n\n    await trackUsage({ event: 'didCopyProjectFiles', scope });\n\n    // copy templates\n    await fse.writeJSON(\n      join(rootPath, 'package.json'),\n      packageJSON({\n        strapiDependencies: scope.strapiDependencies,\n        additionalsDependencies: dependencies,\n        strapiVersion: scope.strapiVersion,\n        projectName: _.kebabCase(scope.name),\n        uuid: scope.uuid,\n      }),\n      {\n        spaces: 2,\n      }\n    );\n\n    await trackUsage({ event: 'didWritePackageJSON', scope });\n\n    // ensure node_modules is created\n    await fse.ensureDir(join(rootPath, 'node_modules'));\n\n    // create config/database.js\n    await fse.writeFile(\n      join(rootPath, `config/database.js`),\n      createDatabaseConfig({\n        client,\n        connection,\n      })\n    );\n\n    // create config/server.js\n    await fse.writeFile(join(rootPath, `config/server.js`), createServerConfig());\n    await trackUsage({ event: 'didCopyConfigurationFiles', scope });\n\n    // merge template files if a template is specified\n    const hasTemplate = Boolean(scope.template);\n    if (hasTemplate) {\n      try {\n        await mergeTemplate(scope, rootPath);\n      } catch (error) {\n        throw new Error(` Template installation failed: ${error.message}`);\n      }\n    }\n  } catch (err) {\n    await fse.remove(scope.rootPath);\n    throw err;\n  }\n\n  await trackUsage({ event: 'willInstallProjectDependencies', scope });\n\n  const installPrefix = chalk.yellow('Installing dependencies:');\n  const loader = ora(installPrefix).start();\n\n  const logInstall = (chunk = '') => {\n    loader.text = `${installPrefix} ${chunk\n      .toString()\n      .split('\\n')\n      .join(' ')}`;\n  };\n\n  try {\n    if (scope.installDependencies !== false) {\n      const runner = runInstall(scope);\n\n      runner.stdout.on('data', logInstall);\n      runner.stderr.on('data', logInstall);\n\n      await runner;\n    }\n\n    loader.stop();\n    console.log(`Dependencies installed ${chalk.green('successfully')}.`);\n\n    await trackUsage({ event: 'didInstallProjectDependencies', scope });\n  } catch (error) {\n    loader.stop();\n    await trackUsage({\n      event: 'didNotInstallProjectDependencies',\n      scope,\n      error: error.stderr.slice(-1024),\n    });\n\n    console.error(`${chalk.red('Error')} while installing dependencies:`);\n    console.error(error.stderr);\n\n    await captureStderr('didNotInstallProjectDependencies', error);\n\n    console.log(chalk.black.bgWhite(' Keep trying!             '));\n    console.log();\n    console.log(\n      chalk.bold(\n        'Oh, it seems that you encountered errors while installing dependencies in your project.'\n      )\n    );\n    console.log(`Don't give up, your project was created correctly.`);\n    console.log(\n      `Fix the issues mentioned in the installation errors and try to run the following command:`\n    );\n    console.log();\n    console.log(\n      `cd ${chalk.green(rootPath)} && ${chalk.cyan(scope.useYarn ? 'yarn' : 'npm')} install`\n    );\n    console.log();\n\n    stopProcess();\n  }\n\n  await trackUsage({ event: 'didCreateProject', scope });\n\n  console.log();\n  console.log(`Your application was created at ${chalk.green(rootPath)}.\\n`);\n\n  const cmd = chalk.cyan(scope.useYarn ? 'yarn' : 'npm run');\n\n  console.log('Available commands in your project:');\n  console.log();\n  console.log(`  ${cmd} develop`);\n  console.log('  Start Strapi in watch mode.');\n  console.log();\n  console.log(`  ${cmd} start`);\n  console.log('  Start Strapi without watch mode.');\n  console.log();\n  console.log(`  ${cmd} build`);\n  console.log('  Build Strapi admin panel.');\n  console.log();\n  console.log(`  ${cmd} strapi`);\n  console.log(`  Display all available commands.`);\n  console.log();\n  console.log('You can start by doing:');\n  console.log();\n  console.log(`  ${chalk.cyan('cd')} ${rootPath}`);\n  console.log(`  ${cmd} develop`);\n  console.log();\n};\n\nconst installArguments = ['install', '--production', '--no-optional'];\nfunction runInstall({ rootPath, useYarn }) {\n  if (useYarn) {\n    return execa('yarnpkg', installArguments, {\n      cwd: rootPath,\n      stdin: 'ignore',\n    });\n  }\n\n  return execa('npm', installArguments, { cwd: rootPath, stdin: 'ignore' });\n}\n",
    "packages/strapi-generate-new/lib/create-quickstart-project.js": "'use strict';\n\nconst execa = require('execa');\n\nconst { trackUsage, captureStderr } = require('./utils/usage');\nconst defaultConfigs = require('./utils/db-configs.js');\nconst clientDependencies = require('./utils/db-client-dependencies.js');\nconst createProject = require('./create-project');\n\nmodule.exports = async function createQuickStartProject(scope) {\n  console.log('Creating a quickstart project.');\n  await trackUsage({ event: 'didChooseQuickstart', scope });\n\n  // get default sqlite config\n  const client = 'sqlite';\n  const configuration = {\n    client,\n    connection: defaultConfigs[client],\n    dependencies: clientDependencies({ scope, client }),\n  };\n\n  await createProject(scope, configuration);\n\n  if (scope.runQuickstartApp !== true) return;\n\n  try {\n    await trackUsage({ event: 'willBuildAdmin', scope });\n\n    await execa('npm', ['run', 'build', '--', '--no-optimization'], {\n      stdio: 'inherit',\n      cwd: scope.rootPath,\n      env: {\n        FORCE_COLOR: 1,\n      },\n    });\n\n    await trackUsage({ event: 'didBuildAdmin', scope });\n  } catch (error) {\n    await trackUsage({\n      event: 'didNotBuildAdmin',\n      scope,\n      error,\n    });\n\n    await captureStderr('didNotBuildAdmin', error);\n    process.exit(1);\n  }\n\n  console.log(`Running your Strapi application.`);\n\n  try {\n    await trackUsage({ event: 'willStartServer', scope });\n\n    await execa('npm', ['run', 'develop'], {\n      stdio: 'inherit',\n      cwd: scope.rootPath,\n      env: {\n        FORCE_COLOR: 1,\n      },\n    });\n  } catch (error) {\n    await trackUsage({\n      event: 'didNotStartServer',\n      scope,\n      error,\n    });\n\n    await captureStderr('didNotStartServer', error);\n    process.exit(1);\n  }\n};\n",
    "packages/strapi-generate-new/lib/generate-new.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Node.js core.\nconst chalk = require('chalk');\nconst inquirer = require('inquirer');\nconst fse = require('fs-extra');\n\nconst { trackUsage } = require('./utils/usage');\nconst stopProcess = require('./utils/stop-process');\nconst createCLIDatabaseProject = require('./create-cli-db-project');\nconst createCustomizeProject = require('./create-customized-project');\nconst createQuickStartProject = require('./create-quickstart-project');\n\nmodule.exports = async scope => {\n  const hasDatabaseConfig = Boolean(scope.database);\n\n  // check rootPath is empty\n  if (await fse.exists(scope.rootPath)) {\n    const stat = await fse.stat(scope.rootPath);\n\n    if (!stat.isDirectory()) {\n      stopProcess(\n        ` ${chalk.green(\n          scope.rootPath\n        )} is not a directory. Make sure to create a Strapi application in an empty directory.`\n      );\n    }\n\n    const files = await fse.readdir(scope.rootPath);\n    if (files.length > 1) {\n      stopProcess(\n        ` You can only create a Strapi app in an empty directory.\\nMake sure ${chalk.green(\n          scope.rootPath\n        )} is empty.`\n      );\n    }\n  }\n\n  await trackUsage({ event: 'willCreateProject', scope });\n\n  // if database config is provided don't test the connection and create the project directly\n  if (hasDatabaseConfig) {\n    return createCLIDatabaseProject(scope);\n  }\n\n  // if cli quickstart create project with default sqlite options\n  if (scope.quick === true) {\n    return createQuickStartProject(scope);\n  }\n\n  const useQuickStart = await askShouldUseQuickstart();\n  // else if question response is quickstart create project\n  if (useQuickStart) {\n    return createQuickStartProject(scope);\n  }\n\n  // create a project with full list of questions\n  return createCustomizeProject(scope);\n};\n\nasync function askShouldUseQuickstart() {\n  const answer = await inquirer.prompt([\n    {\n      type: 'list',\n      name: 'type',\n      message: 'Choose your installation type',\n      choices: [\n        {\n          name: 'Quickstart (recommended)',\n          value: 'quick',\n        },\n        {\n          name: 'Custom (manual settings)',\n          value: 'custom',\n        },\n      ],\n    },\n  ]);\n\n  return answer.type === 'quick';\n}\n",
    "packages/strapi-generate-new/lib/utils/merge-template.js": "'use strict';\n\nconst os = require('os');\nconst path = require('path');\nconst fse = require('fs-extra');\nconst fetch = require('node-fetch');\nconst tar = require('tar');\nconst _ = require('lodash');\nconst chalk = require('chalk');\nconst gitInfo = require('hosted-git-info');\n\n// Specify all the files and directories a template can have\nconst allowChildren = '*';\nconst allowedTemplateContents = {\n  'README.md': true,\n  '.env.example': true,\n  api: allowChildren,\n  components: allowChildren,\n  config: {\n    functions: allowChildren,\n  },\n  data: allowChildren,\n  plugins: allowChildren,\n  public: allowChildren,\n  scripts: allowChildren,\n};\n\n/**\n * merge template with new project being created\n * @param {string} scope  project creation params\n * @param {string} rootPath  project path\n */\nmodule.exports = async function mergeTemplate(scope, rootPath) {\n  // Parse template info\n  const repoInfo = getRepoInfo(scope.template);\n  const { user, project } = repoInfo;\n  console.log(`Installing ${chalk.yellow(`${user}/${project}`)} template.`);\n\n  // Download template repository to a temporary directory\n  const templatePath = await fse.mkdtemp(path.join(os.tmpdir(), 'strapi-'));\n\n  try {\n    await downloadGithubRepo(repoInfo, templatePath);\n  } catch (error) {\n    throw Error(`Could not download ${chalk.yellow(`${user}/${project}`)} repository.`);\n  }\n\n  // Make sure the downloaded template matches the required format\n  const { templateConfig } = await checkTemplateRootStructure(templatePath, scope);\n  await checkTemplateContentsStructure(path.resolve(templatePath, 'template'));\n\n  // Merge contents of the template in the project\n  const fullTemplateUrl = `https://github.com/${user}/${project}`;\n  await mergePackageJSON(rootPath, templateConfig, fullTemplateUrl);\n  await mergeFilesAndDirectories(rootPath, templatePath);\n\n  // Delete the downloaded template repo\n  await fse.remove(templatePath);\n};\n\n// Make sure the template has the required top-level structure\nasync function checkTemplateRootStructure(templatePath, scope) {\n  // Make sure the root of the repo has a template.json or a template.js file\n  const templateJsonPath = path.join(templatePath, 'template.json');\n  const templateFunctionPath = path.join(templatePath, 'template.js');\n\n  // Store the template config, whether it comes from a JSON or a function\n  let templateConfig = {};\n\n  const hasJsonConfig = fse.existsSync(templateJsonPath);\n  if (hasJsonConfig) {\n    const jsonStat = await fse.stat(templateJsonPath);\n    if (!jsonStat.isFile()) {\n      throw new Error(`A template's ${chalk.green('template.json')} must be a file`);\n    }\n    templateConfig = require(templateJsonPath);\n  }\n\n  const hasFunctionConfig = fse.existsSync(templateFunctionPath);\n  if (hasFunctionConfig) {\n    const functionStat = await fse.stat(templateFunctionPath);\n    if (!functionStat.isFile()) {\n      throw new Error(`A template's ${chalk.green('template.js')} must be a file`);\n    }\n    // Get the config by passing the scope to the function\n    templateConfig = require(templateFunctionPath)(scope);\n  }\n\n  // Make sure there's exactly one template config file\n  if (!hasJsonConfig && !hasFunctionConfig) {\n    throw new Error(\n      `A template must have either a ${chalk.green('template.json')} or a ${chalk.green(\n        'template.js'\n      )} root file`\n    );\n  } else if (hasJsonConfig && hasFunctionConfig) {\n    throw new Error(\n      `A template cannot have both ${chalk.green('template.json')} and ${chalk.green(\n        'template.js'\n      )} root files`\n    );\n  }\n\n  // Make sure the root of the repo has a template folder\n  const templateDirPath = path.join(templatePath, 'template');\n  try {\n    const stat = await fse.stat(templateDirPath);\n    if (!stat.isDirectory()) {\n      throw Error(`A template must have a root ${chalk.green('template/')} directory`);\n    }\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      throw Error(`A template must have a root ${chalk.green('template/')} directory`);\n    }\n\n    throw error;\n  }\n\n  return { templateConfig };\n}\n\n// Traverse template tree to make sure each file and folder is allowed\nasync function checkTemplateContentsStructure(templateContentsPath) {\n  // Recursively check if each item in a directory is allowed\n  const checkPathContents = (pathToCheck, parents) => {\n    const contents = fse.readdirSync(pathToCheck);\n    contents.forEach(item => {\n      const nextParents = [...parents, item];\n      const matchingTreeValue = _.get(allowedTemplateContents, nextParents);\n\n      // Treat files and directories separately\n      const itemPath = path.resolve(pathToCheck, item);\n      const isDirectory = fse.statSync(itemPath).isDirectory();\n\n      if (matchingTreeValue === undefined) {\n        // Unknown paths are forbidden\n        throw Error(\n          `Illegal template structure, unknown path ${chalk.green(nextParents.join('/'))}`\n        );\n      }\n\n      if (matchingTreeValue === true) {\n        if (!isDirectory) {\n          // All good, the file is allowed\n          return;\n        }\n        throw Error(\n          `Illegal template structure, expected a file and got a directory at ${chalk.green(\n            nextParents.join('/')\n          )}`\n        );\n      }\n\n      if (isDirectory) {\n        if (matchingTreeValue === allowChildren) {\n          // All children are allowed\n          return;\n        }\n        // Check if the contents of the directory are allowed\n        checkPathContents(itemPath, nextParents);\n      } else {\n        throw Error(\n          `Illegal template structure, unknow file ${chalk.green(nextParents.join('/'))}`\n        );\n      }\n    });\n  };\n\n  checkPathContents(templateContentsPath, []);\n}\n\nfunction getRepoInfo(template) {\n  try {\n    const { user, project, default: urlStrategy } = gitInfo.fromUrl(template);\n    if (urlStrategy === 'https' || urlStrategy === 'http') {\n      // A full GitHub URL was provided, return username and project directly\n      return { user, project };\n    }\n    if (urlStrategy === 'shortcut') {\n      // A shorthand was provided, so prefix the project name with \"strapi-template-\"\n      return {\n        user,\n        project: `strapi-template-${project}`,\n      };\n    }\n  } catch (error) {\n    // If it's not a GitHub URL, then assume it's a shorthand for an official template\n    return {\n      user: 'strapi',\n      project: `strapi-template-${template}`,\n    };\n  }\n}\n\nasync function downloadGithubRepo(repoInfo, templatePath) {\n  // Download from GitHub\n  const { user, project } = repoInfo;\n  const codeload = `https://codeload.github.com/${user}/${project}/tar.gz/master`;\n  const response = await fetch(codeload);\n  if (!response.ok) {\n    throw Error(`Could not download the ${chalk.green(`${user}/${project}`)} repository`);\n  }\n\n  await new Promise(resolve => {\n    response.body.pipe(tar.extract({ strip: 1, cwd: templatePath })).on('close', resolve);\n  });\n}\n\n// Merge the template's template.json into the Strapi project's package.json\nasync function mergePackageJSON(rootPath, templateConfig, templateUrl) {\n  // Import the package.json as an object\n  const packageJSON = require(path.resolve(rootPath, 'package.json'));\n\n  if (!templateConfig.package) {\n    // Nothing to overwrite\n    return;\n  }\n\n  // Make sure the template.json doesn't overwrite the UUID\n  if (templateConfig.package.strapi && templateConfig.package.strapi.uuid) {\n    throw Error('A template cannot overwrite the Strapi UUID');\n  }\n\n  // Use lodash to deeply merge them\n  const mergedConfig = _.merge(packageJSON, templateConfig.package);\n\n  // Add starter info to package.json\n  _.set(mergedConfig, 'strapi.template', templateUrl);\n\n  // Save the merged config as the new package.json\n  const packageJSONPath = path.join(rootPath, 'package.json');\n  await fse.writeJSON(packageJSONPath, mergedConfig, { spaces: 2 });\n}\n\n// Merge all allowed files and directories\nasync function mergeFilesAndDirectories(rootPath, templatePath) {\n  const templateDir = path.join(templatePath, 'template');\n  await fse.copy(templateDir, rootPath, { overwrite: true, recursive: true });\n}\n",
    "packages/strapi-generate-new/lib/utils/usage.js": "'use strict';\n\nconst os = require('os');\nconst fetch = require('node-fetch');\nconst sentry = require('@sentry/node');\n\nasync function captureException(error) {\n  try {\n    sentry.captureException(error);\n    await sentry.flush();\n  } catch (err) {\n    /** ignore errors*/\n    return Promise.resolve();\n  }\n}\n\nasync function captureError(message) {\n  try {\n    sentry.captureMessage(message, 'error');\n    await sentry.flush();\n  } catch (err) {\n    /** ignore errors*/\n    return Promise.resolve();\n  }\n}\n\nfunction captureStderr(name, error) {\n  if (error && error.stderr && error.stderr.trim() !== '') {\n    error.stderr\n      .trim()\n      .split('\\n')\n      .forEach(line => {\n        sentry.addBreadcrumb({\n          category: 'stderr',\n          message: line,\n          level: 'error',\n        });\n      });\n  }\n\n  return captureError(name);\n}\n\nfunction trackEvent(event, body) {\n  try {\n    return fetch('https://analytics.strapi.io/track', {\n      method: 'POST',\n      body: JSON.stringify({\n        event,\n        ...body,\n      }),\n      timeout: 1000,\n      headers: { 'Content-Type': 'application/json' },\n    }).catch(() => {});\n  } catch (err) {\n    /** ignore errors*/\n    return Promise.resolve();\n  }\n}\n\nfunction trackError({ scope, error }) {\n  try {\n    return trackEvent('didNotCreateProject', {\n      uuid: scope.uuid,\n      deviceId: scope.deviceId,\n      properties: {\n        error: typeof error == 'string' ? error : error && error.message,\n        os: os.type(),\n        platform: os.platform(),\n        release: os.release(),\n        version: scope.strapiVersion,\n        nodeVersion: process.version,\n        docker: scope.docker,\n        useYarn: scope.useYarn,\n        template: scope.template || '',\n      },\n    });\n  } catch (err) {\n    /** ignore errors*/\n    return Promise.resolve();\n  }\n}\n\nfunction trackUsage({ event, scope, error }) {\n  try {\n    return trackEvent(event, {\n      uuid: scope.uuid,\n      deviceId: scope.deviceId,\n      properties: {\n        error: typeof error == 'string' ? error : error && error.message,\n        os: os.type(),\n        os_platform: os.platform(),\n        os_release: os.release(),\n        node_version: process.version,\n        version: scope.strapiVersion,\n        docker: scope.docker,\n        useYarn: scope.useYarn.toString(),\n        noRun: (scope.runQuickstartApp !== true).toString(),\n        template: scope.template || null,\n      },\n    });\n  } catch (err) {\n    /** ignore errors*/\n    return Promise.resolve();\n  }\n}\n\nmodule.exports = {\n  trackError,\n  trackUsage,\n  captureException,\n  captureStderr,\n};\n",
    "packages/strapi-helper-plugin/lib/src/hooks/useUserPermissions/index.js": "import { useCallback, useEffect, useMemo, useReducer, useRef } from 'react';\nimport hasPermissions from '../../utils/hasPermissions';\nimport useUser from '../useUser';\n\nimport generateResultsObject from './utils/generateResultsObject';\nimport reducer from './reducer';\nimport init from './init';\n\nconst useUserPermissions = pluginPermissions => {\n  const abortController = new AbortController();\n  const { signal } = abortController;\n\n  const isMounted = useRef(true);\n  const permissionNames = useMemo(() => {\n    return Object.keys(pluginPermissions);\n  }, [pluginPermissions]);\n  const currentUserPermissions = useUser();\n  const [state, dispatch] = useReducer(reducer, {}, () => init(permissionNames));\n  const checkPermissionsRef = useRef();\n  const generateArrayOfPromisesRef = useRef();\n\n  checkPermissionsRef.current = async permissionName => {\n    const hasPermission = await hasPermissions(\n      currentUserPermissions,\n      pluginPermissions[permissionName],\n      signal\n    );\n\n    return { permissionName, hasPermission };\n  };\n\n  generateArrayOfPromisesRef.current = array =>\n    array.map(permissionName => checkPermissionsRef.current(permissionName));\n\n  useEffect(() => {\n    isMounted.current = true;\n\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    const getData = async () => {\n      try {\n        dispatch({\n          type: 'GET_DATA',\n          permissionNames,\n        });\n        const arrayOfPromises = generateArrayOfPromisesRef.current(permissionNames);\n        const results = await Promise.all(arrayOfPromises);\n        const data = generateResultsObject(results);\n\n        if (isMounted.current) {\n          dispatch({\n            type: 'GET_DATA_SUCCEEDED',\n            data,\n          });\n        }\n      } catch (err) {\n        // Silent\n      }\n    };\n\n    getData();\n\n    return () => {\n      abortController.abort();\n    };\n  }, [permissionNames]);\n\n  // This function is used to synchronise the hook when used in dynamic components\n  const setIsLoading = useCallback(() => {\n    dispatch({\n      type: 'SET_IS_LOADING',\n    });\n  }, []);\n\n  return { ...state, setIsLoading };\n};\n\nexport default useUserPermissions;\n",
    "packages/strapi-helper-plugin/lib/src/utils/hasPermissions.js": "import { isEmpty, pickBy, transform } from 'lodash';\nimport request from './request';\n\nconst findMatchingPermissions = (userPermissions, permissions) => {\n  return transform(\n    userPermissions,\n    (result, value) => {\n      const associatedPermission = permissions.find(\n        perm => perm.action === value.action && perm.subject === value.subject\n      );\n\n      if (associatedPermission) {\n        result.push(value);\n      }\n    },\n    []\n  );\n};\n\nconst formatPermissionsForRequest = permissions =>\n  permissions.map(permission =>\n    pickBy(permission, (value, key) => {\n      return ['action', 'subject'].includes(key) && !isEmpty(value);\n    })\n  );\n\nconst shouldCheckPermissions = permissions =>\n  !isEmpty(permissions) && permissions.every(perm => !isEmpty(perm.conditions));\n\nconst hasPermissions = async (userPermissions, permissions, signal) => {\n  if (!permissions || !permissions.length) {\n    return true;\n  }\n\n  const matchingPermissions = findMatchingPermissions(userPermissions, permissions);\n\n  if (shouldCheckPermissions(matchingPermissions)) {\n    let hasPermission = false;\n\n    try {\n      const { data } = await request('/admin/permissions/check', {\n        method: 'POST',\n        body: {\n          permissions: formatPermissionsForRequest(matchingPermissions),\n        },\n        signal,\n      });\n\n      hasPermission = data.every(v => v === true);\n    } catch (err) {\n      console.error('Error while checking permissions', err);\n    }\n\n    return hasPermission;\n  }\n\n  return matchingPermissions.length > 0;\n};\n\nexport default hasPermissions;\nexport { findMatchingPermissions, formatPermissionsForRequest, shouldCheckPermissions };\n",
    "packages/strapi-hook-redis/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Core\nconst util = require('util');\n/* eslint-disable prefer-template */\n\n// Public node modules.\nconst _ = require('lodash');\nconst Redis = require('ioredis');\nconst stackTrace = require('stack-trace');\n/**\n * Redis hook\n */\n\nmodule.exports = function(strapi) {\n  const hook = {\n    /**\n     * Default options\n     */\n\n    defaults: {\n      port: 6379,\n      host: 'localhost',\n      options: {\n        db: 0,\n      },\n      showFriendlyErrorStack: process.env.NODE_ENV !== 'production',\n    },\n\n    /**\n     * Initialize the hook\n     */\n\n    initialize: () => {\n      if (\n        _.isEmpty(strapi.models) ||\n        !_.pickBy(strapi.config.connections, {\n          connector: 'strapi-hook-redis',\n        })\n      ) {\n        return;\n      }\n\n      const connections = _.pickBy(strapi.config.connections, {\n        connector: 'strapi-hook-redis',\n      });\n\n      if (_.size(connections) === 0) {\n        return;\n      }\n\n      const done = _.after(_.size(connections), () => {\n        return;\n      });\n\n      // For each connection in the config register a new Knex connection.\n      _.forEach(connections, (connection, name) => {\n        // Apply defaults\n        _.defaults(connection.settings, strapi.config.hook.settings.redis);\n\n        const redis = new Redis(\n          _.defaultsDeep(\n            {\n              port: _.get(connection.settings, 'port'),\n              host: _.get(connection.settings, 'host'),\n              options: {\n                db: _.get(connection.options, 'database') || 0,\n              },\n            },\n            strapi.config.hook.settings.redis\n          )\n        );\n\n        redis.on('error', err => {\n          strapi.log.error(err);\n          process.exit(0);\n        });\n\n        // Utils function.\n        // Behavior: Try to retrieve data from Redis, if null\n        // execute callback and set the value in Redis for this serial key.\n        redis.cache = async ({ expired = 60 * 60, serial }, cb, type) => {\n          if (_.isEmpty(serial)) {\n            strapi.log.warn(\n              `Be careful, you're using cache() function of strapi-redis without serial`\n            );\n\n            const traces = stackTrace.get();\n\n            strapi.log.warn(\n              `> [${traces[1].getLineNumber()}] ${traces[1]\n                .getFileName()\n                .replace(strapi.config.appPath, '')}`\n            );\n\n            return await cb();\n          }\n\n          let cache = await redis.get(serial);\n\n          if (!cache) {\n            cache = await cb();\n\n            if (cache && _.get(connection, 'options.disabledCaching') !== true) {\n              switch (type) {\n                case 'json':\n                  redis.set(serial, JSON.stringify(cache), 'ex', expired);\n                  break;\n                case 'int':\n                default:\n                  redis.set(serial, cache, 'ex', expired);\n                  break;\n              }\n            }\n          }\n\n          switch (type) {\n            case 'int':\n              return parseInt(cache);\n            case 'float':\n              return _.toNumber(cache);\n            case 'json':\n              try {\n                return _.isObject(cache) ? cache : JSON.parse(cache);\n              } catch (e) {\n                return cache;\n              }\n            default:\n              return cache;\n          }\n        };\n\n        // Define as new connection.\n        strapi.connections[name] = redis;\n\n        // Expose global\n        if (_.get(connection, 'options.global') !== false) {\n          global[_.get(connection, 'options.globalName') || 'redis'] = redis;\n        }\n\n        if (_.get(connection, 'options.debug') === true) {\n          redis.monitor((err, monitor) => {\n            if (err) {\n              console.error(err);\n            }\n            // Entering monitoring mode.\n            monitor.on('monitor', (time, args) => {\n              console.log(time + ': ' + util.inspect(args));\n            });\n          });\n        }\n\n        redis.on('ready', () => {\n          done();\n        });\n      });\n    },\n  };\n\n  return hook;\n};\n",
    "packages/strapi-plugin-content-manager/admin/src/components/DraggedFieldWithPreview/DynamicComponent.js": "import React, { useEffect, useState } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport PropTypes from 'prop-types';\nimport { hasPermissions, useUser } from 'strapi-helper-plugin';\nimport pluginId from '../../pluginId';\nimport pluginPermissions from '../../permissions';\nimport DynamicComponentCard from '../DynamicComponentCard';\nimport Tooltip from './Tooltip';\n\nconst DynamicComponent = ({ componentUid, friendlyName, icon, setIsOverDynamicZone }) => {\n  const [isOver, setIsOver] = useState(false);\n  const [{ isLoading, canAccess }, setState] = useState({ isLoading: true, canAccess: false });\n  const { push } = useHistory();\n  const userPermissions = useUser();\n\n  useEffect(() => {\n    const checkPermission = async () => {\n      try {\n        const canAccess = await hasPermissions(\n          userPermissions,\n          pluginPermissions.componentsConfigurations\n        );\n\n        setState({ isLoading: false, canAccess });\n      } catch (err) {\n        setState({ isLoading: false });\n      }\n    };\n\n    checkPermission();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const handleMouseEvent = () => {\n    setIsOverDynamicZone(v => !v);\n    setIsOver(v => !v);\n  };\n\n  return (\n    <DynamicComponentCard\n      componentUid={componentUid}\n      friendlyName={friendlyName}\n      icon={icon}\n      isOver={isOver}\n      onClick={() => {\n        if (!isLoading && canAccess) {\n          push(`/plugins/${pluginId}/components/${componentUid}/configurations/edit`);\n        }\n      }}\n      onMouseEvent={handleMouseEvent}\n      tradId=\"components.DraggableAttr.edit\"\n    >\n      <Tooltip isOver={isOver}>{componentUid}</Tooltip>\n    </DynamicComponentCard>\n  );\n};\n\nDynamicComponent.defaultProps = {\n  friendlyName: '',\n  icon: 'smile',\n};\n\nDynamicComponent.propTypes = {\n  componentUid: PropTypes.string.isRequired,\n  friendlyName: PropTypes.string,\n  icon: PropTypes.string,\n  setIsOverDynamicZone: PropTypes.func.isRequired,\n};\n\nexport default DynamicComponent;\n",
    "packages/strapi-plugin-content-manager/admin/src/components/InputUID/index.js": "import React, { useEffect, useState, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { Sync } from '@buffetjs/icons';\nimport { ErrorMessage, Description } from '@buffetjs/styles';\nimport { Label, Error } from '@buffetjs/core';\nimport { useDebounce, useClickAwayListener } from '@buffetjs/hooks';\nimport styled from 'styled-components';\nimport { request, LoadingIndicator, useGlobalContext } from 'strapi-helper-plugin';\nimport { FormattedMessage } from 'react-intl';\nimport { get } from 'lodash';\n\nimport getTrad from '../../utils/getTrad';\nimport pluginId from '../../pluginId';\nimport getRequestUrl from '../../utils/getRequestUrl';\nimport useDataManager from '../../hooks/useDataManager';\nimport RightLabel from './RightLabel';\nimport Options from './Options';\nimport RegenerateButton from './RegenerateButton';\nimport RightContent from './RightContent';\nimport Input from './InputUID';\nimport Wrapper from './Wrapper';\nimport SubLabel from './SubLabel';\nimport UID_REGEX from './regex';\nimport RightContentLabel from './RightContentLabel';\n\nconst InputContainer = styled.div`\n  position: relative;\n`;\nconst Name = styled(Label)`\n  display: block;\n  text-transform: capitalize;\n  margin-bottom: 1rem;\n`;\n\n// This component should be in buffetjs. It will be used in the media lib.\n// This component will be the strapi custom dropdown component.\n// TODO : Make this component generic -> InputDropdown.\n// TODO : Use the Compounds components pattern\n// https://blog.bitsrc.io/understanding-compound-components-in-react-23c4b84535b5\nconst InputUID = ({\n  attribute,\n  contentTypeUID,\n  description,\n  error: inputError,\n  label: inputLabel,\n  name,\n  onChange,\n  validations,\n  value,\n  editable,\n  ...inputProps\n}) => {\n  const { modifiedData, initialData, layout } = useDataManager();\n  const [isLoading, setIsLoading] = useState(false);\n  const [availability, setAvailability] = useState(null);\n  const [isSuggestionOpen, setIsSuggestionOpen] = useState(true);\n  const [isCustomized, setIsCustomized] = useState(false);\n  const [label, setLabel] = useState();\n  const debouncedValue = useDebounce(value, 300);\n  const debouncedTargetFieldValue = useDebounce(modifiedData[attribute.targetField], 300);\n  const wrapperRef = useRef(null);\n  const generateUid = useRef();\n  const initialValue = initialData[name];\n  const createdAtName = get(layout, ['options', 'timestamps', 0]);\n  const isCreation = !initialData[createdAtName];\n  const { formatMessage } = useGlobalContext();\n\n  generateUid.current = async (shouldSetInitialValue = false) => {\n    setIsLoading(true);\n    const requestURL = getRequestUrl('uid/generate');\n    try {\n      const { data } = await request(requestURL, {\n        method: 'POST',\n        body: {\n          contentTypeUID,\n          field: name,\n          data: modifiedData,\n        },\n      });\n\n      onChange({ target: { name, value: data, type: 'text' } }, shouldSetInitialValue);\n      setIsLoading(false);\n    } catch (err) {\n      console.error({ err });\n      setIsLoading(false);\n    }\n  };\n\n  const checkAvailability = async () => {\n    setIsLoading(true);\n\n    const requestURL = getRequestUrl('uid/check-availability');\n\n    if (!value) {\n      return;\n    }\n\n    try {\n      const data = await request(requestURL, {\n        method: 'POST',\n        body: {\n          contentTypeUID,\n          field: name,\n          value: value ? value.trim() : '',\n        },\n      });\n      setAvailability(data);\n\n      if (data.suggestion) {\n        setIsSuggestionOpen(true);\n      }\n      setIsLoading(false);\n    } catch (err) {\n      console.error({ err });\n      setIsLoading(false);\n    }\n  };\n\n  // FIXME: we need to find a better way to autofill the input when it is required.\n  // useEffect(() => {\n  //   if (!value && validations.required) {\n  //     generateUid.current(true);\n  //   }\n  //   // eslint-disable-next-line react-hooks/exhaustive-deps\n  // }, []);\n\n  useEffect(() => {\n    if (\n      debouncedValue &&\n      debouncedValue.trim().match(UID_REGEX) &&\n      debouncedValue !== initialValue\n    ) {\n      checkAvailability();\n    }\n    if (!debouncedValue) {\n      setAvailability(null);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [debouncedValue, initialValue]);\n\n  useEffect(() => {\n    let timer;\n\n    if (availability && availability.isAvailable) {\n      timer = setTimeout(() => {\n        setAvailability(null);\n      }, 4000);\n    }\n\n    return () => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n    };\n  }, [availability]);\n\n  useEffect(() => {\n    if (\n      !isCustomized &&\n      isCreation &&\n      debouncedTargetFieldValue &&\n      modifiedData[attribute.targetField]\n    ) {\n      generateUid.current(true);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [debouncedTargetFieldValue, isCustomized, isCreation]);\n\n  useClickAwayListener(wrapperRef, () => setIsSuggestionOpen(false));\n\n  const handleFocus = () => {\n    if (availability && availability.suggestion) {\n      setIsSuggestionOpen(true);\n    }\n  };\n\n  const handleSuggestionClick = () => {\n    setIsSuggestionOpen(false);\n    onChange({ target: { name, value: availability.suggestion, type: 'text' } });\n  };\n\n  const handleGenerateMouseEnter = () => {\n    setLabel('regenerate');\n  };\n\n  const handleGenerateMouseLeave = () => {\n    setLabel(null);\n  };\n\n  const handleChange = (e, canCheck, dispatch) => {\n    if (!canCheck) {\n      dispatch({\n        type: 'SET_CHECK',\n      });\n    }\n\n    dispatch({\n      type: 'SET_ERROR',\n      error: null,\n    });\n\n    if (e.target.value && isCreation) {\n      setIsCustomized(true);\n    }\n\n    onChange(e);\n  };\n\n  return (\n    <Error\n      name={name}\n      inputError={inputError}\n      type=\"text\"\n      validations={{ ...validations, regex: UID_REGEX }}\n    >\n      {({ canCheck, onBlur, error, dispatch }) => {\n        const hasError = Boolean(error);\n\n        return (\n          <Wrapper ref={wrapperRef}>\n            <Name htmlFor={name}>{inputLabel}</Name>\n            <InputContainer>\n              <Input\n                {...inputProps}\n                containsEndAdornment={editable}\n                editable={editable}\n                error={hasError}\n                onFocus={handleFocus}\n                name={name}\n                onChange={e => handleChange(e, canCheck, dispatch)}\n                type=\"text\"\n                onBlur={onBlur}\n                // eslint-disable-next-line no-irregular-whitespace\n                value={value || ''}\n              />\n              <RightContent>\n                {label && (\n                  <RightContentLabel color=\"blue\">\n                    {formatMessage({\n                      id: getTrad('components.uid.regenerate'),\n                    })}\n                  </RightContentLabel>\n                )}\n                {!isLoading && !label && availability && (\n                  <RightLabel\n                    isAvailable={availability.isAvailable || value === availability.suggestion}\n                  />\n                )}\n                {editable && (\n                  <RegenerateButton\n                    onMouseEnter={handleGenerateMouseEnter}\n                    onMouseLeave={handleGenerateMouseLeave}\n                    onClick={() => generateUid.current()}\n                  >\n                    {isLoading ? (\n                      <LoadingIndicator small />\n                    ) : (\n                      <Sync fill={label ? '#007EFF' : '#B5B7BB'} width=\"11px\" height=\"11px\" />\n                    )}\n                  </RegenerateButton>\n                )}\n              </RightContent>\n              {availability && availability.suggestion && isSuggestionOpen && (\n                <FormattedMessage id={`${pluginId}.components.uid.suggested`}>\n                  {msg => (\n                    <Options\n                      title={msg}\n                      options={[\n                        {\n                          id: 'suggestion',\n                          label: availability.suggestion,\n                          onClick: handleSuggestionClick,\n                        },\n                      ]}\n                    />\n                  )}\n                </FormattedMessage>\n              )}\n            </InputContainer>\n            {!hasError && description && <SubLabel as={Description}>{description}</SubLabel>}\n            {hasError && <SubLabel as={ErrorMessage}>{error}</SubLabel>}\n          </Wrapper>\n        );\n      }}\n    </Error>\n  );\n};\n\nInputUID.propTypes = {\n  attribute: PropTypes.object.isRequired,\n  contentTypeUID: PropTypes.string.isRequired,\n  description: PropTypes.string,\n  editable: PropTypes.bool,\n  error: PropTypes.string,\n  label: PropTypes.string.isRequired,\n  name: PropTypes.string.isRequired,\n  onChange: PropTypes.func.isRequired,\n  validations: PropTypes.object,\n  value: PropTypes.string,\n};\n\nInputUID.defaultProps = {\n  description: '',\n  editable: false,\n  error: null,\n  validations: {},\n  value: '',\n};\n\nexport default InputUID;\n",
    "packages/strapi-plugin-content-manager/admin/src/components/RelationPreviewList/RelationPreviewTooltip.js": "import React, { useState, useEffect, useCallback, useRef, useLayoutEffect } from 'react';\nimport { Text, Padded } from '@buffetjs/core';\nimport { request } from 'strapi-helper-plugin';\nimport { LoadingIndicator } from '@buffetjs/styles';\nimport PropTypes from 'prop-types';\nimport { getDisplayedValue, getRequestUrl } from '../../utils';\nimport Tooltip from '../Tooltip';\n\nconst RelationPreviewTooltip = ({\n  tooltipId,\n  rowId,\n  mainField,\n  name,\n  queryInfos: { endPoint },\n  size,\n}) => {\n  const [isLoading, setIsLoading] = useState(true);\n  const [relationData, setRelationData] = useState([]);\n  const tooltipRef = useRef();\n\n  const fetchRelationData = useCallback(\n    async signal => {\n      const requestURL = getRequestUrl(`${endPoint}/${rowId}/${name}`);\n      try {\n        const { results } = await request(requestURL, {\n          method: 'GET',\n          signal,\n        });\n\n        setRelationData(results);\n        setIsLoading(false);\n      } catch (err) {\n        console.error({ err });\n        setIsLoading(false);\n      }\n    },\n    [endPoint, name, rowId]\n  );\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    const timeout = setTimeout(() => {\n      fetchRelationData(signal);\n    }, 500);\n\n    return () => {\n      clearTimeout(timeout);\n      abortController.abort();\n    };\n  }, [fetchRelationData]);\n\n  const getValueToDisplay = useCallback(\n    item => {\n      return getDisplayedValue(mainField.schema.type, item[mainField.name], mainField.name);\n    },\n    [mainField]\n  );\n\n  // Used to update the position after the loader\n  useLayoutEffect(() => {\n    if (!isLoading && tooltipRef.current) {\n      // A react-tooltip uncaught error is triggered when updatePosition is called in firefox.\n      // https://github.com/wwayne/react-tooltip/issues/619\n      try {\n        tooltipRef.current.updatePosition();\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  }, [isLoading]);\n\n  return (\n    <Tooltip ref={tooltipRef} id={tooltipId}>\n      <div>\n        {isLoading ? (\n          <Padded left right size=\"sm\">\n            <LoadingIndicator borderWidth=\"3px\" size=\"2rem\" />\n          </Padded>\n        ) : (\n          <>\n            {relationData.map(item => (\n              <Padded key={item.id} top bottom size=\"xs\">\n                <Text ellipsis color=\"white\">\n                  {getValueToDisplay(item)}\n                </Text>\n              </Padded>\n            ))}\n            {size > 10 && (\n              <Padded top size=\"xs\">\n                <Text color=\"white\">[...]</Text>\n              </Padded>\n            )}\n          </>\n        )}\n      </div>\n    </Tooltip>\n  );\n};\n\nRelationPreviewTooltip.propTypes = {\n  tooltipId: PropTypes.string.isRequired,\n  mainField: PropTypes.exact({\n    name: PropTypes.string.isRequired,\n    schema: PropTypes.shape({\n      type: PropTypes.string.isRequired,\n    }).isRequired,\n  }).isRequired,\n  name: PropTypes.string.isRequired,\n  size: PropTypes.number.isRequired,\n  rowId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n  queryInfos: PropTypes.shape({\n    endPoint: PropTypes.string.isRequired,\n  }).isRequired,\n};\n\nexport default RelationPreviewTooltip;\n",
    "packages/strapi-plugin-content-manager/admin/src/components/SelectWrapper/index.js": "import React, { useCallback, useState, useEffect, useMemo, memo } from 'react';\nimport PropTypes from 'prop-types';\nimport { FormattedMessage } from 'react-intl';\nimport { Link, useLocation } from 'react-router-dom';\nimport { findIndex, get, isArray, isEmpty } from 'lodash';\nimport { request } from 'strapi-helper-plugin';\nimport { Flex, Text, Padded } from '@buffetjs/core';\nimport pluginId from '../../pluginId';\nimport useDataManager from '../../hooks/useDataManager';\nimport NotAllowedInput from '../NotAllowedInput';\nimport SelectOne from '../SelectOne';\nimport SelectMany from '../SelectMany';\nimport ClearIndicator from './ClearIndicator';\nimport DropdownIndicator from './DropdownIndicator';\nimport IndicatorSeparator from './IndicatorSeparator';\nimport Option from './Option';\nimport { A, BaselineAlignment } from './components';\nimport { connect, select, styles } from './utils';\n\nconst initialPaginationState = {\n  _contains: '',\n  _limit: 20,\n  _start: 0,\n};\nfunction SelectWrapper({\n  description,\n  editable,\n  label,\n  isCreatingEntry,\n  isFieldAllowed,\n  isFieldReadable,\n  mainField,\n  name,\n  relationType,\n  targetModel,\n  placeholder,\n  queryInfos,\n}) {\n  // Disable the input in case of a polymorphic relation\n  const isMorph = useMemo(() => relationType.toLowerCase().includes('morph'), [relationType]);\n  const { addRelation, modifiedData, moveRelation, onChange, onRemoveRelation } = useDataManager();\n  const { pathname } = useLocation();\n\n  const value = get(modifiedData, name, null);\n  const [state, setState] = useState(initialPaginationState);\n  const [options, setOptions] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isOpen, setIsOpen] = useState(false);\n\n  const filteredOptions = useMemo(() => {\n    return options.filter(option => {\n      if (!isEmpty(value)) {\n        // SelectMany\n        if (Array.isArray(value)) {\n          return findIndex(value, o => o.id === option.value.id) === -1;\n        }\n\n        // SelectOne\n        return get(value, 'id', '') !== option.value.id;\n      }\n\n      return true;\n    });\n  }, [options, value]);\n\n  const { endPoint, containsKey, defaultParams, shouldDisplayRelationLink } = queryInfos;\n\n  const isSingle = ['oneWay', 'oneToOne', 'manyToOne', 'oneToManyMorph', 'oneToOneMorph'].includes(\n    relationType\n  );\n\n  const idsToOmit = useMemo(() => {\n    if (!value) {\n      return [];\n    }\n\n    if (isSingle) {\n      return [value.id];\n    }\n\n    return value.map(val => val.id);\n  }, [isSingle, value]);\n\n  const getData = useCallback(\n    async signal => {\n      // Currently polymorphic relations are not handled\n      if (isMorph) {\n        setIsLoading(false);\n\n        return;\n      }\n\n      if (!isFieldAllowed) {\n        setIsLoading(false);\n\n        return;\n      }\n\n      setIsLoading(true);\n\n      const params = { _limit: state._limit, ...defaultParams };\n\n      if (state._contains) {\n        params[containsKey] = state._contains;\n      }\n\n      try {\n        const data = await request(endPoint, {\n          method: 'POST',\n          params,\n          signal,\n          body: { idsToOmit },\n        });\n\n        const formattedData = data.map(obj => {\n          return { value: obj, label: obj[mainField.name] };\n        });\n\n        setOptions(prevState =>\n          prevState.concat(formattedData).filter((obj, index) => {\n            const objIndex = prevState.findIndex(el => el.value.id === obj.value.id);\n\n            if (objIndex === -1) {\n              return true;\n            }\n\n            return prevState.findIndex(el => el.value.id === obj.value.id) === index;\n          })\n        );\n        setIsLoading(false);\n      } catch (err) {\n        // Silent\n      }\n    },\n    [\n      isMorph,\n      isFieldAllowed,\n      state._limit,\n      state._contains,\n      defaultParams,\n      containsKey,\n      endPoint,\n      idsToOmit,\n      mainField.name,\n    ]\n  );\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    if (isOpen) {\n      getData(signal);\n    }\n\n    return () => abortController.abort();\n  }, [getData, isOpen]);\n\n  const handleInputChange = (inputValue, { action }) => {\n    if (action === 'input-change') {\n      setState(prevState => {\n        if (prevState._contains === inputValue) {\n          return prevState;\n        }\n\n        return { ...prevState, _contains: inputValue, _start: 0 };\n      });\n    }\n\n    return inputValue;\n  };\n\n  const handleMenuScrollToBottom = () => {\n    setState(prevState => ({ ...prevState, _limit: prevState._limit + 20 }));\n  };\n\n  const handleMenuClose = () => {\n    setState(initialPaginationState);\n    setIsOpen(false);\n  };\n\n  const handleChange = value => {\n    onChange({ target: { name, value: value ? value.value : value } });\n  };\n\n  const handleAddRelation = value => {\n    addRelation({ target: { name, value } });\n  };\n\n  const handleMenuOpen = () => {\n    setIsOpen(true);\n  };\n\n  const to = `/plugins/${pluginId}/collectionType/${targetModel}/${value ? value.id : null}`;\n\n  const link = useMemo(() => {\n    if (!value) {\n      return null;\n    }\n\n    if (!shouldDisplayRelationLink) {\n      return null;\n    }\n\n    return (\n      <Link to={{ pathname: to, state: { from: pathname } }}>\n        <FormattedMessage id=\"content-manager.containers.Edit.seeDetails\">\n          {msg => <A color=\"mediumBlue\">{msg}</A>}\n        </FormattedMessage>\n      </Link>\n    );\n  }, [shouldDisplayRelationLink, pathname, to, value]);\n\n  const Component = isSingle ? SelectOne : SelectMany;\n  const associationsLength = isArray(value) ? value.length : 0;\n\n  const isDisabled = useMemo(() => {\n    if (isMorph) {\n      return true;\n    }\n\n    if (!isCreatingEntry) {\n      return (!isFieldAllowed && isFieldReadable) || !editable;\n    }\n\n    return !editable;\n  }, [isMorph, isCreatingEntry, editable, isFieldAllowed, isFieldReadable]);\n\n  if (!isFieldAllowed && isCreatingEntry) {\n    return <NotAllowedInput label={label} />;\n  }\n\n  if (!isCreatingEntry && !isFieldAllowed && !isFieldReadable) {\n    return <NotAllowedInput label={label} />;\n  }\n\n  return (\n    <Padded>\n      <BaselineAlignment />\n      <Flex justifyContent=\"space-between\">\n        <Text fontWeight=\"semiBold\">\n          {label}\n          {!isSingle && ` (${associationsLength})`}\n        </Text>\n        {isSingle && link}\n      </Flex>\n      {!isEmpty(description) && (\n        <Padded top size=\"xs\">\n          <BaselineAlignment />\n          <Text fontSize=\"sm\" color=\"grey\" lineHeight=\"12px\" ellipsis>\n            {description}\n          </Text>\n        </Padded>\n      )}\n      <Padded top size=\"sm\">\n        <BaselineAlignment />\n\n        <Component\n          addRelation={handleAddRelation}\n          components={{ ClearIndicator, DropdownIndicator, IndicatorSeparator, Option }}\n          displayNavigationLink={shouldDisplayRelationLink}\n          id={name}\n          isDisabled={isDisabled}\n          isLoading={isLoading}\n          isClearable\n          mainField={mainField}\n          move={moveRelation}\n          name={name}\n          options={filteredOptions}\n          onChange={handleChange}\n          onInputChange={handleInputChange}\n          onMenuClose={handleMenuClose}\n          onMenuOpen={handleMenuOpen}\n          onMenuScrollToBottom={handleMenuScrollToBottom}\n          onRemove={onRemoveRelation}\n          placeholder={\n            isEmpty(placeholder) ? (\n              <FormattedMessage id={`${pluginId}.containers.Edit.addAnItem`} />\n            ) : (\n              placeholder\n            )\n          }\n          styles={styles}\n          targetModel={targetModel}\n          value={value}\n        />\n      </Padded>\n      <div style={{ marginBottom: 28 }} />\n    </Padded>\n  );\n}\n\nSelectWrapper.defaultProps = {\n  editable: true,\n  description: '',\n  label: '',\n  isFieldAllowed: true,\n  placeholder: '',\n};\n\nSelectWrapper.propTypes = {\n  editable: PropTypes.bool,\n  description: PropTypes.string,\n  label: PropTypes.string,\n  isCreatingEntry: PropTypes.bool.isRequired,\n  isFieldAllowed: PropTypes.bool,\n  isFieldReadable: PropTypes.bool.isRequired,\n  mainField: PropTypes.shape({\n    name: PropTypes.string.isRequired,\n    schema: PropTypes.shape({\n      type: PropTypes.string.isRequired,\n    }).isRequired,\n  }).isRequired,\n  name: PropTypes.string.isRequired,\n  placeholder: PropTypes.string,\n  relationType: PropTypes.string.isRequired,\n  targetModel: PropTypes.string.isRequired,\n  queryInfos: PropTypes.exact({\n    containsKey: PropTypes.string.isRequired,\n    defaultParams: PropTypes.object,\n    endPoint: PropTypes.string.isRequired,\n    shouldDisplayRelationLink: PropTypes.bool.isRequired,\n  }).isRequired,\n};\n\nconst Memoized = memo(SelectWrapper);\n\nexport default connect(Memoized, select);\n",
    "packages/strapi-plugin-content-manager/admin/src/components/SettingsViewWrapper/index.js": "import React, { useState, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { get, isEqual, upperFirst } from 'lodash';\nimport { withRouter } from 'react-router-dom';\nimport { FormattedMessage } from 'react-intl';\nimport { Inputs as Input, Header } from '@buffetjs/custom';\nimport {\n  BackHeader,\n  LoadingIndicatorPage,\n  PopUpWarning,\n  // contexts\n  useGlobalContext,\n} from 'strapi-helper-plugin';\nimport pluginId from '../../pluginId';\nimport Block from '../Block';\nimport Container from '../Container';\nimport SectionTitle from '../SectionTitle';\nimport Separator from '../Separator';\n\nconst SettingsViewWrapper = ({\n  children,\n  history: { goBack },\n  displayedFields,\n  inputs,\n  initialData,\n  isEditSettings,\n  isLoading,\n  modifiedData,\n  onChange,\n  onConfirmReset,\n  onConfirmSubmit,\n  name,\n}) => {\n  const { emitEvent, formatMessage } = useGlobalContext();\n  const [showWarningCancel, setWarningCancel] = useState(false);\n  const [showWarningSubmit, setWarningSubmit] = useState(false);\n\n  const attributes = useMemo(() => {\n    return get(modifiedData, ['attributes'], {});\n  }, [modifiedData]);\n\n  const toggleWarningCancel = () => setWarningCancel(prevState => !prevState);\n  const toggleWarningSubmit = () => setWarningSubmit(prevState => !prevState);\n\n  const getPluginHeaderActions = () => {\n    return [\n      {\n        color: 'cancel',\n        onClick: toggleWarningCancel,\n        label: formatMessage({\n          id: 'app.components.Button.reset',\n        }),\n        type: 'button',\n        disabled: isEqual(modifiedData, initialData),\n        style: {\n          fontWeight: 600,\n          paddingLeft: 15,\n          paddingRight: 15,\n        },\n      },\n      {\n        color: 'success',\n        label: formatMessage({\n          id: `${pluginId}.containers.Edit.submit`,\n        }),\n        type: 'submit',\n        disabled: isEqual(modifiedData, initialData),\n        style: {\n          minWidth: 150,\n          fontWeight: 600,\n        },\n      },\n    ];\n  };\n\n  const headerProps = {\n    actions: getPluginHeaderActions(),\n    title: {\n      label: formatMessage(\n        {\n          id: `${pluginId}.components.SettingsViewWrapper.pluginHeader.title`,\n        },\n        { name: upperFirst(name) }\n      ),\n    },\n    content: formatMessage({\n      id: `${pluginId}.components.SettingsViewWrapper.pluginHeader.description.${\n        isEditSettings ? 'edit' : 'list'\n      }-settings`,\n    }),\n  };\n\n  const getSelectOptions = input => {\n    if (input.name === 'settings.defaultSortBy') {\n      return [\n        'id',\n        ...displayedFields.filter(name => {\n          const type = get(attributes, [name, 'type']);\n\n          return !['media', 'richtext', 'dynamiczone', 'relation'].includes(type) && name !== 'id';\n        }),\n      ];\n    }\n\n    if (input.name === 'settings.mainField') {\n      const options = Object.keys(attributes).filter(attr => {\n        const type = get(attributes, [attr, 'type'], '');\n\n        return (\n          ![\n            'dynamiczone',\n            'json',\n            'text',\n            'relation',\n            'component',\n            'boolean',\n            'date',\n            'media',\n            'richtext',\n            'timestamp',\n          ].includes(type) && !!type\n        );\n      });\n\n      return options;\n    }\n\n    return input.options;\n  };\n\n  const handleSubmit = e => {\n    e.preventDefault();\n    toggleWarningSubmit();\n    emitEvent('willSaveContentTypeLayout');\n  };\n\n  if (isLoading) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <>\n      <BackHeader onClick={goBack} />\n      <Container className=\"container-fluid\">\n        <form onSubmit={handleSubmit}>\n          <Header {...headerProps} />\n          <div\n            className=\"row\"\n            style={{\n              paddingTop: '3px',\n            }}\n          >\n            <Block\n              style={{\n                marginBottom: '13px',\n                paddingBottom: '30px',\n                paddingTop: '24px',\n              }}\n            >\n              <SectionTitle isSettings />\n              <div className=\"row\">\n                {inputs.map(input => {\n                  return (\n                    <FormattedMessage key={input.name} id={input.label.id}>\n                      {label => (\n                        <div className={input.customBootstrapClass}>\n                          <FormattedMessage\n                            id={get(input, 'description.id', 'app.utils.defaultMessage')}\n                          >\n                            {description => (\n                              <Input\n                                {...input}\n                                description={description}\n                                label={label === ' ' ? null : label}\n                                onChange={onChange}\n                                options={getSelectOptions(input)}\n                                value={get(modifiedData, input.name, '')}\n                              />\n                            )}\n                          </FormattedMessage>\n                        </div>\n                      )}\n                    </FormattedMessage>\n                  );\n                })}\n                <div className=\"col-12\">\n                  <Separator style={{ marginBottom: 20 }} />\n                </div>\n              </div>\n              <SectionTitle />\n              {children}\n            </Block>\n          </div>\n          <PopUpWarning\n            isOpen={showWarningCancel}\n            toggleModal={toggleWarningCancel}\n            content={{\n              message: `${pluginId}.popUpWarning.warning.cancelAllSettings`,\n            }}\n            popUpWarningType=\"danger\"\n            onConfirm={() => {\n              onConfirmReset();\n              toggleWarningCancel();\n            }}\n          />\n          <PopUpWarning\n            isOpen={showWarningSubmit}\n            toggleModal={toggleWarningSubmit}\n            content={{\n              message: `${pluginId}.popUpWarning.warning.updateAllSettings`,\n            }}\n            popUpWarningType=\"danger\"\n            onConfirm={async () => {\n              await onConfirmSubmit();\n              toggleWarningSubmit();\n            }}\n          />\n        </form>\n      </Container>\n    </>\n  );\n};\n\nSettingsViewWrapper.defaultProps = {\n  displayedFields: [],\n  inputs: [],\n  initialData: {},\n  isEditSettings: false,\n  modifiedData: {},\n  name: '',\n  onConfirmReset: () => {},\n  onConfirmSubmit: async () => {},\n  onSubmit: () => {},\n  pluginHeaderProps: {\n    actions: [],\n    description: {\n      id: 'app.utils.defaultMessage',\n    },\n    title: {\n      id: 'app.utils.defaultMessage',\n      values: {},\n    },\n  },\n};\n\nSettingsViewWrapper.propTypes = {\n  children: PropTypes.node.isRequired,\n  displayedFields: PropTypes.array,\n  history: PropTypes.shape({\n    goBack: PropTypes.func.isRequired,\n  }).isRequired,\n  initialData: PropTypes.object,\n  inputs: PropTypes.array,\n  isEditSettings: PropTypes.bool,\n  isLoading: PropTypes.bool.isRequired,\n  modifiedData: PropTypes.object,\n  name: PropTypes.string,\n  onChange: PropTypes.func.isRequired,\n  onConfirmReset: PropTypes.func,\n  onConfirmSubmit: PropTypes.func,\n  onSubmit: PropTypes.func,\n  pluginHeaderProps: PropTypes.shape({\n    actions: PropTypes.array,\n    description: PropTypes.shape({\n      id: PropTypes.string,\n    }),\n    title: PropTypes.shape({\n      id: PropTypes.string,\n      values: PropTypes.object,\n    }),\n  }),\n};\n\nexport default withRouter(SettingsViewWrapper);\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js": "import { memo, useCallback, useEffect, useMemo, useRef, useReducer } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { get } from 'lodash';\nimport { request, useGlobalContext } from 'strapi-helper-plugin';\nimport PropTypes from 'prop-types';\nimport {\n  createDefaultForm,\n  formatComponentData,\n  getTrad,\n  removePasswordFieldsFromData,\n  removeFieldsFromClonedData,\n} from '../../utils';\nimport pluginId from '../../pluginId';\nimport { crudInitialState, crudReducer } from '../../sharedReducers';\nimport { getRequestUrl } from './utils';\n\n// This container is used to handle the CRUD\nconst CollectionTypeFormWrapper = ({ allLayoutData, children, from, slug, id, origin }) => {\n  const { emitEvent } = useGlobalContext();\n  const { push, replace } = useHistory();\n\n  const [\n    { componentsDataStructure, contentTypeDataStructure, data, isLoading, status },\n    dispatch,\n  ] = useReducer(crudReducer, crudInitialState);\n  const emitEventRef = useRef(emitEvent);\n\n  const isCreatingEntry = id === 'create';\n\n  const requestURL = useMemo(() => {\n    if (isCreatingEntry && !origin) {\n      return null;\n    }\n\n    return getRequestUrl(`${slug}/${origin || id}`);\n  }, [slug, id, isCreatingEntry, origin]);\n\n  const cleanClonedData = useCallback(\n    data => {\n      if (!origin) {\n        return data;\n      }\n\n      const cleaned = removeFieldsFromClonedData(\n        data,\n        allLayoutData.contentType,\n        allLayoutData.components\n      );\n\n      return cleaned;\n    },\n    [allLayoutData, origin]\n  );\n\n  const cleanReceivedData = useCallback(\n    data => {\n      const cleaned = removePasswordFieldsFromData(\n        data,\n        allLayoutData.contentType,\n        allLayoutData.components\n      );\n\n      return formatComponentData(cleaned, allLayoutData.contentType, allLayoutData.components);\n    },\n    [allLayoutData]\n  );\n\n  // SET THE DEFAULT LAYOUT the effect is applied when the slug changes\n  useEffect(() => {\n    const componentsDataStructure = Object.keys(allLayoutData.components).reduce((acc, current) => {\n      const defaultComponentForm = createDefaultForm(\n        get(allLayoutData, ['components', current, 'attributes'], {}),\n        allLayoutData.components\n      );\n\n      acc[current] = formatComponentData(\n        defaultComponentForm,\n        allLayoutData.components[current],\n        allLayoutData.components\n      );\n\n      return acc;\n    }, {});\n\n    const contentTypeDataStructure = createDefaultForm(\n      allLayoutData.contentType.attributes,\n      allLayoutData.components\n    );\n\n    dispatch({\n      type: 'SET_DATA_STRUCTURES',\n      componentsDataStructure,\n      contentTypeDataStructure: formatComponentData(\n        contentTypeDataStructure,\n        allLayoutData.contentType,\n        allLayoutData.components\n      ),\n    });\n  }, [allLayoutData]);\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    const getData = async signal => {\n      dispatch({ type: 'GET_DATA' });\n\n      try {\n        const data = await request(requestURL, { method: 'GET', signal });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data: cleanReceivedData(cleanClonedData(data)),\n        });\n      } catch (err) {\n        if (err.name === 'AbortError') {\n          return;\n        }\n\n        console.error(err);\n\n        const resStatus = get(err, 'response.status', null);\n\n        if (resStatus === 404) {\n          push(from);\n\n          return;\n        }\n\n        // Not allowed to read a document\n        if (resStatus === 403) {\n          strapi.notification.info(getTrad('permissions.not-allowed.update'));\n\n          push(from);\n        }\n      }\n    };\n\n    if (requestURL) {\n      getData(signal);\n    } else {\n      dispatch({ type: 'INIT_FORM' });\n    }\n\n    return () => {\n      abortController.abort();\n    };\n  }, [requestURL, push, from, cleanReceivedData, cleanClonedData]);\n\n  const displayErrors = useCallback(err => {\n    const errorPayload = err.response.payload;\n    console.error(errorPayload);\n\n    let errorMessage = get(errorPayload, ['message'], 'Bad Request');\n\n    // TODO handle errors correctly when back-end ready\n    if (Array.isArray(errorMessage)) {\n      errorMessage = get(errorMessage, ['0', 'messages', '0', 'id']);\n    }\n\n    if (typeof errorMessage === 'string') {\n      strapi.notification.error(errorMessage);\n    }\n  }, []);\n\n  const onDelete = useCallback(\n    async trackerProperty => {\n      try {\n        emitEventRef.current('willDeleteEntry', trackerProperty);\n\n        const response = await request(getRequestUrl(`${slug}/${id}`), {\n          method: 'DELETE',\n        });\n\n        strapi.notification.success(getTrad('success.record.delete'));\n\n        emitEventRef.current('didDeleteEntry', trackerProperty);\n\n        return Promise.resolve(response);\n      } catch (err) {\n        emitEventRef.current('didNotDeleteEntry', { error: err, ...trackerProperty });\n\n        return Promise.reject(err);\n      }\n    },\n    [id, slug]\n  );\n\n  const onDeleteSucceeded = useCallback(() => {\n    replace(from);\n  }, [from, replace]);\n\n  const onPost = useCallback(\n    async (body, trackerProperty) => {\n      const endPoint = getRequestUrl(slug);\n\n      try {\n        // Show a loading button in the EditView/Header.js && lock the app => no navigation\n        dispatch({ type: 'SET_STATUS', status: 'submit-pending' });\n\n        const response = await request(endPoint, { method: 'POST', body });\n\n        emitEventRef.current('didCreateEntry', trackerProperty);\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('success.record.save') },\n        });\n\n        dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(response) });\n        // Enable navigation and remove loaders\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n\n        replace(`/plugins/${pluginId}/collectionType/${slug}/${response.id}`);\n      } catch (err) {\n        emitEventRef.current('didNotCreateEntry', { error: err, trackerProperty });\n        displayErrors(err);\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      }\n    },\n    [cleanReceivedData, displayErrors, replace, slug]\n  );\n\n  const onPublish = useCallback(async () => {\n    try {\n      emitEventRef.current('willPublishEntry');\n      const endPoint = getRequestUrl(`${slug}/${id}/actions/publish`);\n\n      dispatch({ type: 'SET_STATUS', status: 'publish-pending' });\n\n      const data = await request(endPoint, { method: 'POST' });\n\n      emitEventRef.current('didPublishEntry');\n\n      dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(data) });\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: getTrad('success.record.publish') },\n      });\n    } catch (err) {\n      displayErrors(err);\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n    }\n  }, [cleanReceivedData, displayErrors, id, slug]);\n\n  const onPut = useCallback(\n    async (body, trackerProperty) => {\n      const endPoint = getRequestUrl(`${slug}/${id}`);\n\n      try {\n        emitEventRef.current('willEditEntry', trackerProperty);\n\n        dispatch({ type: 'SET_STATUS', status: 'submit-pending' });\n\n        const response = await request(endPoint, { method: 'PUT', body });\n\n        emitEventRef.current('didEditEntry', { trackerProperty });\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('success.record.save') },\n        });\n\n        dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(response) });\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      } catch (err) {\n        emitEventRef.current('didNotEditEntry', { error: err, trackerProperty });\n        displayErrors(err);\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      }\n    },\n    [cleanReceivedData, displayErrors, slug, id]\n  );\n\n  const onUnpublish = useCallback(async () => {\n    const endPoint = getRequestUrl(`${slug}/${id}/actions/unpublish`);\n\n    dispatch({ type: 'SET_STATUS', status: 'unpublish-pending' });\n\n    try {\n      emitEventRef.current('willUnpublishEntry');\n\n      const response = await request(endPoint, { method: 'POST' });\n\n      emitEventRef.current('didUnpublishEntry');\n      strapi.notification.success(getTrad('success.record.unpublish'));\n\n      dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(response) });\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n    } catch (err) {\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      displayErrors(err);\n    }\n  }, [cleanReceivedData, displayErrors, id, slug]);\n\n  return children({\n    componentsDataStructure,\n    contentTypeDataStructure,\n    data,\n    isCreatingEntry,\n    isLoadingForData: isLoading,\n    onDelete,\n    onDeleteSucceeded,\n    onPost,\n    onPublish,\n    onPut,\n    onUnpublish,\n    status,\n  });\n};\n\nCollectionTypeFormWrapper.defaultProps = {\n  from: '/',\n  origin: null,\n};\n\nCollectionTypeFormWrapper.propTypes = {\n  allLayoutData: PropTypes.exact({\n    components: PropTypes.object.isRequired,\n    contentType: PropTypes.exact({\n      apiID: PropTypes.string.isRequired,\n      attributes: PropTypes.object.isRequired,\n      info: PropTypes.object.isRequired,\n      isDisplayed: PropTypes.bool.isRequired,\n      kind: PropTypes.string.isRequired,\n      layouts: PropTypes.object.isRequired,\n      metadatas: PropTypes.object.isRequired,\n      options: PropTypes.object.isRequired,\n      settings: PropTypes.object.isRequired,\n      uid: PropTypes.string.isRequired,\n    }).isRequired,\n  }).isRequired,\n  children: PropTypes.func.isRequired,\n  from: PropTypes.string,\n  id: PropTypes.string.isRequired,\n  origin: PropTypes.string,\n  slug: PropTypes.string.isRequired,\n};\n\nexport default memo(CollectionTypeFormWrapper);\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/ComponentSetttingsView/index.js": "import React, { memo, useEffect, useMemo, useReducer } from 'react';\nimport { useParams } from 'react-router-dom';\nimport { CheckPagePermissions, LoadingIndicatorPage, request } from 'strapi-helper-plugin';\nimport { useSelector } from 'react-redux';\nimport { getRequestUrl, mergeMetasWithSchema } from '../../utils';\nimport { makeSelectModelAndComponentSchemas } from '../Main/selectors';\nimport pluginPermissions from '../../permissions';\nimport { crudInitialState, crudReducer } from '../../sharedReducers';\nimport EditSettingsView from '../EditSettingsView';\n\nconst ComponentSettingsView = () => {\n  const [{ isLoading, data: layout }, dispatch] = useReducer(crudReducer, crudInitialState);\n  const schemasSelector = useMemo(makeSelectModelAndComponentSchemas, []);\n  const { schemas } = useSelector(state => schemasSelector(state), []);\n  const { uid } = useParams();\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    const getData = async signal => {\n      try {\n        dispatch({ type: 'GET_DATA' });\n\n        const { data } = await request(getRequestUrl(`components/${uid}/configuration`), {\n          method: 'GET',\n          signal,\n        });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data: mergeMetasWithSchema(data, schemas, 'component'),\n        });\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    getData(signal);\n\n    return () => {\n      abortController.abort();\n    };\n  }, [uid, schemas]);\n\n  if (isLoading) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <CheckPagePermissions permissions={pluginPermissions.componentsConfigurations}>\n      <EditSettingsView components={layout.components} mainLayout={layout.component} slug={uid} />\n    </CheckPagePermissions>\n  );\n};\n\nexport default memo(ComponentSettingsView);\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/EditSettingsView/index.js": "import React, { useCallback, useMemo, useReducer, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { useHistory } from 'react-router-dom';\nimport { useSelector } from 'react-redux';\nimport { cloneDeep, flatMap, get, set, pick } from 'lodash';\nimport { request, useGlobalContext } from 'strapi-helper-plugin';\nimport { Inputs as Input } from '@buffetjs/custom';\nimport { FormattedMessage } from 'react-intl';\nimport pluginId from '../../pluginId';\nimport { getInjectedComponents, getRequestUrl } from '../../utils';\nimport FieldsReorder from '../../components/FieldsReorder';\nimport FormTitle from '../../components/FormTitle';\nimport LayoutTitle from '../../components/LayoutTitle';\nimport PopupForm from '../../components/PopupForm';\nimport SettingsViewWrapper from '../../components/SettingsViewWrapper';\nimport SortableList from '../../components/SortableList';\nimport { makeSelectModelAndComponentSchemas } from '../Main/selectors';\nimport LayoutDndProvider from '../LayoutDndProvider';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\nimport { createPossibleMainFieldsForModelsAndComponents, getInputProps } from './utils';\nimport { unformatLayout } from './utils/layout';\n\nconst EditSettingsView = ({ components, mainLayout, isContentTypeView, slug, updateLayout }) => {\n  const { push } = useHistory();\n  const { currentEnvironment, emitEvent, plugins } = useGlobalContext();\n\n  const [reducerState, dispatch] = useReducer(reducer, initialState, () =>\n    init(initialState, mainLayout, components)\n  );\n  const [isModalFormOpen, setIsModalFormOpen] = useState(false);\n  const [isDraggingSibling, setIsDraggingSibling] = useState(false);\n\n  const schemasSelector = useMemo(makeSelectModelAndComponentSchemas, []);\n  const { schemas } = useSelector(state => schemasSelector(state), []);\n\n  const { componentLayouts, initialData, metaToEdit, modifiedData, metaForm } = reducerState.toJS();\n\n  const componentsAndModelsPossibleMainFields = useMemo(() => {\n    return createPossibleMainFieldsForModelsAndComponents(schemas);\n  }, [schemas]);\n\n  const fieldsReorderClassName = isContentTypeView ? 'col-8' : 'col-12';\n\n  const attributes = useMemo(() => get(modifiedData, 'attributes', {}), [modifiedData]);\n  const editLayout = modifiedData.layouts.edit;\n  const relationsLayout = modifiedData.layouts.editRelations;\n  const editRelationsLayoutRemainingFields = useMemo(() => {\n    return Object.keys(attributes)\n      .filter(attr => attributes[attr].type === 'relation')\n      .filter(attr => relationsLayout.indexOf(attr) === -1);\n  }, [attributes, relationsLayout]);\n\n  const formToDisplay = useMemo(() => {\n    if (!metaToEdit) {\n      return [];\n    }\n\n    const associatedMetas = get(modifiedData, ['metadatas', metaToEdit, 'edit'], {});\n\n    return Object.keys(associatedMetas).filter(meta => meta !== 'visible');\n  }, [metaToEdit, modifiedData]);\n\n  const editLayoutRemainingFields = useMemo(() => {\n    const displayedFields = flatMap(modifiedData.layouts.edit, 'rowContent');\n\n    return Object.keys(modifiedData.attributes)\n      .filter(attr => {\n        if (!isContentTypeView) {\n          return true;\n        }\n\n        return get(modifiedData, ['attributes', attr, 'type'], '') !== 'relation';\n      })\n      .filter(attr => get(modifiedData, ['metadatas', attr, 'edit', 'visible'], false) === true)\n      .filter(attr => {\n        return displayedFields.findIndex(el => el.name === attr) === -1;\n      })\n      .sort();\n  }, [isContentTypeView, modifiedData]);\n\n  const getSelectedItemSelectOptions = useCallback(\n    formType => {\n      if (formType !== 'relation' && formType !== 'component') {\n        return [];\n      }\n\n      const targetKey = formType === 'component' ? 'component' : 'targetModel';\n      const key = get(modifiedData, ['attributes', metaToEdit, targetKey], '');\n\n      return get(componentsAndModelsPossibleMainFields, [key], []);\n    },\n\n    [metaToEdit, componentsAndModelsPossibleMainFields, modifiedData]\n  );\n\n  const handleChange = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: name.split('.'),\n      value,\n    });\n  };\n\n  const handleChangeMeta = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE_META',\n      keys: name.split('.'),\n      value,\n    });\n  };\n\n  const handleConfirm = async () => {\n    try {\n      const body = pick(cloneDeep(modifiedData), ['layouts', 'metadatas', 'settings']);\n\n      // We need to send the unformated edit layout\n      set(body, 'layouts.edit', unformatLayout(body.layouts.edit));\n\n      const requestURL = isContentTypeView\n        ? getRequestUrl(`content-types/${slug}/configuration`)\n        : getRequestUrl(`components/${slug}/configuration`);\n\n      const response = await request(requestURL, { method: 'PUT', body });\n\n      if (updateLayout) {\n        updateLayout(response.data);\n      }\n\n      dispatch({\n        type: 'SUBMIT_SUCCEEDED',\n      });\n\n      emitEvent('didEditEditSettings');\n    } catch (err) {\n      strapi.notification.error('notification.error');\n    }\n  };\n\n  const handleSubmitMetaForm = e => {\n    e.preventDefault();\n    dispatch({\n      type: 'SUBMIT_META_FORM',\n    });\n    toggleModalForm();\n  };\n\n  const moveItem = (dragIndex, hoverIndex, dragRowIndex, hoverRowIndex) => {\n    // Same row = just reorder\n    if (dragRowIndex === hoverRowIndex) {\n      dispatch({\n        type: 'REORDER_ROW',\n        dragRowIndex,\n        dragIndex,\n        hoverIndex,\n      });\n    } else {\n      dispatch({\n        type: 'REORDER_DIFF_ROW',\n        dragIndex,\n        hoverIndex,\n        dragRowIndex,\n        hoverRowIndex,\n      });\n    }\n  };\n\n  const moveRow = (dragRowIndex, hoverRowIndex) => {\n    dispatch({\n      type: 'MOVE_ROW',\n      dragRowIndex,\n      hoverRowIndex,\n    });\n  };\n\n  const toggleModalForm = () => {\n    setIsModalFormOpen(prevState => !prevState);\n  };\n\n  const renderForm = () =>\n    formToDisplay.map((meta, index) => {\n      const formType = get(attributes, [metaToEdit, 'type']);\n\n      if (formType === 'dynamiczone' && !['label', 'description'].includes(meta)) {\n        return null;\n      }\n\n      if ((formType === 'component' || formType === 'media') && meta !== 'label') {\n        return null;\n      }\n\n      if ((formType === 'json' || formType === 'boolean') && meta === 'placeholder') {\n        return null;\n      }\n\n      if (formType === 'richtext' && meta === 'editable') {\n        return null;\n      }\n\n      return (\n        <div className=\"col-6\" key={meta}>\n          <FormattedMessage\n            id={`${pluginId}.containers.SettingPage.editSettings.relation-field.description`}\n          >\n            {description => (\n              <FormattedMessage\n                id={get(getInputProps(meta), 'label.id', 'app.utils.defaultMessage')}\n              >\n                {label => (\n                  <Input\n                    autoFocus={index === 0}\n                    description={meta === 'mainField' ? description : ''}\n                    label={label}\n                    name={meta}\n                    type={getInputProps(meta).type}\n                    value={get(metaForm, meta, '')}\n                    onChange={handleChangeMeta}\n                    options={getSelectedItemSelectOptions(formType)}\n                  />\n                )}\n              </FormattedMessage>\n            )}\n          </FormattedMessage>\n        </div>\n      );\n    });\n\n  return (\n    <LayoutDndProvider\n      attributes={attributes}\n      buttonData={editLayoutRemainingFields}\n      componentLayouts={componentLayouts}\n      goTo={push}\n      isDraggingSibling={isDraggingSibling}\n      layout={editLayout}\n      metadatas={get(modifiedData, ['metadatas'], {})}\n      moveItem={moveItem}\n      moveRow={moveRow}\n      onAddData={name => {\n        dispatch({\n          type: 'ON_ADD_DATA',\n          name,\n        });\n      }}\n      relationsLayout={relationsLayout}\n      removeField={(rowIndex, fieldIndex) => {\n        dispatch({\n          type: 'REMOVE_FIELD',\n          rowIndex,\n          fieldIndex,\n        });\n      }}\n      setEditFieldToSelect={name => {\n        dispatch({\n          type: 'SET_FIELD_TO_EDIT',\n          name,\n        });\n        toggleModalForm();\n      }}\n      setIsDraggingSibling={setIsDraggingSibling}\n      selectedItemName={metaToEdit}\n    >\n      <SettingsViewWrapper\n        inputs={[\n          {\n            label: {\n              id: `${pluginId}.containers.SettingPage.editSettings.entry.title`,\n            },\n            description: {\n              id: `${pluginId}.containers.SettingPage.editSettings.entry.title.description`,\n            },\n            type: 'select',\n            name: 'settings.mainField',\n            customBootstrapClass: 'col-md-4',\n            selectOptions: ['id'],\n            didCheckErrors: false,\n            validations: {},\n          },\n        ]}\n        initialData={initialData}\n        isLoading={false}\n        modifiedData={modifiedData}\n        name={modifiedData.info.name}\n        onChange={handleChange}\n        onConfirmReset={() => {\n          dispatch({\n            type: 'ON_RESET',\n          });\n        }}\n        onConfirmSubmit={handleConfirm}\n        slug={slug}\n        isEditSettings\n      >\n        <div className=\"row\">\n          <LayoutTitle className={fieldsReorderClassName}>\n            <div\n              style={{\n                display: 'flex',\n                justifyContent: 'space-between',\n              }}\n            >\n              <div>\n                <FormTitle\n                  title={`${pluginId}.global.displayedFields`}\n                  description={`${pluginId}.containers.SettingPage.editSettings.description`}\n                />\n              </div>\n              <div\n                style={{\n                  marginTop: -6,\n                }}\n              >\n                {getInjectedComponents(\n                  'editSettingsView',\n                  'left.links',\n                  plugins,\n                  currentEnvironment,\n                  slug,\n                  push,\n                  {\n                    componentSlug: slug,\n                    type: isContentTypeView ? 'content-types' : 'components',\n                    modifiedData,\n                  }\n                )}\n              </div>\n            </div>\n          </LayoutTitle>\n          {isContentTypeView && (\n            <LayoutTitle className=\"col-4\">\n              <FormTitle\n                title={`${pluginId}.containers.SettingPage.relations`}\n                description={`${pluginId}.containers.SettingPage.editSettings.description`}\n              />\n            </LayoutTitle>\n          )}\n\n          <FieldsReorder className={fieldsReorderClassName} />\n          {isContentTypeView && (\n            <SortableList\n              addItem={name => {\n                dispatch({\n                  type: 'ADD_RELATION',\n                  name,\n                });\n              }}\n              buttonData={editRelationsLayoutRemainingFields}\n              moveItem={(dragIndex, hoverIndex) => {\n                dispatch({\n                  type: 'MOVE_RELATION',\n                  dragIndex,\n                  hoverIndex,\n                });\n              }}\n              removeItem={index => {\n                dispatch({\n                  type: 'REMOVE_RELATION',\n                  index,\n                });\n              }}\n            />\n          )}\n        </div>\n      </SettingsViewWrapper>\n\n      <PopupForm\n        headerId={`${pluginId}.containers.EditSettingsView.modal-form.edit-field`}\n        isOpen={isModalFormOpen}\n        onClosed={() => {\n          dispatch({\n            type: 'UNSET_FIELD_TO_EDIT',\n          });\n        }}\n        onSubmit={handleSubmitMetaForm}\n        onToggle={toggleModalForm}\n        renderForm={renderForm}\n        subHeaderContent={metaToEdit}\n        type={get(attributes, [metaToEdit, 'type'], '')}\n      />\n    </LayoutDndProvider>\n  );\n};\n\nEditSettingsView.defaultProps = {\n  isContentTypeView: false,\n  updateLayout: null,\n};\n\nEditSettingsView.propTypes = {\n  components: PropTypes.object.isRequired,\n  mainLayout: PropTypes.shape({\n    attributes: PropTypes.object.isRequired,\n    info: PropTypes.object.isRequired,\n    layouts: PropTypes.shape({\n      list: PropTypes.array.isRequired,\n      editRelations: PropTypes.array.isRequired,\n      edit: PropTypes.array.isRequired,\n    }).isRequired,\n    metadatas: PropTypes.object.isRequired,\n    options: PropTypes.object.isRequired,\n  }).isRequired,\n  isContentTypeView: PropTypes.bool,\n\n  slug: PropTypes.string.isRequired,\n  updateLayout: PropTypes.func,\n};\n\nexport default EditSettingsView;\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/EditView/DeleteLink/index.js": "import React, { memo, useState } from 'react';\nimport { useIntl } from 'react-intl';\nimport { get } from 'lodash';\nimport isEqual from 'react-fast-compare';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { Text } from '@buffetjs/core';\nimport { PopUpWarning } from 'strapi-helper-plugin';\nimport PropTypes from 'prop-types';\nimport pluginId from '../../../pluginId';\nimport { getTrad } from '../../../utils';\nimport { DeleteButton } from '../components';\nimport { connect, select } from './utils';\n\nconst DeleteLink = ({ isCreatingEntry, onDelete, onDeleteSucceeded, trackerProperty }) => {\n  const [showWarningDelete, setWarningDelete] = useState(false);\n  const [didDeleteEntry, setDidDeleteEntry] = useState(false);\n  const [isModalConfirmButtonLoading, setIsModalConfirmButtonLoading] = useState(false);\n  const { formatMessage } = useIntl();\n\n  const toggleWarningDelete = () => setWarningDelete(prevState => !prevState);\n\n  const handleConfirmDelete = async () => {\n    try {\n      // Show the loading state\n      setIsModalConfirmButtonLoading(true);\n\n      await onDelete(trackerProperty);\n\n      // This is used to perform action after the modal is closed\n      // so the transitions are smoother\n      // Actions will be performed in the handleClosed function\n      setDidDeleteEntry(true);\n    } catch (err) {\n      const errorMessage = get(\n        err,\n        'response.payload.message',\n        formatMessage({ id: `${pluginId}.error.record.delete` })\n      );\n      strapi.notification.error(errorMessage);\n    } finally {\n      setIsModalConfirmButtonLoading(false);\n      toggleWarningDelete();\n    }\n  };\n\n  const handleClosed = () => {\n    setDidDeleteEntry(false);\n\n    if (didDeleteEntry) {\n      onDeleteSucceeded();\n    }\n  };\n\n  if (isCreatingEntry) {\n    return null;\n  }\n\n  return (\n    <>\n      <li>\n        <DeleteButton onClick={toggleWarningDelete}>\n          <FontAwesomeIcon icon=\"trash-alt\" />\n          <Text lineHeight=\"22px\" color=\"lightOrange\">\n            {formatMessage({\n              id: getTrad('containers.Edit.delete-entry'),\n            })}\n          </Text>\n        </DeleteButton>\n      </li>\n      <PopUpWarning\n        isOpen={showWarningDelete}\n        toggleModal={toggleWarningDelete}\n        content={{\n          message: getTrad('popUpWarning.bodyMessage.contentType.delete'),\n        }}\n        popUpWarningType=\"danger\"\n        onConfirm={handleConfirmDelete}\n        onClosed={handleClosed}\n        isConfirmButtonLoading={isModalConfirmButtonLoading}\n      />\n    </>\n  );\n};\n\nDeleteLink.propTypes = {\n  isCreatingEntry: PropTypes.bool.isRequired,\n  onDelete: PropTypes.func.isRequired,\n  onDeleteSucceeded: PropTypes.func.isRequired,\n  trackerProperty: PropTypes.object.isRequired,\n};\n\nconst Memoized = memo(DeleteLink, isEqual);\n\nexport default connect(Memoized, select);\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/EditViewDataManagerProvider/index.js": "import React, { useCallback, useEffect, useMemo, useRef, useReducer } from 'react';\nimport { cloneDeep, get, isEmpty, isEqual, set } from 'lodash';\nimport PropTypes from 'prop-types';\nimport { Prompt, Redirect } from 'react-router-dom';\nimport { LoadingIndicatorPage, useGlobalContext, OverlayBlocker } from 'strapi-helper-plugin';\nimport EditViewDataManagerContext from '../../contexts/EditViewDataManager';\nimport { getTrad, removeKeyInObject } from '../../utils';\nimport reducer, { initialState } from './reducer';\nimport { cleanData, createYupSchema, getYupInnerErrors } from './utils';\n\nconst EditViewDataManagerProvider = ({\n  allLayoutData,\n  allowedActions: { canCreate, canRead, canUpdate },\n  children,\n  componentsDataStructure,\n  contentTypeDataStructure,\n  createActionAllowedFields,\n  from,\n  initialValues,\n  isCreatingEntry,\n  isLoadingForData,\n  isSingleType,\n  onPost,\n  onPublish,\n  onPut,\n  onUnpublish,\n  readActionAllowedFields,\n  // Not sure this is needed anymore\n  redirectToPreviousPage,\n  slug,\n  status,\n  updateActionAllowedFields,\n}) => {\n  const [reducerState, dispatch] = useReducer(reducer, initialState);\n  const {\n    formErrors,\n    initialData,\n    modifiedData,\n    modifiedDZName,\n    shouldCheckErrors,\n  } = reducerState.toJS();\n\n  const currentContentTypeLayout = get(allLayoutData, ['contentType'], {});\n\n  const hasDraftAndPublish = useMemo(() => {\n    return get(currentContentTypeLayout, ['options', 'draftAndPublish'], false);\n  }, [currentContentTypeLayout]);\n\n  const shouldNotRunValidations = useMemo(() => {\n    return hasDraftAndPublish && !initialData.published_at;\n  }, [hasDraftAndPublish, initialData.published_at]);\n\n  const { emitEvent, formatMessage } = useGlobalContext();\n  const emitEventRef = useRef(emitEvent);\n\n  const shouldRedirectToHomepageWhenCreatingEntry = useMemo(() => {\n    if (isLoadingForData) {\n      return false;\n    }\n\n    if (!isCreatingEntry) {\n      return false;\n    }\n\n    if (canCreate === false) {\n      return true;\n    }\n\n    return false;\n  }, [isCreatingEntry, canCreate, isLoadingForData]);\n\n  const shouldRedirectToHomepageWhenEditingEntry = useMemo(() => {\n    if (isLoadingForData) {\n      return false;\n    }\n\n    if (isCreatingEntry) {\n      return false;\n    }\n\n    if (canRead === false && canUpdate === false) {\n      return true;\n    }\n\n    return false;\n  }, [isLoadingForData, isCreatingEntry, canRead, canUpdate]);\n\n  // TODO check this effect if it is really needed (not prio)\n  useEffect(() => {\n    if (!isLoadingForData) {\n      checkFormErrors();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [shouldCheckErrors]);\n\n  useEffect(() => {\n    if (shouldRedirectToHomepageWhenEditingEntry) {\n      strapi.notification.info(getTrad('permissions.not-allowed.update'));\n    }\n  }, [shouldRedirectToHomepageWhenEditingEntry]);\n\n  useEffect(() => {\n    if (shouldRedirectToHomepageWhenCreatingEntry) {\n      strapi.notification.info(getTrad('permissions.not-allowed.create'));\n    }\n  }, [shouldRedirectToHomepageWhenCreatingEntry]);\n\n  useEffect(() => {\n    dispatch({\n      type: 'SET_DEFAULT_DATA_STRUCTURES',\n      componentsDataStructure,\n      contentTypeDataStructure,\n    });\n  }, [componentsDataStructure, contentTypeDataStructure]);\n\n  useEffect(() => {\n    dispatch({\n      type: 'INIT_FORM',\n      initialValues,\n    });\n  }, [initialValues]);\n\n  const addComponentToDynamicZone = useCallback((keys, componentUid, shouldCheckErrors = false) => {\n    emitEventRef.current('didAddComponentToDynamicZone');\n\n    dispatch({\n      type: 'ADD_COMPONENT_TO_DYNAMIC_ZONE',\n      keys: keys.split('.'),\n      componentUid,\n      shouldCheckErrors,\n    });\n  }, []);\n\n  const addNonRepeatableComponentToField = useCallback((keys, componentUid) => {\n    dispatch({\n      type: 'ADD_NON_REPEATABLE_COMPONENT_TO_FIELD',\n      keys: keys.split('.'),\n      componentUid,\n    });\n  }, []);\n\n  const addRelation = useCallback(({ target: { name, value } }) => {\n    dispatch({\n      type: 'ADD_RELATION',\n      keys: name.split('.'),\n      value,\n    });\n  }, []);\n\n  const addRepeatableComponentToField = useCallback(\n    (keys, componentUid, shouldCheckErrors = false) => {\n      dispatch({\n        type: 'ADD_REPEATABLE_COMPONENT_TO_FIELD',\n        keys: keys.split('.'),\n        componentUid,\n        shouldCheckErrors,\n      });\n    },\n    []\n  );\n\n  const yupSchema = useMemo(() => {\n    const options = { isCreatingEntry, isDraft: shouldNotRunValidations, isFromComponent: false };\n\n    return createYupSchema(\n      currentContentTypeLayout,\n      {\n        components: allLayoutData.components || {},\n      },\n      options\n    );\n  }, [\n    allLayoutData.components,\n    currentContentTypeLayout,\n    isCreatingEntry,\n    shouldNotRunValidations,\n  ]);\n\n  const checkFormErrors = useCallback(\n    async (dataToSet = {}) => {\n      let errors = {};\n      const updatedData = cloneDeep(modifiedData);\n\n      if (!isEmpty(updatedData)) {\n        set(updatedData, dataToSet.path, dataToSet.value);\n      }\n\n      try {\n        // Validate the form using yup\n        await yupSchema.validate(updatedData, { abortEarly: false });\n      } catch (err) {\n        errors = getYupInnerErrors(err);\n\n        if (modifiedDZName) {\n          errors = Object.keys(errors).reduce((acc, current) => {\n            const dzName = current.split('.')[0];\n\n            if (dzName !== modifiedDZName) {\n              acc[current] = errors[current];\n            }\n\n            return acc;\n          }, {});\n        }\n      }\n\n      dispatch({\n        type: 'SET_FORM_ERRORS',\n        errors,\n      });\n    },\n    [modifiedDZName, modifiedData, yupSchema]\n  );\n\n  const handleChange = useCallback(\n    ({ target: { name, value, type } }, shouldSetInitialValue = false) => {\n      let inputValue = value;\n\n      // Empty string is not a valid date,\n      // Set the date to null when it's empty\n      if (type === 'date' && value === '') {\n        inputValue = null;\n      }\n\n      if (type === 'password' && !value) {\n        dispatch({\n          type: 'REMOVE_PASSWORD_FIELD',\n          keys: name.split('.'),\n        });\n\n        return;\n      }\n\n      // Allow to reset enum\n      if (type === 'select-one' && value === '') {\n        inputValue = null;\n      }\n\n      // Allow to reset number input\n      if (type === 'number' && value === '') {\n        inputValue = null;\n      }\n\n      dispatch({\n        type: 'ON_CHANGE',\n        keys: name.split('.'),\n        value: inputValue,\n        shouldSetInitialValue,\n      });\n    },\n    []\n  );\n\n  const createFormData = useCallback(\n    data => {\n      // First we need to remove the added keys needed for the dnd\n      const preparedData = removeKeyInObject(cloneDeep(data), '__temp_key__');\n      // Then we need to apply our helper\n      const cleanedData = cleanData(\n        preparedData,\n        currentContentTypeLayout,\n        allLayoutData.components\n      );\n\n      return cleanedData;\n    },\n    [allLayoutData.components, currentContentTypeLayout]\n  );\n\n  const trackerProperty = useMemo(() => {\n    if (!hasDraftAndPublish) {\n      return {};\n    }\n\n    return shouldNotRunValidations ? { status: 'draft' } : {};\n  }, [hasDraftAndPublish, shouldNotRunValidations]);\n\n  const handleSubmit = useCallback(\n    async e => {\n      e.preventDefault();\n      let errors = {};\n\n      // First validate the form\n      try {\n        await yupSchema.validate(modifiedData, { abortEarly: false });\n\n        const formData = createFormData(modifiedData);\n\n        if (isCreatingEntry) {\n          onPost(formData, trackerProperty);\n        } else {\n          onPut(formData, trackerProperty);\n        }\n      } catch (err) {\n        console.error('ValidationError');\n        console.error(err);\n\n        errors = getYupInnerErrors(err);\n      }\n\n      dispatch({\n        type: 'SET_FORM_ERRORS',\n        errors,\n      });\n    },\n    [createFormData, isCreatingEntry, modifiedData, onPost, onPut, trackerProperty, yupSchema]\n  );\n\n  const handlePublish = useCallback(async () => {\n    // Create yup schema here's we need to apply all the validations\n    const schema = createYupSchema(\n      currentContentTypeLayout,\n      {\n        components: get(allLayoutData, 'components', {}),\n      },\n      { isCreatingEntry, isDraft: false, isFromComponent: false }\n    );\n    let errors = {};\n\n    try {\n      // Validate the form using yup\n      await schema.validate(modifiedData, { abortEarly: false });\n\n      onPublish();\n    } catch (err) {\n      console.error('ValidationError');\n      console.error(err);\n\n      errors = getYupInnerErrors(err);\n    }\n\n    dispatch({\n      type: 'SET_FORM_ERRORS',\n      errors,\n    });\n  }, [allLayoutData, currentContentTypeLayout, isCreatingEntry, modifiedData, onPublish]);\n\n  const shouldCheckDZErrors = useCallback(\n    dzName => {\n      const doesDZHaveError = Object.keys(formErrors).some(key => key.split('.')[0] === dzName);\n      const shouldCheckErrors = !isEmpty(formErrors) && doesDZHaveError;\n\n      return shouldCheckErrors;\n    },\n    [formErrors]\n  );\n\n  const moveComponentDown = useCallback(\n    (dynamicZoneName, currentIndex) => {\n      emitEventRef.current('changeComponentsOrder');\n\n      dispatch({\n        type: 'MOVE_COMPONENT_DOWN',\n        dynamicZoneName,\n        currentIndex,\n        shouldCheckErrors: shouldCheckDZErrors(dynamicZoneName),\n      });\n    },\n    [shouldCheckDZErrors]\n  );\n\n  const moveComponentUp = useCallback(\n    (dynamicZoneName, currentIndex) => {\n      emitEventRef.current('changeComponentsOrder');\n\n      dispatch({\n        type: 'MOVE_COMPONENT_UP',\n        dynamicZoneName,\n        currentIndex,\n        shouldCheckErrors: shouldCheckDZErrors(dynamicZoneName),\n      });\n    },\n    [shouldCheckDZErrors]\n  );\n\n  const moveComponentField = useCallback((pathToComponent, dragIndex, hoverIndex) => {\n    dispatch({\n      type: 'MOVE_COMPONENT_FIELD',\n      pathToComponent,\n      dragIndex,\n      hoverIndex,\n    });\n  }, []);\n\n  const moveRelation = useCallback((dragIndex, overIndex, name) => {\n    dispatch({\n      type: 'MOVE_FIELD',\n      dragIndex,\n      overIndex,\n      keys: name.split('.'),\n    });\n  }, []);\n\n  const onRemoveRelation = useCallback(keys => {\n    dispatch({\n      type: 'REMOVE_RELATION',\n      keys,\n    });\n  }, []);\n\n  const removeComponentFromDynamicZone = useCallback(\n    (dynamicZoneName, index) => {\n      emitEventRef.current('removeComponentFromDynamicZone');\n\n      dispatch({\n        type: 'REMOVE_COMPONENT_FROM_DYNAMIC_ZONE',\n        dynamicZoneName,\n        index,\n        shouldCheckErrors: shouldCheckDZErrors(dynamicZoneName),\n      });\n    },\n    [shouldCheckDZErrors]\n  );\n\n  const removeComponentFromField = useCallback((keys, componentUid) => {\n    dispatch({\n      type: 'REMOVE_COMPONENT_FROM_FIELD',\n      keys: keys.split('.'),\n      componentUid,\n    });\n  }, []);\n\n  const removeRepeatableField = useCallback((keys, componentUid) => {\n    dispatch({\n      type: 'REMOVE_REPEATABLE_FIELD',\n      keys: keys.split('.'),\n      componentUid,\n    });\n  }, []);\n\n  const triggerFormValidation = useCallback(() => {\n    dispatch({\n      type: 'TRIGGER_FORM_VALIDATION',\n    });\n  }, []);\n\n  const overlayBlockerParams = useMemo(\n    () => ({\n      children: <div />,\n      noGradient: true,\n    }),\n    []\n  );\n\n  // Redirect the user to the homepage if he is not allowed to create a document\n  if (shouldRedirectToHomepageWhenCreatingEntry) {\n    return <Redirect to=\"/\" />;\n  }\n\n  // Redirect the user to the previous page if he is not allowed to read/update a document\n  if (shouldRedirectToHomepageWhenEditingEntry) {\n    return <Redirect to={from} />;\n  }\n\n  return (\n    <EditViewDataManagerContext.Provider\n      value={{\n        addComponentToDynamicZone,\n        addNonRepeatableComponentToField,\n        addRelation,\n        addRepeatableComponentToField,\n        allLayoutData,\n        checkFormErrors,\n        createActionAllowedFields,\n        formErrors,\n        hasDraftAndPublish,\n        initialData,\n        isCreatingEntry,\n        isSingleType,\n        shouldNotRunValidations,\n        status,\n        layout: currentContentTypeLayout,\n        modifiedData,\n        moveComponentDown,\n        moveComponentField,\n        moveComponentUp,\n        moveRelation,\n        onChange: handleChange,\n        onPublish: handlePublish,\n        onUnpublish,\n        onRemoveRelation,\n        readActionAllowedFields,\n        redirectToPreviousPage,\n        removeComponentFromDynamicZone,\n        removeComponentFromField,\n        removeRepeatableField,\n        slug,\n        triggerFormValidation,\n        updateActionAllowedFields,\n      }}\n    >\n      <>\n        <OverlayBlocker\n          key=\"overlayBlocker\"\n          isOpen={status !== 'resolved'}\n          {...overlayBlockerParams}\n        />\n        {isLoadingForData ? (\n          <LoadingIndicatorPage />\n        ) : (\n          <>\n            <Prompt\n              when={!isEqual(modifiedData, initialData)}\n              message={formatMessage({ id: 'global.prompt.unsaved' })}\n            />\n            <form onSubmit={handleSubmit}>{children}</form>\n          </>\n        )}\n      </>\n    </EditViewDataManagerContext.Provider>\n  );\n};\n\nEditViewDataManagerProvider.defaultProps = {\n  from: '/',\n  redirectToPreviousPage: () => {},\n};\n\nEditViewDataManagerProvider.propTypes = {\n  allLayoutData: PropTypes.object.isRequired,\n  allowedActions: PropTypes.object.isRequired,\n  children: PropTypes.arrayOf(PropTypes.element).isRequired,\n  componentsDataStructure: PropTypes.object.isRequired,\n  contentTypeDataStructure: PropTypes.object.isRequired,\n  createActionAllowedFields: PropTypes.array.isRequired,\n  from: PropTypes.string,\n  initialValues: PropTypes.object.isRequired,\n  isCreatingEntry: PropTypes.bool.isRequired,\n  isLoadingForData: PropTypes.bool.isRequired,\n  isSingleType: PropTypes.bool.isRequired,\n  onPost: PropTypes.func.isRequired,\n  onPublish: PropTypes.func.isRequired,\n  onPut: PropTypes.func.isRequired,\n  onUnpublish: PropTypes.func.isRequired,\n  readActionAllowedFields: PropTypes.array.isRequired,\n  redirectToPreviousPage: PropTypes.func,\n  slug: PropTypes.string.isRequired,\n  status: PropTypes.string.isRequired,\n  updateActionAllowedFields: PropTypes.array.isRequired,\n};\n\nexport default EditViewDataManagerProvider;\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/ListSettingsView/index.js": "import React, { memo, useMemo, useReducer, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { get, pick } from 'lodash';\nimport { request, useGlobalContext } from 'strapi-helper-plugin';\nimport { FormattedMessage, useIntl } from 'react-intl';\nimport { useDrop } from 'react-dnd';\nimport { DropdownItem } from 'reactstrap';\nimport { Inputs as Input } from '@buffetjs/custom';\nimport pluginId from '../../pluginId';\nimport { checkIfAttributeIsDisplayable, ItemTypes, getRequestUrl } from '../../utils';\nimport PopupForm from '../../components/PopupForm';\nimport SettingsViewWrapper from '../../components/SettingsViewWrapper';\nimport SortWrapper from '../../components/SortWrapper';\nimport LayoutDndProvider from '../LayoutDndProvider';\nimport Label from './Label';\nimport MenuDropdown from './MenuDropdown';\nimport DropdownButton from './DropdownButton';\nimport DragWrapper from './DragWrapper';\nimport Toggle from './Toggle';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\nimport forms from './forms.json';\n\nconst ListSettingsView = ({ layout, slug, updateLayout }) => {\n  const [reducerState, dispatch] = useReducer(reducer, initialState, () =>\n    init(initialState, layout)\n  );\n  const [isOpen, setIsOpen] = useState(false);\n  const [isModalFormOpen, setIsModalFormOpen] = useState(false);\n  const [isDraggingSibling, setIsDraggingSibling] = useState(false);\n  const { formatMessage } = useIntl();\n  const { emitEvent } = useGlobalContext();\n  const toggleModalForm = () => setIsModalFormOpen(prevState => !prevState);\n  const { labelForm, labelToEdit, initialData, modifiedData } = reducerState.toJS();\n  const attributes = useMemo(() => {\n    return get(modifiedData, ['attributes'], {});\n  }, [modifiedData]);\n\n  const getName = useMemo(() => {\n    return get(modifiedData, ['info', 'name'], '');\n  }, [modifiedData]);\n\n  const displayedFields = useMemo(() => {\n    return get(modifiedData, ['layouts', 'list'], []);\n  }, [modifiedData]);\n\n  const listRemainingFields = useMemo(() => {\n    const metadatas = get(modifiedData, ['metadatas'], {});\n\n    return Object.keys(metadatas)\n      .filter(key => {\n        return checkIfAttributeIsDisplayable(get(attributes, key, {}));\n      })\n      .filter(field => {\n        return !displayedFields.includes(field);\n      })\n      .sort();\n  }, [displayedFields, attributes, modifiedData]);\n\n  const handleClickEditLabel = labelToEdit => {\n    dispatch({\n      type: 'SET_LABEL_TO_EDIT',\n      labelToEdit,\n    });\n    toggleModalForm();\n  };\n\n  const handleClosed = () => {\n    dispatch({\n      type: 'UNSET_LABEL_TO_EDIT',\n    });\n  };\n\n  const handleChange = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: name,\n      value: name === 'settings.pageSize' ? parseInt(value, 10) : value,\n    });\n  };\n\n  const handleChangeEditLabel = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE_LABEL_METAS',\n      name,\n      value,\n    });\n  };\n\n  const handleConfirm = async () => {\n    try {\n      const body = pick(modifiedData, ['layouts', 'settings', 'metadatas']);\n\n      const response = await request(getRequestUrl(`content-types/${slug}/configuration`), {\n        method: 'PUT',\n        body,\n      });\n\n      updateLayout(response.data);\n\n      dispatch({\n        type: 'SUBMIT_SUCCEEDED',\n      });\n      emitEvent('didEditListSettings');\n    } catch (err) {\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  const move = (originalIndex, atIndex) => {\n    dispatch({\n      type: 'MOVE_FIELD',\n      originalIndex,\n      atIndex,\n    });\n  };\n\n  const [, drop] = useDrop({ accept: ItemTypes.FIELD });\n\n  const renderForm = () => {\n    const type = get(attributes, [labelToEdit, 'type'], 'text');\n    const relationType = get(attributes, [labelToEdit, 'relationType']);\n    let shouldDisplaySortToggle = !['media', 'relation'].includes(type);\n    const label = formatMessage({ id: `${pluginId}.form.Input.label` });\n    const description = formatMessage({ id: `${pluginId}.form.Input.label.inputDescription` });\n\n    if (['oneWay', 'oneToOne', 'manyToOne'].includes(relationType)) {\n      shouldDisplaySortToggle = true;\n    }\n\n    return (\n      <>\n        <div className=\"col-6\" style={{ marginBottom: 4 }}>\n          <Input\n            description={description}\n            label={label}\n            type=\"text\"\n            name=\"label\"\n            onBlur={() => {}}\n            value={get(labelForm, 'label', '')}\n            onChange={handleChangeEditLabel}\n          />\n        </div>\n        {shouldDisplaySortToggle && (\n          <div className=\"col-6\" style={{ marginBottom: 4 }}>\n            <FormattedMessage id={`${pluginId}.form.Input.sort.field`}>\n              {label => (\n                <Input\n                  label={label}\n                  type=\"bool\"\n                  name=\"sortable\"\n                  value={get(labelForm, 'sortable', false)}\n                  onChange={handleChangeEditLabel}\n                />\n              )}\n            </FormattedMessage>\n          </div>\n        )}\n      </>\n    );\n  };\n\n  return (\n    <LayoutDndProvider\n      isDraggingSibling={isDraggingSibling}\n      setIsDraggingSibling={setIsDraggingSibling}\n    >\n      <SettingsViewWrapper\n        displayedFields={displayedFields}\n        inputs={forms}\n        isLoading={false}\n        initialData={initialData}\n        modifiedData={modifiedData}\n        onChange={handleChange}\n        onConfirmReset={() => {\n          dispatch({\n            type: 'ON_RESET',\n          });\n        }}\n        onConfirmSubmit={handleConfirm}\n        name={getName}\n      >\n        <DragWrapper>\n          <div className=\"row\">\n            <div className=\"col-12\">\n              <SortWrapper\n                ref={drop}\n                style={{\n                  display: 'flex',\n                  width: '100%',\n                }}\n              >\n                {displayedFields.map((item, index) => {\n                  const label = get(modifiedData, ['metadatas', item, 'list', 'label'], '');\n\n                  return (\n                    <Label\n                      count={displayedFields.length}\n                      key={item}\n                      index={index}\n                      isDraggingSibling={isDraggingSibling}\n                      label={label}\n                      move={move}\n                      name={item}\n                      onClick={handleClickEditLabel}\n                      onRemove={e => {\n                        e.stopPropagation();\n\n                        if (displayedFields.length === 1) {\n                          strapi.notification.toggle({\n                            type: 'info',\n                            message: { id: `${pluginId}.notification.info.minimumFields` },\n                          });\n                        } else {\n                          dispatch({\n                            type: 'REMOVE_FIELD',\n                            index,\n                          });\n                        }\n                      }}\n                      selectedItem={labelToEdit}\n                      setIsDraggingSibling={setIsDraggingSibling}\n                    />\n                  );\n                })}\n              </SortWrapper>\n            </div>\n          </div>\n          <DropdownButton\n            isOpen={isOpen}\n            toggle={() => {\n              if (listRemainingFields.length > 0) {\n                setIsOpen(prevState => !prevState);\n              }\n            }}\n            direction=\"down\"\n            style={{\n              position: 'absolute',\n              top: 11,\n              right: 10,\n            }}\n          >\n            <Toggle disabled={listRemainingFields.length === 0} />\n            <MenuDropdown>\n              {listRemainingFields.map(item => (\n                <DropdownItem\n                  key={item}\n                  onClick={() => {\n                    dispatch({\n                      type: 'ADD_FIELD',\n                      item,\n                    });\n                  }}\n                >\n                  {item}\n                </DropdownItem>\n              ))}\n            </MenuDropdown>\n          </DropdownButton>\n        </DragWrapper>\n      </SettingsViewWrapper>\n      <PopupForm\n        headerId={`${pluginId}.containers.ListSettingsView.modal-form.edit-label`}\n        isOpen={isModalFormOpen}\n        onClosed={handleClosed}\n        onSubmit={e => {\n          e.preventDefault();\n          toggleModalForm();\n          dispatch({\n            type: 'SUBMIT_LABEL_FORM',\n          });\n        }}\n        onToggle={toggleModalForm}\n        renderForm={renderForm}\n        subHeaderContent={labelToEdit}\n        type={get(attributes, [labelToEdit, 'type'], 'text')}\n      />\n    </LayoutDndProvider>\n  );\n};\n\nListSettingsView.propTypes = {\n  layout: PropTypes.shape({\n    uid: PropTypes.string.isRequired,\n    settings: PropTypes.object.isRequired,\n    metadatas: PropTypes.object.isRequired,\n    options: PropTypes.object.isRequired,\n    attributes: PropTypes.object.isRequired,\n  }).isRequired,\n  slug: PropTypes.string.isRequired,\n  updateLayout: PropTypes.func.isRequired,\n};\n\nexport default memo(ListSettingsView);\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/ListView/index.js": "import React, { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport { bindActionCreators, compose } from 'redux';\nimport { get, isEmpty } from 'lodash';\nimport { FormattedMessage, useIntl } from 'react-intl';\nimport { useHistory, useLocation } from 'react-router-dom';\nimport { Header } from '@buffetjs/custom';\nimport isEqual from 'react-fast-compare';\nimport { stringify } from 'qs';\nimport {\n  PopUpWarning,\n  request,\n  CheckPermissions,\n  useGlobalContext,\n  useUserPermissions,\n} from 'strapi-helper-plugin';\nimport pluginId from '../../pluginId';\nimport pluginPermissions from '../../permissions';\nimport { useQueryParams } from '../../hooks';\nimport {\n  formatFiltersFromQuery,\n  generatePermissionsObject,\n  getRequestUrl,\n  getTrad,\n} from '../../utils';\nimport Container from '../../components/Container';\nimport CustomTable from '../../components/CustomTable';\nimport FilterPicker from '../../components/FilterPicker';\nimport Search from '../../components/Search';\nimport ListViewProvider from '../ListViewProvider';\nimport { AddFilterCta, FilterIcon, Wrapper } from './components';\nimport FieldPicker from './FieldPicker';\nimport Filter from './Filter';\nimport Footer from './Footer';\nimport {\n  getData,\n  getDataSucceeded,\n  onChangeBulk,\n  onChangeBulkSelectall,\n  onDeleteDataError,\n  onDeleteDataSucceeded,\n  onDeleteSeveralDataSucceeded,\n  resetProps,\n  setModalLoadingState,\n  toggleModalDelete,\n  toggleModalDeleteAll,\n  setLayout,\n  onChangeListHeaders,\n  onResetListHeaders,\n} from './actions';\nimport makeSelectListView from './selectors';\n\nimport { getAllAllowedHeaders, getFirstSortableHeader } from './utils';\n\n/* eslint-disable react/no-array-index-key */\n\nfunction ListView({\n  didDeleteData,\n  entriesToDelete,\n  onChangeBulk,\n  onChangeBulkSelectall,\n  onDeleteDataError,\n  onDeleteDataSucceeded,\n  onDeleteSeveralDataSucceeded,\n  setModalLoadingState,\n  showWarningDelete,\n  showModalConfirmButtonLoading,\n  showWarningDeleteAll,\n  toggleModalDelete,\n  toggleModalDeleteAll,\n  data,\n  displayedHeaders,\n  getData,\n  getDataSucceeded,\n  isLoading,\n  layout,\n  onChangeListHeaders,\n  onResetListHeaders,\n  pagination: { total },\n  resetProps,\n  setLayout,\n  slug,\n}) {\n  const {\n    contentType: {\n      attributes,\n      metadatas,\n      settings: {\n        defaultSortBy,\n        defaultSortOrder,\n        bulkable: isBulkable,\n        filterable: isFilterable,\n        searchable: isSearchable,\n        pageSize: defaultPageSize,\n      },\n    },\n  } = layout;\n\n  const { emitEvent } = useGlobalContext();\n  const emitEventRef = useRef(emitEvent);\n  const viewPermissions = useMemo(() => generatePermissionsObject(slug), [slug]);\n  const {\n    isLoading: isLoadingForPermissions,\n    allowedActions: { canCreate, canRead, canUpdate, canDelete },\n  } = useUserPermissions(viewPermissions);\n  const defaultSort = `${defaultSortBy}:${defaultSortOrder}`;\n  const initParams = useMemo(() => ({ page: 1, pageSize: defaultPageSize, _sort: defaultSort }), [\n    defaultPageSize,\n    defaultSort,\n  ]);\n  const [{ query, rawQuery }, setQuery] = useQueryParams(initParams);\n\n  const { pathname } = useLocation();\n  const { push } = useHistory();\n  const { formatMessage } = useIntl();\n\n  const [isFilterPickerOpen, setFilterPickerState] = useState(false);\n  const [idToDelete, setIdToDelete] = useState(null);\n  const contentType = layout.contentType;\n  const hasDraftAndPublish = get(contentType, 'options.draftAndPublish', false);\n  const allAllowedHeaders = useMemo(() => getAllAllowedHeaders(attributes), [attributes]);\n\n  const filters = useMemo(() => {\n    return formatFiltersFromQuery(query);\n  }, [query]);\n\n  const _sort = query._sort;\n  const _q = query._q || '';\n\n  const label = contentType.info.label;\n\n  const params = useMemo(() => {\n    return rawQuery || `?${stringify(initParams, { encode: false })}`;\n  }, [initParams, rawQuery]);\n\n  const firstSortableHeader = useMemo(() => getFirstSortableHeader(displayedHeaders), [\n    displayedHeaders,\n  ]);\n\n  useEffect(() => {\n    setLayout(layout);\n    setFilterPickerState(false);\n\n    return () => {\n      resetProps();\n    };\n  }, [layout, setLayout, resetProps]);\n\n  // Using a ref to avoid requests being fired multiple times on slug on change\n  // We need it because the hook as mulitple dependencies so it may run before the permissions have checked\n  const requestUrlRef = useRef('');\n\n  const fetchData = useCallback(\n    async (endPoint, abortSignal = false) => {\n      getData();\n      const signal = abortSignal || new AbortController().signal;\n\n      try {\n        const { results, pagination } = await request(endPoint, { method: 'GET', signal });\n\n        getDataSucceeded(pagination, results);\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          console.error(err);\n          strapi.notification.error(getTrad('error.model.fetch'));\n        }\n      }\n    },\n    [getData, getDataSucceeded]\n  );\n\n  const handleChangeListLabels = useCallback(\n    ({ name, value }) => {\n      // Display a notification if trying to remove the last displayed field\n\n      if (value && displayedHeaders.length === 1) {\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'content-manager.notification.error.displayedFields' },\n        });\n      } else {\n        emitEventRef.current('didChangeDisplayedFields');\n\n        onChangeListHeaders({ name, value });\n      }\n    },\n    [displayedHeaders, onChangeListHeaders]\n  );\n\n  const handleConfirmDeleteAllData = useCallback(async () => {\n    try {\n      setModalLoadingState();\n\n      await request(getRequestUrl(`collection-types/${slug}/actions/bulkDelete`), {\n        method: 'POST',\n        body: { ids: entriesToDelete },\n      });\n\n      onDeleteSeveralDataSucceeded();\n      emitEventRef.current('didBulkDeleteEntries');\n    } catch (err) {\n      strapi.notification.error(`${pluginId}.error.record.delete`);\n    }\n  }, [entriesToDelete, onDeleteSeveralDataSucceeded, slug, setModalLoadingState]);\n\n  const handleConfirmDeleteData = useCallback(async () => {\n    try {\n      let trackerProperty = {};\n\n      if (hasDraftAndPublish) {\n        const dataToDelete = data.find(obj => obj.id.toString() === idToDelete.toString());\n        const isDraftEntry = isEmpty(dataToDelete.published_at);\n        const status = isDraftEntry ? 'draft' : 'published';\n\n        trackerProperty = { status };\n      }\n\n      emitEventRef.current('willDeleteEntry', trackerProperty);\n      setModalLoadingState();\n\n      await request(getRequestUrl(`collection-types/${slug}/${idToDelete}`), {\n        method: 'DELETE',\n      });\n\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: `${pluginId}.success.record.delete` },\n      });\n\n      // Close the modal and refetch data\n      onDeleteDataSucceeded();\n      emitEventRef.current('didDeleteEntry', trackerProperty);\n    } catch (err) {\n      const errorMessage = get(\n        err,\n        'response.payload.message',\n        formatMessage({ id: `${pluginId}.error.record.delete` })\n      );\n\n      strapi.notification.toggle({\n        type: 'warning',\n        message: errorMessage,\n      });\n      // Close the modal\n      onDeleteDataError();\n    }\n  }, [\n    hasDraftAndPublish,\n    setModalLoadingState,\n    slug,\n    idToDelete,\n    onDeleteDataSucceeded,\n    data,\n    formatMessage,\n    onDeleteDataError,\n  ]);\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    const shouldSendRequest = !isLoadingForPermissions && canRead;\n    const requestUrl = `/${pluginId}/collection-types/${slug}${params}`;\n\n    if (shouldSendRequest && requestUrl.includes(requestUrlRef.current)) {\n      fetchData(requestUrl, signal);\n    }\n\n    return () => {\n      requestUrlRef.current = slug;\n      abortController.abort();\n    };\n  }, [isLoadingForPermissions, canRead, getData, slug, params, getDataSucceeded, fetchData]);\n\n  const handleClickDelete = id => {\n    setIdToDelete(id);\n    toggleModalDelete();\n  };\n\n  const handleModalClose = useCallback(() => {\n    if (didDeleteData) {\n      const requestUrl = `/${pluginId}/collection-types/${slug}${params}`;\n\n      fetchData(requestUrl);\n    }\n  }, [fetchData, didDeleteData, slug, params]);\n\n  const toggleFilterPickerState = useCallback(() => {\n    setFilterPickerState(prevState => {\n      if (!prevState) {\n        emitEventRef.current('willFilterEntries');\n      }\n\n      return !prevState;\n    });\n  }, []);\n\n  const headerAction = useMemo(() => {\n    if (!canCreate) {\n      return [];\n    }\n\n    return [\n      {\n        label: formatMessage(\n          {\n            id: 'content-manager.containers.List.addAnEntry',\n          },\n          {\n            entity: label || 'Content Manager',\n          }\n        ),\n        onClick: () => {\n          const trackerProperty = hasDraftAndPublish ? { status: 'draft' } : {};\n\n          emitEventRef.current('willCreateEntry', trackerProperty);\n          push({\n            pathname: `${pathname}/create`,\n          });\n        },\n        color: 'primary',\n        type: 'button',\n        icon: true,\n        style: {\n          paddingLeft: 15,\n          paddingRight: 15,\n          fontWeight: 600,\n        },\n      },\n    ];\n  }, [label, pathname, canCreate, formatMessage, hasDraftAndPublish, push]);\n\n  const headerProps = useMemo(() => {\n    /* eslint-disable indent */\n    return {\n      title: {\n        label: label || 'Content Manager',\n      },\n      content: canRead\n        ? formatMessage(\n            {\n              id:\n                total > 1\n                  ? `${pluginId}.containers.List.pluginHeaderDescription`\n                  : `${pluginId}.containers.List.pluginHeaderDescription.singular`,\n            },\n            { label: total }\n          )\n        : null,\n      actions: headerAction,\n    };\n  }, [total, headerAction, label, canRead, formatMessage]);\n\n  const handleToggleModalDeleteAll = e => {\n    emitEventRef.current('willBulkDeleteEntries');\n    toggleModalDeleteAll(e);\n  };\n\n  return (\n    <>\n      <ListViewProvider\n        _q={_q}\n        _sort={_sort}\n        data={data}\n        entriesToDelete={entriesToDelete}\n        filters={filters}\n        firstSortableHeader={firstSortableHeader}\n        label={label}\n        onChangeBulk={onChangeBulk}\n        onChangeBulkSelectall={onChangeBulkSelectall}\n        onClickDelete={handleClickDelete}\n        slug={slug}\n        toggleModalDeleteAll={handleToggleModalDeleteAll}\n        setQuery={setQuery}\n      >\n        <FilterPicker\n          contentType={contentType}\n          filters={filters}\n          isOpen={isFilterPickerOpen}\n          metadatas={metadatas}\n          name={label}\n          toggleFilterPickerState={toggleFilterPickerState}\n          setQuery={setQuery}\n          slug={slug}\n        />\n        <Container className=\"container-fluid\">\n          {!isFilterPickerOpen && <Header {...headerProps} isLoading={isLoading && canRead} />}\n          {isSearchable && canRead && (\n            <Search changeParams={setQuery} initValue={_q} model={label} value={_q} />\n          )}\n          {canRead && (\n            <Wrapper>\n              <div className=\"row\" style={{ marginBottom: '5px' }}>\n                <div className=\"col-10\">\n                  <div className=\"row\" style={{ marginLeft: 0, marginRight: 0 }}>\n                    {isFilterable && (\n                      <>\n                        <AddFilterCta type=\"button\" onClick={toggleFilterPickerState}>\n                          <FilterIcon />\n                          <FormattedMessage id=\"app.utils.filters\" />\n                        </AddFilterCta>\n                        {filters.map(({ filter: filterName, name, value }, key) => (\n                          <Filter\n                            contentType={contentType}\n                            filterName={filterName}\n                            filters={filters}\n                            index={key}\n                            key={key}\n                            metadatas={metadatas}\n                            name={name}\n                            toggleFilterPickerState={toggleFilterPickerState}\n                            isFilterPickerOpen={isFilterPickerOpen}\n                            setQuery={setQuery}\n                            value={value}\n                          />\n                        ))}\n                      </>\n                    )}\n                  </div>\n                </div>\n                <div className=\"col-2\">\n                  <CheckPermissions permissions={pluginPermissions.collectionTypesConfigurations}>\n                    <FieldPicker\n                      displayedHeaders={displayedHeaders}\n                      items={allAllowedHeaders}\n                      onChange={handleChangeListLabels}\n                      onClickReset={onResetListHeaders}\n                      slug={slug}\n                    />\n                  </CheckPermissions>\n                </div>\n              </div>\n              <div className=\"row\" style={{ paddingTop: '12px' }}>\n                <div className=\"col-12\">\n                  <CustomTable\n                    data={data}\n                    canCreate={canCreate}\n                    canDelete={canDelete}\n                    canUpdate={canUpdate}\n                    displayedHeaders={displayedHeaders}\n                    hasDraftAndPublish={hasDraftAndPublish}\n                    isBulkable={isBulkable}\n                    setQuery={setQuery}\n                    showLoader={isLoading}\n                  />\n                  <Footer count={total} params={query} onChange={setQuery} />\n                </div>\n              </div>\n            </Wrapper>\n          )}\n        </Container>\n        <PopUpWarning\n          isOpen={showWarningDelete}\n          toggleModal={toggleModalDelete}\n          content={{\n            message: getTrad('popUpWarning.bodyMessage.contentType.delete'),\n          }}\n          onConfirm={handleConfirmDeleteData}\n          popUpWarningType=\"danger\"\n          onClosed={handleModalClose}\n          isConfirmButtonLoading={showModalConfirmButtonLoading}\n        />\n        <PopUpWarning\n          isOpen={showWarningDeleteAll}\n          toggleModal={toggleModalDeleteAll}\n          content={{\n            message: getTrad(\n              `popUpWarning.bodyMessage.contentType.delete${\n                entriesToDelete.length > 1 ? '.all' : ''\n              }`\n            ),\n          }}\n          popUpWarningType=\"danger\"\n          onConfirm={handleConfirmDeleteAllData}\n          onClosed={handleModalClose}\n          isConfirmButtonLoading={showModalConfirmButtonLoading}\n        />\n      </ListViewProvider>\n    </>\n  );\n}\n\nListView.propTypes = {\n  displayedHeaders: PropTypes.array.isRequired,\n  data: PropTypes.array.isRequired,\n  didDeleteData: PropTypes.bool.isRequired,\n  entriesToDelete: PropTypes.array.isRequired,\n  layout: PropTypes.exact({\n    components: PropTypes.object.isRequired,\n    contentType: PropTypes.shape({\n      attributes: PropTypes.object.isRequired,\n      metadatas: PropTypes.object.isRequired,\n      info: PropTypes.shape({ label: PropTypes.string.isRequired }).isRequired,\n      layouts: PropTypes.shape({\n        list: PropTypes.array.isRequired,\n        editRelations: PropTypes.array,\n      }).isRequired,\n      options: PropTypes.object.isRequired,\n      settings: PropTypes.object.isRequired,\n    }).isRequired,\n  }).isRequired,\n  isLoading: PropTypes.bool.isRequired,\n  getData: PropTypes.func.isRequired,\n  getDataSucceeded: PropTypes.func.isRequired,\n  onChangeBulk: PropTypes.func.isRequired,\n  onChangeBulkSelectall: PropTypes.func.isRequired,\n  onChangeListHeaders: PropTypes.func.isRequired,\n  onDeleteDataError: PropTypes.func.isRequired,\n  onDeleteDataSucceeded: PropTypes.func.isRequired,\n  onDeleteSeveralDataSucceeded: PropTypes.func.isRequired,\n  onResetListHeaders: PropTypes.func.isRequired,\n  pagination: PropTypes.shape({ total: PropTypes.number.isRequired }).isRequired,\n  resetProps: PropTypes.func.isRequired,\n  setModalLoadingState: PropTypes.func.isRequired,\n  showModalConfirmButtonLoading: PropTypes.bool.isRequired,\n  showWarningDelete: PropTypes.bool.isRequired,\n  showWarningDeleteAll: PropTypes.bool.isRequired,\n  slug: PropTypes.string.isRequired,\n  toggleModalDelete: PropTypes.func.isRequired,\n  toggleModalDeleteAll: PropTypes.func.isRequired,\n  setLayout: PropTypes.func.isRequired,\n};\n\nconst mapStateToProps = makeSelectListView();\n\nexport function mapDispatchToProps(dispatch) {\n  return bindActionCreators(\n    {\n      getData,\n      getDataSucceeded,\n      onChangeBulk,\n      onChangeBulkSelectall,\n      onChangeListHeaders,\n      onDeleteDataError,\n      onDeleteDataSucceeded,\n      onDeleteSeveralDataSucceeded,\n      onResetListHeaders,\n      resetProps,\n      setModalLoadingState,\n      toggleModalDelete,\n      toggleModalDeleteAll,\n      setLayout,\n    },\n    dispatch\n  );\n}\nconst withConnect = connect(mapStateToProps, mapDispatchToProps);\n\nexport default compose(withConnect)(memo(ListView, isEqual));\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/Main/index.js": "import React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport { bindActionCreators, compose } from 'redux';\nimport { Switch, Route } from 'react-router-dom';\nimport {\n  CheckPagePermissions,\n  LoadingIndicatorPage,\n  NotFound,\n  request,\n} from 'strapi-helper-plugin';\nimport { DndProvider } from 'react-dnd';\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport pluginId from '../../pluginId';\nimport pluginPermissions from '../../permissions';\nimport { getRequestUrl } from '../../utils';\nimport DragLayer from '../../components/DragLayer';\nimport CollectionTypeRecursivePath from '../CollectionTypeRecursivePath';\nimport ComponentSettingsView from '../ComponentSetttingsView';\nimport SingleTypeRecursivePath from '../SingleTypeRecursivePath';\nimport { getData, getDataSucceeded, resetProps } from './actions';\nimport makeSelectMain from './selectors';\n\nfunction Main({ getData, getDataSucceeded, isLoading, resetProps }) {\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    const fetchData = async signal => {\n      getData();\n\n      try {\n        const [{ data: components }, { data: models }] = await Promise.all(\n          ['components', 'content-types'].map(endPoint =>\n            request(getRequestUrl(endPoint), { method: 'GET', signal })\n          )\n        );\n\n        getDataSucceeded(models, components);\n      } catch (err) {\n        console.error(err);\n        strapi.notification.error('notification.error');\n      }\n    };\n\n    fetchData(signal);\n\n    return () => {\n      abortController.abort();\n      resetProps();\n    };\n  }, [getData, getDataSucceeded, resetProps]);\n\n  if (isLoading) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <DndProvider backend={HTML5Backend}>\n      <DragLayer />\n\n      <Switch>\n        <Route path={`/plugins/${pluginId}/components/:uid/configurations/edit`}>\n          <CheckPagePermissions permissions={pluginPermissions.componentsConfigurations}>\n            <ComponentSettingsView />\n          </CheckPagePermissions>\n        </Route>\n        <Route\n          path={`/plugins/${pluginId}/collectionType/:slug`}\n          component={CollectionTypeRecursivePath}\n        />\n        <Route path={`/plugins/${pluginId}/singleType/:slug`} component={SingleTypeRecursivePath} />\n        <Route path=\"\" component={NotFound} />\n      </Switch>\n    </DndProvider>\n  );\n}\n\nMain.propTypes = {\n  getData: PropTypes.func.isRequired,\n  getDataSucceeded: PropTypes.func.isRequired,\n  isLoading: PropTypes.bool.isRequired,\n  resetProps: PropTypes.func.isRequired,\n};\n\nconst mapStateToProps = makeSelectMain();\n\nexport function mapDispatchToProps(dispatch) {\n  return bindActionCreators(\n    {\n      getData,\n      getDataSucceeded,\n      resetProps,\n    },\n    dispatch\n  );\n}\nconst withConnect = connect(mapStateToProps, mapDispatchToProps);\n\nexport default compose(withConnect)(Main);\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js": "import { memo, useCallback, useEffect, useRef, useReducer, useState } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { get } from 'lodash';\nimport { request, useGlobalContext } from 'strapi-helper-plugin';\nimport PropTypes from 'prop-types';\nimport {\n  createDefaultForm,\n  formatComponentData,\n  getTrad,\n  removePasswordFieldsFromData,\n} from '../../utils';\nimport { crudInitialState, crudReducer } from '../../sharedReducers';\nimport { getRequestUrl } from './utils';\n\n// This container is used to handle the CRUD\nconst SingleTypeFormWrapper = ({ allLayoutData, children, from, slug }) => {\n  const { emitEvent } = useGlobalContext();\n  const { push } = useHistory();\n  const emitEventRef = useRef(emitEvent);\n  const [isCreatingEntry, setIsCreatingEntry] = useState(true);\n\n  const [\n    { componentsDataStructure, contentTypeDataStructure, data, isLoading, status },\n    dispatch,\n  ] = useReducer(crudReducer, crudInitialState);\n\n  const cleanReceivedData = useCallback(\n    data => {\n      const cleaned = removePasswordFieldsFromData(\n        data,\n        allLayoutData.contentType,\n        allLayoutData.components\n      );\n\n      // This is needed in order to add a unique id for the repeatable components, in order to make the reorder easier\n      return formatComponentData(cleaned, allLayoutData.contentType, allLayoutData.components);\n    },\n    [allLayoutData]\n  );\n\n  useEffect(() => {\n    const componentsDataStructure = Object.keys(allLayoutData.components).reduce((acc, current) => {\n      const defaultComponentForm = createDefaultForm(\n        get(allLayoutData, ['components', current, 'attributes'], {}),\n        allLayoutData.components\n      );\n\n      acc[current] = formatComponentData(\n        defaultComponentForm,\n        allLayoutData.components[current],\n        allLayoutData.components\n      );\n\n      return acc;\n    }, {});\n\n    const contentTypeDataStructure = createDefaultForm(\n      allLayoutData.contentType.attributes,\n      allLayoutData.components\n    );\n\n    dispatch({\n      type: 'SET_DATA_STRUCTURES',\n      componentsDataStructure,\n      contentTypeDataStructure: formatComponentData(\n        contentTypeDataStructure,\n        allLayoutData.contentType,\n        allLayoutData.components\n      ),\n    });\n  }, [allLayoutData]);\n\n  // Check if creation mode or editing mode\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    const fetchData = async signal => {\n      dispatch({ type: 'GET_DATA' });\n\n      setIsCreatingEntry(true);\n\n      try {\n        const data = await request(getRequestUrl(slug), { method: 'GET', signal });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data: cleanReceivedData(data),\n        });\n        setIsCreatingEntry(false);\n      } catch (err) {\n        if (err.name === 'AbortError') {\n          return;\n        }\n\n        const responseStatus = get(err, 'response.status', null);\n\n        // Creating a single type\n        if (responseStatus === 404) {\n          dispatch({ type: 'INIT_FORM' });\n        }\n\n        if (responseStatus === 403) {\n          strapi.notification.info(getTrad('permissions.not-allowed.update'));\n\n          push(from);\n        }\n      }\n    };\n\n    fetchData(signal);\n\n    return () => abortController.abort();\n  }, [cleanReceivedData, from, push, slug]);\n\n  const displayErrors = useCallback(err => {\n    const errorPayload = err.response.payload;\n    console.error(errorPayload);\n\n    let errorMessage = get(errorPayload, ['message'], 'Bad Request');\n\n    // TODO handle errors correctly when back-end ready\n    if (Array.isArray(errorMessage)) {\n      errorMessage = get(errorMessage, ['0', 'messages', '0', 'id']);\n    }\n\n    if (typeof errorMessage === 'string') {\n      strapi.notification.error(errorMessage);\n    }\n  }, []);\n\n  const onDelete = useCallback(\n    async trackerProperty => {\n      try {\n        emitEventRef.current('willDeleteEntry', trackerProperty);\n\n        const response = await request(getRequestUrl(`${slug}`), {\n          method: 'DELETE',\n        });\n\n        strapi.notification.success(getTrad('success.record.delete'));\n\n        emitEventRef.current('didDeleteEntry', trackerProperty);\n\n        return Promise.resolve(response);\n      } catch (err) {\n        emitEventRef.current('didNotDeleteEntry', { error: err, ...trackerProperty });\n\n        return Promise.reject(err);\n      }\n    },\n    [slug]\n  );\n\n  const onDeleteSucceeded = useCallback(() => {\n    setIsCreatingEntry(true);\n\n    dispatch({ type: 'INIT_FORM' });\n  }, []);\n\n  const onPost = useCallback(\n    async (body, trackerProperty) => {\n      const endPoint = getRequestUrl(slug);\n\n      try {\n        dispatch({ type: 'SET_STATUS', status: 'submit-pending' });\n\n        const response = await request(endPoint, { method: 'PUT', body });\n\n        emitEventRef.current('didCreateEntry', trackerProperty);\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('success.record.save') },\n        });\n\n        dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(response) });\n        setIsCreatingEntry(false);\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      } catch (err) {\n        emitEventRef.current('didNotCreateEntry', { error: err, trackerProperty });\n\n        displayErrors(err);\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      }\n    },\n    [cleanReceivedData, displayErrors, slug]\n  );\n  const onPublish = useCallback(async () => {\n    try {\n      emitEventRef.current('willPublishEntry');\n      const endPoint = getRequestUrl(`${slug}/actions/publish`);\n\n      dispatch({ type: 'SET_STATUS', status: 'publish-pending' });\n\n      const data = await request(endPoint, { method: 'POST' });\n\n      emitEventRef.current('didPublishEntry');\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: getTrad('success.record.publish') },\n      });\n\n      dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(data) });\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n    } catch (err) {\n      displayErrors(err);\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n    }\n  }, [cleanReceivedData, displayErrors, slug]);\n\n  const onPut = useCallback(\n    async (body, trackerProperty) => {\n      const endPoint = getRequestUrl(`${slug}`);\n\n      try {\n        emitEventRef.current('willEditEntry', trackerProperty);\n\n        dispatch({ type: 'SET_STATUS', status: 'submit-pending' });\n\n        const response = await request(endPoint, { method: 'PUT', body });\n\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('success.record.save') },\n        });\n\n        emitEventRef.current('didEditEntry', { trackerProperty });\n\n        dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(response) });\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      } catch (err) {\n        displayErrors(err);\n\n        emitEventRef.current('didNotEditEntry', { error: err, trackerProperty });\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      }\n    },\n    [cleanReceivedData, displayErrors, slug]\n  );\n\n  // The publish and unpublish method could be refactored but let's leave the duplication for now\n  const onUnpublish = useCallback(async () => {\n    const endPoint = getRequestUrl(`${slug}/actions/unpublish`);\n    dispatch({ type: 'SET_STATUS', status: 'unpublish-pending' });\n\n    try {\n      emitEventRef.current('willUnpublishEntry');\n\n      const response = await request(endPoint, { method: 'POST' });\n\n      emitEventRef.current('didUnpublishEntry');\n      strapi.notification.success(getTrad('success.record.unpublish'));\n\n      dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(response) });\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n    } catch (err) {\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      displayErrors(err);\n    }\n  }, [cleanReceivedData, displayErrors, slug]);\n\n  return children({\n    componentsDataStructure,\n    contentTypeDataStructure,\n    data,\n    isCreatingEntry,\n    isLoadingForData: isLoading,\n    onDelete,\n    onDeleteSucceeded,\n    onPost,\n    onPublish,\n    onPut,\n    onUnpublish,\n    status,\n  });\n};\n\nSingleTypeFormWrapper.defaultProps = {\n  from: '/',\n};\n\nSingleTypeFormWrapper.propTypes = {\n  allLayoutData: PropTypes.shape({\n    components: PropTypes.object.isRequired,\n    contentType: PropTypes.object.isRequired,\n  }).isRequired,\n  children: PropTypes.func.isRequired,\n  from: PropTypes.string,\n  slug: PropTypes.string.isRequired,\n};\n\nexport default memo(SingleTypeFormWrapper);\n",
    "packages/strapi-plugin-content-manager/admin/src/hooks/useFetchContentTypeLayout/index.js": "import { useCallback, useEffect, useMemo, useReducer, useRef } from 'react';\nimport { useSelector } from 'react-redux';\nimport { request } from 'strapi-helper-plugin';\nimport formatLayouts from './utils/formatLayouts';\nimport reducer, { initialState } from './reducer';\nimport { makeSelectModelAndComponentSchemas } from '../../containers/Main/selectors';\n\nconst useFetchContentTypeLayout = contentTypeUID => {\n  const [{ error, isLoading, layout, layouts }, dispatch] = useReducer(reducer, initialState);\n  const schemasSelector = useMemo(makeSelectModelAndComponentSchemas, []);\n  const { schemas } = useSelector(state => schemasSelector(state), []);\n  const isMounted = useRef(true);\n\n  const getData = useCallback(\n    async (uid, abortSignal = false) => {\n      let signal = abortSignal || new AbortController().signal;\n\n      if (layouts[uid]) {\n        dispatch({ type: 'SET_LAYOUT_FROM_STATE', uid });\n\n        return;\n      }\n      dispatch({ type: 'GET_DATA' });\n\n      try {\n        const { data } = await request(`/content-manager/content-types/${uid}/configuration`, {\n          method: 'GET',\n          signal,\n        });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data: formatLayouts(data, schemas),\n        });\n      } catch (error) {\n        if (isMounted.current && error.name !== 'AbortError') {\n          dispatch({ type: 'GET_DATA_ERROR', error });\n        }\n      }\n    },\n    [layouts, schemas]\n  );\n\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    getData(contentTypeUID, signal);\n\n    return () => {\n      abortController.abort();\n    };\n  }, [contentTypeUID, getData]);\n\n  const updateLayout = useCallback(\n    newLayout => {\n      dispatch({\n        type: 'UPDATE_LAYOUT',\n        newLayout: formatLayouts({ contentType: newLayout, components: {} }, schemas),\n      });\n    },\n    [schemas]\n  );\n\n  return {\n    error,\n    isLoading,\n    layout,\n    updateLayout,\n  };\n};\n\nexport default useFetchContentTypeLayout;\n",
    "packages/strapi-plugin-content-manager/config/functions/bootstrap.js": "'use strict';\n\nconst { getService } = require('../../utils');\n\nmodule.exports = async () => {\n  await getService('components').syncConfigurations();\n  await getService('content-types').syncConfigurations();\n  await getService('permission').registerPermissions();\n};\n",
    "packages/strapi-plugin-content-manager/config/policies/routing.js": "'use strict';\n\nconst _ = require('lodash');\n\nmodule.exports = async (ctx, next) => {\n  const { model } = ctx.params;\n\n  const ct = strapi.contentTypes[model];\n\n  if (!ct) {\n    return ctx.send({ error: 'contentType.notFound' }, 404);\n  }\n\n  const target = ct.plugin === 'admin' ? strapi.admin : strapi.plugins[ct.plugin];\n\n  const actionPath = ['config', 'layout', ct.modelName, 'actions', ctx.request.route.action];\n\n  if (_.has(target, actionPath)) {\n    const [controller, action] = _.get(target, actionPath, []).split('.');\n\n    if (controller && action) {\n      return await target.controllers[controller.toLowerCase()][action](ctx);\n    }\n  }\n\n  await next();\n};\n",
    "packages/strapi-plugin-content-manager/controllers/collection-types.js": "'use strict';\n\nconst { has, pipe, prop, pick } = require('lodash/fp');\nconst { MANY_RELATIONS } = require('strapi-utils').relations.constants;\n\nconst {\n  getService,\n  wrapBadRequest,\n  setCreatorFields,\n  pickWritableAttributes,\n} = require('../utils');\nconst { validateBulkDeleteInput, validatePagination } = require('./validation');\n\nmodule.exports = {\n  async find(ctx) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { query } = ctx.request;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const method = has('_q', query) ? 'searchWithRelationCounts' : 'findWithRelationCounts';\n\n    const permissionQuery = permissionChecker.buildReadQuery(query);\n\n    const { results, pagination } = await entityManager[method](permissionQuery, model);\n\n    ctx.body = {\n      results: results.map(entity => permissionChecker.sanitizeOutput(entity)),\n      pagination,\n    };\n  },\n\n  async findOne(ctx) {\n    const { userAbility } = ctx.state;\n    const { model, id } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await entityManager.findOneWithCreatorRoles(id, model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.read(entity)) {\n      return ctx.forbidden();\n    }\n\n    ctx.body = permissionChecker.sanitizeOutput(entity);\n  },\n\n  async create(ctx) {\n    const { userAbility, user } = ctx.state;\n    const { model } = ctx.params;\n    const { body } = ctx.request;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.create()) {\n      return ctx.forbidden();\n    }\n\n    const pickWritables = pickWritableAttributes({ model });\n    const pickPermittedFields = permissionChecker.sanitizeCreateInput;\n    const setCreator = setCreatorFields({ user });\n\n    const sanitizeFn = pipe([pickWritables, pickPermittedFields, setCreator]);\n\n    await wrapBadRequest(async () => {\n      const entity = await entityManager.create(sanitizeFn(body), model);\n      ctx.body = permissionChecker.sanitizeOutput(entity);\n\n      await strapi.telemetry.send('didCreateFirstContentTypeEntry', { model });\n    })();\n  },\n\n  async update(ctx) {\n    const { userAbility, user } = ctx.state;\n    const { id, model } = ctx.params;\n    const { body } = ctx.request;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.update()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await entityManager.findOneWithCreatorRoles(id, model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.update(entity)) {\n      return ctx.forbidden();\n    }\n\n    const pickWritables = pickWritableAttributes({ model });\n    const pickPermittedFields = permissionChecker.sanitizeUpdateInput(entity);\n    const setCreator = setCreatorFields({ user, isEdition: true });\n\n    const sanitizeFn = pipe([pickWritables, pickPermittedFields, setCreator]);\n\n    await wrapBadRequest(async () => {\n      const updatedEntity = await entityManager.update(entity, sanitizeFn(body), model);\n\n      ctx.body = permissionChecker.sanitizeOutput(updatedEntity);\n    })();\n  },\n\n  async delete(ctx) {\n    const { userAbility } = ctx.state;\n    const { id, model } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.delete()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await entityManager.findOneWithCreatorRoles(id, model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.delete(entity)) {\n      return ctx.forbidden();\n    }\n\n    const result = await entityManager.delete(entity, model);\n\n    ctx.body = permissionChecker.sanitizeOutput(result);\n  },\n\n  async publish(ctx) {\n    const { userAbility } = ctx.state;\n    const { id, model } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.publish()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await entityManager.findOneWithCreatorRoles(id, model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.publish(entity)) {\n      return ctx.forbidden();\n    }\n\n    const result = await entityManager.publish(entity, model);\n\n    ctx.body = permissionChecker.sanitizeOutput(result);\n  },\n\n  async unpublish(ctx) {\n    const { userAbility } = ctx.state;\n    const { id, model } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.unpublish()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await entityManager.findOneWithCreatorRoles(id, model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.unpublish(entity)) {\n      return ctx.forbidden();\n    }\n\n    const result = await entityManager.unpublish(entity, model);\n\n    ctx.body = permissionChecker.sanitizeOutput(result);\n  },\n\n  async bulkDelete(ctx) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { query, body } = ctx.request;\n    const { ids } = body;\n\n    await validateBulkDeleteInput(body);\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.delete()) {\n      return ctx.forbidden();\n    }\n\n    const permissionQuery = permissionChecker.buildDeleteQuery(query);\n\n    const idsWhereClause = { [`id_in`]: ids };\n    const params = {\n      ...permissionQuery,\n      _where: [idsWhereClause].concat(permissionQuery._where || {}),\n    };\n\n    const results = await entityManager.findAndDelete(params, model);\n\n    ctx.body = results.map(result => permissionChecker.sanitizeOutput(result));\n  },\n\n  async previewManyRelations(ctx) {\n    const { userAbility } = ctx.state;\n    const { model, id, targetField } = ctx.params;\n    const { pageSize = 10, page = 1 } = ctx.request.query;\n\n    validatePagination({ page, pageSize });\n\n    const contentTypeService = getService('content-types');\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const modelDef = strapi.getModel(model);\n    const assoc = modelDef.associations.find(a => a.alias === targetField);\n\n    if (!assoc || !MANY_RELATIONS.includes(assoc.nature)) {\n      return ctx.badRequest('Invalid target field');\n    }\n\n    const entity = await entityManager.findOneWithCreatorRoles(id, model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.read(entity, targetField)) {\n      return ctx.forbidden();\n    }\n\n    let relationList;\n    if (assoc.nature === 'manyWay') {\n      const populatedEntity = await entityManager.findOne(id, model, [targetField]);\n      const relationsListIds = populatedEntity[targetField].map(prop('id'));\n      relationList = await entityManager.findPage(\n        { page, pageSize, id_in: relationsListIds },\n        assoc.targetUid\n      );\n    } else {\n      const assocModel = strapi.db.getModelByAssoc(assoc);\n      relationList = await entityManager.findPage(\n        { page, pageSize, [`${assoc.via}.${assocModel.primaryKey}`]: entity.id },\n        assoc.targetUid\n      );\n    }\n\n    const config = await contentTypeService.findConfiguration({ uid: model });\n    const mainField = prop(['metadatas', assoc.alias, 'edit', 'mainField'], config);\n\n    ctx.body = {\n      pagination: relationList.pagination,\n      results: relationList.results.map(pick(['id', modelDef.primaryKey, mainField])),\n    };\n  },\n};\n",
    "packages/strapi-plugin-content-manager/controllers/components.js": "'use strict';\n\nconst { getService } = require('../utils');\nconst { createModelConfigurationSchema } = require('./validation');\n\nmodule.exports = {\n  findComponents(ctx) {\n    const components = getService('components').findAllComponents();\n    const { toDto } = getService('data-mapper');\n\n    ctx.body = { data: components.map(toDto) };\n  },\n\n  async findComponentConfiguration(ctx) {\n    const { uid } = ctx.params;\n\n    const componentService = getService('components');\n\n    const component = componentService.findComponent(uid);\n\n    if (!component) {\n      return ctx.notFound('component.notFound');\n    }\n\n    const configuration = await componentService.findConfiguration(component);\n    const componentsConfigurations = await componentService.findComponentsConfigurations(component);\n\n    ctx.body = {\n      data: {\n        component: configuration,\n        components: componentsConfigurations,\n      },\n    };\n  },\n\n  async updateComponentConfiguration(ctx) {\n    const { uid } = ctx.params;\n    const { body } = ctx.request;\n\n    const componentService = getService('components');\n\n    const component = componentService.findComponent(uid);\n\n    if (!component) {\n      return ctx.notFound('component.notFound');\n    }\n\n    let input;\n    try {\n      input = await createModelConfigurationSchema(component).validate(body, {\n        abortEarly: false,\n        stripUnknown: true,\n        strict: true,\n      });\n    } catch (error) {\n      return ctx.badRequest(null, {\n        name: 'validationError',\n        errors: error.errors,\n      });\n    }\n\n    const newConfiguration = await componentService.updateConfiguration(component, input);\n\n    ctx.body = { data: newConfiguration };\n  },\n};\n",
    "packages/strapi-plugin-content-manager/controllers/content-types.js": "'use strict';\n\nconst { has, assoc, mapValues, prop } = require('lodash/fp');\nconst { getService } = require('../utils');\nconst { createModelConfigurationSchema, validateKind } = require('./validation');\n\nconst hasEditMainField = has('edit.mainField');\nconst getEditMainField = prop('edit.mainField');\nconst assocListMainField = assoc('list.mainField');\n\nconst assocMainField = metadata =>\n  hasEditMainField(metadata) ? assocListMainField(getEditMainField(metadata), metadata) : metadata;\n\nmodule.exports = {\n  async findContentTypes(ctx) {\n    const { kind } = ctx.query;\n\n    try {\n      await validateKind(kind);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    const contentTypes = getService('content-types').findContentTypesByKind(kind);\n    const { toDto } = getService('data-mapper');\n\n    ctx.body = { data: contentTypes.map(toDto) };\n  },\n\n  async findContentTypeConfiguration(ctx) {\n    const { uid } = ctx.params;\n\n    const contentTypeService = getService('content-types');\n\n    const contentType = await contentTypeService.findContentType(uid);\n\n    if (!contentType) {\n      return ctx.notFound('contentType.notFound');\n    }\n\n    const configuration = await contentTypeService.findConfiguration(contentType);\n\n    const confWithUpdatedMetadata = {\n      ...configuration,\n      metadatas: mapValues(assocMainField, configuration.metadatas),\n    };\n\n    const components = await contentTypeService.findComponentsConfigurations(contentType);\n\n    ctx.body = {\n      data: {\n        contentType: confWithUpdatedMetadata,\n        components,\n      },\n    };\n  },\n\n  async updateContentTypeConfiguration(ctx) {\n    const { userAbility } = ctx.state;\n    const { uid } = ctx.params;\n    const { body } = ctx.request;\n\n    const contentTypeService = getService('content-types');\n    const metricsService = getService('metrics');\n\n    const contentType = await contentTypeService.findContentType(uid);\n\n    if (!contentType) {\n      return ctx.notFound('contentType.notFound');\n    }\n\n    if (!getService('permission').canConfigureContentType({ userAbility, contentType })) {\n      return ctx.forbidden();\n    }\n\n    let input;\n    try {\n      input = await createModelConfigurationSchema(contentType).validate(body, {\n        abortEarly: false,\n        stripUnknown: true,\n        strict: true,\n      });\n    } catch (error) {\n      return ctx.badRequest(null, {\n        name: 'validationError',\n        errors: error.errors,\n      });\n    }\n\n    const newConfiguration = await contentTypeService.updateConfiguration(contentType, input);\n\n    await metricsService.sendDidConfigureListView(contentType, newConfiguration);\n\n    ctx.body = { data: newConfiguration };\n  },\n};\n",
    "packages/strapi-plugin-content-manager/controllers/relations.js": "'use strict';\n\nconst { has, prop, pick, concat } = require('lodash/fp');\nconst { PUBLISHED_AT_ATTRIBUTE } = require('strapi-utils').contentTypes.constants;\n\nconst { getService } = require('../utils');\n\nmodule.exports = {\n  async find(ctx) {\n    const { model, targetField } = ctx.params;\n    const { _component, ...query } = ctx.request.query;\n    const { idsToOmit } = ctx.request.body;\n\n    if (!targetField) {\n      return ctx.badRequest();\n    }\n\n    const modelDef = _component ? strapi.db.getModel(_component) : strapi.db.getModel(model);\n\n    if (!modelDef) {\n      return ctx.notFound('model.notFound');\n    }\n\n    const attr = modelDef.attributes[targetField];\n    if (!attr) {\n      return ctx.badRequest('targetField.invalid');\n    }\n\n    const target = strapi.db.getModelByAssoc(attr);\n\n    if (!target) {\n      return ctx.notFound('target.notFound');\n    }\n\n    if (idsToOmit && Array.isArray(idsToOmit)) {\n      query._where = query._where || {};\n      query._where.id_nin = concat(query._where.id_nin || [], idsToOmit);\n    }\n\n    const entityManager = getService('entity-manager');\n\n    let entities = [];\n\n    if (has('_q', ctx.request.query)) {\n      entities = await entityManager.search(query, target.uid);\n    } else {\n      entities = await entityManager.find(query, target.uid);\n    }\n\n    if (!entities) {\n      return ctx.notFound();\n    }\n\n    const modelConfig = _component\n      ? await getService('components').findConfiguration(modelDef)\n      : await getService('content-types').findConfiguration(modelDef);\n\n    const field = prop(`metadatas.${targetField}.edit.mainField`, modelConfig) || 'id';\n    const pickFields = [field, 'id', target.primaryKey, PUBLISHED_AT_ATTRIBUTE];\n\n    ctx.body = entities.map(pick(pickFields));\n  },\n};\n",
    "packages/strapi-plugin-content-manager/controllers/single-types.js": "'use strict';\n\nconst { pipe } = require('lodash/fp');\nconst {\n  getService,\n  wrapBadRequest,\n  setCreatorFields,\n  pickWritableAttributes,\n} = require('../utils');\n\nconst findEntity = async model => {\n  const entityManager = getService('entity-manager');\n\n  const entity = await entityManager.find({}, model);\n  return entityManager.assocCreatorRoles(entity);\n};\n\nmodule.exports = {\n  async find(ctx) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await findEntity(model);\n\n    // allow user with create permission to know a single type is not created\n    if (!entity) {\n      if (permissionChecker.cannot.create()) {\n        return ctx.forbidden();\n      }\n\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.read(entity)) {\n      return ctx.forbidden();\n    }\n\n    ctx.body = permissionChecker.sanitizeOutput(entity);\n  },\n\n  async createOrUpdate(ctx) {\n    const { user, userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { body } = ctx.request;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.create() && permissionChecker.cannot.update()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await findEntity(model);\n\n    const pickWritables = pickWritableAttributes({ model });\n\n    const pickPermittedFields = entity\n      ? permissionChecker.sanitizeUpdateInput(entity)\n      : permissionChecker.sanitizeCreateInput;\n\n    const setCreator = entity\n      ? setCreatorFields({ user, isEdition: true })\n      : setCreatorFields({ user });\n\n    const sanitizeFn = pipe([pickWritables, pickPermittedFields, setCreator]);\n\n    await wrapBadRequest(async () => {\n      if (!entity) {\n        const newEntity = await entityManager.create(sanitizeFn(body), model);\n        ctx.body = permissionChecker.sanitizeOutput(newEntity);\n\n        await strapi.telemetry.send('didCreateFirstContentTypeEntry', { model });\n        return;\n      }\n\n      if (permissionChecker.cannot.update(entity)) {\n        return ctx.forbidden();\n      }\n\n      const updatedEntity = await entityManager.update(entity, sanitizeFn(body), model);\n      ctx.body = permissionChecker.sanitizeOutput(updatedEntity);\n    })();\n  },\n\n  async delete(ctx) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.delete()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await findEntity(model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.delete(entity)) {\n      return ctx.forbidden();\n    }\n\n    const deletedEntity = await entityManager.delete(entity, model);\n\n    ctx.body = permissionChecker.sanitizeOutput(deletedEntity);\n  },\n\n  async publish(ctx) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.publish()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await findEntity(model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.publish(entity)) {\n      return ctx.forbidden();\n    }\n\n    const publishedEntity = await entityManager.publish(entity, model);\n\n    ctx.body = permissionChecker.sanitizeOutput(publishedEntity);\n  },\n\n  async unpublish(ctx) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.unpublish()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await findEntity(model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.unpublish(entity)) {\n      return ctx.forbidden();\n    }\n\n    const unpublishedEntity = await entityManager.unpublish(entity, model);\n\n    ctx.body = permissionChecker.sanitizeOutput(unpublishedEntity);\n  },\n};\n",
    "packages/strapi-plugin-content-manager/controllers/uid.js": "'use strict';\n\nconst { getService } = require('../utils');\nconst {\n  validateGenerateUIDInput,\n  validateCheckUIDAvailabilityInput,\n  validateUIDField,\n} = require('./validation');\n\nmodule.exports = {\n  async generateUID(ctx) {\n    const { contentTypeUID, field, data } = await validateGenerateUIDInput(ctx.request.body);\n\n    await validateUIDField(contentTypeUID, field);\n\n    const uidService = getService('uid');\n\n    ctx.body = {\n      data: await uidService.generateUIDField({ contentTypeUID, field, data }),\n    };\n  },\n\n  async checkUIDAvailability(ctx) {\n    const { contentTypeUID, field, value } = await validateCheckUIDAvailabilityInput(\n      ctx.request.body\n    );\n\n    await validateUIDField(contentTypeUID, field);\n\n    const uidService = getService('uid');\n\n    const isAvailable = await uidService.checkUIDAvailability({ contentTypeUID, field, value });\n\n    ctx.body = {\n      isAvailable,\n      suggestion: !isAvailable\n        ? await uidService.findUniqueUID({ contentTypeUID, field, value })\n        : null,\n    };\n  },\n};\n",
    "packages/strapi-plugin-content-manager/services/__tests__/content-types.test.js": "'use strict';\n\nconst createConfigurationService = require('../configuration');\nconst storeUtils = require('../utils/store');\n\nconst createCfg = (opts = {}) => {\n  return createConfigurationService({\n    prefix: 'test_prefix',\n    storeUtils,\n    get models() {\n      return {};\n    },\n    ...opts,\n  });\n};\n\ndescribe('Model Configuration', () => {\n  test('getConfiguration calls store with right key', async () => {\n    const uid = 'test-uid';\n    const spyFn = jest.spyOn(storeUtils, 'getModelConfiguration').mockImplementation(() => {});\n\n    const { getConfiguration } = createCfg();\n    await getConfiguration(uid);\n\n    expect(spyFn).toHaveBeenCalledWith('test_prefix::test-uid');\n    spyFn.mockRestore();\n  });\n\n  test('setConfiguration calls store with right params', async () => {\n    const uid = 'test-uid';\n    const spyFn = jest.spyOn(storeUtils, 'setModelConfiguration').mockImplementation(() => {});\n\n    const { setConfiguration } = createCfg();\n    await setConfiguration(uid, {\n      settings: {},\n      layouts: {},\n      metadatas: {},\n    });\n\n    expect(spyFn).toHaveBeenCalledWith('test_prefix::test-uid', {\n      layouts: {},\n      metadatas: {},\n      settings: {},\n      uid: 'test-uid',\n    });\n\n    spyFn.mockRestore();\n  });\n\n  test('setConfiguration calls store with isComponent if set in factory option', async () => {\n    const uid = 'test-uid';\n    const spyFn = jest.spyOn(storeUtils, 'setModelConfiguration').mockImplementation(() => {});\n\n    const { setConfiguration } = createCfg({ isComponent: true });\n    await setConfiguration(uid, {\n      settings: {},\n      layouts: {},\n      metadatas: {},\n    });\n\n    expect(spyFn).toHaveBeenCalledWith('test_prefix::test-uid', {\n      layouts: {},\n      metadatas: {},\n      isComponent: true,\n      settings: {},\n      uid: 'test-uid',\n    });\n\n    spyFn.mockRestore();\n  });\n\n  test('deleteConfiguration calls store with right params', async () => {\n    const uid = 'test-uid';\n    const spyFn = jest.spyOn(storeUtils, 'deleteKey').mockImplementation(() => {});\n\n    const { deleteConfiguration } = createCfg();\n    await deleteConfiguration(uid);\n\n    expect(spyFn).toHaveBeenCalledWith('test_prefix::test-uid');\n\n    spyFn.mockRestore();\n  });\n\n  test.todo('Sync Configuration');\n});\n",
    "packages/strapi-plugin-content-manager/services/__tests__/entity-manager.test.js": "'use strict';\n\nconst entityManager = require('../entity-manager');\n\ndescribe('Content-Manager', () => {\n  const fakeModel = {\n    modelName: 'fake model',\n  };\n\n  describe('Publish', () => {\n    beforeEach(() => {\n      global.strapi = {\n        entityService: {\n          update: jest.fn(),\n        },\n        entityValidator: {\n          validateEntityCreation() {},\n        },\n        eventHub: { emit: jest.fn() },\n        getModel: jest.fn(() => fakeModel),\n      };\n    });\n\n    afterEach(() => {\n      jest.clearAllMocks();\n    });\n\n    test('Publish a content-type', async () => {\n      const model = 'application::test.test';\n      const entity = { id: 1, published_at: null };\n      await entityManager.publish(entity, model);\n\n      expect(strapi.entityService.update).toBeCalledWith(\n        { params: { id: entity.id }, data: { published_at: expect.any(Date) } },\n        { model }\n      );\n    });\n  });\n\n  describe('Unpublish', () => {\n    beforeEach(() => {\n      global.strapi = {\n        entityService: {\n          update: jest.fn(),\n        },\n        eventHub: { emit: jest.fn() },\n        getModel: jest.fn(() => fakeModel),\n      };\n    });\n\n    afterEach(() => {\n      jest.clearAllMocks();\n    });\n\n    test('Unpublish a content-type', async () => {\n      const model = 'application::test.test';\n      const entity = { id: 1, published_at: new Date() };\n      await entityManager.unpublish(entity, model);\n\n      expect(strapi.entityService.update).toHaveBeenCalledWith(\n        { params: { id: entity.id }, data: { published_at: null } },\n        { model }\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/services/components.js": "'use strict';\n\nconst { has, isNil, mapValues } = require('lodash/fp');\n\nconst { getService } = require('../utils');\nconst storeUtils = require('./utils/store');\nconst createConfigurationService = require('./configuration');\n\nconst STORE_KEY_PREFIX = 'components';\n\nconst configurationService = createConfigurationService({\n  storeUtils,\n  isComponent: true,\n  prefix: STORE_KEY_PREFIX,\n  getModels() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return mapValues(toContentManagerModel, strapi.components);\n  },\n});\n\nmodule.exports = {\n  findAllComponents() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return Object.values(strapi.components).map(toContentManagerModel);\n  },\n\n  findComponent(uid) {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    const component = strapi.components[uid];\n\n    return isNil(component) ? component : toContentManagerModel(component);\n  },\n\n  // configuration\n\n  async findConfiguration(component) {\n    const configuration = await configurationService.getConfiguration(component.uid);\n\n    return {\n      uid: component.uid,\n      category: component.categoru,\n      ...configuration,\n    };\n  },\n\n  async updateConfiguration(component, newConfiguration) {\n    await configurationService.setConfiguration(component.uid, newConfiguration);\n\n    return this.findConfiguration(component);\n  },\n\n  async findComponentsConfigurations(model) {\n    const componentsMap = {};\n\n    const getComponentConfigurations = async uid => {\n      const component = this.findComponent(uid);\n\n      if (has(uid, componentsMap)) return;\n\n      const componentConfiguration = await this.findConfiguration(component);\n      const componentsConfigurations = await this.findComponentsConfigurations(component);\n\n      Object.assign(componentsMap, {\n        [uid]: componentConfiguration,\n        ...componentsConfigurations,\n      });\n    };\n\n    for (const key in model.attributes) {\n      const attribute = model.attributes[key];\n\n      if (attribute.type === 'component') {\n        await getComponentConfigurations(attribute.component);\n      }\n\n      if (attribute.type === 'dynamiczone') {\n        for (const componentUid of attribute.components) {\n          await getComponentConfigurations(componentUid);\n        }\n      }\n    }\n\n    return componentsMap;\n  },\n\n  syncConfigurations() {\n    return configurationService.syncConfigurations();\n  },\n};\n",
    "packages/strapi-plugin-content-manager/services/configuration.js": "'use strict';\n\nconst { intersection, difference } = require('lodash');\nconst { createDefaultConfiguration, syncConfiguration } = require('./utils/configuration');\n\nmodule.exports = ({ isComponent, prefix, storeUtils, getModels }) => {\n  const uidToStoreKey = uid => {\n    return `${prefix}::${uid}`;\n  };\n\n  const getConfiguration = uid => {\n    const storeKey = uidToStoreKey(uid);\n    return storeUtils.getModelConfiguration(storeKey);\n  };\n\n  const setConfiguration = (uid, input) => {\n    const { settings, metadatas, layouts } = input;\n\n    const configuration = {\n      uid,\n      settings,\n      metadatas,\n      layouts,\n    };\n\n    if (isComponent) {\n      configuration.isComponent = isComponent;\n    }\n\n    const storeKey = uidToStoreKey(uid);\n    return storeUtils.setModelConfiguration(storeKey, configuration);\n  };\n\n  const deleteConfiguration = uid => {\n    const storeKey = uidToStoreKey(uid);\n    return storeUtils.deleteKey(storeKey);\n  };\n\n  const syncConfigurations = async () => {\n    const models = getModels();\n\n    const configurations = await storeUtils.findByKey(\n      `plugin_content_manager_configuration_${prefix}`\n    );\n\n    const updateConfiguration = async uid => {\n      const conf = configurations.find(conf => conf.uid === uid);\n\n      return setConfiguration(uid, await syncConfiguration(conf, models[uid]));\n    };\n\n    const generateNewConfiguration = async uid => {\n      return setConfiguration(uid, await createDefaultConfiguration(models[uid]));\n    };\n\n    const currentUIDS = Object.keys(models);\n    const DBUIDs = configurations.map(({ uid }) => uid);\n\n    const contentTypesToUpdate = intersection(currentUIDS, DBUIDs);\n    const contentTypesToAdd = difference(currentUIDS, DBUIDs);\n    const contentTypesToDelete = difference(DBUIDs, currentUIDS);\n\n    // delete old schemas\n    await Promise.all(contentTypesToDelete.map(uid => deleteConfiguration(uid)));\n\n    // create new schemas\n    await Promise.all(contentTypesToAdd.map(uid => generateNewConfiguration(uid)));\n\n    // update current schemas\n    await Promise.all(contentTypesToUpdate.map(uid => updateConfiguration(uid)));\n  };\n\n  return {\n    getConfiguration,\n    setConfiguration,\n    deleteConfiguration,\n    syncConfigurations,\n  };\n};\n",
    "packages/strapi-plugin-content-manager/services/content-types.js": "'use strict';\n\nconst { isNil, mapValues } = require('lodash/fp');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\n\nconst { getService } = require('../utils');\nconst storeUtils = require('./utils/store');\nconst createConfigurationService = require('./configuration');\n\nconst configurationService = createConfigurationService({\n  storeUtils,\n  prefix: 'content_types',\n  getModels() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return mapValues(toContentManagerModel, strapi.contentTypes);\n  },\n});\n\nconst service = {\n  findAllContentTypes() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return Object.values(strapi.contentTypes).map(toContentManagerModel);\n  },\n\n  findContentType(uid) {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    const contentType = strapi.contentTypes[uid];\n\n    return isNil(contentType) ? contentType : toContentManagerModel(contentType);\n  },\n\n  findDisplayedContentTypes() {\n    return this.findAllContentTypes().filter(({ isDisplayed }) => isDisplayed === true);\n  },\n\n  findContentTypesByKind(kind) {\n    if (!kind) {\n      return this.findAllContentTypes();\n    }\n\n    return this.findAllContentTypes().filter(contentTypesUtils.isKind(kind));\n  },\n\n  // configuration\n\n  async findConfiguration(contentType) {\n    const configuration = await configurationService.getConfiguration(contentType.uid);\n\n    return {\n      uid: contentType.uid,\n      ...configuration,\n    };\n  },\n\n  async updateConfiguration(contentType, newConfiguration) {\n    await configurationService.setConfiguration(contentType.uid, newConfiguration);\n    return this.findConfiguration(contentType);\n  },\n\n  findComponentsConfigurations(contentType) {\n    // delegate to componentService\n    return getService('components').findComponentsConfigurations(contentType);\n  },\n\n  syncConfigurations() {\n    return configurationService.syncConfigurations();\n  },\n};\n\nmodule.exports = service;\n",
    "packages/strapi-plugin-content-manager/services/entity-manager.js": "'use strict';\n\nconst { assoc, has, prop, omit } = require('lodash/fp');\nconst strapiUtils = require('strapi-utils');\n\nconst { sanitizeEntity } = strapiUtils;\nconst { hasDraftAndPublish } = strapiUtils.contentTypes;\nconst { PUBLISHED_AT_ATTRIBUTE, CREATED_BY_ATTRIBUTE } = strapiUtils.contentTypes.constants;\nconst { ENTRY_PUBLISH, ENTRY_UNPUBLISH } = strapiUtils.webhook.webhookEvents;\n\nconst omitPublishedAtField = omit(PUBLISHED_AT_ATTRIBUTE);\n\nconst emitEvent = (event, fn) => async (entity, model) => {\n  const result = await fn(entity, model);\n\n  const modelDef = strapi.getModel(model);\n\n  strapi.eventHub.emit(event, {\n    model: modelDef.modelName,\n    entry: sanitizeEntity(result, { model: modelDef }),\n  });\n\n  return result;\n};\n\nconst findCreatorRoles = entity => {\n  const createdByPath = `${CREATED_BY_ATTRIBUTE}.id`;\n\n  if (has(createdByPath, entity)) {\n    const creatorId = prop(createdByPath, entity);\n    return strapi.query('role', 'admin').find({ 'users.id': creatorId }, []);\n  }\n\n  return [];\n};\n\nmodule.exports = {\n  async assocCreatorRoles(entity) {\n    if (!entity) {\n      return entity;\n    }\n\n    const roles = await findCreatorRoles(entity);\n    return assoc(`${CREATED_BY_ATTRIBUTE}.roles`, roles, entity);\n  },\n\n  find(params, model, populate) {\n    return strapi.entityService.find({ params, populate }, { model });\n  },\n\n  findPage(params, model, populate) {\n    return strapi.entityService.findPage({ params, populate }, { model });\n  },\n\n  findWithRelationCounts(params, model, populate) {\n    return strapi.entityService.findWithRelationCounts({ params, populate }, { model });\n  },\n\n  search(params, model, populate) {\n    return strapi.entityService.search({ params, populate }, { model });\n  },\n\n  searchPage(params, model, populate) {\n    return strapi.entityService.searchPage({ params, populate }, { model });\n  },\n\n  searchWithRelationCounts(params, model, populate) {\n    return strapi.entityService.searchWithRelationCounts({ params, populate }, { model });\n  },\n\n  count(params, model) {\n    return strapi.entityService.count({ params }, { model });\n  },\n\n  async findOne(id, model, populate) {\n    return strapi.entityService.findOne({ params: { id }, populate }, { model });\n  },\n\n  async findOneWithCreatorRoles(id, model, populate) {\n    const entity = await this.findOne(id, model, populate);\n\n    if (!entity) {\n      return entity;\n    }\n\n    return this.assocCreatorRoles(entity);\n  },\n\n  async create(body, model) {\n    const modelDef = strapi.getModel(model);\n    const publishData = { ...body };\n\n    if (hasDraftAndPublish(modelDef)) {\n      publishData[PUBLISHED_AT_ATTRIBUTE] = null;\n    }\n\n    return strapi.entityService.create({ data: publishData }, { model });\n  },\n\n  update(entity, body, model) {\n    const params = { id: entity.id };\n    const publishData = omitPublishedAtField(body);\n\n    return strapi.entityService.update({ params, data: publishData }, { model });\n  },\n\n  delete(entity, model) {\n    const params = { id: entity.id };\n    return strapi.entityService.delete({ params }, { model });\n  },\n\n  findAndDelete(params, model) {\n    return strapi.entityService.delete({ params }, { model });\n  },\n\n  publish: emitEvent(ENTRY_PUBLISH, async (entity, model) => {\n    if (entity[PUBLISHED_AT_ATTRIBUTE]) {\n      throw strapi.errors.badRequest('already.published');\n    }\n\n    // validate the entity is valid for publication\n    await strapi.entityValidator.validateEntityCreation(strapi.getModel(model), entity);\n\n    const params = { id: entity.id };\n    const data = { [PUBLISHED_AT_ATTRIBUTE]: new Date() };\n\n    return strapi.entityService.update({ params, data }, { model });\n  }),\n\n  unpublish: emitEvent(ENTRY_UNPUBLISH, (entity, model) => {\n    if (!entity[PUBLISHED_AT_ATTRIBUTE]) {\n      throw strapi.errors.badRequest('already.draft');\n    }\n\n    const params = { id: entity.id };\n    const data = { [PUBLISHED_AT_ATTRIBUTE]: null };\n\n    return strapi.entityService.update({ params, data }, { model });\n  }),\n};\n",
    "packages/strapi-plugin-content-manager/services/metrics.js": "'use strict';\n\nconst { intersection, prop } = require('lodash/fp');\nconst { getRelationalFields } = require('strapi-utils').relations;\n\nconst sendDidConfigureListView = async (contentType, configuration) => {\n  const displayedFields = prop('length', configuration.layouts.list);\n  const relationalFields = getRelationalFields(contentType);\n  const displayedRelationalFields = intersection(relationalFields, configuration.layouts.list)\n    .length;\n\n  const data = {\n    containsRelationalFields: !!displayedRelationalFields,\n  };\n\n  if (data.containsRelationalFields) {\n    Object.assign(data, {\n      displayedFields,\n      displayedRelationalFields,\n    });\n  }\n\n  try {\n    await strapi.telemetry.send('didConfigureListView', data);\n  } catch (e) {\n    // silence\n  }\n};\n\nmodule.exports = {\n  sendDidConfigureListView,\n};\n",
    "packages/strapi-plugin-content-manager/services/uid.js": "'use strict';\n\nconst _ = require('lodash');\nconst slugify = require('@sindresorhus/slugify');\n\nmodule.exports = {\n  async generateUIDField({ contentTypeUID, field, data }) {\n    const contentType = strapi.contentTypes[contentTypeUID];\n    const { attributes } = contentType;\n\n    const { targetField, default: defaultValue, options } = attributes[field];\n    const targetValue = _.get(data, targetField);\n\n    if (!_.isEmpty(targetValue)) {\n      return this.findUniqueUID({\n        contentTypeUID,\n        field,\n        value: slugify(targetValue, options),\n      });\n    }\n\n    return this.findUniqueUID({\n      contentTypeUID,\n      field,\n      value: slugify(defaultValue || contentType.modelName, options),\n    });\n  },\n\n  async findUniqueUID({ contentTypeUID, field, value }) {\n    const query = strapi.db.query(contentTypeUID);\n\n    const possibleColisions = await query\n      .find({\n        [`${field}_contains`]: value,\n        _limit: -1,\n      })\n      .then(results => results.map(result => result[field]));\n\n    if (possibleColisions.length === 0) {\n      return value;\n    }\n\n    let i = 1;\n    let tmpUId = `${value}-${i}`;\n    while (possibleColisions.includes(tmpUId)) {\n      i += 1;\n      tmpUId = `${value}-${i}`;\n    }\n\n    return tmpUId;\n  },\n\n  async checkUIDAvailability({ contentTypeUID, field, value }) {\n    const query = strapi.db.query(contentTypeUID);\n\n    const count = await query.count({\n      [field]: value,\n    });\n\n    if (count > 0) return false;\n    return true;\n  },\n};\n",
    "packages/strapi-plugin-content-manager/services/utils/configuration/index.js": "'use strict';\n\nconst { createModelConfigurationSchema } = require('../../../controllers/validation');\nconst { createDefaultSettings, syncSettings } = require('./settings');\nconst { createDefaultMetadatas, syncMetadatas } = require('./metadatas');\nconst { createDefaultLayouts, syncLayouts } = require('./layouts');\n\nasync function validateCustomConfig(schema) {\n  try {\n    await createModelConfigurationSchema(schema, {\n      allowUndefined: true,\n    }).validate(schema.config);\n  } catch (error) {\n    throw new Error(\n      `Invalid Model configuration for model ${schema.uid}. Verify your {{modelName}}.config.js(on) file:\\n  - ${error.message}\\n`\n    );\n  }\n}\n\nasync function createDefaultConfiguration(schema) {\n  await validateCustomConfig(schema);\n\n  return {\n    settings: await createDefaultSettings(schema),\n    metadatas: await createDefaultMetadatas(schema),\n    layouts: await createDefaultLayouts(schema),\n  };\n}\n\nasync function syncConfiguration(conf, schema) {\n  await validateCustomConfig(schema);\n\n  return {\n    settings: await syncSettings(conf, schema),\n    layouts: await syncLayouts(conf, schema),\n    metadatas: await syncMetadatas(conf, schema),\n  };\n}\n\nmodule.exports = {\n  createDefaultConfiguration,\n  syncConfiguration,\n};\n",
    "packages/strapi-plugin-content-manager/services/utils/store.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst keys = {\n  CONFIGURATION: 'configuration',\n};\n\nconst getStore = () => {\n  return strapi.store({\n    environment: '',\n    type: 'plugin',\n    name: 'content_manager',\n  });\n};\n\n/** Model configuration */\nconst EMPTY_CONFIG = {\n  settings: {},\n  metadatas: {},\n  layouts: {},\n};\n\nconst configurationKey = key => `${keys.CONFIGURATION}_${key}`;\n\nconst getModelConfiguration = async key => {\n  const config = await getStore().get({ key: configurationKey(key) });\n  return _.merge({}, EMPTY_CONFIG, config);\n};\n\nconst setModelConfiguration = async (key, value) => {\n  const storedConfig = (await getStore().get({ key: configurationKey(key) })) || {};\n  const currentConfig = { ...storedConfig };\n  Object.keys(value).forEach(key => {\n    if (value[key] !== null && value[key] !== undefined) {\n      _.set(currentConfig, key, value[key]);\n    }\n  });\n\n  if (!_.isEqual(currentConfig, storedConfig)) {\n    return getStore().set({\n      key: configurationKey(key),\n      value: currentConfig,\n    });\n  }\n};\n\nconst deleteKey = key => {\n  return strapi.query('core_store').delete({ key: `plugin_content_manager_configuration_${key}` });\n};\n\nfunction findByKeyQuery({ model }, key) {\n  if (model.orm === 'mongoose') {\n    return model\n      .find({\n        key: { $regex: `${key}.*` },\n      })\n      .then(results => results.map(({ value }) => JSON.parse(value)));\n  }\n\n  return model\n    .query(qb => {\n      qb.where('key', 'like', `${key}%`);\n    })\n    .fetchAll()\n    .then(config => config && config.toJSON())\n    .then(results => results.map(({ value }) => JSON.parse(value)));\n}\n\nconst findByKey = key => strapi.query('core_store').custom(findByKeyQuery)(key);\nconst moveKey = (oldKey, newKey) => {\n  return strapi.query('core_store').update(\n    {\n      key: `plugin_content_manager_configuration_${oldKey}`,\n    },\n    {\n      key: `plugin_content_manager_configuration_${newKey}`,\n    }\n  );\n};\n\nconst getAllConfigurations = () => findByKey('plugin_content_manager_configuration');\n\nmodule.exports = {\n  getAllConfigurations,\n  findByKey,\n  getModelConfiguration,\n  setModelConfiguration,\n\n  deleteKey,\n  moveKey,\n  keys,\n};\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompo: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n};\n\nconst productWithCompo = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      component: 'default.compo',\n      type: 'component',\n      required: true,\n      repeatable: true,\n    },\n  },\n  connection: 'default',\n  name: 'product with compo',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('CM API - Basic + compo', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompo)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: [\n        {\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results[0]).toMatchObject(data.productsWithCompo[0]);\n    res.body.results.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: [\n        {\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-compo.product-with-compo/${data.productsWithCompo[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-compo.product-with-compo/${data.productsWithCompo[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompo[0]);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo', '0'])).toBe('compo must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: '',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at least 4 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: 'A very long description that exceed the min length.',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at most 30 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].name', '0'])).toBe(\n        'compo[0].name must be defined.'\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompo: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n};\n\nconst productWithCompo = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      component: 'default.compo',\n      type: 'component',\n      required: true,\n    },\n  },\n  connection: 'default',\n  name: 'product with compo',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('CM API - Basic + compo', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompo)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: {\n        name: 'compo name',\n        description: 'short',\n      },\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results[0]).toMatchObject(data.productsWithCompo[0]);\n    res.body.results.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: {\n        name: 'compo name updated',\n        description: 'update',\n      },\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-compo.product-with-compo/${data.productsWithCompo[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-compo.product-with-compo/${data.productsWithCompo[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompo[0]);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.compo.0')).toBe('compo must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: '',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at least 4 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: 'A very long description that exceed the min length.',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at most 30 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          description: 'short',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.name', '0'])).toBe(\n        'compo.name must be defined.'\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompoAndDP: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n};\n\nconst productWithCompoAndDP = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      type: 'component',\n      component: 'default.compo',\n      required: true,\n      repeatable: true,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product with compo and DP',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('CM API - Basic + compo + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompoAndDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: [\n        {\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url:\n        '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithCompoAndDP.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url:\n        '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results[0]).toMatchObject(data.productsWithCompoAndDP[0]);\n    res.body.results.forEach(p => {\n      expect(p.published_at).toBeNull();\n    });\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: [\n        {\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp/${data.productsWithCompoAndDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithCompoAndDP[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp/${data.productsWithCompoAndDP[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompoAndDP[0]);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithCompoAndDP.shift();\n  });\n\n  describe('validation', () => {\n    test('Can create product with compo - compo required - []', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [],\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithCompoAndDP.push(res.body);\n    });\n\n    test('Can create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: '',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithCompoAndDP.push(res.body);\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: 'A very long description that exceed the min length.',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at most 30 characters'\n      );\n    });\n\n    test('Can create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithCompoAndDP.push(res.body);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompoAndDP: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n};\n\nconst productWithCompoAndDP = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      type: 'component',\n      component: 'default.compo',\n      required: true,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product with compo and DP',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('CM API - Basic + compo + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompoAndDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: {\n        name: 'compo name',\n        description: 'short',\n      },\n    };\n    const res = await rq({\n      method: 'POST',\n      url:\n        '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithCompoAndDP.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url:\n        '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results[0]).toMatchObject(data.productsWithCompoAndDP[0]);\n    res.body.results.forEach(p => {\n      expect(p.published_at).toBeNull();\n    });\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: {\n        name: 'compo name updated',\n        description: 'update',\n      },\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp/${data.productsWithCompoAndDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithCompoAndDP[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp/${data.productsWithCompoAndDP[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompoAndDP[0]);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithCompoAndDP.shift();\n  });\n\n  describe('validation', () => {\n    test('Can create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: null,\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithCompoAndDP.push(res.body);\n    });\n\n    test('Can create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: '',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithCompoAndDP.push(res.body);\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: 'A very long description that exceed the min length.',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at most 30 characters'\n      );\n    });\n\n    test('Can create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          description: 'short',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithCompoAndDP.push(res.body);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithDzAndDP: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n};\n\nconst productWithCompoAndDP = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    dz: {\n      components: ['default.compo'],\n      type: 'dynamiczone',\n      required: true,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product with dz and DP',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('CM API - Basic + dz + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompoAndDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      dz: [\n        {\n          __component: 'default.compo',\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url:\n        '/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDzAndDP.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url:\n        '/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results[0]).toMatchObject(data.productsWithDzAndDP[0]);\n    res.body.results.forEach(p => {\n      expect(p.published_at).toBeNull();\n    });\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      dz: [\n        {\n          __component: 'default.compo',\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${data.productsWithDzAndDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithDzAndDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDzAndDP[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${data.productsWithDzAndDP[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithDzAndDP[0]);\n    expect(res.body.id).toEqual(data.productsWithDzAndDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDzAndDP.shift();\n  });\n\n  describe('validation', () => {\n    describe.each(['create', 'update'])('%p', method => {\n      test(`Can ${method} product with compo - compo required - []`, async () => {\n        const product = {\n          name: 'Product 1',\n          description: 'Product description',\n          dz: [],\n        };\n        const res = await rq({\n          method: method === 'create' ? 'POST' : 'PUT',\n          url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${\n            method === 'update' ? data.productsWithDzAndDP[0].id : ''\n          }`,\n          body: product,\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject(product);\n        data.productsWithDzAndDP.push(res.body);\n      });\n\n      test(`Can ${method} product with compo - minLength`, async () => {\n        const product = {\n          name: 'Product 1',\n          description: 'Product description',\n          dz: [\n            {\n              __component: 'default.compo',\n              name: 'compo name',\n              description: 'k',\n            },\n          ],\n        };\n        const res = await rq({\n          method: method === 'create' ? 'POST' : 'PUT',\n          url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${\n            method === 'update' ? data.productsWithDzAndDP[0].id : ''\n          }`,\n          body: product,\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject(product);\n        data.productsWithDzAndDP.push(res.body);\n      });\n\n      test(`Cannot ${method} product with compo - maxLength`, async () => {\n        const product = {\n          name: 'Product 1',\n          description: 'Product description',\n          dz: [\n            {\n              __component: 'default.compo',\n              name: 'compo name',\n              description: 'A very long description that exceed the min length.',\n            },\n          ],\n        };\n        const res = await rq({\n          method: method === 'create' ? 'POST' : 'PUT',\n          url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${\n            method === 'update' ? data.productsWithDzAndDP[0].id : ''\n          }`,\n          body: product,\n        });\n\n        expect(res.statusCode).toBe(400);\n        expect(_.get(res.body.data, ['errors', 'dz[0].description', '0'])).toBe(\n          'dz[0].description must be at most 30 characters'\n        );\n      });\n\n      test(`Can ${method} product with compo - required`, async () => {\n        const product = {\n          name: 'Product 1',\n          description: 'Product description',\n          dz: [\n            {\n              __component: 'default.compo',\n              description: 'short',\n            },\n          ],\n        };\n        const res = await rq({\n          method: method === 'create' ? 'POST' : 'PUT',\n          url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${\n            method === 'update' ? data.productsWithDzAndDP[0].id : ''\n          }`,\n          body: product,\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject(product);\n        data.productsWithDzAndDP.push(res.body);\n      });\n\n      test(`Cannot ${method} product with compo - missing __component`, async () => {\n        const product = {\n          name: 'Product 1',\n          description: 'Product description',\n          dz: [\n            {\n              name: 'Product 1',\n              description: 'short',\n            },\n          ],\n        };\n        const res = await rq({\n          method: method === 'create' ? 'POST' : 'PUT',\n          url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${\n            method === 'update' ? data.productsWithDzAndDP[0].id : ''\n          }`,\n          body: product,\n        });\n\n        expect(res.statusCode).toBe(400);\n        expect(_.get(res.body.data, ['errors', 'dz[0].__component', '0'])).toBe(\n          'dz[0].__component is a required field'\n        );\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithDP: [],\n};\n\nconst productWithDP = {\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 30,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product with DP',\n  description: '',\n  collectionName: '',\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n};\n\ndescribe('CM API - Basic + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create a product', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/content-manager/collection-types/application::product-with-dp.product-with-dp',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDP.push(res.body);\n  });\n\n  test('Create a product + cannot overwrite published_at', async () => {\n    const product = {\n      name: 'Product 2',\n      description: 'Product description',\n      published_at: '2020-08-20T10:27:55.866Z',\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/content-manager/collection-types/application::product-with-dp.product-with-dp',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(_.omit(product, 'published_at'));\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDP.push(res.body);\n  });\n\n  test('Read all products', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/content-manager/collection-types/application::product-with-dp.product-with-dp',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(2);\n    expect(res.body.results).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          name: 'Product 1',\n          description: 'Product description',\n        }),\n      ])\n    );\n    res.body.results.forEach(p => {\n      expect(p.published_at).toBeNull();\n    });\n  });\n\n  test('Update a draft', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${data.productsWithDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(_.omit(product, 'published_at'));\n    expect(res.body.id).toEqual(data.productsWithDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDP[0] = res.body;\n  });\n\n  test('Update product + cannot overwrite published_at', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      published_at: '2020-08-27T09:50:50.465Z',\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${data.productsWithDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(_.omit(product, ['published_at']));\n    expect(res.body.published_at).toBeNull();\n    expect(res.body.id).toEqual(data.productsWithDP[0].id);\n    data.productsWithDP[0] = res.body;\n  });\n\n  test('Publish a product, expect published_at to be defined', async () => {\n    const entry = data.productsWithDP[0];\n\n    let { body } = await rq({\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${entry.id}/actions/publish`,\n      method: 'POST',\n    });\n\n    data.productsWithDP[0] = body;\n\n    expect(body.published_at).toBeISODate();\n  });\n\n  test('Publish article1, expect article1 to be already published', async () => {\n    const entry = data.productsWithDP[0];\n\n    let { body } = await rq({\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${entry.id}/actions/publish`,\n      method: 'POST',\n    });\n\n    expect(body.statusCode).toBe(400);\n    expect(body.message).toBe('already.published');\n  });\n\n  test('Unpublish article1, expect article1 to be set to null', async () => {\n    const entry = data.productsWithDP[0];\n\n    let { body } = await rq({\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${entry.id}/actions/unpublish`,\n      method: 'POST',\n    });\n\n    data.productsWithDP[0] = body;\n\n    expect(body.published_at).toBeNull();\n  });\n\n  test('Unpublish article1, expect article1 to already be a draft', async () => {\n    const entry = data.productsWithDP[0];\n\n    let { body } = await rq({\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${entry.id}/actions/unpublish`,\n      method: 'POST',\n    });\n\n    expect(body.statusCode).toBe(400);\n    expect(body.message).toBe('already.draft');\n  });\n\n  test('Delete a draft', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${data.productsWithDP[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithDP[0]);\n    expect(res.body.id).toEqual(data.productsWithDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDP.shift();\n  });\n\n  describe('validators', () => {\n    test('Can create a product - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: '',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dp.product-with-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithDP.push(res.body);\n    });\n\n    test('Can create a product - required', async () => {\n      const product = {\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dp.product-with-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        ...product,\n      });\n      expect(_.isNil(res.body.name)).toBe(true);\n      data.productsWithDP.push(res.body);\n    });\n\n    test('Cannot create a product - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: \"I'm a product description that is very long. At least thirty characters.\",\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dp.product-with-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.description.0')).toBe(\n        'description must be at most 30 characters'\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithDz: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithDz = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    dz: {\n      components: ['default.compo'],\n      type: 'dynamiczone',\n      required: true,\n    },\n  },\n  connection: 'default',\n  name: 'product with dz',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + dz', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithDz)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      dz: [\n        {\n          __component: 'default.compo',\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithDz.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results[0]).toMatchObject(data.productsWithDz[0]);\n    res.body.results.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      dz: [\n        {\n          __component: 'default.compo',\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-dz.product-with-dz/${data.productsWithDz[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithDz[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithDz[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-dz.product-with-dz/${data.productsWithDz[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithDz[0]);\n    expect(res.body.id).toEqual(data.productsWithDz[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithDz.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz', '0'])).toBe('dz must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            __component: 'default.compo',\n            name: 'compo name',\n            description: '',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].description', '0'])).toBe(\n        'dz[0].description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            __component: 'default.compo',\n            name: 'compo name',\n            description: 'A very long description that exceed the min length.',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].description', '0'])).toBe(\n        'dz[0].description must be at most 10 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            __component: 'default.compo',\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].name', '0'])).toBe(\n        'dz[0].name must be defined.'\n      );\n    });\n\n    test('Cannot create product with compo - missing __component', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            name: 'Product 1',\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].__component', '0'])).toBe(\n        'dz[0].__component is a required field'\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js": "'use strict';\n\nconst { createAuthRequest } = require('../../../../test/helpers/request');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\n\nlet strapi;\nlet rq;\nconst builder = createTestBuilder();\n\nlet data = {\n  stamps: [],\n  collectors: [],\n};\n\nconst stamp = {\n  name: 'stamp',\n  kind: 'collectionType',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst collector = {\n  name: 'collector',\n  kind: 'collectionType',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    age: {\n      type: 'integer',\n    },\n    stamps: {\n      nature: 'manyWay',\n      target: 'application::stamp.stamp',\n      unique: false,\n    },\n    stamps_one_way: {\n      nature: 'oneWay',\n      target: 'application::stamp.stamp',\n      unique: false,\n    },\n    stamps_m2m: {\n      nature: 'manyToMany',\n      targetAttribute: 'collectors',\n      target: 'application::stamp.stamp',\n      unique: false,\n      dominant: true,\n    },\n    stamps_one_many: {\n      nature: 'oneToMany',\n      targetAttribute: 'collector',\n      target: 'application::stamp.stamp',\n      unique: false,\n    },\n    stamps_one_one: {\n      nature: 'oneToOne',\n      targetAttribute: 'collector_one_one',\n      target: 'application::stamp.stamp',\n      unique: false,\n    },\n  },\n};\n\nconst stampFixtures = [\n  {\n    name: '1946',\n  },\n  {\n    name: '1947',\n  },\n  {\n    name: '1948',\n  },\n];\n\nconst collectorFixtures = ({ stamp }) => [\n  {\n    name: 'Bernard',\n    age: 25,\n    stamps: [stamp[0].id, stamp[1].id],\n    stamps_m2m: [stamp[0].id],\n    stamps_one_many: [],\n    stamps_one_way: stamp[0].id,\n    stamps_one_one: stamp[0].id,\n  },\n  {\n    name: 'Isabelle',\n    age: 55,\n    stamps: [stamp[0].id],\n    stamps_m2m: [],\n    stamps_one_many: [stamp[1].id, stamp[2].id],\n    stamps_one_way: stamp[1].id,\n    stamps_one_one: stamp[1].id,\n  },\n  {\n    name: 'Emma',\n    age: 23,\n    stamps: [],\n    stamps_m2m: [stamp[0].id, stamp[1].id],\n    stamps_one_many: [stamp[0].id],\n    stamps_one_way: stamp[2].id,\n    stamps_one_one: stamp[2].id,\n  },\n];\n\nconst getCollectorByName = (collectors, name) => collectors.find(c => c.name === name);\nconst getStampByName = (stamps, name) => stamps.find(s => s.name === name);\n\ndescribe('CM API', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentTypes([stamp, collector])\n      .addFixtures(stamp.name, stampFixtures)\n      .addFixtures(collector.name, collectorFixtures)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    data.collectors = builder.sanitizedFixturesFor(collector.name, strapi);\n    data.stamps = builder.sanitizedFixturesFor(stamp.name, strapi);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Count relations', () => {\n    test('many-way', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(getCollectorByName(res.body.results, 'Bernard').stamps.count).toBe(2);\n      expect(getCollectorByName(res.body.results, 'Isabelle').stamps.count).toBe(1);\n      expect(getCollectorByName(res.body.results, 'Emma').stamps.count).toBe(0);\n    });\n\n    test('many-to-many (collector -> stamps)', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(getCollectorByName(res.body.results, 'Bernard').stamps_m2m.count).toBe(1);\n      expect(getCollectorByName(res.body.results, 'Isabelle').stamps_m2m.count).toBe(0);\n      expect(getCollectorByName(res.body.results, 'Emma').stamps_m2m.count).toBe(2);\n    });\n\n    test('many-to-many (stamp -> collectors)', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::stamp.stamp',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(getStampByName(res.body.results, '1946').collectors.count).toBe(2);\n      expect(getStampByName(res.body.results, '1947').collectors.count).toBe(1);\n      expect(getStampByName(res.body.results, '1948').collectors.count).toBe(0);\n    });\n\n    test('one-to-many', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(getCollectorByName(res.body.results, 'Bernard').stamps_one_many.count).toBe(0);\n      expect(getCollectorByName(res.body.results, 'Isabelle').stamps_one_many.count).toBe(2);\n      expect(getCollectorByName(res.body.results, 'Emma').stamps_one_many.count).toBe(1);\n    });\n  });\n\n  describe('Filter relations', () => {\n    test('many-way', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _where: { 'stamps.name': '1946' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(2);\n      expect(res.body.results[0].name).toBe('Bernard');\n      expect(res.body.results[1].name).toBe('Isabelle');\n    });\n\n    test('many-to-many (collector -> stamps)', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _where: { 'stamps_m2m.name': '1946' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(2);\n      expect(getCollectorByName(res.body.results, 'Bernard')).toBeDefined();\n      expect(getCollectorByName(res.body.results, 'Emma')).toBeDefined();\n    });\n\n    test('many-to-many (stamp -> collectors)', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::stamp.stamp',\n        qs: {\n          _where: { 'collectors.name': 'Emma' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(2);\n      expect(getStampByName(res.body.results, '1946')).toBeDefined();\n      expect(getStampByName(res.body.results, '1947')).toBeDefined();\n    });\n\n    test('one-to-many', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _where: { 'stamps_one_many.name': '1947' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(1);\n      expect(res.body.results[0].name).toBe('Isabelle');\n    });\n\n    test('many-to-one', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::stamp.stamp',\n        qs: {\n          _where: { 'collector.name': 'Isabelle' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(2);\n      expect(getStampByName(res.body.results, '1947')).toBeDefined();\n      expect(getStampByName(res.body.results, '1948')).toBeDefined();\n    });\n\n    test('one-way', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _where: { 'stamps_one_way.name': '1947' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(1);\n      expect(getCollectorByName(res.body.results, 'Isabelle')).toBeDefined();\n    });\n\n    test('one-one', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _where: { 'stamps_one_one.name': '1947' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(1);\n      expect(getCollectorByName(res.body.results, 'Isabelle')).toBeDefined();\n    });\n  });\n\n  describe('Sort relations', () => {\n    test('many-to-one', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::stamp.stamp',\n        qs: {\n          _sort: 'collector.name:ASC',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(res.body.results[0].collector.name).toBe('Emma');\n      expect(res.body.results[1].collector.name).toBe('Isabelle');\n      expect(res.body.results[2].collector.name).toBe('Isabelle');\n\n      res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::stamp.stamp',\n        qs: {\n          _sort: 'collector.name:DESC',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(res.body.results[0].collector.name).toBe('Isabelle');\n      expect(res.body.results[1].collector.name).toBe('Isabelle');\n      expect(res.body.results[2].collector.name).toBe('Emma');\n    });\n\n    test('one-way', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _sort: 'stamps_one_way.name:ASC',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(res.body.results[0].stamps_one_way.name).toBe('1946');\n      expect(res.body.results[1].stamps_one_way.name).toBe('1947');\n      expect(res.body.results[2].stamps_one_way.name).toBe('1948');\n\n      res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _sort: 'stamps_one_way.name:DESC',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(res.body.results[0].stamps_one_way.name).toBe('1948');\n      expect(res.body.results[1].stamps_one_way.name).toBe('1947');\n      expect(res.body.results[2].stamps_one_way.name).toBe('1946');\n    });\n\n    test('one-one', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _sort: 'stamps_one_one.name:ASC',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(res.body.results[0].stamps_one_one.name).toBe('1946');\n      expect(res.body.results[1].stamps_one_one.name).toBe('1947');\n      expect(res.body.results[2].stamps_one_one.name).toBe('1948');\n\n      res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _sort: 'stamps_one_one.name:DESC',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(res.body.results[0].stamps_one_one.name).toBe('1948');\n      expect(res.body.results[1].stamps_one_one.name).toBe('1947');\n      expect(res.body.results[2].stamps_one_one.name).toBe('1946');\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  products: [],\n};\n\nconst product = {\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n  connection: 'default',\n  name: 'product',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('CM API - Basic', () => {\n  beforeAll(async () => {\n    await builder.addContentType(product).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/content-manager/collection-types/application::product.product',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.products.push(res.body);\n  });\n\n  test('Read product', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/content-manager/collection-types/application::product.product',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          name: 'Product 1',\n          description: 'Product description',\n        }),\n      ])\n    );\n    res.body.results.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product.product/${data.products[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.products[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.products[0] = res.body;\n  });\n\n  test('Delete product', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product.product/${data.products[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.products[0]);\n    expect(res.body.id).toEqual(data.products[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.products.shift();\n  });\n\n  describe('validators', () => {\n    test('Cannot create a product - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: '',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product.product',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.description.0')).toBe(\n        'description must be at least 4 characters'\n      );\n    });\n\n    test('Cannot create a product - required', async () => {\n      const product = {\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product.product',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.name.0')).toBe('name must be defined.');\n    });\n\n    test('Cannot create a product - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: \"I'm a product description that is very long. At least thirty characters.\",\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product.product',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.description.0')).toBe(\n        'description must be at most 30 characters'\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js": "'use strict';\n\nconst { prop, difference, map, uniq } = require('lodash/fp');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\n\nconst toIds = arr => uniq(map(prop('id'))(arr));\n\nlet strapi;\nlet rq;\nconst builder = createTestBuilder();\n\nconst data = {\n  product: [],\n  category: [],\n  shop: [],\n};\n\nconst productModel = {\n  attributes: {\n    name: {\n      type: 'string',\n      unique: true,\n    },\n    categories: {\n      nature: 'oneToMany',\n      private: false,\n      target: 'application::category.category',\n      targetAttribute: 'product',\n    },\n    shops: {\n      nature: 'manyWay',\n      target: 'application::shop.shop',\n    },\n  },\n  name: 'product',\n};\n\nconst categoryModel = {\n  attributes: {\n    name: {\n      type: 'string',\n      unique: true,\n    },\n  },\n  name: 'category',\n};\n\nconst shopModel = {\n  attributes: {\n    name: {\n      type: 'string',\n      unique: true,\n    },\n    metadata: {\n      type: 'string',\n    },\n  },\n  name: 'shop',\n};\n\nconst fixtures = {\n  shop: [\n    { name: 'SH.A', metadata: 'foobar' },\n    { name: 'SH.B', metadata: 'foobar' },\n    { name: 'SH.C', metadata: 'foobar' },\n    { name: 'SH.D', metadata: 'foobar' },\n    { name: 'SH.E', metadata: 'foobar' },\n    { name: 'SH.F', metadata: 'foobar' },\n    { name: 'SH.G', metadata: 'foobar' },\n    { name: 'SH.H', metadata: 'foobar' },\n    { name: 'SH.I', metadata: 'foobar' },\n    { name: 'SH.J', metadata: 'foobar' },\n    { name: 'SH.K', metadata: 'foobar' },\n    { name: 'SH.L', metadata: 'foobar' },\n  ],\n  category: [\n    { name: 'CT.A' },\n    { name: 'CT.B' },\n    { name: 'CT.C' },\n    { name: 'CT.D' },\n    { name: 'CT.E' },\n    { name: 'CT.F' },\n    { name: 'CT.G' },\n    { name: 'CT.H' },\n    { name: 'CT.I' },\n    { name: 'CT.J' },\n    { name: 'CT.K' },\n    { name: 'CT.L' },\n  ],\n  product: ({ shop, category }) => [\n    {\n      name: 'PD.A',\n      categories: category.slice(0, 5).map(prop('id')),\n      shops: shop.slice(0, 12).map(prop('id')),\n    },\n  ],\n};\n\nconst getUID = modelName => `application::${modelName}.${modelName}`;\nconst getCMPrefixUrl = modelName => `/content-manager/collection-types/${getUID(modelName)}`;\n\ndescribe('x-to-many RF Preview', () => {\n  const cmProductUrl = getCMPrefixUrl(productModel.name);\n\n  beforeAll(async () => {\n    await builder\n      .addContentTypes([shopModel, categoryModel, productModel])\n      .addFixtures(shopModel.name, fixtures.shop)\n      .addFixtures(categoryModel.name, fixtures.category)\n      .addFixtures(productModel.name, fixtures.product)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    Object.assign(data, builder.sanitizedFixtures(strapi));\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Entity Misc', () => {\n    test.each(['foobar', 'name'])(`Throws if the targeted field is invalid (%s)`, async field => {\n      const product = data.product[0];\n      const { body, statusCode } = await rq.get(`${cmProductUrl}/${product.id}/${field}`);\n\n      expect(statusCode).toBe(400);\n      expect(body.error).toBe('Bad Request');\n      expect(body.message).toBe('Invalid target field');\n    });\n\n    test('Throws if the entity does not exist', async () => {\n      const { body, statusCode } = await rq.get(`${cmProductUrl}/${data.shop[11].id}/categories`);\n\n      expect(statusCode).toBe(404);\n      expect(body.error).toBe('Not Found');\n    });\n  });\n\n  describe('Relation Nature', () => {\n    test(`Throws if the relation's nature is not a x-to-many`, async () => {\n      const url = getCMPrefixUrl(categoryModel.name);\n      const id = data.category[0].id;\n\n      const { body, statusCode } = await rq.get(`${url}/${id}/product`);\n\n      expect(statusCode).toBe(400);\n      expect(body.error).toBe('Bad Request');\n      expect(body.message).toBe('Invalid target field');\n    });\n  });\n\n  describe('Default Behavior', () => {\n    test.each(['shops', 'categories'])('Should return a preview for the %s field', async field => {\n      const product = data.product[0];\n\n      const { body, statusCode } = await rq.get(`${cmProductUrl}/${product.id}/${field}`);\n\n      const expected = product[field].slice(0, 10);\n\n      expect(statusCode).toBe(200);\n      expect(body.results).toHaveLength(expected.length);\n      expect(difference(toIds(body.results), toIds(product[field]))).toHaveLength(0);\n    });\n  });\n\n  describe('Pagination', () => {\n    test.each([\n      [1, 10],\n      [2, 10],\n      [5, 1],\n      [4, 2],\n      [1, 100],\n    ])('Custom pagination (%s, %s)', async (page, pageSize) => {\n      const product = data.product[0];\n\n      const { body, statusCode } = await rq.get(\n        `${cmProductUrl}/${product.id}/shops?page=${page}&pageSize=${pageSize}`\n      );\n\n      expect(statusCode).toBe(200);\n\n      const { pagination, results } = body;\n\n      expect(pagination.page).toBe(page);\n      expect(pagination.pageSize).toBe(pageSize);\n      expect(results).toHaveLength(\n        Math.min(pageSize, product.shops.length - pageSize * (page - 1))\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst component = {\n  name: 'somecomponent',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst ct = {\n  name: 'withcomponent',\n  attributes: {\n    field: {\n      type: 'component',\n      component: 'default.somecomponent',\n      repeatable: true,\n      required: false,\n      min: 2,\n      max: 5,\n    },\n  },\n};\n\ndescribe.each([\n  ['CONTENT MANAGER', '/content-manager/collection-types/application::withcomponent.withcomponent'],\n  ['GENERATED API', '/withcomponents'],\n])('[%s] => Non repeatable and Not required component', (_, path) => {\n  const builder = createTestBuilder();\n  const hasPagination = path.includes('/content-manager');\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(component)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('POST new entry', () => {\n    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'someString',\n          }),\n        ])\n      );\n    });\n\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws if the field is not an array %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n      }\n    );\n\n    test('Throws when sending a non empty array with less then the min', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'test',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Success when sending an empty array', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n    });\n\n    test('Throws when sending too many items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Can send input without the component field', async () => {\n      const res = await rq.post('/', {\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual([]);\n    });\n  });\n\n  describe('GET entries', () => {\n    test('Data is ordered in the order sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'firstString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'firstString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/');\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        res.body.results.forEach(entry => {\n          expect(Array.isArray(entry.field)).toBe(true);\n\n          if (entry.field.length === 0) return;\n\n          expect(entry.field).toEqual(\n            expect.arrayContaining([\n              expect.objectContaining({\n                name: expect.any(String),\n              }),\n            ])\n          );\n        });\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      res.body.forEach(entry => {\n        expect(Array.isArray(entry.field)).toBe(true);\n\n        if (entry.field.length === 0) return;\n\n        expect(entry.field).toEqual(\n          expect.arrayContaining([\n            expect.objectContaining({\n              name: expect.any(String),\n            }),\n          ])\n        );\n      });\n    });\n  });\n\n  describe('PUT entry', () => {\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws when sending invalid updated field %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: [\n              {\n                name: 'someString',\n              },\n              {\n                name: 'someString',\n              },\n            ],\n          },\n        });\n\n        const updateRes = await rq.put(`/${res.body.id}`, {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(updateRes.statusCode).toBe(400);\n\n        // shouldn't have been updated\n        const getRes = await rq.get(`/${res.body.id}`);\n\n        expect(getRes.statusCode).toBe(200);\n        expect(getRes.body).toMatchObject({\n          id: res.body.id,\n          field: res.body.field,\n        });\n      }\n    );\n\n    test('Updates order at each request', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      expect(res.body.field[0]).toMatchObject({\n        name: 'someString',\n      });\n      expect(res.body.field[1]).toMatchObject({\n        name: 'otherString',\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'otherString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(Array.isArray(updateRes.body.field)).toBe(true);\n\n      expect(updateRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(updateRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {},\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n    });\n\n    test('Throws when not enough items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'lala',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(res.body);\n    });\n\n    test('Throws when too many items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'test',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(res.body);\n    });\n\n    test('Replaces the previous components if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            { name: 'test' },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'new String',\n            },\n            {\n              name: 'test',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n\n      const oldIds = res.body.field.map(val => val.id);\n      updateRes.body.field.forEach(val => {\n        expect(oldIds.includes(val.id)).toBe(false);\n      });\n\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n          {\n            name: 'test',\n          },\n        ],\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n          {\n            name: 'test',\n          },\n        ],\n      });\n    });\n\n    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'test',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: 'invalid_id',\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n    });\n\n    test('Updates component with ids, create new ones and removes old ones', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'one',\n            },\n            {\n              name: 'two',\n            },\n            {\n              name: 'three',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: res.body.field[0].id, // send old id to update the previous component\n              name: 'newOne',\n            },\n            {\n              name: 'newTwo',\n            },\n            {\n              id: res.body.field[2].id,\n              name: 'three',\n            },\n            {\n              name: 'four',\n            },\n          ],\n        },\n      });\n\n      const expectedResult = {\n        id: res.body.id,\n        field: [\n          {\n            id: res.body.field[0].id,\n            name: 'newOne',\n          },\n          {\n            name: 'newTwo',\n          },\n          {\n            id: res.body.field[2].id,\n            name: 'three',\n          },\n          {\n            name: 'four',\n          },\n        ],\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n\n      expect(updateRes.body).toMatchObject(expectedResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectedResult);\n    });\n  });\n\n  describe('DELETE entry', () => {\n    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someOtherString',\n            },\n            {\n              name: 'otherSomeString',\n            },\n          ],\n        },\n      });\n\n      const deleteRes = await rq.delete(`/${res.body.id}`);\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body).toMatchObject(res.body);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(404);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst component = {\n  name: 'somecomponent',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst ct = {\n  name: 'withcomponent',\n  attributes: {\n    field: {\n      type: 'component',\n      component: 'default.somecomponent',\n      repeatable: true,\n      required: false,\n    },\n  },\n};\n\ndescribe.each([\n  ['CONTENT MANAGER', '/content-manager/collection-types/application::withcomponent.withcomponent'],\n  ['GENERATED API', '/withcomponents'],\n])('[%s] => Non repeatable and Not required component', (_, path) => {\n  const builder = createTestBuilder();\n  const hasPagination = path.includes('/content-manager');\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(component)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('POST new entry', () => {\n    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'someString',\n          }),\n        ])\n      );\n    });\n\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws if the field is not an object %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n      }\n    );\n\n    test('Can send an empty array', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual([]);\n    });\n\n    test('Can send input without the component field', async () => {\n      const res = await rq.post('/', {\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual([]);\n    });\n  });\n\n  describe('GET entries', () => {\n    test('Data is orderd in the order sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'firstString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'firstString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/');\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        res.body.results.forEach(entry => {\n          expect(Array.isArray(entry.field)).toBe(true);\n\n          if (entry.field.length === 0) return;\n\n          expect(entry.field).toEqual(\n            expect.arrayContaining([\n              expect.objectContaining({\n                name: expect.any(String),\n              }),\n            ])\n          );\n        });\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      res.body.forEach(entry => {\n        expect(Array.isArray(entry.field)).toBe(true);\n\n        if (entry.field.length === 0) return;\n\n        expect(entry.field).toEqual(\n          expect.arrayContaining([\n            expect.objectContaining({\n              name: expect.any(String),\n            }),\n          ])\n        );\n      });\n    });\n  });\n\n  describe('PUT entry', () => {\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws when sending invalid updated field %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: [\n              {\n                name: 'someString',\n              },\n            ],\n          },\n        });\n\n        const updateRes = await rq.put(`/${res.body.id}`, {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(updateRes.statusCode).toBe(400);\n\n        // shouldn't have been updated\n        const getRes = await rq.get(`/${res.body.id}`);\n\n        expect(getRes.statusCode).toBe(200);\n        expect(getRes.body).toMatchObject({\n          id: res.body.id,\n          field: res.body.field,\n        });\n      }\n    );\n\n    test('Updates order at each request', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      expect(res.body.field[0]).toMatchObject({\n        name: 'someString',\n      });\n      expect(res.body.field[1]).toMatchObject({\n        name: 'otherString',\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'otherString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(Array.isArray(updateRes.body.field)).toBe(true);\n\n      expect(updateRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(updateRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {},\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n    });\n\n    test('Removes previous components if empty array sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [],\n        },\n      });\n\n      const expectResult = {\n        id: res.body.id,\n        field: [],\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectResult);\n    });\n\n    test('Replaces the previous components if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n\n      const oldIds = res.body.field.map(val => val.id);\n      updateRes.body.field.forEach(val => {\n        expect(oldIds.includes(val.id)).toBe(false);\n      });\n\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n        ],\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n        ],\n      });\n    });\n\n    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: 'invalid_id',\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n    });\n\n    test('Updates component with ids, create new ones and removes old ones', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'one',\n            },\n            {\n              name: 'two',\n            },\n            {\n              name: 'three',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: res.body.field[0].id, // send old id to update the previous component\n              name: 'newOne',\n            },\n            {\n              name: 'newTwo',\n            },\n            {\n              id: res.body.field[2].id,\n              name: 'three',\n            },\n            {\n              name: 'four',\n            },\n          ],\n        },\n      });\n\n      const expectedResult = {\n        id: res.body.id,\n        field: [\n          {\n            id: res.body.field[0].id,\n            name: 'newOne',\n          },\n          {\n            name: 'newTwo',\n          },\n          {\n            id: res.body.field[2].id,\n            name: 'three',\n          },\n          {\n            name: 'four',\n          },\n        ],\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectedResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectedResult);\n    });\n  });\n\n  describe('DELETE entry', () => {\n    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someOtherString',\n            },\n            {\n              name: 'otherSomeString',\n            },\n          ],\n        },\n      });\n\n      const deleteRes = await rq.delete(`/${res.body.id}`);\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body).toMatchObject(res.body);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(404);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst component = {\n  name: 'somecomponent',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst ct = {\n  name: 'withcomponent',\n  attributes: {\n    field: {\n      type: 'component',\n      component: 'default.somecomponent',\n      repeatable: true,\n      required: true,\n      min: 1,\n      max: 5,\n    },\n  },\n};\n\ndescribe.each([\n  ['CONTENT MANAGER', '/content-manager/collection-types/application::withcomponent.withcomponent'],\n  ['GENERATED API', '/withcomponents'],\n])('[%s] => Non repeatable and Not required component', (_, path) => {\n  const builder = createTestBuilder();\n  const hasPagination = path.includes('/content-manager');\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(component)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('POST new entry', () => {\n    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'someString',\n          }),\n        ])\n      );\n    });\n\n    test('Creating second entry', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someValue',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'someValue',\n          }),\n        ])\n      );\n    });\n\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws if the field is not an object %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n      }\n    );\n\n    test('Throws when sending an empty array or an array with less than the min', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Throws when sending too many items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n  });\n\n  describe('GET entries', () => {\n    test('Data is orderd in the order sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'firstString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'firstString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/');\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        res.body.results.forEach(entry => {\n          expect(Array.isArray(entry.field)).toBe(true);\n\n          if (entry.field.length === 0) return;\n\n          expect(entry.field).toEqual(\n            expect.arrayContaining([\n              expect.objectContaining({\n                name: expect.any(String),\n              }),\n            ])\n          );\n        });\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      res.body.forEach(entry => {\n        expect(Array.isArray(entry.field)).toBe(true);\n\n        if (entry.field.length === 0) return;\n\n        expect(entry.field).toEqual(\n          expect.arrayContaining([\n            expect.objectContaining({\n              name: expect.any(String),\n            }),\n          ])\n        );\n      });\n    });\n  });\n\n  describe('PUT entry', () => {\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws when sending invalid updated field %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: [\n              {\n                name: 'someString',\n              },\n            ],\n          },\n        });\n\n        const updateRes = await rq.put(`/${res.body.id}`, {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(updateRes.statusCode).toBe(400);\n\n        // shouldn't have been updated\n        const getRes = await rq.get(`/${res.body.id}`);\n\n        expect(getRes.statusCode).toBe(200);\n        expect(getRes.body).toMatchObject({\n          id: res.body.id,\n          field: res.body.field,\n        });\n      }\n    );\n\n    test('Updates order at each request', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      expect(res.body.field[0]).toMatchObject({\n        name: 'someString',\n      });\n      expect(res.body.field[1]).toMatchObject({\n        name: 'otherString',\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'otherString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(Array.isArray(updateRes.body.field)).toBe(true);\n\n      expect(updateRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(updateRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {},\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n    });\n\n    test('Throws when not enough items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(res.body);\n    });\n\n    test('Throws when too many items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(res.body);\n    });\n\n    test('Replaces the previous components if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n\n      const oldIds = res.body.field.map(val => val.id);\n      updateRes.body.field.forEach(val => {\n        expect(oldIds.includes(val.id)).toBe(false);\n      });\n\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n        ],\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n        ],\n      });\n    });\n\n    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: 'invalid_id',\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n    });\n\n    test('Updates component with ids, create new ones and removes old ones', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'one',\n            },\n            {\n              name: 'two',\n            },\n            {\n              name: 'three',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: res.body.field[0].id, // send old id to update the previous component\n              name: 'newOne',\n            },\n            {\n              name: 'newTwo',\n            },\n            {\n              id: res.body.field[2].id,\n              name: 'three',\n            },\n            {\n              name: 'four',\n            },\n          ],\n        },\n      });\n\n      const expectedResult = {\n        id: res.body.id,\n        field: [\n          {\n            id: res.body.field[0].id,\n            name: 'newOne',\n          },\n          {\n            name: 'newTwo',\n          },\n          {\n            id: res.body.field[2].id,\n            name: 'three',\n          },\n          {\n            name: 'four',\n          },\n        ],\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectedResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectedResult);\n    });\n  });\n\n  describe('DELETE entry', () => {\n    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someOtherString',\n            },\n            {\n              name: 'otherSomeString',\n            },\n          ],\n        },\n      });\n\n      const deleteRes = await rq.delete(`/${res.body.id}`);\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body).toMatchObject(res.body);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(404);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst component = {\n  name: 'somecomponent',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst ct = {\n  name: 'withcomponent',\n  attributes: {\n    field: {\n      type: 'component',\n      component: 'default.somecomponent',\n      repeatable: true,\n      required: true,\n    },\n  },\n};\n\ndescribe.each([\n  ['CONTENT MANAGER', '/content-manager/collection-types/application::withcomponent.withcomponent'],\n  ['GENERATED API', '/withcomponents'],\n])('[%s] => Non repeatable and Not required component', (_, path) => {\n  const hasPagination = path.includes('/content-manager');\n  const builder = createTestBuilder();\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(component)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('POST new entry', () => {\n    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'someString',\n          }),\n        ])\n      );\n    });\n\n    test('Creating second entry', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someValue',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'someValue',\n          }),\n        ])\n      );\n    });\n\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws if the field is not an object %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n      }\n    );\n\n    test('Can send an empty array', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual([]);\n    });\n\n    test('Throws when component is not provided', async () => {\n      const res = await rq.post('/', {\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n  });\n\n  describe('GET entries', () => {\n    test('Data is orderd in the order sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'firstString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'firstString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/');\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        res.body.results.forEach(entry => {\n          expect(Array.isArray(entry.field)).toBe(true);\n\n          if (entry.field.length === 0) return;\n\n          expect(entry.field).toEqual(\n            expect.arrayContaining([\n              expect.objectContaining({\n                name: expect.any(String),\n              }),\n            ])\n          );\n        });\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      res.body.forEach(entry => {\n        expect(Array.isArray(entry.field)).toBe(true);\n\n        if (entry.field.length === 0) return;\n\n        expect(entry.field).toEqual(\n          expect.arrayContaining([\n            expect.objectContaining({\n              name: expect.any(String),\n            }),\n          ])\n        );\n      });\n    });\n  });\n\n  describe('PUT entry', () => {\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws when sending invalid updated field %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: [\n              {\n                name: 'someString',\n              },\n            ],\n          },\n        });\n\n        const updateRes = await rq.put(`/${res.body.id}`, {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(updateRes.statusCode).toBe(400);\n\n        // shouldn't have been updated\n        const getRes = await rq.get(`/${res.body.id}`);\n\n        expect(getRes.statusCode).toBe(200);\n        expect(getRes.body).toMatchObject({\n          id: res.body.id,\n          field: res.body.field,\n        });\n      }\n    );\n\n    test('Updates order at each request', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      expect(res.body.field[0]).toMatchObject({\n        name: 'someString',\n      });\n      expect(res.body.field[1]).toMatchObject({\n        name: 'otherString',\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'otherString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(Array.isArray(updateRes.body.field)).toBe(true);\n\n      expect(updateRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(updateRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {},\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n    });\n\n    test('Removes previous components if empty array sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [],\n        },\n      });\n\n      const expectResult = {\n        id: res.body.id,\n        field: [],\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectResult);\n    });\n\n    test('Replaces the previous components if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n\n      const oldIds = res.body.field.map(val => val.id);\n      updateRes.body.field.forEach(val => {\n        expect(oldIds.includes(val.id)).toBe(false);\n      });\n\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n        ],\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n        ],\n      });\n    });\n\n    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: 'invalid_id',\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n    });\n\n    test('Updates component with ids, create new ones and removes old ones', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'one',\n            },\n            {\n              name: 'two',\n            },\n            {\n              name: 'three',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: res.body.field[0].id, // send old id to update the previous component\n              name: 'newOne',\n            },\n            {\n              name: 'newTwo',\n            },\n            {\n              id: res.body.field[2].id,\n              name: 'three',\n            },\n            {\n              name: 'four',\n            },\n          ],\n        },\n      });\n\n      const expectedResult = {\n        id: res.body.id,\n        field: [\n          {\n            id: res.body.field[0].id,\n            name: 'newOne',\n          },\n          {\n            name: 'newTwo',\n          },\n          {\n            id: res.body.field[2].id,\n            name: 'three',\n          },\n          {\n            name: 'four',\n          },\n        ],\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectedResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectedResult);\n    });\n  });\n\n  describe('DELETE entry', () => {\n    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someOtherString',\n            },\n            {\n              name: 'otherSomeString',\n            },\n          ],\n        },\n      });\n\n      const deleteRes = await rq.delete(`/${res.body.id}`);\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body).toMatchObject(res.body);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(404);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst component = {\n  name: 'somecomponent',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst ct = {\n  name: 'withcomponent',\n  attributes: {\n    field: {\n      type: 'component',\n      component: 'default.somecomponent',\n      repeatable: false,\n      required: false,\n    },\n  },\n};\n\ndescribe.each([\n  ['CONTENT MANAGER', '/content-manager/collection-types/application::withcomponent.withcomponent'],\n  ['GENERATED API', '/withcomponents'],\n])('[%s] => Non repeatable and Not required component', (_, path) => {\n  const builder = createTestBuilder();\n  const hasPagination = path.includes('/content-manager');\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(component)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('POST new entry', () => {\n    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual(\n        expect.objectContaining({\n          id: expect.anything(),\n          name: 'someString',\n        })\n      );\n    });\n\n    test('Creating second entry ', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someValue',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual(\n        expect.objectContaining({\n          id: expect.anything(),\n          name: 'someValue',\n        })\n      );\n    });\n\n    test.each([[], 'someString', 128219, false])(\n      'Throws if the field is not an object %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n      }\n    );\n\n    test('Can send a null value', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: null,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toBe(null);\n    });\n\n    test('Can send input without the component field', async () => {\n      const res = await rq.post('/', {\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toBe(null);\n    });\n  });\n\n  describe('GET entries', () => {\n    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/');\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        res.body.results.forEach(entry => {\n          if (entry.field === null) return;\n\n          expect(entry.field).toMatchObject({\n            name: expect.any(String),\n          });\n        });\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      res.body.forEach(entry => {\n        if (entry.field === null) return;\n\n        expect(entry.field).toMatchObject({\n          name: expect.any(String),\n        });\n      });\n    });\n  });\n\n  describe('PUT entry', () => {\n    test.each([[], 'someString', 128219, false])(\n      'Throws when sending invalid updated field %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: {\n              name: 'someString',\n            },\n          },\n        });\n\n        const updateRes = await rq.put(`/${res.body.id}`, {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(updateRes.statusCode).toBe(400);\n\n        // shouldn't have been updated\n        const getRes = await rq.get(`/${res.body.id}`);\n\n        expect(getRes.statusCode).toBe(200);\n        expect(getRes.body).toMatchObject({\n          id: res.body.id,\n          field: res.body.field,\n        });\n      }\n    );\n\n    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {},\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n    });\n\n    test('Removes previous component if null sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: null,\n        },\n      });\n\n      const expectResult = {\n        id: res.body.id,\n        field: null,\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectResult);\n    });\n\n    test('Replaces the previous component if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: {\n            name: 'new String',\n          },\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.field.id).not.toBe(res.body.field.id);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: {\n          name: 'new String',\n        },\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: {\n          name: 'new String',\n        },\n      });\n    });\n\n    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: {\n            id: 'invalid_id',\n            name: 'new String',\n          },\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n    });\n\n    test('Updates component if previsous component id is sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: {\n            id: res.body.field.id, // send old id to update the previous component\n            name: 'new String',\n          },\n        },\n      });\n\n      const expectedResult = {\n        id: res.body.id,\n        field: {\n          id: res.body.field.id,\n          name: 'new String',\n        },\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectedResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectedResult);\n    });\n  });\n\n  describe('DELETE entry', () => {\n    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const deleteRes = await rq.delete(`/${res.body.id}`);\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body).toMatchObject(res.body);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(404);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst component = {\n  name: 'somecomponent',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst ct = {\n  name: 'withcomponent',\n  attributes: {\n    field: {\n      type: 'component',\n      component: 'default.somecomponent',\n      repeatable: false,\n      required: true,\n    },\n  },\n};\n\ndescribe.each([\n  ['CONTENT MANAGER', '/content-manager/collection-types/application::withcomponent.withcomponent'],\n  ['GENERATED API', '/withcomponents'],\n])('[%s] => Non repeatable and required component', (_, path) => {\n  const builder = createTestBuilder();\n  const hasPagination = path.includes('/content-manager');\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(component)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('POST new entry', () => {\n    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual(\n        expect.objectContaining({\n          id: expect.anything(),\n          name: 'someString',\n        })\n      );\n    });\n\n    test('Creating a second entry works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someValue',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual(\n        expect.objectContaining({\n          id: expect.anything(),\n          name: 'someValue',\n        })\n      );\n    });\n\n    test.each([[], 'someString', 128219, false])(\n      'Throws if the field is not an object %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n      }\n    );\n\n    test('Throws when sending a null value', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: null,\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Throws when the component is not provided', async () => {\n      const res = await rq.post('/', {\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n  });\n\n  describe('GET entries', () => {\n    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/');\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        res.body.results.forEach(entry => {\n          if (entry.field === null) return;\n\n          expect(entry.field).toMatchObject({\n            name: expect.any(String),\n          });\n        });\n\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      res.body.forEach(entry => {\n        if (entry.field === null) return;\n\n        expect(entry.field).toMatchObject({\n          name: expect.any(String),\n        });\n      });\n    });\n  });\n\n  describe('PUT entry', () => {\n    test.each([[], 'someString', 128219, false])(\n      'Throws when sending invalid updated field %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: {\n              name: 'someString',\n            },\n          },\n        });\n\n        const updateRes = await rq.put(`/${res.body.id}`, {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(updateRes.statusCode).toBe(400);\n\n        // shouldn't have been updated\n        const getRes = await rq.get(`/${res.body.id}`);\n\n        expect(getRes.statusCode).toBe(200);\n        expect(getRes.body).toMatchObject({\n          id: res.body.id,\n          field: res.body.field,\n        });\n      }\n    );\n\n    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {},\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n    });\n\n    test('Throws if component is null', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: null,\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(res.body);\n    });\n\n    test('Replaces the previous component if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: {\n            name: 'new String',\n          },\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.field.id).not.toBe(res.body.field.id);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: {\n          name: 'new String',\n        },\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: {\n          name: 'new String',\n        },\n      });\n    });\n\n    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: {\n            id: 'invalid_id',\n            name: 'new String',\n          },\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n    });\n\n    test('Updates component if previsous component id is sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: {\n            id: res.body.field.id, // send old id to update the previous component\n            name: 'new String',\n          },\n        },\n      });\n\n      const expectedResult = {\n        id: res.body.id,\n        field: {\n          id: res.body.field.id,\n          name: 'new String',\n        },\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectedResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectedResult);\n    });\n  });\n\n  describe('DELETE entry', () => {\n    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const deleteRes = await rq.delete(`/${res.body.id}`);\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body).toMatchObject(res.body);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(404);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet uid = 'application::uid-model.uid-model';\n\nconst model = {\n  kind: 'collectionType',\n  name: 'uid-model',\n  attributes: {\n    title: {\n      type: 'string',\n    },\n    slug: {\n      type: 'uid',\n      targetField: 'title',\n    },\n    otherField: {\n      type: 'integer',\n    },\n  },\n};\n\ndescribe('Content Manager single types', () => {\n  beforeAll(async () => {\n    await builder.addContentType(model).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Generate UID', () => {\n    test('Throws if input is not provided', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          contentTypeUID: expect.arrayContaining([expect.stringMatching('required field')]),\n          field: expect.arrayContaining([expect.stringMatching('required field')]),\n          data: expect.arrayContaining([expect.stringMatching('required field')]),\n        },\n      });\n    });\n\n    test('Throws when contentType is not found', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: 'non-existent',\n          field: 'slug',\n          data: {},\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: ['ContentType not found'],\n      });\n    });\n\n    test('Throws when field is not a uid field', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'otherField',\n          data: {},\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          field: [expect.stringMatching('must be a valid `uid` attribute')],\n        },\n      });\n    });\n\n    test('Generates a unique field when targetField is empty', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {},\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toBe('uid-model');\n\n      await rq({\n        url: `/content-manager/collection-types/${uid}`,\n        method: 'POST',\n        body: {\n          slug: res.body.data,\n        },\n      });\n\n      const secondRes = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {},\n        },\n      });\n\n      expect(secondRes.statusCode).toBe(200);\n      expect(secondRes.body.data).toBe('uid-model-1');\n    });\n\n    test('Generates a unique field based on targetField', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {\n            title: 'This is a super title',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toBe('this-is-a-super-title');\n\n      await rq({\n        url: `/content-manager/collection-types/${uid}`,\n        method: 'POST',\n        body: {\n          slug: res.body.data,\n        },\n      });\n\n      const secondRes = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {\n            title: 'This is a super title',\n          },\n        },\n      });\n\n      expect(secondRes.statusCode).toBe(200);\n      expect(secondRes.body.data).toBe('this-is-a-super-title-1');\n    });\n\n    test('Avoids collisions with already generated uids', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {\n            title: 'My title',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toBe('my-title');\n\n      await rq({\n        url: `/content-manager/collection-types/${uid}`,\n        method: 'POST',\n        body: {\n          slug: res.body.data,\n        },\n      });\n\n      const secondRes = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {\n            title: 'My title',\n          },\n        },\n      });\n\n      expect(secondRes.statusCode).toBe(200);\n      expect(secondRes.body.data).toBe('my-title-1');\n\n      await rq({\n        url: `/content-manager/collection-types/${uid}`,\n        method: 'POST',\n        body: {\n          slug: secondRes.body.data,\n        },\n      });\n\n      const thridRes = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {\n            title: 'My title 1',\n          },\n        },\n      });\n\n      expect(thridRes.statusCode).toBe(200);\n      expect(thridRes.body.data).toBe('my-title-1-1');\n    });\n  });\n\n  describe('Check UID availability', () => {\n    test('Throws if input is not provided', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/check-availability`,\n        method: 'POST',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          contentTypeUID: expect.arrayContaining([expect.stringMatching('required field')]),\n          field: expect.arrayContaining([expect.stringMatching('required field')]),\n          value: expect.arrayContaining([expect.stringMatching('required field')]),\n        },\n      });\n    });\n\n    test('Throws on invalid uid value', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/check-availability`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          value: 'Invalid UID valu',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: {\n          value: expect.arrayContaining([expect.stringMatching('must match')]),\n        },\n      });\n    });\n\n    test('Throws when contentType is not found', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/check-availability`,\n        method: 'POST',\n        body: {\n          contentTypeUID: 'non-existent',\n          field: 'slug',\n          value: 'some-slug',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: ['ContentType not found'],\n      });\n    });\n\n    test('Throws when field is not a uid field', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/check-availability`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'otherField',\n          value: 'some-slug',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          field: [expect.stringMatching('must be a valid `uid` attribute')],\n        },\n      });\n    });\n\n    test('Checks availability', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/check-availability`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          value: 'some-available-slug',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        isAvailable: true,\n        suggestion: null,\n      });\n    });\n\n    test('Gives a suggestion when not available', async () => {\n      // create data\n      await rq({\n        url: `/content-manager/collection-types/${uid}`,\n        method: 'POST',\n        body: {\n          slug: 'custom-slug',\n        },\n      });\n\n      const res = await rq({\n        url: `/content-manager/uid/check-availability`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          value: 'custom-slug',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        isAvailable: false,\n        suggestion: 'custom-slug-1',\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst defaultBody = {\n  field: [\n    {\n      __component: 'default.simple-compo',\n      name: 'someString',\n    },\n    {\n      __component: 'default.compo-with-other-compo',\n      compo: {\n        name: 'someString',\n      },\n    },\n  ],\n};\n\nconst models = {\n  ct: {\n    name: 'withdynamiczone',\n    attributes: {\n      field: {\n        type: 'dynamiczone',\n        components: ['default.compo-with-other-compo', 'default.simple-compo'],\n        required: false,\n        min: 2,\n        max: 5,\n      },\n    },\n  },\n  simpleCompo: {\n    name: 'simple-compo',\n    attributes: {\n      name: {\n        type: 'string',\n      },\n    },\n  },\n  otherCompo: {\n    name: 'compo-with-other-compo',\n    attributes: {\n      compo: {\n        type: 'component',\n        component: 'default.simple-compo',\n      },\n    },\n  },\n};\n\nconst createEntry = () => {\n  return rq({\n    method: 'POST',\n    url: '/',\n    body: defaultBody,\n  });\n};\n\nconst createEmpty = () => {\n  return rq({\n    method: 'POST',\n    url: '/',\n    body: {\n      field: [],\n    },\n  });\n};\n\ndescribe.each([\n  [\n    'CONTENT MANAGER',\n    '/content-manager/collection-types/application::withdynamiczone.withdynamiczone',\n  ],\n  ['GENERATED API', '/withdynamiczones'],\n])('[%s] => Not required dynamiczone', (_, path) => {\n  const builder = createTestBuilder();\n  const hasPagination = path.includes('/content-manager');\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(models.simpleCompo)\n      .addComponent(models.otherCompo)\n      .addContentType(models.ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Creation', () => {\n    test('Can create an entry with a dynamic zone and a nested compo', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [\n            {\n              __component: 'default.simple-compo',\n              name: 'someString',\n            },\n            {\n              __component: 'default.compo-with-other-compo',\n              compo: {\n                name: 'someString',\n              },\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'someString',\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.compo-with-other-compo',\n            compo: {\n              id: expect.anything(),\n              name: 'someString',\n            },\n          },\n        ],\n      });\n    });\n\n    test('Can create entry with empty dynamiczone if it is not required', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field.length).toBe(0);\n    });\n\n    test('Throw if min items is not respected', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [\n            {\n              __component: 'default.simple-compo',\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Throws if max items is not respected', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: Array(10).fill({\n            __component: 'default.simple-compo',\n            name: 'someString',\n          }),\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n  });\n\n  describe('Getting one entry', () => {\n    test('The entry has its dynamic zone populated', async () => {\n      const createRes = await createEntry();\n      const entryId = createRes.body.id;\n\n      const res = await rq({ method: 'GET', url: `/${entryId}` });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'someString',\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.compo-with-other-compo',\n            compo: {\n              id: expect.anything(),\n              name: 'someString',\n            },\n          },\n        ],\n      });\n    });\n  });\n\n  describe('Listing entries', () => {\n    test('The entries have their dynamic zones populated', async () => {\n      const res = await rq({ method: 'GET', url: '/' });\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        expect(res.body.results).toEqual(\n          expect.arrayContaining([\n            expect.objectContaining({\n              field: expect.arrayContaining([\n                expect.objectContaining({\n                  id: expect.anything(),\n                  __component: expect.any(String),\n                }),\n              ]),\n            }),\n          ])\n        );\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            field: expect.arrayContaining([\n              expect.objectContaining({\n                id: expect.anything(),\n                __component: expect.any(String),\n              }),\n            ]),\n          }),\n        ])\n      );\n    });\n  });\n\n  describe('Edition', () => {\n    test('Can empty non required dynamic zone', async () => {\n      const createRes = await createEntry();\n\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.id;\n\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: {\n          field: [],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual([]);\n    });\n\n    test('Can add items to empty dynamic zone', async () => {\n      const createRes = await createEmpty();\n\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.id;\n\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: defaultBody,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'someString',\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.compo-with-other-compo',\n            compo: {\n              id: expect.anything(),\n              name: 'someString',\n            },\n          },\n        ],\n      });\n    });\n\n    test('Can remove items from dynamic zone', async () => {\n      const createRes = await createEntry();\n\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.id;\n\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: {\n          field: [\n            {\n              __component: 'default.simple-compo',\n              name: 'otherString',\n            },\n            {\n              __component: 'default.simple-compo',\n              name: 'secondString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'otherString',\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'secondString',\n          },\n        ],\n      });\n    });\n\n    test('Respects min items', async () => {\n      const createRes = await createEntry();\n\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.id;\n\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: {\n          field: [\n            {\n              __component: 'default.simple-compo',\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Respects max items', async () => {\n      const createRes = await createEntry();\n\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.id;\n\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: {\n          field: Array(10).fill({\n            __component: 'default.simple-compo',\n            name: 'otherString',\n          }),\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n  });\n\n  describe('Deletion', () => {\n    test('Returns the entry with its paths populated', async () => {\n      const createRes = await createEntry();\n\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.id;\n\n      const res = await rq({ method: 'DELETE', url: `/${entryId}` });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toEqual(\n        expect.objectContaining({\n          field: expect.arrayContaining([\n            expect.objectContaining({\n              id: expect.anything(),\n              __component: expect.any(String),\n            }),\n          ]),\n        })\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js": "'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\nlet baseRq;\n\nconst uploadImg = () => {\n  return baseRq({\n    method: 'POST',\n    url: '/upload',\n    formData: {\n      files: fs.createReadStream(path.join(__dirname, 'rec.jpg')),\n    },\n  });\n};\n\nconst components = {\n  singleMedia: {\n    name: 'single-media',\n    attributes: {\n      media: {\n        type: 'media',\n      },\n    },\n  },\n  multipleMedia: {\n    name: 'multiple-media',\n    attributes: {\n      media: {\n        type: 'media',\n        multiple: true,\n      },\n    },\n  },\n  withNested: {\n    name: 'with-nested',\n    attributes: {\n      singleMedia: {\n        type: 'component',\n        component: 'default.single-media',\n      },\n      multipleMedia: {\n        type: 'component',\n        component: 'default.multiple-media',\n      },\n    },\n  },\n};\n\nconst ct = {\n  name: 'withdynamiczonemedia',\n  attributes: {\n    field: {\n      type: 'dynamiczone',\n      components: ['default.single-media', 'default.multiple-media', 'default.with-nested'],\n    },\n  },\n};\n\ndescribe.each([\n  [\n    'CONTENT MANAGER',\n    '/content-manager/collection-types/application::withdynamiczonemedia.withdynamiczonemedia',\n  ],\n  ['GENERATED API', '/withdynamiczonemedias'],\n])('[%s] => Not required dynamiczone', (_, path) => {\n  const builder = createTestBuilder();\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(components.singleMedia)\n      .addComponent(components.multipleMedia)\n      .addComponent(components.withNested)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n\n    baseRq = await createAuthRequest({ strapi });\n\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Contains components with medias', () => {\n    test('The medias are correctly related to the components on creation', async () => {\n      const imgRes = await uploadImg();\n\n      expect(imgRes.statusCode).toBe(200);\n      const mediaId = imgRes.body[0].id;\n\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [\n            {\n              __component: 'default.single-media',\n              media: mediaId,\n            },\n            {\n              __component: 'default.multiple-media',\n              media: [mediaId, mediaId],\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.single-media',\n            media: {\n              id: mediaId,\n              url: expect.any(String),\n            },\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.multiple-media',\n            media: expect.arrayContaining([\n              expect.objectContaining({\n                id: mediaId,\n                url: expect.any(String),\n              }),\n            ]),\n          },\n        ],\n      });\n    });\n\n    test('The medias are correctly related to the components on edition', async () => {\n      const imgRes = await uploadImg();\n\n      expect(imgRes.statusCode).toBe(200);\n      const mediaId = imgRes.body[0].id;\n\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [\n            {\n              __component: 'default.single-media',\n              media: mediaId,\n            },\n            {\n              __component: 'default.multiple-media',\n              media: [mediaId, mediaId],\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n\n      const newImgRes = await uploadImg();\n\n      expect(newImgRes.statusCode).toBe(200);\n      const newMediaId = newImgRes.body[0].id;\n      const updateRes = await rq({\n        method: 'PUT',\n        url: `/${res.body.id}`,\n        body: {\n          field: [\n            {\n              __component: 'default.single-media',\n              media: newMediaId,\n            },\n            {\n              __component: 'default.multiple-media',\n              media: [newMediaId, newMediaId],\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.single-media',\n            media: {\n              id: newMediaId,\n              url: expect.any(String),\n            },\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.multiple-media',\n            media: expect.arrayContaining([\n              expect.objectContaining({\n                id: newMediaId,\n                url: expect.any(String),\n              }),\n            ]),\n          },\n        ],\n      });\n    });\n\n    test('The media are populated on the components', async () => {\n      const imgRes = await uploadImg();\n\n      expect(imgRes.statusCode).toBe(200);\n      const mediaId = imgRes.body[0].id;\n\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [\n            {\n              __component: 'default.single-media',\n              media: mediaId,\n            },\n            {\n              __component: 'default.multiple-media',\n              media: [mediaId, mediaId],\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n\n      const getRes = await rq({ method: 'GET', url: `/${res.body.id}` });\n      expect(getRes.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.single-media',\n            media: {\n              id: mediaId,\n              url: expect.any(String),\n            },\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.multiple-media',\n            media: expect.arrayContaining([\n              expect.objectContaining({\n                id: mediaId,\n                url: expect.any(String),\n              }),\n            ]),\n          },\n        ],\n      });\n    });\n  });\n\n  describe('Contains components with nested components having medias', () => {\n    test('The medias are correctly related to the nested components on creation', async () => {\n      const imgRes = await uploadImg();\n\n      expect(imgRes.statusCode).toBe(200);\n      const mediaId = imgRes.body[0].id;\n\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [\n            {\n              __component: 'default.with-nested',\n              singleMedia: {\n                media: mediaId,\n              },\n              multipleMedia: {\n                media: [mediaId, mediaId],\n              },\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.with-nested',\n            singleMedia: {\n              media: {\n                id: mediaId,\n                url: expect.any(String),\n              },\n            },\n            multipleMedia: {\n              media: expect.arrayContaining([\n                expect.objectContaining({\n                  id: mediaId,\n                  url: expect.any(String),\n                }),\n              ]),\n            },\n          },\n        ],\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withbiginteger',\n  attributes: {\n    field: {\n      type: 'biginteger',\n    },\n  },\n};\n\ndescribe('Test type biginteger', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const inputValue = '1223372036854775';\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withbiginteger.withbiginteger',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: inputValue,\n    });\n  });\n\n  test('Create entry with integer should return a string', async () => {\n    const inputValue = 1821;\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withbiginteger.withbiginteger',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: `${inputValue}`,\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withbiginteger.withbiginteger'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(String));\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const inputValue = '1223372036854775';\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withbiginteger.withbiginteger',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    const newVal = '9882823782712112';\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withbiginteger.withbiginteger/${res.body.id}`,\n      {\n        body: {\n          field: newVal,\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: newVal,\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withboolean',\n  attributes: {\n    field: {\n      type: 'boolean',\n    },\n  },\n};\n\ndescribe('Test type boolean', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withboolean.withboolean',\n      {\n        body: {\n          field: true,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: true,\n    });\n  });\n\n  test('Throws on invalid boolean value', async () => {\n    let res = await rq.post(\n      '/content-manager/collection-types/application::withboolean.withboolean',\n      {\n        body: { field: 'random' },\n      }\n    );\n\n    expect(res.statusCode).toBe(400);\n  });\n\n  test('Convert integer to boolean value', async () => {\n    let res = await rq.post(\n      '/content-manager/collection-types/application::withboolean.withboolean',\n      {\n        body: { field: 1 },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: true,\n    });\n\n    res = await rq.post('/content-manager/collection-types/application::withboolean.withboolean', {\n      body: { field: 0 },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: false,\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withboolean.withboolean'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(Boolean));\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withboolean.withboolean',\n      {\n        body: {\n          field: true,\n        },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withboolean.withboolean/${res.body.id}`,\n      {\n        body: {\n          field: false,\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: false,\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withdate',\n  attributes: {\n    field: {\n      type: 'date',\n    },\n  },\n};\n\ndescribe('Test type date', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with valid value JSON', async () => {\n    const res = await rq.post('/content-manager/collection-types/application::withdate.withdate', {\n      body: {\n        field: '2019-08-08',\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: '2019-08-08',\n    });\n  });\n\n  test.each([\n    '2019-08-08',\n    '2019-08-08 12:11:12',\n    '2019-08-08T00:00:00',\n    '2019-08-08T00:00:00Z',\n    '2019-08-08 00:00:00.123',\n    '2019-08-08 00:00:00.123Z',\n    '2019-08-08T00:00:00.123',\n    '2019-08-08T00:00:00.123Z',\n  ])('Date can be sent in any iso format and the date part will be kept, (%s)', async input => {\n    const res = await rq.post('/content-manager/collection-types/application::withdate.withdate', {\n      body: {\n        field: input,\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: '2019-08-08',\n    });\n  });\n\n  test.each([1234567891012, '1234567891012', '2019/12/11', '12:11:11'])(\n    'Throws on invalid date (%s)',\n    async value => {\n      const res = await rq.post(\n        '/content-manager/collection-types/application::withdate.withdate',\n        {\n          body: {\n            field: value,\n          },\n        }\n      );\n\n      expect(res.statusCode).toBe(400);\n    }\n  );\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get('/content-manager/collection-types/application::withdate.withdate');\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toMatch(/^([12]\\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]))$/);\n    });\n  });\n\n  test('Updating entry sets the right value and format JSON', async () => {\n    const now = new Date(2018, 7, 5);\n\n    const res = await rq.post('/content-manager/collection-types/application::withdate.withdate', {\n      body: {\n        field: now,\n      },\n    });\n\n    const newDate = new Date(2017, 10, 23);\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withdate.withdate/${res.body.id}`,\n      {\n        body: {\n          field: newDate,\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: '2017-11-23',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withdatetime',\n  attributes: {\n    field: {\n      type: 'datetime',\n    },\n  },\n};\n\ndescribe('Test type datetime', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with valid value JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdatetime.withdatetime',\n      {\n        body: {\n          field: '2019-08-08T10:10:57.000Z',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: '2019-08-08T10:10:57.000Z',\n    });\n  });\n\n  test('Create entry with timestamp value should be converted to ISO', async () => {\n    const now = new Date(2016, 4, 8);\n\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdatetime.withdatetime',\n      {\n        body: {\n          field: now.getTime(),\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: now.toISOString(),\n    });\n  });\n\n  test('Accepts string timestamp', async () => {\n    const now = new Date(2000, 0, 1);\n\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdatetime.withdatetime',\n      {\n        body: {\n          field: `${now.getTime()}`,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: now.toISOString(),\n    });\n  });\n\n  test('Throws on invalid date format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdatetime.withdatetime',\n      {\n        body: {\n          field: 'azdazindoaizdnoainzd',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(400);\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withdatetime.withdatetime'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(new Date(entry.field).toISOString()).toBe(entry.field);\n    });\n  });\n\n  test('Updating entry sets the right value and format JSON', async () => {\n    const now = new Date(2018, 7, 5);\n\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdatetime.withdatetime',\n      {\n        body: {\n          field: now.getTime(),\n        },\n      }\n    );\n\n    const newDate = new Date(2017, 10, 23);\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withdatetime.withdatetime/${res.body.id}`,\n      {\n        body: {\n          field: newDate,\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: newDate.toISOString(),\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withdecimal',\n  attributes: {\n    field: {\n      type: 'decimal',\n    },\n  },\n};\n\ndescribe('Test type decimal', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const inputValue = 12.31;\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdecimal.withdecimal',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: inputValue,\n    });\n  });\n\n  test('Create entry with integer should convert to decimal', async () => {\n    const inputValue = 1821;\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdecimal.withdecimal',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 1821.0,\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withdecimal.withdecimal'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(Number));\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdecimal.withdecimal',\n      {\n        body: {\n          field: 11.2,\n        },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withdecimal.withdecimal/${res.body.id}`,\n      {\n        body: {\n          field: 14,\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 14.0,\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withemail',\n  attributes: {\n    field: {\n      type: 'email',\n    },\n  },\n};\n\ndescribe('Test type email', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withemail.withemail',\n      {\n        body: {\n          field: 'validemail@test.fr',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 'validemail@test.fr',\n    });\n  });\n\n  test('Should Throw on invalid email', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withemail.withemail',\n      {\n        body: {\n          field: 'invalidemail',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(400);\n  });\n\n  test('Create entry with value input Formdata', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withemail.withemail',\n      {\n        body: {\n          field: 'test@email.fr',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 'test@email.fr',\n    });\n  });\n\n  test('Reading entry returns correct value', async () => {\n    const res = await rq.get('/content-manager/collection-types/application::withemail.withemail');\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          field: expect.any(String),\n        }),\n      ])\n    );\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withemail.withemail',\n      {\n        body: {\n          field: 'valid@email.fr',\n        },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withemail.withemail/${res.body.id}`,\n      {\n        body: {\n          field: 'new-email@email.fr',\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 'new-email@email.fr',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withenumeration',\n  attributes: {\n    field: {\n      type: 'enumeration',\n      enum: ['one', 'two'],\n    },\n  },\n};\n\ndescribe('Test type enumeration', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry value enumeration input JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withenumeration.withenumeration',\n      {\n        body: {\n          field: 'one',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200); // should return 201\n    expect(res.body).toMatchObject({\n      field: 'one',\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withenumeration.withenumeration'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(['one', 'two'].includes(entry.field)).toBe(true);\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withenumeration.withenumeration',\n      {\n        body: {\n          field: 'two',\n        },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withenumeration.withenumeration/${res.body.id}`,\n      {\n        body: {\n          field: 'one',\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 'one',\n    });\n  });\n\n  test('Allows null value', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withenumeration.withenumeration',\n      {\n        body: {\n          field: null,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200); // should return 201\n    expect(res.body).toMatchObject({\n      field: null,\n    });\n  });\n\n  test('Throws an error when the enumeration value is not in the options', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withenumeration.withenumeration',\n      {\n        body: {\n          field: 'invalid-value',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(400);\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withfloat',\n  attributes: {\n    field: {\n      type: 'float',\n    },\n  },\n};\n\ndescribe('Test type float', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const inputValue = 12.31;\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withfloat.withfloat',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: inputValue,\n    });\n  });\n\n  test('Create entry with integer should convert to float', async () => {\n    const inputValue = 1821;\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withfloat.withfloat',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 1821.0,\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get('/content-manager/collection-types/application::withfloat.withfloat');\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(Number));\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withfloat.withfloat',\n      {\n        body: {\n          field: 11.2,\n        },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withfloat.withfloat/${res.body.id}`,\n      {\n        body: {\n          field: 14,\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 14.0,\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withinteger',\n  attributes: {\n    field: {\n      type: 'integer',\n    },\n  },\n};\n\ndescribe('Test type integer', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withinteger.withinteger',\n      {\n        body: {\n          field: 123456,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 123456,\n    });\n  });\n\n  // I don't think it will work everywhere ...\n  test('Create entry with a string should cast the value', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withinteger.withinteger',\n      {\n        body: {\n          field: '123456',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 123456,\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withinteger.withinteger'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(Number.isInteger(entry.field)).toBe(true);\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withinteger.withinteger',\n      {\n        body: {\n          field: 123,\n        },\n      }\n    );\n\n    const updatedRes = await rq.put(\n      `/content-manager/collection-types/application::withinteger.withinteger/${res.body.id}`,\n      {\n        body: {\n          field: 543,\n        },\n      }\n    );\n\n    expect(updatedRes.statusCode).toBe(200);\n    expect(updatedRes.body).toMatchObject({\n      id: res.body.id,\n      field: 543,\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withjson',\n  attributes: {\n    field: {\n      type: 'json',\n    },\n  },\n};\n\ndescribe('Test type json', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const inputValue = {\n      key: 'value',\n    };\n    const res = await rq.post('/content-manager/collection-types/application::withjson.withjson', {\n      body: {\n        field: inputValue,\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: inputValue,\n    });\n  });\n\n  test('Create entry with array value input JSON', async () => {\n    const inputValue = [\n      {\n        key: 'value',\n      },\n      {\n        key: 'value',\n      },\n    ];\n    const res = await rq.post('/content-manager/collection-types/application::withjson.withjson', {\n      body: {\n        field: inputValue,\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: inputValue,\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get('/content-manager/collection-types/application::withjson.withjson');\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toBeDefined();\n      expect(entry.field).not.toBeNull();\n      expect(typeof entry.field).toBe('object');\n    });\n  });\n\n  test.todo('Throw when input is not a nested object');\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post('/content-manager/collection-types/application::withjson.withjson', {\n      body: {\n        field: {\n          key: 'value',\n        },\n      },\n    });\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withjson.withjson/${res.body.id}`,\n      {\n        body: {\n          field: {\n            newKey: 'newVal',\n          },\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: { newKey: 'newVal' },\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withpassword',\n  attributes: {\n    field: {\n      type: 'password',\n    },\n  },\n};\n\ndescribe('Test type password', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withpassword.withpassword',\n      {\n        body: {\n          field: 'somePassword',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.field).toBeUndefined();\n  });\n\n  test.todo('Should be private by default');\n\n  test('Create entry with value input Formdata', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withpassword.withpassword',\n      {\n        body: {\n          field: '1234567',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.field).toBeUndefined();\n  });\n\n  test('Reading entry returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withpassword.withpassword'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(element => {\n      expect(element.field).toBeUndefined();\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withpassword.withpassword',\n      {\n        body: {\n          field: 'somePassword',\n        },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withpassword.withpassword/${res.body.id}`,\n      {\n        body: {\n          field: 'otherPwd',\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n    });\n    expect(res.body.field).toBeUndefined();\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withrichtext',\n  attributes: {\n    field: {\n      type: 'richtext',\n    },\n  },\n};\n\ndescribe('Test type richtext', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Creates an entry with JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withrichtext.withrichtext',\n      {\n        body: {\n          field: 'Some\\ntext',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 'Some\\ntext',\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withrichtext.withrichtext'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(String));\n    });\n  });\n\n  test('Updating entry with JSON sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withrichtext.withrichtext',\n      {\n        body: { field: 'Some \\ntext' },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withrichtext.withrichtext/${res.body.id}`,\n      {\n        body: { field: 'Updated \\nstring' },\n      }\n    );\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 'Updated \\nstring',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withstring',\n  attributes: {\n    field: {\n      type: 'string',\n    },\n  },\n};\n\ndescribe('Test type string', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Creates an entry with JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withstring.withstring',\n      {\n        body: {\n          field: 'Some string',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 'Some string',\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withstring.withstring'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(String));\n    });\n  });\n\n  test('Updating entry with JSON sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withstring.withstring',\n      {\n        body: { field: 'Some string' },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withstring.withstring/${res.body.id}`,\n      {\n        body: { field: 'Updated string' },\n      }\n    );\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 'Updated string',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withtext',\n  attributes: {\n    field: {\n      type: 'text',\n    },\n  },\n};\n\ndescribe('Test type text', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Creates an entry with JSON', async () => {\n    const res = await rq.post('/content-manager/collection-types/application::withtext.withtext', {\n      body: {\n        field: 'Some\\ntext',\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 'Some\\ntext',\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get('/content-manager/collection-types/application::withtext.withtext');\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(String));\n    });\n  });\n\n  test('Updating entry with JSON sets the right value and format', async () => {\n    const res = await rq.post('/content-manager/collection-types/application::withtext.withtext', {\n      body: { field: 'Some \\ntext' },\n    });\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withtext.withtext/${res.body.id}`,\n      {\n        body: { field: 'Updated \\nstring' },\n      }\n    );\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 'Updated \\nstring',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withtime',\n  attributes: {\n    field: {\n      type: 'time',\n    },\n  },\n};\n\ndescribe('Test type time', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with valid value JSON', async () => {\n    const res = await rq.post('/content-manager/collection-types/application::withtime.withtime', {\n      body: {\n        field: '10:10:57.123',\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: '10:10:57.123',\n    });\n  });\n\n  test.each(['00:00:00', '01:03:11.2', '01:03:11.93', '01:03:11.123'])(\n    'Accepts multiple time formats %s',\n    async input => {\n      const res = await rq.post(\n        '/content-manager/collection-types/application::withtime.withtime',\n        {\n          body: {\n            field: input,\n          },\n        }\n      );\n\n      expect(res.statusCode).toBe(200);\n    }\n  );\n\n  test.each(['24:11:23', '23:72:11', '12:45:83', 1234, {}, 'test', new Date()])(\n    'Throws on invalid time (%s)',\n    async input => {\n      const res = await rq.post(\n        '/content-manager/collection-types/application::withtime.withtime',\n        {\n          body: {\n            field: input,\n          },\n        }\n      );\n\n      expect(res.statusCode).toBe(400);\n    }\n  );\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get('/content-manager/collection-types/application::withtime.withtime');\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toMatch(/^2[0-3]|[01][0-9]:[0-5][0-9]:[0-5][0-9](.[0-9]{1,3})?$/);\n    });\n  });\n\n  test('Updating entry sets the right value and format JSON', async () => {\n    const res = await rq.post('/content-manager/collection-types/application::withtime.withtime', {\n      body: {\n        field: '12:11:04',\n      },\n    });\n\n    const uptimeRes = await rq.put(\n      `/content-manager/collection-types/application::withtime.withtime/${res.body.id}`,\n      {\n        body: {\n          field: '13:45:19.123',\n        },\n      }\n    );\n\n    expect(uptimeRes.statusCode).toBe(200);\n    expect(uptimeRes.body).toMatchObject({\n      id: res.body.id,\n      field: '13:45:19.123',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\ndescribe('Test type UID', () => {\n  describe('No targetField, required=false, not length limits', () => {\n    const model = {\n      name: 'withuid',\n      attributes: {\n        slug: {\n          type: 'uid',\n        },\n      },\n    };\n\n    const builder = createTestBuilder();\n\n    beforeAll(async () => {\n      await builder.addContentType(model).build();\n\n      strapi = await createStrapiInstance();\n      rq = await createAuthRequest({ strapi });\n    }, 60000);\n\n    afterAll(async () => {\n      await strapi.destroy();\n      await builder.cleanup();\n    }, 60000);\n\n    test('Creates an entry successfully', async () => {\n      const res = await rq.post('/content-manager/collection-types/application::withuid.withuid', {\n        body: {\n          slug: 'valid-uid',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        slug: 'valid-uid',\n      });\n    });\n\n    test('Throws error on duplicate value', async () => {\n      const res = await rq.post('/content-manager/collection-types/application::withuid.withuid', {\n        body: {\n          slug: 'duplicate-uid',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        slug: 'duplicate-uid',\n      });\n\n      const conflicting = await rq.post(\n        '/content-manager/collection-types/application::withuid.withuid',\n        {\n          body: {\n            slug: 'duplicate-uid',\n          },\n        }\n      );\n\n      expect(conflicting.statusCode).toBe(400);\n    });\n\n    test('Can set value to be null', async () => {\n      const res = await rq.post('/content-manager/collection-types/application::withuid.withuid', {\n        body: {\n          slug: null,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        slug: null,\n      });\n    });\n  });\n\n  describe('No targetField, required, no length limits', () => {\n    const model = {\n      name: 'withrequireduid',\n      attributes: {\n        slug: {\n          type: 'uid',\n          required: true,\n        },\n      },\n    };\n\n    const builder = createTestBuilder();\n\n    beforeAll(async () => {\n      await builder.addContentType(model).build();\n\n      strapi = await createStrapiInstance();\n      rq = await createAuthRequest({ strapi });\n    }, 60000);\n\n    afterAll(async () => {\n      await strapi.destroy();\n      await builder.cleanup();\n    }, 60000);\n\n    test('Creates an entry successfully', async () => {\n      const res = await rq.post(\n        '/content-manager/collection-types/application::withrequireduid.withrequireduid',\n        {\n          body: {\n            slug: 'valid-uid',\n          },\n        }\n      );\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        slug: 'valid-uid',\n      });\n    });\n\n    test('Throws error on duplicate value', async () => {\n      const res = await rq.post(\n        '/content-manager/collection-types/application::withrequireduid.withrequireduid',\n        {\n          body: {\n            slug: 'duplicate-uid',\n          },\n        }\n      );\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        slug: 'duplicate-uid',\n      });\n\n      const conflicting = await rq.post(\n        '/content-manager/collection-types/application::withrequireduid.withrequireduid',\n        {\n          body: {\n            slug: 'duplicate-uid',\n          },\n        }\n      );\n\n      expect(conflicting.statusCode).toBe(400);\n    });\n\n    test('Cannot set value to be null', async () => {\n      const res = await rq.post(\n        '/content-manager/collection-types/application::withrequireduid.withrequireduid',\n        {\n          body: {\n            slug: null,\n          },\n        }\n      );\n\n      expect(res.statusCode).toBe(400);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/index.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst form = require('../../../test/helpers/generators');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst cleanDate = entry => {\n  delete entry.updatedAt;\n  delete entry.createdAt;\n  delete entry.created_at;\n  delete entry.updated_at;\n};\n\nconst builder = createTestBuilder();\nlet strapi;\nlet data;\nlet rq;\n\nconst deleteFixtures = async () => {\n  for (const [name, modelName] of [\n    ['references', 'reference'],\n    ['tags', 'tag'],\n    ['categories', 'category'],\n    ['articles', 'article'],\n    ['articlesWithTag', 'articlewithtag'],\n  ]) {\n    const uid = `application::${modelName}.${modelName}`;\n\n    await rq({\n      method: 'POST',\n      url: `/content-manager/collection-types/${uid}/actions/bulkDelete`,\n      body: {\n        ids: (data[name] || []).map(({ id }) => id),\n      },\n    });\n  }\n};\n\ndescribe('Content Manager End to End', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentTypes(\n        [form.article, form.tag, form.category, form.reference, form.articlewithtag],\n        { batch: true }\n      )\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Content Types api', () => {\n    test('Label is pluralized', async () => {\n      const res = await rq({\n        url: `/content-manager/content-types`,\n        method: 'GET',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            info: expect.objectContaining({\n              label: 'Articles',\n            }),\n          }),\n          expect.objectContaining({\n            info: expect.objectContaining({\n              label: 'Tags',\n            }),\n          }),\n          expect.objectContaining({\n            info: expect.objectContaining({\n              label: 'Categories',\n            }),\n          }),\n        ])\n      );\n    });\n  });\n\n  describe('Test manyToMany relation (article - tag) with Content Manager', () => {\n    beforeAll(async () => {\n      data = {\n        articles: [],\n        tags: [],\n      };\n    });\n\n    afterAll(async () => {\n      await deleteFixtures();\n    });\n\n    test('Create tag1', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag1',\n        },\n      });\n\n      data.tags.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('tag1');\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Create tag2', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag2',\n        },\n      });\n\n      data.tags.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('tag2');\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Create tag3', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag3',\n        },\n      });\n\n      data.tags.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('tag3');\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Create article1 without relation', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'My super content 1',\n        date: '2019-08-13T00:00:00.000Z',\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(0);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Create article2 with tag1', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n        tags: [data.tags[0]],\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(1);\n      expect(body.tags[0].id).toBe(data.tags[0].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Update article1 add tag2', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        tags: [data.tags[1]],\n      });\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(1);\n      expect(body.tags[0].id).toBe(data.tags[1].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Update article1 add tag1 and tag3', async () => {\n      const entry = Object.assign({}, data.articles[0]);\n      entry.tags.push(data.tags[0]);\n      entry.tags.push(data.tags[2]);\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(3);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Update article1 remove one tag', async () => {\n      const entry = Object.assign({}, data.articles[0]);\n      entry.tags = entry.tags.slice(1);\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(2);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Update article1 remove all tag', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        tags: [],\n      });\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(0);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Delete all articles should remove the association in each tags related to them', async () => {\n      const { body: createdTag } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag11',\n        },\n      });\n\n      const { body: article12 } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: {\n          title: 'article12',\n          content: 'Content',\n          tags: [createdTag],\n        },\n      });\n\n      const { body: updatedTag } = await rq({\n        url: `/content-manager/collection-types/application::tag.tag/${createdTag.id}`,\n        method: 'GET',\n      });\n\n      const { body: article13 } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: {\n          title: 'article13',\n          content: 'Content',\n          tags: [updatedTag],\n        },\n      });\n\n      const articles = [article12, article13];\n\n      expect(Array.isArray(articles[0].tags)).toBeTruthy();\n      expect(articles[0].tags.length).toBe(1);\n      expect(Array.isArray(articles[1].tags)).toBeTruthy();\n      expect(articles[1].tags.length).toBe(1);\n\n      let { body: tagToGet } = await rq({\n        url: `/content-manager/collection-types/application::tag.tag/${createdTag.id}`,\n        method: 'GET',\n      });\n\n      expect(Array.isArray(tagToGet.articles)).toBeTruthy();\n      expect(tagToGet.articles.length).toBe(2);\n\n      await rq({\n        url: '/content-manager/collection-types/application::article.article/actions/bulkDelete',\n        method: 'POST',\n        body: {\n          ids: articles.map(article => article.id),\n        },\n      });\n\n      let { body: tagToGet2 } = await rq({\n        url: `/content-manager/collection-types/application::tag.tag/${createdTag.id}`,\n        method: 'GET',\n      });\n\n      expect(Array.isArray(tagToGet2.articles)).toBeTruthy();\n      expect(tagToGet2.articles.length).toBe(0);\n    });\n  });\n\n  describe('Test manyWay articlesWithTags and tags', () => {\n    beforeAll(() => {\n      data = {\n        tags: [],\n        articlesWithTag: [],\n      };\n    });\n\n    afterAll(async () => {\n      await deleteFixtures();\n    });\n\n    test('Creating an article with some many way tags', async () => {\n      const { body: createdTag } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag11',\n        },\n      });\n\n      data.tags.push(createdTag);\n\n      const entry = {\n        tags: [createdTag.id],\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::articlewithtag.articlewithtag',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articlesWithTag.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(1);\n      expect(body.tags[0].id).toBe(data.tags[0].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n  });\n\n  describe('Test oneToMany - manyToOne relation (article - category) with Content Manager', () => {\n    beforeAll(() => {\n      data = {\n        articles: [],\n        categories: [],\n      };\n    });\n\n    afterAll(async () => {\n      await deleteFixtures();\n    });\n\n    test('Create cat1', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::category.category',\n        method: 'POST',\n        body: {\n          name: 'cat1',\n        },\n      });\n\n      data.categories.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('cat1');\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Create cat2', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::category.category',\n        method: 'POST',\n        body: {\n          name: 'cat2',\n        },\n      });\n\n      data.categories.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('cat2');\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Create article1 with cat1', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'Content 1',\n        category: data.categories[0],\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.category.name).toBe(entry.category.name);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Update article1 with cat2', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        category: data.categories[1],\n      });\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.category.name).toBe(entry.category.name);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Create article2', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Update article2 with cat2', async () => {\n      const entry = Object.assign({}, data.articles[1], {\n        category: data.categories[1],\n      });\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[1] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.category.name).toBe(entry.category.name);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Update cat1 with article1', async () => {\n      const entry = Object.assign({}, data.categories[0]);\n      entry.articles.push(data.articles[0]);\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::category.category/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.categories[0] = body;\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.articles.length).toBe(1);\n      expect(body.name).toBe(entry.name);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Create cat3 with article1', async () => {\n      const entry = {\n        name: 'cat3',\n        articles: [data.articles[0]],\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::category.category',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.categories.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.articles.length).toBe(1);\n      expect(body.name).toBe(entry.name);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Get article1 with cat3', async () => {\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${data.articles[0].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.category.id).toBe(data.categories[2].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Get article2 with cat2', async () => {\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${data.articles[1].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.category.id).toBe(data.categories[1].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Get cat1 without relations', async () => {\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::category.category/${data.categories[0].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.articles.length).toBe(0);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Get cat2 with article2', async () => {\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::category.category/${data.categories[1].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.articles.length).toBe(1);\n      expect(body.articles[0].id).toBe(data.articles[1].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Get cat3 with article1', async () => {\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::category.category/${data.categories[2].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.articles.length).toBe(1);\n      expect(body.articles[0].id).toBe(data.articles[0].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n  });\n\n  describe('Test oneToOne relation (article - reference) with Content Manager', () => {\n    beforeAll(() => {\n      data = {\n        articles: [],\n        references: [],\n      };\n    });\n\n    afterAll(async () => {\n      await deleteFixtures();\n    });\n\n    test('Create ref1', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::reference.reference',\n        method: 'POST',\n        body: {\n          name: 'ref1',\n        },\n      });\n\n      data.references.push(body);\n\n      expect(body.id);\n      expect(body.name).toBe('ref1');\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Create article1', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'Content 1',\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Update article1 with ref1', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        reference: data.references[0].id,\n      });\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.reference.id).toBe(entry.reference);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Create article2 with ref1', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n        reference: data.references[0].id,\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.reference.id).toBe(entry.reference);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n  });\n\n  describe('Test oneWay relation (reference - tag) with Content Manager', () => {\n    test('Attach Tag to a Reference', async () => {\n      const { body: tagToCreate } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag111',\n        },\n      });\n\n      const { body: referenceToCreate } = await rq({\n        url: '/content-manager/collection-types/application::reference.reference',\n        method: 'POST',\n        body: {\n          name: 'cat111',\n          tag: tagToCreate,\n        },\n      });\n\n      expect(referenceToCreate.tag.id).toBe(tagToCreate.id);\n    });\n\n    test('Detach Tag to a Reference', async () => {\n      const { body: tagToCreate } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag111',\n        },\n      });\n\n      const { body: referenceToCreate } = await rq({\n        url: '/content-manager/collection-types/application::reference.reference',\n        method: 'POST',\n        body: {\n          name: 'cat111',\n          tag: tagToCreate,\n        },\n      });\n\n      expect(referenceToCreate.tag.id).toBe(tagToCreate.id);\n\n      const { body: referenceToUpdate } = await rq({\n        url: `/content-manager/collection-types/application::reference.reference/${referenceToCreate.id}`,\n        method: 'PUT',\n        body: {\n          tag: null,\n        },\n      });\n\n      expect(referenceToUpdate.tag).toBe(null);\n    });\n\n    test('Delete Tag so the relation in the Reference side should be removed', async () => {\n      const { body: tagToCreate } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag111',\n        },\n      });\n\n      const { body: referenceToCreate } = await rq({\n        url: '/content-manager/collection-types/application::reference.reference',\n        method: 'POST',\n        body: {\n          name: 'cat111',\n          tag: tagToCreate,\n        },\n      });\n\n      await rq({\n        url: `/content-manager/collection-types/application::tag.tag/${tagToCreate.id}`,\n        method: 'DELETE',\n      });\n\n      const { body: referenceToGet } = await rq({\n        url: `/content-manager/collection-types/application::reference.reference/${referenceToCreate.id}`,\n        method: 'GET',\n      });\n\n      if (!referenceToGet.tag || Object.keys(referenceToGet.tag).length === 0) return;\n      expect(referenceToGet.tag).toBe(null);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst { omit, pick } = require('lodash/fp');\n\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet rq;\nlet data = {\n  products: [],\n  shops: [],\n};\n\nconst productModel = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n  connection: 'default',\n  name: 'product',\n  description: '',\n  collectionName: '',\n};\n\nconst productWithDPModel = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n  connection: 'default',\n  name: 'product',\n  draftAndPublish: true,\n  description: '',\n  collectionName: '',\n};\n\nconst shopModel = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    products: {\n      dominant: true,\n      nature: 'manyToMany',\n      target: 'application::product.product',\n      targetAttribute: 'shops',\n    },\n  },\n  connection: 'default',\n  name: 'shop',\n};\n\nconst shops = [\n  {\n    name: 'market',\n  },\n];\n\nconst products = ({ withPublished = false }) => ({ shop }) => {\n  const shops = [shop[0].id];\n\n  const entries = [\n    {\n      name: 'tomato',\n      shops,\n      published_at: new Date(),\n    },\n    {\n      name: 'apple',\n      shops,\n      published_at: null,\n    },\n  ];\n\n  if (withPublished) {\n    return entries;\n  }\n\n  return entries.map(omit('published_at'));\n};\n\ndescribe('Relation-list route', () => {\n  describe('without draftAndPublish', () => {\n    const builder = createTestBuilder();\n\n    beforeAll(async () => {\n      await builder\n        .addContentTypes([productModel, shopModel])\n        .addFixtures(shopModel.name, shops)\n        .addFixtures(productModel.name, products({ withPublished: false }))\n        .build();\n\n      strapi = await createStrapiInstance();\n      rq = await createAuthRequest({ strapi });\n\n      data.shops = builder.sanitizedFixturesFor(shopModel.name, strapi);\n      data.products = builder.sanitizedFixturesFor(productModel.name, strapi);\n    }, 60000);\n\n    afterAll(async () => {\n      await strapi.destroy();\n      await builder.cleanup();\n    }, 60000);\n\n    test('Can get relation-list for products of a shop', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/relations/application::shop.shop/products',\n      });\n\n      expect(res.body).toHaveLength(data.products.length);\n      data.products.forEach((product, index) => {\n        expect(res.body[index]).toStrictEqual(pick(['_id', 'id', 'name'], product));\n      });\n    });\n\n    test('Can get relation-list for products of a shop and omit some results', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/relations/application::shop.shop/products',\n        body: {\n          idsToOmit: [data.products[0].id],\n        },\n      });\n\n      expect(res.body).toHaveLength(1);\n      expect(res.body[0]).toStrictEqual(pick(['_id', 'id', 'name'], data.products[1]));\n    });\n  });\n\n  describe('with draftAndPublish', () => {\n    const builder = createTestBuilder();\n\n    beforeAll(async () => {\n      await builder\n        .addContentTypes([productWithDPModel, shopModel])\n        .addFixtures(shopModel.name, shops)\n        .addFixtures(productWithDPModel.name, products({ withPublished: true }))\n        .build();\n\n      strapi = await createStrapiInstance();\n      rq = await createAuthRequest({ strapi });\n\n      data.shops = builder.sanitizedFixturesFor(shopModel.name, strapi);\n      data.products = builder.sanitizedFixturesFor(productWithDPModel.name, strapi);\n    }, 60000);\n\n    afterAll(async () => {\n      await strapi.destroy();\n      await builder.cleanup();\n    }, 60000);\n\n    test('Can get relation-list for products of a shop', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/relations/application::shop.shop/products',\n      });\n\n      expect(res.body).toHaveLength(data.products.length);\n\n      const tomatoProductRes = res.body.find(p => p.name === 'tomato');\n      const appleProductRes = res.body.find(p => p.name === 'apple');\n\n      expect(tomatoProductRes).toMatchObject(pick(['_id', 'id', 'name'], data.products[0]));\n      expect(tomatoProductRes.published_at).toBeISODate();\n      expect(appleProductRes).toStrictEqual({\n        ...pick(['_id', 'id', 'name'], data.products[1]),\n        published_at: null,\n      });\n    });\n\n    test('Can get relation-list for products of a shop and omit some results', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/relations/application::shop.shop/products',\n        body: {\n          idsToOmit: [data.products[1].id],\n        },\n      });\n\n      expect(res.body).toHaveLength(1);\n      expect(res.body[0]).toMatchObject(pick(['_id', 'id', 'name'], data.products[0]));\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/search.test.e2e.js": "'use strict';\n\n// Test an API with all the possible filed types and simple filterings (no deep filtering, no relations)\nconst { omit } = require('lodash/fp');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst CREATOR_FIELDS = ['updated_by', 'created_by'];\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  beds: [],\n};\n\nconst bedModel = {\n  name: 'bed',\n  kind: 'collectionType',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    weight: {\n      type: 'decimal',\n    },\n    shortDescription: {\n      type: 'text',\n    },\n    description: {\n      type: 'richtext',\n    },\n    sku: {\n      type: 'uid',\n    },\n    savEmail: {\n      type: 'email',\n    },\n    type: {\n      enum: ['spring', 'foam', 'feather'],\n      type: 'enumeration',\n    },\n    serialNumber: {\n      type: 'biginteger',\n    },\n    peopleNumber: {\n      type: 'integer',\n    },\n    fabricThickness: {\n      type: 'float',\n    },\n  },\n};\n\nconst bedFixtures = [\n  {\n    name: 'Sleepy Bed',\n    weight: 12.4,\n    shortDescription: 'Is a good bed to sleep in.',\n    description: '**Is a very good bed to sleep in.** We promise.',\n    sku: 'sleepybed_0152',\n    savEmail: 'sav@bed.fr',\n    type: 'foam',\n    serialNumber: 9999999999999999,\n    peopleNumber: 6,\n    fabricThickness: 1.14157,\n  },\n  {\n    name: 'Tired Bed',\n    weight: 11.1,\n    shortDescription: 'You will never wake up again.',\n    description: '**You will never wake up again.** Never.',\n    sku: 'tiredbed_0001',\n    savEmail: 'sav@sleep.fr',\n    type: 'feather',\n    serialNumber: 1111111111111111,\n    peopleNumber: 1,\n    fabricThickness: 1.0001,\n  },\n  {\n    name: 'Zombie Bed',\n    weight: null,\n    shortDescription: null,\n    description: null,\n    sku: null,\n    savEmail: null,\n    type: null,\n    serialNumber: null,\n    peopleNumber: null,\n    fabricThickness: null,\n  },\n  {\n    name: 'a*b_c%d\\\\e+f',\n    weight: null,\n    shortDescription: null,\n    description: null,\n    sku: null,\n    savEmail: null,\n    type: null,\n    serialNumber: null,\n    peopleNumber: null,\n    fabricThickness: null,\n  },\n  {\n    name: 'Tired Bed',\n    weight: null,\n    shortDescription: null,\n    description: null,\n    sku: null,\n    savEmail: null,\n    type: null,\n    serialNumber: null,\n    peopleNumber: 7,\n    fabricThickness: null,\n  },\n];\n\ndescribe('Search query', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentType(bedModel)\n      .addFixtures(bedModel.name, bedFixtures)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    data.beds = builder.sanitizedFixturesFor(bedModel.name, strapi);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Without filters', () => {\n    test('search for \"id\"', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: data.beds[2].id,\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(1);\n      expect(res.body.results[0]).toMatchObject(data.beds[2]);\n    });\n\n    test.each(Object.keys(bedFixtures[0]))('search that target column %p', async columnName => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: bedFixtures[0][columnName],\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(1);\n      expect(res.body.results[0]).toMatchObject(data.beds[0]);\n    });\n\n    test('search with an empty query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: '',\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(data.beds.length);\n      expect(res.body.results.map(omit(CREATOR_FIELDS))).toEqual(expect.arrayContaining(data.beds));\n    });\n\n    test('search with special characters', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: data.beds[3].name,\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(1);\n      expect(res.body.results[0]).toMatchObject(data.beds[3]);\n    });\n  });\n\n  describe('With filters', () => {\n    test('search with an empty query & peopleNumber > 0', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: '',\n          peopleNumber_gt: 0,\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(3);\n      expect(res.body.results).toMatchObject([data.beds[0], data.beds[1], data.beds[4]]);\n    });\n    test('search with an empty query & peopleNumber > 1', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: '',\n          peopleNumber_gt: 1,\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(2);\n      expect(res.body.results).toMatchObject([data.beds[0], data.beds[4]]);\n    });\n    test('search with an empty query & peopleNumber in [1, 6]', async () => {\n      const res = await rq({\n        method: 'GET',\n        url:\n          '/content-manager/collection-types/application::bed.bed?peopleNumber=1&peopleNumber=6&_q=',\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(2);\n      expect(res.body.results).toMatchObject(data.beds.slice(0, 2));\n    });\n    test('search for \"Sleepy Bed\" & peopleNumber < 7', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: 'Sleepy Bed',\n          peopleNumber_lt: 7,\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(1);\n      expect(res.body.results).toMatchObject([data.beds[0]]);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet uid = 'application::single-type-model.single-type-model';\n\nconst ct = {\n  kind: 'singleType',\n  name: 'single-type-model',\n  attributes: {\n    title: {\n      type: 'string',\n    },\n  },\n};\n\ndescribe('Content Manager single types', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Label is not pluralized', async () => {\n    const res = await rq({\n      url: `/content-manager/content-types?kind=singleType`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          info: expect.objectContaining({\n            label: 'Single-type-model',\n          }),\n        }),\n      ])\n    );\n  });\n\n  test('find single type content returns 404 when not created', async () => {\n    const res = await rq({\n      url: `/content-manager/single-types/${uid}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(404);\n  });\n\n  test('Create content', async () => {\n    const res = await rq({\n      url: `/content-manager/single-types/${uid}`,\n      method: 'PUT',\n      body: {\n        title: 'Title',\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      id: expect.anything(),\n      title: 'Title',\n    });\n  });\n\n  test('find single type content returns an object ', async () => {\n    const res = await rq({\n      url: `/content-manager/single-types/${uid}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      id: expect.anything(),\n      title: 'Title',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/utils/wrap-bad-request.js": "'use strict';\n\nmodule.exports = fn => async (...args) => {\n  try {\n    await fn(...args);\n  } catch (error) {\n    if (strapi.errors.isBoom(error)) {\n      throw error;\n    }\n\n    // these are errors like unique constraints\n    strapi.log.error(error);\n    throw strapi.errors.badRequest('Invalid input data. Please verify unique constraints');\n  }\n};\n",
    "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js": "import React, { memo, useEffect, useMemo, useReducer, useState, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { get, groupBy, set, size } from 'lodash';\nimport {\n  request,\n  LoadingIndicatorPage,\n  useGlobalContext,\n  PopUpWarning,\n} from 'strapi-helper-plugin';\nimport { useHistory, useLocation, useRouteMatch, Redirect } from 'react-router-dom';\nimport DataManagerContext from '../../contexts/DataManagerContext';\nimport getTrad from '../../utils/getTrad';\nimport makeUnique from '../../utils/makeUnique';\nimport pluginId from '../../pluginId';\nimport FormModal from '../FormModal';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\nimport createDataObject from './utils/createDataObject';\nimport createModifiedDataSchema, {\n  orderAllDataAttributesWithImmutable,\n} from './utils/createModifiedDataSchema';\nimport retrieveSpecificInfoFromComponents from './utils/retrieveSpecificInfoFromComponents';\nimport retrieveComponentsFromSchema from './utils/retrieveComponentsFromSchema';\nimport retrieveNestedComponents from './utils/retrieveNestedComponents';\nimport { retrieveComponentsThatHaveComponents } from './utils/retrieveComponentsThatHaveComponents';\nimport {\n  getComponentsToPost,\n  formatMainDataType,\n  getCreatedAndModifiedComponents,\n  sortContentType,\n} from './utils/cleanData';\n\nconst DataManagerProvider = ({ allIcons, children }) => {\n  const [reducerState, dispatch] = useReducer(reducer, initialState, init);\n  const [infoModals, toggleInfoModal] = useState({ cancel: false });\n  const {\n    autoReload,\n    currentEnvironment,\n    emitEvent,\n    fetchUserPermissions,\n    formatMessage,\n    menu,\n  } = useGlobalContext();\n  const {\n    components,\n    contentTypes,\n    isLoading,\n    isLoadingForDataToBeSet,\n    initialData,\n    modifiedData,\n    reservedNames,\n  } = reducerState.toJS();\n  const { pathname } = useLocation();\n  const { push } = useHistory();\n  const contentTypeMatch = useRouteMatch(`/plugins/${pluginId}/content-types/:uid`);\n  const componentMatch = useRouteMatch(\n    `/plugins/${pluginId}/component-categories/:categoryUid/:componentUid`\n  );\n\n  const formatMessageRef = useRef();\n  formatMessageRef.current = formatMessage;\n  const isInDevelopmentMode = currentEnvironment === 'development' && autoReload;\n\n  const isInContentTypeView = contentTypeMatch !== null;\n  const firstKeyToMainSchema = isInContentTypeView ? 'contentType' : 'component';\n  const currentUid = isInContentTypeView\n    ? get(contentTypeMatch, 'params.uid', null)\n    : get(componentMatch, 'params.componentUid', null);\n  const abortController = new AbortController();\n  const { signal } = abortController;\n  const getDataRef = useRef();\n  const endPoint = isInContentTypeView ? 'content-types' : 'components';\n\n  getDataRef.current = async () => {\n    try {\n      const [\n        { data: componentsArray },\n        { data: contentTypesArray },\n        reservedNames,\n      ] = await Promise.all(\n        ['components', 'content-types', 'reserved-names'].map(endPoint => {\n          return request(`/${pluginId}/${endPoint}`, {\n            method: 'GET',\n            signal,\n          });\n        })\n      );\n\n      const components = createDataObject(componentsArray);\n      const contentTypes = createDataObject(contentTypesArray);\n      const orderedComponents = orderAllDataAttributesWithImmutable({\n        components,\n      });\n      const orderedContenTypes = orderAllDataAttributesWithImmutable({\n        components: contentTypes,\n      });\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        components: orderedComponents.get('components'),\n        contentTypes: orderedContenTypes.get('components'),\n        reservedNames,\n      });\n    } catch (err) {\n      console.error({ err });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  useEffect(() => {\n    getDataRef.current();\n  }, []);\n\n  useEffect(() => {\n    // We need to set the modifiedData after the data has been retrieved\n    // and also on pathname change\n    if (!isLoading && currentUid) {\n      setModifiedData();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isLoading, pathname, currentUid]);\n\n  useEffect(() => {\n    if (currentEnvironment === 'development' && !autoReload) {\n      strapi.notification.toggle({\n        type: 'info',\n        message: { id: getTrad('notification.info.autoreaload-disable') },\n      });\n    }\n  }, [autoReload, currentEnvironment]);\n\n  const didModifiedComponents =\n    getCreatedAndModifiedComponents(modifiedData.components || {}, components).length > 0;\n\n  const addAttribute = (\n    attributeToSet,\n    forTarget,\n    targetUid,\n    isEditing = false,\n    initialAttribute,\n    shouldAddComponentToData = false\n  ) => {\n    const actionType = isEditing ? 'EDIT_ATTRIBUTE' : 'ADD_ATTRIBUTE';\n\n    dispatch({\n      type: actionType,\n      attributeToSet,\n      forTarget,\n      targetUid,\n      initialAttribute,\n      shouldAddComponentToData,\n    });\n  };\n\n  const addCreatedComponentToDynamicZone = (dynamicZoneTarget, componentsToAdd) => {\n    dispatch({\n      type: 'ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE',\n      dynamicZoneTarget,\n      componentsToAdd,\n    });\n  };\n\n  const cancelChanges = () => {\n    toggleModalCancel();\n    dispatch({ type: 'CANCEL_CHANGES' });\n  };\n\n  const createSchema = (\n    data,\n    schemaType,\n    uid,\n    componentCategory,\n    shouldAddComponentToData = false\n  ) => {\n    const type = schemaType === 'contentType' ? 'CREATE_SCHEMA' : 'CREATE_COMPONENT_SCHEMA';\n\n    dispatch({\n      type,\n      data,\n      componentCategory,\n      schemaType,\n      uid,\n      shouldAddComponentToData,\n    });\n  };\n\n  const changeDynamicZoneComponents = (dynamicZoneTarget, newComponents) => {\n    dispatch({\n      type: 'CHANGE_DYNAMIC_ZONE_COMPONENTS',\n      dynamicZoneTarget,\n      newComponents,\n    });\n  };\n\n  const removeAttribute = (mainDataKey, attributeToRemoveName, componentUid = '') => {\n    const type =\n      mainDataKey === 'components' ? 'REMOVE_FIELD_FROM_DISPLAYED_COMPONENT' : 'REMOVE_FIELD';\n\n    if (mainDataKey === 'contentType') {\n      emitEvent('willDeleteFieldOfContentType');\n    }\n\n    dispatch({\n      type,\n      mainDataKey,\n      attributeToRemoveName,\n      componentUid,\n    });\n  };\n\n  const deleteCategory = async categoryUid => {\n    try {\n      const requestURL = `/${pluginId}/component-categories/${categoryUid}`;\n      // eslint-disable-next-line no-alert\n      const userConfirm = window.confirm(\n        formatMessage({\n          id: getTrad('popUpWarning.bodyMessage.category.delete'),\n        })\n      );\n      // Close the modal\n      push({ search: '' });\n\n      if (userConfirm) {\n        strapi.lockApp();\n\n        await request(requestURL, { method: 'DELETE' }, true);\n\n        await updatePermissions();\n\n        // Reload the plugin so the cycle is new again\n        dispatch({ type: 'RELOAD_PLUGIN' });\n        // Refetch all the data\n        getDataRef.current();\n      }\n    } catch (err) {\n      console.error({ err });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      strapi.unlockApp();\n    }\n  };\n\n  const deleteData = async () => {\n    try {\n      const requestURL = `/${pluginId}/${endPoint}/${currentUid}`;\n      const isTemporary = get(modifiedData, [firstKeyToMainSchema, 'isTemporary'], false);\n      // eslint-disable-next-line no-alert\n      const userConfirm = window.confirm(\n        formatMessage({\n          id: getTrad(\n            `popUpWarning.bodyMessage.${isInContentTypeView ? 'contentType' : 'component'}.delete`\n          ),\n        })\n      );\n\n      // Close the modal\n      push({ search: '' });\n\n      if (userConfirm) {\n        if (isTemporary) {\n          // Delete the not saved type\n          // Here we just need to reset the components to the initial ones and also the content types\n          // Doing so will trigging a url change since the type doesn't exist in either the contentTypes or the components\n          // so the modified and the initial data will also be reset in the useEffect...\n          dispatch({ type: 'DELETE_NOT_SAVED_TYPE' });\n\n          return;\n        }\n\n        strapi.lockApp();\n\n        await request(requestURL, { method: 'DELETE' }, true);\n\n        // Reload the plugin so the cycle is new again\n        dispatch({ type: 'RELOAD_PLUGIN' });\n\n        // Refetch the permissions\n        await updatePermissions();\n\n        // Update the app menu\n        await updateAppMenu();\n        // Refetch all the data\n        getDataRef.current();\n      }\n    } catch (err) {\n      console.error({ err });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      strapi.unlockApp();\n    }\n  };\n\n  const editCategory = async (categoryUid, body) => {\n    try {\n      const requestURL = `/${pluginId}/component-categories/${categoryUid}`;\n\n      // Close the modal\n      push({ search: '' });\n\n      // Lock the app\n      strapi.lockApp();\n\n      // Update the category\n      await request(requestURL, { method: 'PUT', body }, true);\n\n      await updatePermissions();\n\n      // Reload the plugin so the cycle is new again\n      dispatch({ type: 'RELOAD_PLUGIN' });\n      // Refetch all the data\n      getDataRef.current();\n    } catch (err) {\n      console.error({ err });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      strapi.unlockApp();\n    }\n  };\n\n  const getAllComponentsThatHaveAComponentInTheirAttributes = () => {\n    // We need to create an object with all the non modified compos\n    // plus the ones that are created on the fly\n    const allCompos = Object.assign({}, components, modifiedData.components);\n\n    // Since we apply the modification of a specific component only in the modified data\n    // we need to update all compos with the modifications\n    if (!isInContentTypeView) {\n      const currentEditedCompo = get(modifiedData, 'component', {});\n\n      set(allCompos, get(currentEditedCompo, ['uid'], ''), currentEditedCompo);\n    }\n\n    const composWithCompos = retrieveComponentsThatHaveComponents(allCompos);\n\n    return makeUnique(composWithCompos);\n  };\n\n  const getAllNestedComponents = () => {\n    const appNestedCompo = retrieveNestedComponents(components);\n    const editingDataNestedCompos = retrieveNestedComponents(modifiedData.components || {});\n\n    return makeUnique([...editingDataNestedCompos, ...appNestedCompo]);\n  };\n\n  const removeComponentFromDynamicZone = (dzName, componentToRemoveIndex) => {\n    dispatch({\n      type: 'REMOVE_COMPONENT_FROM_DYNAMIC_ZONE',\n      dzName,\n      componentToRemoveIndex,\n    });\n  };\n\n  const setModifiedData = () => {\n    const currentSchemas = isInContentTypeView ? contentTypes : components;\n    const schemaToSet = get(currentSchemas, currentUid, {\n      schema: { attributes: {} },\n    });\n\n    const retrievedComponents = retrieveComponentsFromSchema(\n      schemaToSet.schema.attributes,\n      components\n    );\n    const newSchemaToSet = createModifiedDataSchema(\n      schemaToSet,\n      retrievedComponents,\n      components,\n      isInContentTypeView\n    );\n\n    const dataShape = orderAllDataAttributesWithImmutable(newSchemaToSet, isInContentTypeView);\n\n    // This prevents from losing the created content type or component when clicking on the link from the left menu\n    const hasJustCreatedSchema =\n      get(schemaToSet, 'isTemporary', false) &&\n      size(get(schemaToSet, 'schema.attributes', {})) === 0;\n\n    dispatch({\n      type: 'SET_MODIFIED_DATA',\n      schemaToSet: dataShape,\n      hasJustCreatedSchema,\n    });\n  };\n\n  const shouldRedirect = useMemo(() => {\n    const dataSet = isInContentTypeView ? contentTypes : components;\n\n    return !Object.keys(dataSet).includes(currentUid) && !isLoading;\n  }, [components, contentTypes, currentUid, isInContentTypeView, isLoading]);\n\n  const redirectEndpoint = useMemo(() => {\n    const allowedEndpoints = Object.keys(contentTypes)\n      .filter(uid => get(contentTypes, [uid, 'schema', 'editable'], true))\n      .sort();\n\n    return get(allowedEndpoints, '0', '');\n  }, [contentTypes]);\n\n  if (shouldRedirect) {\n    return <Redirect to={`/plugins/${pluginId}/content-types/${redirectEndpoint}`} />;\n  }\n\n  const submitData = async additionalContentTypeData => {\n    try {\n      const isCreating = get(modifiedData, [firstKeyToMainSchema, 'isTemporary'], false);\n      const body = {\n        components: getComponentsToPost(\n          modifiedData.components,\n          components,\n          currentUid,\n          isCreating\n        ),\n      };\n\n      if (isInContentTypeView) {\n        body.contentType = {\n          ...formatMainDataType(modifiedData.contentType),\n          ...additionalContentTypeData,\n        };\n\n        emitEvent('willSaveContentType');\n      } else {\n        body.component = formatMainDataType(modifiedData.component, true);\n\n        emitEvent('willSaveComponent');\n      }\n\n      const method = isCreating ? 'POST' : 'PUT';\n\n      const baseURL = `/${pluginId}/${endPoint}`;\n      const requestURL = isCreating ? baseURL : `${baseURL}/${currentUid}`;\n\n      // Lock the app\n      strapi.lockApp();\n\n      await request(requestURL, { method, body }, true);\n\n      await updatePermissions();\n\n      // Update the app menu\n      await updateAppMenu();\n\n      // Submit ct tracking success\n      if (isInContentTypeView) {\n        emitEvent('didSaveContentType');\n\n        const oldName = get(body, ['contentType', 'schema', 'name'], '');\n        const newName = get(initialData, ['contentType', 'schema', 'name'], '');\n\n        if (!isCreating && oldName !== newName) {\n          emitEvent('didEditNameOfContentType');\n        }\n      } else {\n        emitEvent('didSaveComponent');\n      }\n\n      // Reload the plugin so the cycle is new again\n      dispatch({ type: 'RELOAD_PLUGIN' });\n      // Refetch all the data\n      getDataRef.current();\n    } catch (err) {\n      if (!isInContentTypeView) {\n        emitEvent('didNotSaveComponent');\n      }\n\n      console.error({ err: err.response });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      strapi.unlockApp();\n    }\n  };\n\n  // Open the modal warning cancel changes\n  const toggleModalCancel = () => {\n    toggleInfoModal(prev => ({ ...prev, cancel: !prev.cancel }));\n  };\n\n  // Update the menu using the internal API\n  const updateAppMenu = async () => {\n    if (menu.getModels) {\n      await menu.getModels();\n    }\n  };\n\n  const updatePermissions = async () => {\n    await fetchUserPermissions();\n  };\n\n  const updateSchema = (data, schemaType, componentUID) => {\n    dispatch({\n      type: 'UPDATE_SCHEMA',\n      data,\n      schemaType,\n      uid: componentUID,\n    });\n  };\n\n  return (\n    <DataManagerContext.Provider\n      value={{\n        addAttribute,\n        addCreatedComponentToDynamicZone,\n        allComponentsCategories: retrieveSpecificInfoFromComponents(components, ['category']),\n        allComponentsIconAlreadyTaken: retrieveSpecificInfoFromComponents(components, [\n          'schema',\n          'icon',\n        ]),\n        allIcons,\n        changeDynamicZoneComponents,\n        components,\n        componentsGroupedByCategory: groupBy(components, 'category'),\n        componentsThatHaveOtherComponentInTheirAttributes: getAllComponentsThatHaveAComponentInTheirAttributes(),\n        contentTypes,\n        createSchema,\n        deleteCategory,\n        deleteData,\n        editCategory,\n        isInDevelopmentMode,\n        initialData,\n        isInContentTypeView,\n        modifiedData,\n        nestedComponents: getAllNestedComponents(),\n        removeAttribute,\n        removeComponentFromDynamicZone,\n        reservedNames,\n        setModifiedData,\n        sortedContentTypesList: sortContentType(contentTypes),\n        submitData,\n        toggleModalCancel,\n        updateSchema,\n      }}\n    >\n      {isLoadingForDataToBeSet ? (\n        <LoadingIndicatorPage />\n      ) : (\n        <>\n          {children}\n          {isInDevelopmentMode && (\n            <>\n              <FormModal />\n              <PopUpWarning\n                isOpen={infoModals.cancel}\n                toggleModal={toggleModalCancel}\n                content={{\n                  message: getTrad(\n                    `popUpWarning.bodyMessage.cancel-modifications${\n                      didModifiedComponents ? '.with-components' : ''\n                    }`\n                  ),\n                }}\n                popUpWarningType=\"danger\"\n                onConfirm={() => {\n                  cancelChanges();\n                }}\n              />\n            </>\n          )}\n        </>\n      )}\n    </DataManagerContext.Provider>\n  );\n};\n\nDataManagerProvider.propTypes = {\n  allIcons: PropTypes.array.isRequired,\n  children: PropTypes.node.isRequired,\n};\n\nexport default memo(DataManagerProvider);\n",
    "packages/strapi-plugin-content-type-builder/admin/src/containers/FormModal/index.js": "import React, { useCallback, useEffect, useReducer, useRef, useState } from 'react';\nimport {\n  HeaderModal,\n  HeaderModalTitle,\n  Modal,\n  ModalBody,\n  ModalFooter,\n  ModalForm,\n  PopUpWarning,\n  getYupInnerErrors,\n  useGlobalContext,\n  useQuery,\n  InputsIndex,\n} from 'strapi-helper-plugin';\nimport { Button, Text, Padded } from '@buffetjs/core';\nimport { Inputs } from '@buffetjs/custom';\n\nimport { useHistory, useLocation } from 'react-router-dom';\nimport { FormattedMessage } from 'react-intl';\nimport { get, has, isEmpty, set, toLower, toString, upperFirst } from 'lodash';\nimport pluginId from '../../pluginId';\nimport useDataManager from '../../hooks/useDataManager';\nimport AttributeOption from '../../components/AttributeOption';\nimport BooleanBox from '../../components/BooleanBox';\nimport ComponentIconPicker from '../../components/ComponentIconPicker';\nimport CustomCheckbox from '../../components/CustomCheckbox';\nimport ModalHeader from '../../components/ModalHeader';\nimport HeaderModalNavContainer from '../../components/HeaderModalNavContainer';\nimport RelationForm from '../../components/RelationForm';\nimport HeaderNavLink from '../../components/HeaderNavLink';\nimport WrapperSelect from '../../components/WrapperSelect';\nimport getTrad from '../../utils/getTrad';\nimport makeSearch from '../../utils/makeSearch';\nimport getAttributes from './utils/attributes';\nimport forms from './utils/forms';\nimport createHeadersArray from './utils/createHeadersArray';\nimport createHeadersObjectFromArray from './utils/createHeadersObjectFromArray';\nimport { createComponentUid, createUid } from './utils/createUid';\nimport getModalTitleSubHeader from './utils/getModalTitleSubHeader';\nimport getNextSearch from './utils/getNextSearch';\nimport { NAVLINKS, INITIAL_STATE_DATA } from './utils/staticData';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\nimport CustomButton from './CustomButton';\nimport canEditContentType from './utils/canEditContentType';\n\n/* eslint-disable indent */\n/* eslint-disable react/no-array-index-key */\n\nconst FormModal = () => {\n  const [state, setState] = useState(INITIAL_STATE_DATA);\n  const [showConfirmModal, setShowConfirmModal] = useState(false);\n  const [reducerState, dispatch] = useReducer(reducer, initialState, init);\n  const { push } = useHistory();\n  const { search } = useLocation();\n  const { emitEvent, formatMessage } = useGlobalContext();\n  const query = useQuery();\n  const attributeOptionRef = useRef();\n\n  const {\n    addAttribute,\n    addCreatedComponentToDynamicZone,\n    allComponentsCategories,\n    changeDynamicZoneComponents,\n    contentTypes,\n    components,\n    createSchema,\n    deleteCategory,\n    deleteData,\n    editCategory,\n    submitData,\n    modifiedData: allDataSchema,\n    nestedComponents,\n    setModifiedData,\n    sortedContentTypesList,\n    updateSchema,\n    reservedNames,\n  } = useDataManager();\n  const {\n    componentToCreate,\n    formErrors,\n    initialData,\n    isCreatingComponentWhileAddingAField,\n    modifiedData,\n  } = reducerState.toJS();\n\n  useEffect(() => {\n    if (!isEmpty(search)) {\n      const actionType = query.get('actionType');\n      // Returns 'null' if there isn't any attributeType search params\n      const attributeName = query.get('attributeName');\n      const attributeType = query.get('attributeType');\n      const dynamicZoneTarget = query.get('dynamicZoneTarget');\n      const forTarget = query.get('forTarget');\n      const modalType = query.get('modalType');\n      const kind = query.get('kind') || get(allDataSchema, ['contentType', 'schema', 'kind'], null);\n      const targetUid = query.get('targetUid');\n      const settingType = query.get('settingType');\n      const headerId = query.get('headerId');\n      const header_label_1 = query.get('header_label_1');\n      const header_icon_name_1 = query.get('header_icon_name_1');\n      const header_icon_isCustom_1 = query.get('header_icon_isCustom_1');\n      const header_info_category_1 = query.get('header_info_category_1');\n      const header_info_name_1 = query.get('header_info_name_1');\n      const header_label_2 = query.get('header_label_2');\n      const header_icon_name_2 = query.get('header_icon_name_2');\n      const header_icon_isCustom_2 = query.get('header_icon_isCustom_2');\n      const header_info_category_2 = query.get('header_info_category_2');\n      const header_info_name_2 = query.get('header_info_name_2');\n      const header_label_3 = query.get('header_label_3');\n      const header_icon_name_3 = query.get('header_icon_name_3');\n      const header_icon_isCustom_3 = query.get('header_icon_isCustom_3');\n      const header_info_category_3 = query.get('header_info_category_3');\n      const header_info_name_3 = query.get('header_info_name_3');\n      const header_label_4 = query.get('header_label_4');\n      const header_icon_name_4 = query.get('header_icon_name_4');\n      const header_icon_isCustom_4 = query.get('header_icon_isCustom_4');\n      const header_info_category_4 = query.get('header_info_category_4');\n      const header_info_name_4 = query.get('header_info_name_4');\n      const header_label_5 = query.get('header_label_5');\n      const header_icon_name_5 = query.get('header_icon_name_5');\n      const header_icon_isCustom_5 = query.get('header_icon_isCustom_5');\n      const header_info_category_5 = query.get('header_info_category_5');\n      const header_info_name_5 = query.get('header_info_name_5');\n      const step = query.get('step');\n      const pathToSchema =\n        forTarget === 'contentType' || forTarget === 'component'\n          ? [forTarget]\n          : [forTarget, targetUid];\n\n      setState({\n        actionType,\n        attributeName,\n        attributeType,\n        kind,\n        dynamicZoneTarget,\n        forTarget,\n        modalType,\n        pathToSchema,\n        settingType,\n        step,\n        targetUid,\n        header_label_1,\n        header_icon_name_1,\n        header_icon_isCustom_1,\n        header_info_name_1,\n        header_info_category_1,\n        header_label_2,\n        header_icon_name_2,\n        header_icon_isCustom_2,\n        header_info_name_2,\n        header_info_category_2,\n        header_label_3,\n        header_icon_name_3,\n        header_icon_isCustom_3,\n        header_info_name_3,\n        header_info_category_3,\n        header_label_4,\n        header_icon_name_4,\n        header_icon_isCustom_4,\n        header_info_name_4,\n        header_info_category_4,\n        header_label_5,\n        header_icon_name_5,\n        header_icon_isCustom_5,\n        header_info_name_5,\n        header_info_category_5,\n        headerId,\n      });\n\n      const collectionTypesForRelation = sortedContentTypesList.filter(\n        ({ kind }) => kind === 'collectionType'\n      );\n\n      // Reset all the modification when opening the edit category modal\n      if (modalType === 'editCategory') {\n        setModifiedData();\n      }\n\n      if (actionType === 'edit' && modalType === 'attribute' && forTarget === 'contentType') {\n        emitEvent('willEditFieldOfContentType');\n      }\n\n      // Case:\n      // the user opens the modal chooseAttributes\n      // selects dynamic zone => set the field name\n      // then goes to step 1 (the modal is addComponentToDynamicZone) and finally reloads the app.\n      // In this particular if the user tries to add components to the zone it will pop an error since the dz is unknown\n      const shouldCloseModalToPreventErrorWhenCreatingADZ =\n        get(allDataSchema, [...pathToSchema, 'schema', 'attributes', dynamicZoneTarget], null) ===\n          null && modalType === 'addComponentToDynamicZone';\n\n      // Similarly when creating a component on the fly if the user reloads the app\n      // The previous data is lost\n      // Since the modal uses the search it will still be opened\n      const shouldCloseModalChooseAttribute =\n        get(allDataSchema, ['components', targetUid], null) === null &&\n        // modalType === 'chooseAttribute' &&\n        forTarget === 'components';\n\n      if (shouldCloseModalToPreventErrorWhenCreatingADZ || shouldCloseModalChooseAttribute) {\n        push({ search: '' });\n      }\n\n      // Edit category\n      if (modalType === 'editCategory' && actionType === 'edit') {\n        dispatch({\n          type: 'SET_DATA_TO_EDIT',\n          data: {\n            name: query.get('categoryName'),\n          },\n        });\n      }\n\n      // Create content type we need to add the default option draftAndPublish\n      if (\n        modalType === 'contentType' &&\n        state.modalType !== 'contentType' && // Prevent setting the data structure when navigating from one tab to another\n        actionType === 'create'\n      ) {\n        dispatch({\n          type: 'SET_DATA_TO_EDIT',\n          data: {\n            draftAndPublish: true,\n          },\n        });\n      }\n\n      // Edit content type\n      if (\n        modalType === 'contentType' &&\n        state.modalType !== 'contentType' &&\n        actionType === 'edit'\n      ) {\n        const { name, collectionName, draftAndPublish, kind } = get(\n          allDataSchema,\n          [...pathToSchema, 'schema'],\n          {\n            name: null,\n            collectionName: null,\n          }\n        );\n\n        dispatch({\n          type: 'SET_DATA_TO_EDIT',\n          data: {\n            name,\n            collectionName,\n            draftAndPublish,\n            kind,\n          },\n        });\n      }\n\n      // Edit component\n      if (modalType === 'component' && state.modalType !== 'component' && actionType === 'edit') {\n        const data = get(allDataSchema, pathToSchema, {});\n\n        dispatch({\n          type: 'SET_DATA_TO_EDIT',\n          data: {\n            name: data.schema.name,\n            category: data.category,\n            icon: data.schema.icon,\n            collectionName: data.schema.collectionName,\n          },\n        });\n      }\n\n      // Special case for the dynamic zone\n      if (\n        modalType === 'addComponentToDynamicZone' &&\n        state.modalType !== 'addComponentToDynamicZone' &&\n        actionType === 'edit'\n      ) {\n        const attributeToEditNotFormatted = get(\n          allDataSchema,\n          [...pathToSchema, 'schema', 'attributes', dynamicZoneTarget],\n          {}\n        );\n        const attributeToEdit = {\n          ...attributeToEditNotFormatted,\n          // We filter the available components\n          // Because this modal is only used for adding components\n          components: [],\n          name: dynamicZoneTarget,\n          createComponent: false,\n          componentToCreate: { type: 'component' },\n        };\n\n        dispatch({\n          type: 'SET_DYNAMIC_ZONE_DATA_SCHEMA',\n          attributeToEdit,\n        });\n      }\n\n      // Set the predefined data structure to create an attribute\n      if (\n        attributeType &&\n        attributeType !== 'null' &&\n        // This condition is added to prevent the reducer state to be cleared when navigating from the base tab to tha advanced one\n        state.modalType !== 'attribute'\n      ) {\n        const attributeToEditNotFormatted = get(\n          allDataSchema,\n          [...pathToSchema, 'schema', 'attributes', attributeName],\n          {}\n        );\n        const attributeToEdit = {\n          ...attributeToEditNotFormatted,\n          name: attributeName,\n        };\n\n        // We need to set the repeatable key to false when editing a component\n        // The API doesn't send this info\n        if (attributeType === 'component' && actionType === 'edit') {\n          if (!attributeToEdit.repeatable) {\n            set(attributeToEdit, 'repeatable', false);\n          }\n        }\n\n        if (attributeType === 'relation' && !has(attributeToEdit, ['targetAttribute'])) {\n          set(attributeToEdit, ['targetAttribute'], '-');\n        }\n\n        dispatch({\n          type: 'SET_ATTRIBUTE_DATA_SCHEMA',\n          attributeType,\n          nameToSetForRelation: get(collectionTypesForRelation, ['0', 'title'], 'error'),\n          targetUid: get(collectionTypesForRelation, ['0', 'uid'], 'error'),\n          isEditing: actionType === 'edit',\n          modifiedDataToSetForEditing: attributeToEdit,\n          step,\n        });\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [search]);\n\n  const form = get(forms, [state.modalType, 'form', state.settingType], () => ({\n    items: [],\n  }));\n  const headers = createHeadersArray(state);\n\n  const isCreatingContentType = state.modalType === 'contentType';\n  const isCreatingComponent = state.modalType === 'component';\n  const isCreatingAttribute = state.modalType === 'attribute';\n  const isComponentAttribute = state.attributeType === 'component' && isCreatingAttribute;\n\n  const isCreating = state.actionType === 'create';\n  const isCreatingComponentFromAView =\n    get(modifiedData, 'createComponent', false) || isCreatingComponentWhileAddingAField;\n  const isInFirstComponentStep = state.step === '1';\n  const isEditingCategory = state.modalType === 'editCategory';\n  const isOpen = !isEmpty(search);\n  const isPickingAttribute = state.modalType === 'chooseAttribute';\n  const uid = createUid(modifiedData.name || '');\n  const attributes = get(allDataSchema, [...state.pathToSchema, 'schema', 'attributes'], null);\n\n  const checkFormValidity = async () => {\n    let schema;\n    const dataToValidate =\n      isCreatingComponentFromAView && state.step === '1'\n        ? get(modifiedData, 'componentToCreate', {})\n        : modifiedData;\n\n    // Check form validity for content type\n    if (isCreatingContentType) {\n      schema = forms.contentType.schema(\n        Object.keys(contentTypes),\n        state.actionType === 'edit',\n        // currentUID\n        get(allDataSchema, [...state.pathToSchema, 'uid'], null),\n        reservedNames\n      );\n\n      // Check form validity for component\n      // This is happening when the user click on the link from the left menu\n    } else if (isCreatingComponent) {\n      schema = forms.component.schema(\n        Object.keys(components),\n        modifiedData.category || '',\n        reservedNames,\n        state.actionType === 'edit',\n        get(allDataSchema, [...state.pathToSchema, 'uid'], null)\n      );\n\n      // Check for validity for creating a component\n      // This is happening when the user creates a component \"on the fly\"\n      // Since we temporarily store the component info in another object\n      // The data is set in the componentToCreate key\n    } else if (isComponentAttribute && isCreatingComponentFromAView && isInFirstComponentStep) {\n      schema = forms.component.schema(\n        Object.keys(components),\n        get(modifiedData, 'componentToCreate.category', ''),\n        reservedNames\n      );\n\n      // Check form validity for creating a 'common attribute'\n      // We need to make sure that it is independent from the step\n    } else if (isCreatingAttribute && !isInFirstComponentStep) {\n      const type = state.attributeType === 'relation' ? 'relation' : modifiedData.type;\n\n      let alreadyTakenTargetContentTypeAttributes = [];\n\n      if (type === 'relation') {\n        const targetContentTypeUID = get(modifiedData, ['target'], null);\n        const targetContentTypeAttributes = get(\n          contentTypes,\n          [targetContentTypeUID, 'schema', 'attributes'],\n          {}\n        );\n\n        // Create an array with all the targetContentType attributes name\n        // in order to prevent the user from creating a relation with a targetAttribute\n        // that may exist in the other content type\n        alreadyTakenTargetContentTypeAttributes = Object.keys(targetContentTypeAttributes).filter(\n          attrName => {\n            // Keep all the target content type attributes when creating a relation\n            if (state.actionType !== 'edit') {\n              return true;\n            }\n\n            // Remove the already created one when editing\n            return attrName !== initialData.targetAttribute;\n          }\n        );\n      }\n      schema = forms[state.modalType].schema(\n        get(allDataSchema, state.pathToSchema, {}),\n        type,\n        modifiedData,\n        state.actionType === 'edit',\n        state.attributeName,\n        initialData,\n        alreadyTakenTargetContentTypeAttributes,\n        reservedNames\n      );\n    } else if (isEditingCategory) {\n      schema = forms.editCategory.schema(allComponentsCategories, initialData);\n    } else {\n      // The user is either in the addComponentToDynamicZone modal or\n      // in step 1 of the add component (modalType=attribute&attributeType=component) but not creating a component\n\n      // eslint-disable-next-line no-lonely-if\n      if (isInFirstComponentStep && isCreatingComponentFromAView) {\n        schema = forms.component.schema(\n          Object.keys(components),\n          get(modifiedData, 'componentToCreate.category', ''),\n          reservedNames\n        );\n      } else {\n        // The form is valid\n        // The case here is being in the addComponentToDynamicZone modal and not creating a component\n        return;\n      }\n    }\n\n    await schema.validate(dataToValidate, { abortEarly: false });\n  };\n\n  // TODO this should be a util for testing\n  const getButtonSubmitMessage = () => {\n    const { attributeType, modalType } = state;\n    const isCreatingAComponent = get(modifiedData, 'createComponent', false);\n    let tradId;\n\n    switch (modalType) {\n      case 'contentType':\n      case 'component':\n      case 'editCategory':\n        tradId = !isCreating ? getTrad('form.button.finish') : getTrad('form.button.continue');\n        break;\n      case 'addComponentToDynamicZone': {\n        tradId = isCreatingAComponent\n          ? getTrad('form.button.add-first-field-to-created-component')\n          : getTrad('form.button.finish');\n        break;\n      }\n      case 'attribute': {\n        if (attributeType === 'dynamiczone') {\n          tradId = getTrad('form.button.add-components-to-dynamiczone');\n        } else if (attributeType === 'component') {\n          if (isInFirstComponentStep) {\n            tradId = isCreatingAComponent\n              ? getTrad('form.button.configure-component')\n              : getTrad('form.button.select-component');\n          } else {\n            tradId = isCreatingComponentWhileAddingAField\n              ? getTrad('form.button.add-first-field-to-created-component')\n              : getTrad('form.button.add-field');\n          }\n        } else {\n          tradId = getTrad('form.button.add-field');\n        }\n        break;\n      }\n      default:\n        tradId = getTrad('form.button.add-field');\n    }\n\n    return formatMessage({ id: tradId });\n  };\n\n  // TODO remove and use the utils/makeSearch\n  const makeNextSearch = (searchObj, shouldContinue = isCreating) => {\n    if (!shouldContinue) {\n      return '';\n    }\n\n    return Object.keys(searchObj).reduce((acc, current, index) => {\n      if (searchObj[current] !== null) {\n        acc = `${acc}${index === 0 ? '' : '&'}${current}=${searchObj[current]}`;\n      }\n\n      return acc;\n    }, '');\n  };\n\n  const handleClickAddComponentsToDynamicZone = ({\n    target: { name, components, shouldAddComponents },\n  }) => {\n    dispatch({\n      type: 'ADD_COMPONENTS_TO_DYNAMIC_ZONE',\n      name,\n      components,\n      shouldAddComponents,\n    });\n  };\n\n  const handleChangeMediaAllowedTypes = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE_ALLOWED_TYPE',\n      name,\n      value,\n    });\n  };\n\n  const toggleConfirmModal = useCallback(() => setShowConfirmModal(prev => !prev), []);\n\n  const handleChange = useCallback(\n    ({ target: { name, value, type, ...rest } }) => {\n      const namesThatCanResetToNullValue = [\n        'enumName',\n        'max',\n        'min',\n        'maxLength',\n        'minLength',\n        'regex',\n      ];\n\n      // When toggling the draftAndPublish from true to false\n      // We need to display a confirmation box\n      if (name === 'draftAndPublish' && state.actionType === 'edit' && value === false) {\n        toggleConfirmModal();\n\n        return;\n      }\n\n      let val;\n\n      if (['default', ...namesThatCanResetToNullValue].includes(name) && value === '') {\n        val = null;\n      } else if (\n        type === 'radio' &&\n        (name === 'multiple' ||\n          name === 'single' ||\n          name === 'createComponent' ||\n          name === 'repeatable')\n      ) {\n        // eslint-disable-next-line no-unneeded-ternary\n        val = value === 'false' ? false : true;\n\n        // The boolean default accepts 3 different values\n        // This check has been added to allow a reset to null for the bool\n      } else if (type === 'radio' && name === 'default') {\n        if (value === 'false') {\n          val = false;\n        } else if (value === 'true') {\n          val = true;\n        } else {\n          val = null;\n        }\n\n        // We store an array for the enum\n      } else if (name === 'enum') {\n        val = value.split('\\n');\n      } else {\n        val = value;\n      }\n\n      const clonedErrors = Object.assign({}, formErrors);\n\n      // Reset min error when modifying the max\n      if (name === 'max') {\n        delete clonedErrors.min;\n      }\n\n      // Same here\n      if (name === 'maxLength') {\n        delete clonedErrors.minLength;\n      }\n\n      // Since the onBlur is deactivated we remove the errors directly when changing an input\n      delete clonedErrors[name];\n\n      dispatch({\n        type: 'SET_ERRORS',\n        errors: clonedErrors,\n      });\n\n      dispatch({\n        type: 'ON_CHANGE',\n        keys: name.split('.'),\n        value: val,\n        ...rest,\n      });\n    },\n    [formErrors, state.actionType, toggleConfirmModal]\n  );\n\n  const handleConfirmDisableDraftAndPublish = useCallback(() => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: ['draftAndPublish'],\n      value: false,\n    });\n\n    toggleConfirmModal();\n  }, [toggleConfirmModal]);\n\n  const handleSubmit = async (e, shouldContinue = isCreating) => {\n    e.preventDefault();\n\n    try {\n      await checkFormValidity();\n      sendButtonAddMoreFieldEvent(shouldContinue);\n      const targetUid = state.forTarget === 'components' ? state.targetUid : uid;\n      let headerIcon;\n\n      if (state.forTarget === 'contentType') {\n        const currentKind = get(allDataSchema, ['contentType', 'schema', 'kind'], 'contentType');\n\n        headerIcon = state.kind || currentKind;\n      } else if (state.forTarget === 'component') {\n        headerIcon = 'component';\n      } else {\n        headerIcon = get(allDataSchema, ['components', state.targetUid, 'schema', 'icon'], '');\n      }\n\n      // Remove the last header when editing\n      if (state.actionType === 'edit') {\n        headers.pop();\n      }\n\n      const headersObject = createHeadersObjectFromArray(headers);\n      const nextHeaderIndex = headers.length + 1;\n\n      if (isCreatingContentType) {\n        // Create the content type schema\n        if (isCreating) {\n          createSchema({ ...modifiedData, kind: state.kind }, state.modalType, uid);\n        } else {\n          if (canEditContentType(allDataSchema, modifiedData)) {\n            push({ search: '' });\n            submitData(modifiedData);\n          } else {\n            strapi.notification.toggle({\n              type: 'warning',\n              message: { id: 'notification.contentType.relations.conflict' },\n            });\n          }\n\n          return;\n        }\n\n        push({\n          pathname: `/plugins/${pluginId}/content-types/${uid}`,\n          search: makeNextSearch({\n            modalType: 'chooseAttribute',\n            forTarget: state.forTarget,\n            targetUid,\n            header_label_1: modifiedData.name,\n            header_icon_name_1: headerIcon,\n            header_icon_isCustom_1: null,\n          }),\n        });\n      } else if (isCreatingComponent) {\n        if (isCreating) {\n          // Create the component schema\n          const componentUid = createComponentUid(modifiedData.name, modifiedData.category);\n          const { category, ...rest } = modifiedData;\n\n          createSchema(rest, 'component', componentUid, category);\n\n          push({\n            search: makeNextSearch({\n              modalType: 'chooseAttribute',\n              forTarget: state.forTarget,\n              targetUid: componentUid,\n              header_label_1: modifiedData.name,\n              header_icon_name_1: 'contentType',\n              header_icon_isCustom_1: null,\n            }),\n            pathname: `/plugins/${pluginId}/component-categories/${category}/${componentUid}`,\n          });\n        } else {\n          updateSchema(modifiedData, state.modalType, state.targetUid);\n\n          // Close the modal\n          push({ search: '' });\n\n          return;\n        }\n      } else if (isEditingCategory) {\n        if (toLower(initialData.name) === toLower(modifiedData.name)) {\n          // Close the modal\n          push({ search: '' });\n\n          return;\n        }\n\n        editCategory(initialData.name, modifiedData);\n\n        return;\n        // Add/edit a field to a content type\n        // Add/edit a field to a created component (the end modal is not step 2)\n      } else if (isCreatingAttribute && !isCreatingComponentFromAView) {\n        // Normal fields like boolean relations or dynamic zone\n        if (!isComponentAttribute) {\n          addAttribute(\n            modifiedData,\n            state.forTarget,\n            state.targetUid,\n            state.actionType === 'edit',\n            initialData\n          );\n\n          const isDynamicZoneAttribute = state.attributeType === 'dynamiczone';\n          // Adding a component to a dynamiczone is not the same logic as creating a simple field\n          // so the search is different\n\n          const dzSearch = makeNextSearch({\n            modalType: 'addComponentToDynamicZone',\n            forTarget: 'contentType',\n            targetUid: state.targetUid,\n\n            dynamicZoneTarget: modifiedData.name,\n            settingType: 'base',\n            step: '1',\n            actionType: 'create',\n            ...headersObject,\n            header_label_2: modifiedData.name,\n            header_icon_name_2: null,\n            header_icon_isCustom_2: false,\n          });\n          const nextSearch = isDynamicZoneAttribute\n            ? dzSearch\n            : makeNextSearch(\n                {\n                  modalType: 'chooseAttribute',\n                  forTarget: state.forTarget,\n                  targetUid,\n                  ...headersObject,\n                  header_icon_isCustom_1: !['contentType', 'component'].includes(state.forTarget),\n                  header_icon_name_1: headerIcon,\n                },\n                shouldContinue\n              );\n\n          // The user is creating a DZ (he had entered the name of the dz)\n          if (isDynamicZoneAttribute) {\n            // Step 1 of adding a component to a DZ, the user has the option to create a component\n            dispatch({\n              type: 'RESET_PROPS_AND_SET_THE_FORM_FOR_ADDING_A_COMPO_TO_A_DZ',\n            });\n\n            push({ search: isCreating ? nextSearch : '' });\n\n            return;\n          }\n\n          push({ search: nextSearch });\n\n          return;\n\n          // Adding an existing component\n        }\n        // eslint-disable-next-line no-lonely-if\n        if (isInFirstComponentStep) {\n          // Navigate the user to step 2\n          const nextSearchObj = {\n            modalType: 'attribute',\n            actionType: state.actionType,\n            settingType: 'base',\n            forTarget: state.forTarget,\n            targetUid: state.targetUid,\n            attributeType: 'component',\n            step: '2',\n            ...headersObject,\n            header_icon_isCustom_1: !['contentType', 'component'].includes(state.forTarget),\n            header_icon_name_1: headerIcon,\n          };\n\n          push({\n            search: makeNextSearch(nextSearchObj, shouldContinue),\n          });\n\n          // Clear the reducer and prepare the modified data\n          // This way we don't have to add some logic to re-run the useEffect\n          // The first step is either needed to create a component or just to navigate\n          // To the modal for adding a \"common field\"\n          dispatch({\n            type: 'RESET_PROPS_AND_SET_FORM_FOR_ADDING_AN_EXISTING_COMPO',\n          });\n\n          // We don't want all the props to be reset\n          return;\n\n          // Here we are in step 2\n          // The step 2 is also use to edit an attribute that is a component\n        }\n        addAttribute(\n          modifiedData,\n          state.forTarget,\n          state.targetUid,\n          // This change the dispatched type\n          // either 'EDIT_ATTRIBUTE' or 'ADD_ATTRIBUTE' in the DataManagerProvider\n          state.actionType === 'edit',\n          // This is for the edit part\n          initialData,\n          // Passing true will add the component to the components object\n          // This way we can add fields to the added component (if it wasn't there already)\n          true\n        );\n        const nextSearch = {\n          modalType: 'chooseAttribute',\n          forTarget: state.forTarget,\n          targetUid: state.targetUid,\n          ...headersObject,\n          header_icon_isCustom_1: !['contentType', 'component'].includes(state.forTarget),\n          header_icon_name_1: headerIcon,\n        };\n\n        push({ search: makeSearch(nextSearch, shouldContinue) });\n\n        // We don't need to end the loop here we want the reducer to be reinitialised\n\n        // Logic for creating a component without clicking on the link in\n        // the left menu\n        // We need to separate the logic otherwise the component would be created\n        // even though the user didn't set any field\n        // We need to prevent the component from being created if the user closes the modal at step 2 without any submission\n      } else if (isCreatingAttribute && isCreatingComponentFromAView) {\n        // Step 1\n        if (isInFirstComponentStep) {\n          // Here the search could be refactored since it is the same as the case from above\n          // Navigate the user to step 2\n\n          let searchObj = {\n            modalType: 'attribute',\n            actionType: state.actionType,\n            settingType: 'base',\n            forTarget: state.forTarget,\n            targetUid: state.targetUid,\n            attributeType: 'component',\n            step: '2',\n            ...headersObject,\n            header_icon_isCustom_1: false,\n            header_icon_name_1: 'component',\n          };\n\n          emitEvent('willCreateComponentFromAttributesModal');\n\n          push({\n            search: makeNextSearch(searchObj, shouldContinue),\n          });\n\n          // Here we clear the reducer state but we also keep the created component\n          // If we were to create the component before\n          dispatch({\n            type: 'RESET_PROPS_AND_SAVE_CURRENT_DATA',\n          });\n\n          // Terminate because we don't want the reducer to be entirely reset\n          return;\n\n          // Step 2 of creating a component (which is setting the attribute name in the parent's schema)\n        }\n        // We are destructuring because the modifiedData object doesn't have the appropriate format to create a field\n        const { category, type, ...rest } = componentToCreate;\n        // Create a the component temp UID\n        // This could be refactored but I think it's more understandable to separate the logic\n        const componentUid = createComponentUid(componentToCreate.name, category);\n        // Create the component first and add it to the components data\n        createSchema(\n          // Component data\n          rest,\n          // Type will always be component\n          // It will dispatch the CREATE_COMPONENT_SCHEMA action\n          // So the component will be added in the main components object\n          // This might not be needed if we don't allow navigation between entries while editing\n          type,\n          componentUid,\n          category,\n          // This will add the created component in the datamanager modifiedData components key\n          // Like explained above we will be able to modify the created component structure\n          isCreatingComponentFromAView\n        );\n        // Add the field to the schema\n        addAttribute(modifiedData, state.forTarget, state.targetUid, false);\n\n        dispatch({ type: 'RESET_PROPS' });\n\n        // Open modal attribute for adding attr to component\n\n        const searchToOpenModalAttributeToAddAttributesToAComponent = {\n          modalType: 'chooseAttribute',\n          forTarget: 'components',\n          targetUid: componentUid,\n          ...headersObject,\n          header_icon_isCustom_1: true,\n          header_icon_name_1: componentToCreate.icon,\n          [`header_label_${nextHeaderIndex}`]: modifiedData.name,\n          [`header_icon_name_${nextHeaderIndex}`]: 'component',\n          [`header_icon_isCustom_${nextHeaderIndex}`]: false,\n          [`header_info_category_${nextHeaderIndex}`]: category,\n          [`header_info_name_${nextHeaderIndex}`]: componentToCreate.name,\n        };\n\n        push({\n          search: makeNextSearch(\n            searchToOpenModalAttributeToAddAttributesToAComponent,\n            shouldContinue\n          ),\n        });\n\n        return;\n\n        // The modal is addComponentToDynamicZone\n      } else {\n        // The modal is addComponentToDynamicZone\n        if (isInFirstComponentStep) {\n          if (isCreatingComponentFromAView) {\n            const { category, type, ...rest } = modifiedData.componentToCreate;\n            const componentUid = createComponentUid(modifiedData.componentToCreate.name, category);\n            // Create the component first and add it to the components data\n            createSchema(\n              // Component data\n              rest,\n              // Type will always be component\n              // It will dispatch the CREATE_COMPONENT_SCHEMA action\n              // So the component will be added in the main components object\n              // This might not be needed if we don't allow navigation between entries while editing\n              type,\n              componentUid,\n              category,\n              // This will add the created component in the datamanager modifiedData components key\n              // Like explained above we will be able to modify the created component structure\n              isCreatingComponentFromAView\n            );\n            // Add the created component to the DZ\n            // We don't want to remove the old ones\n            addCreatedComponentToDynamicZone(state.dynamicZoneTarget, [componentUid]);\n\n            // The Dynamic Zone and the component is created created\n            // Open the modal to add fields to the created component\n\n            const searchToOpenAddField = {\n              modalType: 'chooseAttribute',\n              forTarget: 'components',\n              targetUid: componentUid,\n              ...headersObject,\n              header_icon_isCustom_1: true,\n              header_icon_name_1: modifiedData.componentToCreate.icon,\n              [`header_label_${nextHeaderIndex}`]: modifiedData.name,\n              [`header_icon_name_${nextHeaderIndex}`]: 'component',\n              [`header_icon_isCustom_${nextHeaderIndex}`]: false,\n              [`header_info_category_${nextHeaderIndex}`]: category,\n              [`header_info_name_${nextHeaderIndex}`]: modifiedData.componentToCreate.name,\n            };\n\n            push({ search: makeSearch(searchToOpenAddField, true) });\n          } else {\n            // Add the components to the DZ\n            changeDynamicZoneComponents(state.dynamicZoneTarget, modifiedData.components);\n\n            // TODO nav\n            // Search to open modal add fields for the main type (content type)\n            push({ search: '' });\n          }\n        } else {\n          console.error('This case is not handled');\n        }\n\n        return;\n      }\n\n      dispatch({\n        type: 'RESET_PROPS',\n      });\n    } catch (err) {\n      const errors = getYupInnerErrors(err);\n\n      dispatch({\n        type: 'SET_ERRORS',\n        errors,\n      });\n    }\n  };\n  const handleToggle = () => {\n    push({ search: '' });\n  };\n\n  const onClosed = () => {\n    setState(INITIAL_STATE_DATA);\n    dispatch({\n      type: 'RESET_PROPS',\n    });\n  };\n  const onOpened = () => {\n    if (state.modalType === 'chooseAttribute') {\n      attributeOptionRef.current.focus();\n    }\n  };\n\n  const sendAdvancedTabEvent = tab => {\n    if (tab !== 'advanced') {\n      return;\n    }\n\n    if (isCreatingContentType) {\n      emitEvent('didSelectContentTypeSettings');\n\n      return;\n    }\n\n    if (state.forTarget === 'contentType') {\n      emitEvent('didSelectContentTypeFieldSettings');\n    }\n  };\n\n  const sendButtonAddMoreFieldEvent = shouldContinue => {\n    if (\n      state.modalType === 'attribute' &&\n      state.forTarget === 'contentType' &&\n      state.attributeType !== 'dynamiczone' &&\n      shouldContinue\n    ) {\n      emitEvent('willAddMoreFieldToContentType');\n    }\n  };\n\n  const shouldDisableAdvancedTab = () => {\n    return (\n      ((state.attributeType === 'component' || state.modalType === 'addComponentToDynamicZone') &&\n        get(modifiedData, ['createComponent'], null) === false) ||\n      state.modalType === 'editCategory'\n    );\n  };\n\n  // Display data for the attributes picker modal\n  const displayedAttributes = getAttributes(\n    state.forTarget,\n    state.targetUid,\n    // We need the nested components so we know when to remove the component option\n    nestedComponents\n  );\n\n  // Styles\n  const modalBodyStyle = isPickingAttribute ? { paddingTop: '0.5rem', paddingBottom: '3rem' } : {};\n\n  return (\n    <>\n      <Modal\n        isOpen={isOpen}\n        onOpened={onOpened}\n        onClosed={onClosed}\n        onToggle={handleToggle}\n        withoverflow={toString(\n          state.modalType === 'addComponentToDynamicZone' ||\n            (state.modalType === 'attribute' && state.attributeType === 'media')\n        )}\n      >\n        <HeaderModal>\n          <ModalHeader headerId={state.headerId} headers={headers} />\n          <section>\n            <HeaderModalTitle>\n              <FormattedMessage\n                id={getModalTitleSubHeader(state)}\n                values={{\n                  type: upperFirst(\n                    formatMessage({\n                      id: getTrad(`attribute.${state.attributeType}`),\n                    })\n                  ),\n                  name: upperFirst(state.attributeName),\n                  step: state.step,\n                }}\n              >\n                {msg => <span>{upperFirst(msg)}</span>}\n              </FormattedMessage>\n\n              {!isPickingAttribute && (\n                <>\n                  <div className=\"settings-tabs\">\n                    <HeaderModalNavContainer>\n                      {NAVLINKS.map((link, index) => {\n                        return (\n                          <HeaderNavLink\n                            // The advanced tab is disabled when adding an existing component\n                            // step 1\n                            isDisabled={index === 1 && shouldDisableAdvancedTab()}\n                            isActive={state.settingType === link.id}\n                            key={link.id}\n                            {...link}\n                            onClick={() => {\n                              setState(prev => ({\n                                ...prev,\n                                settingType: link.id,\n                              }));\n                              sendAdvancedTabEvent(link.id);\n                              push({ search: getNextSearch(link.id, state) });\n                            }}\n                            nextTab={index === NAVLINKS.length - 1 ? 0 : index + 1}\n                          />\n                        );\n                      })}\n                    </HeaderModalNavContainer>\n                  </div>\n                  <hr />\n                </>\n              )}\n            </HeaderModalTitle>\n          </section>\n        </HeaderModal>\n        <form onSubmit={handleSubmit}>\n          <ModalForm>\n            <ModalBody style={modalBodyStyle}>\n              <div className=\"container-fluid\">\n                {isPickingAttribute\n                  ? displayedAttributes.map((row, i) => {\n                      return (\n                        <div key={i} className=\"row\">\n                          {i === 1 && (\n                            <hr\n                              style={{\n                                width: 'calc(100% - 30px)',\n                                marginBottom: 16,\n                                marginTop: 19,\n                                borderColor: '#F0F3F8',\n                              }}\n                            />\n                          )}\n                          {row.map((attr, index) => {\n                            const tabIndex =\n                              i === 0 ? index : displayedAttributes[0].length + index;\n\n                            return (\n                              <AttributeOption\n                                key={attr}\n                                tabIndex={tabIndex}\n                                isDisplayed\n                                onClick={() => {}}\n                                ref={i === 0 && index === 0 ? attributeOptionRef : null}\n                                type={attr}\n                              />\n                            );\n                          })}\n                        </div>\n                      );\n                    })\n                  : form(\n                      modifiedData,\n                      state.attributeType,\n                      state.step,\n                      state.actionType,\n                      attributes\n                    ).items.map((row, index) => {\n                      return (\n                        <div className=\"row\" key={index}>\n                          {row.map((input, i) => {\n                            // The divider type is used mainly the advanced tab\n                            // It is the one responsible for displaying the settings label\n                            if (input.type === 'divider' || input.type === 'dividerDraftPublish') {\n                              const tradId =\n                                input.type === 'divider'\n                                  ? 'form.attribute.item.settings.name'\n                                  : 'form.contentType.divider.draft-publish';\n\n                              return (\n                                <div className=\"col-12\" key=\"divider\">\n                                  <Padded bottom size=\"smd\">\n                                    <div style={{ paddingTop: 3 }} />\n                                    <Text\n                                      fontSize=\"xs\"\n                                      color=\"grey\"\n                                      fontWeight=\"bold\"\n                                      textTransform=\"uppercase\"\n                                    >\n                                      <FormattedMessage id={getTrad(tradId)}>\n                                        {txt => txt}\n                                      </FormattedMessage>\n                                    </Text>\n                                  </Padded>\n                                </div>\n                              );\n                            }\n\n                            // The spacer type is used mainly to align the icon picker...\n                            if (input.type === 'spacer') {\n                              return <div key=\"spacer\" style={{ height: 8 }} />;\n                            }\n\n                            // The spacer type is used mainly to align the icon picker...\n                            if (input.type === 'spacer-small') {\n                              return <div key={`${index}.${i}`} style={{ height: 4 }} />;\n                            }\n\n                            if (input.type === 'spacer-medium') {\n                              return <div key={`${index}.${i}`} style={{ height: 8 }} />;\n                            }\n\n                            // This type is used in the addComponentToDynamicZone modal when selecting the option add an existing component\n                            // It pushes select the components to the right\n                            if (input.type === 'pushRight') {\n                              return <div key={`${index}.${i}`} className={`col-${input.size}`} />;\n                            }\n\n                            if (input.type === 'relation') {\n                              return (\n                                <RelationForm\n                                  key=\"relation\"\n                                  mainBoxHeader={get(headers, [0, 'label'], '')}\n                                  modifiedData={modifiedData}\n                                  naturePickerType={state.forTarget}\n                                  onChange={handleChange}\n                                  errors={formErrors}\n                                />\n                              );\n                            }\n\n                            // Retrieve the error for a specific input\n                            const errorId = get(\n                              formErrors,\n                              [\n                                ...input.name\n                                  .split('.')\n                                  // The filter here is used when creating a component\n                                  // in the component step 1 modal\n                                  // Since the component info is stored in the\n                                  // componentToCreate object we can access the error\n                                  // By removing the key\n                                  .filter(key => key !== 'componentToCreate'),\n                                'id',\n                              ],\n                              null\n                            );\n\n                            const retrievedValue = get(modifiedData, input.name, '');\n\n                            let value;\n\n                            // Condition for the boolean default value\n                            // The radio input doesn't accept false, true or null as value\n                            // So we pass them as string\n                            // This way the data stays accurate and we don't have to operate\n                            // any data mutation\n                            if (input.name === 'default' && state.attributeType === 'boolean') {\n                              value = toString(retrievedValue);\n                              // Same here for the enum\n                            } else if (input.name === 'enum' && Array.isArray(retrievedValue)) {\n                              value = retrievedValue.join('\\n');\n                            } else if (input.name === 'uid') {\n                              value = input.value;\n                            } else if (input.name === 'allowedTypes' && retrievedValue === '') {\n                              value = null;\n                            } else {\n                              value = retrievedValue;\n                            }\n\n                            // The addon input is not present in @buffetjs so we are using the old lib\n                            // for the moment that's why we don't want them be passed to buffet\n                            // like the other created inputs\n                            if (input.type === 'addon') {\n                              return (\n                                <InputsIndex\n                                  key={input.name}\n                                  {...input}\n                                  type=\"string\"\n                                  onChange={handleChange}\n                                  value={value}\n                                />\n                              );\n                            }\n\n                            return (\n                              <div className={`col-${input.size || 6}`} key={input.name}>\n                                <Inputs\n                                  {...input}\n                                  modifiedData={modifiedData}\n                                  addComponentsToDynamicZone={handleClickAddComponentsToDynamicZone}\n                                  changeMediaAllowedTypes={handleChangeMediaAllowedTypes}\n                                  customInputs={{\n                                    allowedTypesSelect: WrapperSelect,\n                                    componentIconPicker: ComponentIconPicker,\n                                    componentSelect: WrapperSelect,\n                                    creatableSelect: WrapperSelect,\n                                    customCheckboxWithChildren: CustomCheckbox,\n                                    booleanBox: BooleanBox,\n                                  }}\n                                  isCreating={isCreating}\n                                  // Props for the componentSelect\n                                  isCreatingComponentWhileAddingAField={\n                                    isCreatingComponentWhileAddingAField\n                                  }\n                                  // Props for the componentSelect\n                                  // Since the component is created after adding it to a type\n                                  // its name and category can't be retrieved from the data manager\n                                  componentCategoryNeededForAddingAfieldWhileCreatingAComponent={get(\n                                    componentToCreate,\n                                    'category',\n                                    null\n                                  )}\n                                  // Props for the componentSelect same explanation\n                                  componentNameNeededForAddingAfieldWhileCreatingAComponent={get(\n                                    componentToCreate,\n                                    'name',\n                                    null\n                                  )}\n                                  isAddingAComponentToAnotherComponent={\n                                    state.forTarget === 'components' ||\n                                    state.forTarget === 'component'\n                                  }\n                                  value={value}\n                                  error={isEmpty(errorId) ? null : formatMessage({ id: errorId })}\n                                  onChange={handleChange}\n                                  onBlur={() => {}}\n                                  description={\n                                    get(input, 'description.id', null)\n                                      ? formatMessage(input.description)\n                                      : input.description\n                                  }\n                                  placeholder={\n                                    get(input, 'placeholder.id', null)\n                                      ? formatMessage(input.placeholder)\n                                      : input.placeholder\n                                  }\n                                  label={\n                                    get(input, 'label.id', null)\n                                      ? formatMessage(input.label)\n                                      : input.label\n                                  }\n                                />\n                              </div>\n                            );\n                          })}\n                        </div>\n                      );\n                    })}\n              </div>\n            </ModalBody>\n          </ModalForm>\n          {!isPickingAttribute && (\n            <ModalFooter>\n              <section style={{ alignItems: 'center' }}>\n                <Button type=\"button\" color=\"cancel\" onClick={handleToggle}>\n                  {formatMessage({\n                    id: 'app.components.Button.cancel',\n                  })}\n                </Button>\n                <div>\n                  {isCreatingAttribute && !isInFirstComponentStep && (\n                    <Button\n                      type={isCreating ? 'button' : 'submit'}\n                      color=\"success\"\n                      onClick={e => {\n                        handleSubmit(e, false);\n                      }}\n                      style={{ marginRight: '10px' }}\n                    >\n                      {formatMessage({ id: 'form.button.finish' })}\n                    </Button>\n                  )}\n                  {(isCreatingContentType || isCreatingComponent) && !isCreating && (\n                    <Button\n                      type=\"button\"\n                      color=\"delete\"\n                      onClick={e => {\n                        e.preventDefault();\n                        deleteData();\n                      }}\n                      style={{ marginRight: '10px' }}\n                    >\n                      {formatMessage({ id: getTrad('form.button.delete') })}\n                    </Button>\n                  )}\n                  {isEditingCategory && (\n                    <Button\n                      type=\"button\"\n                      color=\"delete\"\n                      onClick={e => {\n                        e.preventDefault();\n\n                        deleteCategory(initialData.name);\n                      }}\n                      style={{ marginRight: '10px' }}\n                    >\n                      {formatMessage({ id: getTrad('form.button.delete') })}\n                    </Button>\n                  )}\n                  {isCreating && state.attributeType === 'dynamiczone' && (\n                    <CustomButton\n                      type={isCreating ? 'submit' : 'button'}\n                      color={\n                        (isCreatingContentType ||\n                          isCreatingComponent ||\n                          isEditingCategory ||\n                          (state.modalType === 'addComponentToDynamicZone' &&\n                            state.step === '1' &&\n                            !isCreatingComponentFromAView)) &&\n                        !isCreating\n                          ? 'success'\n                          : 'primary'\n                      }\n                      onClick={e => handleSubmit(e, true)}\n                      icon={\n                        (isCreatingAttribute &&\n                          !isCreatingComponentFromAView &&\n                          state.step !== '1') ||\n                        (state.modalType === 'addComponentToDynamicZone' &&\n                          isCreatingComponentFromAView) ||\n                        (isCreatingComponentFromAView && state.step === '2')\n                      }\n                    >\n                      {getButtonSubmitMessage()}\n                    </CustomButton>\n                  )}\n                  {state.attributeType !== 'dynamiczone' && (\n                    <CustomButton\n                      type={isCreating ? 'submit' : 'button'}\n                      color={\n                        (isCreatingContentType ||\n                          isCreatingComponent ||\n                          isEditingCategory ||\n                          (state.modalType === 'addComponentToDynamicZone' &&\n                            state.step === '1' &&\n                            !isCreatingComponentFromAView)) &&\n                        !isCreating\n                          ? 'success'\n                          : 'primary'\n                      }\n                      onClick={e => handleSubmit(e, true)}\n                      icon={\n                        (isCreatingAttribute &&\n                          !isCreatingComponentFromAView &&\n                          state.step !== '1') ||\n                        (state.modalType === 'addComponentToDynamicZone' &&\n                          isCreatingComponentFromAView) ||\n                        (isCreatingComponentFromAView && state.step === '2')\n                      }\n                    >\n                      {getButtonSubmitMessage()}\n                    </CustomButton>\n                  )}\n                </div>\n              </section>\n            </ModalFooter>\n          )}\n        </form>\n      </Modal>\n      {/* CONFIRM MODAL FOR DRAFT AND PUBLISH */}\n      <PopUpWarning\n        isOpen={showConfirmModal}\n        onConfirm={handleConfirmDisableDraftAndPublish}\n        toggleModal={toggleConfirmModal}\n        popUpWarningType=\"danger\"\n        content={{\n          message: getTrad('popUpWarning.draft-publish.message'),\n          secondMessage: getTrad('popUpWarning.draft-publish.second-message'),\n          confirm: getTrad('popUpWarning.draft-publish.button.confirm'),\n        }}\n      />\n    </>\n  );\n};\n\nexport default FormModal;\n",
    "packages/strapi-plugin-content-type-builder/admin/src/containers/LeftMenu/index.js": "/**\n *\n * LeftMenu\n *\n */\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { sortBy, camelCase, upperFirst } from 'lodash';\nimport { useHistory } from 'react-router-dom';\nimport { LeftMenuList, useGlobalContext } from 'strapi-helper-plugin';\nimport { Text } from '@buffetjs/core';\nimport pluginId from '../../pluginId';\nimport getTrad from '../../utils/getTrad';\nimport CustomLink from '../../components/CustomLink';\nimport useDataManager from '../../hooks/useDataManager';\nimport makeSearch from '../../utils/makeSearch';\nimport Wrapper from './Wrapper';\n\n/* eslint-disable indent */\n\nconst displayNotificationCTNotSaved = () => {\n  strapi.notification.toggle({\n    type: 'info',\n    message: { id: `${pluginId}.notification.info.creating.notSaved` },\n  });\n};\n\nfunction LeftMenu({ wait }) {\n  const {\n    components,\n    componentsGroupedByCategory,\n    contentTypes,\n    isInDevelopmentMode,\n    sortedContentTypesList,\n  } = useDataManager();\n  const { emitEvent, formatMessage } = useGlobalContext();\n  const { push } = useHistory();\n  const componentsData = sortBy(\n    Object.keys(componentsGroupedByCategory).map(category => ({\n      name: category,\n      title: category,\n      isEditable: isInDevelopmentMode,\n      onClickEdit: (e, data) => {\n        e.stopPropagation();\n\n        const search = makeSearch({\n          actionType: 'edit',\n          modalType: 'editCategory',\n          categoryName: data.name,\n          header_label_1: formatMessage({\n            id: getTrad('modalForm.header.categories'),\n          }),\n          header_icon_name_1: 'component',\n          header_icon_isCustom_1: false,\n          header_info_category_1: null,\n          header_info_name_1: null,\n          header_label_2: data.name,\n          header_icon_name_2: null,\n          header_icon_isCustom_2: false,\n          header_info_category_2: null,\n          header_info_name_2: null,\n\n          settingType: 'base',\n        });\n\n        push({ search });\n      },\n      links: sortBy(\n        componentsGroupedByCategory[category].map(compo => ({\n          name: compo.uid,\n          to: `/plugins/${pluginId}/component-categories/${category}/${compo.uid}`,\n          title: compo.schema.name,\n        })),\n        obj => obj.title\n      ),\n    })),\n    obj => obj.title\n  );\n\n  const canOpenModalCreateCTorComponent = () => {\n    return (\n      !Object.keys(contentTypes).some(ct => contentTypes[ct].isTemporary === true) &&\n      !Object.keys(components).some(component => components[component].isTemporary === true)\n    );\n  };\n\n  const handleClickOpenModal = async (modalType, kind = '') => {\n    const type = kind === 'singleType' ? kind : modalType;\n\n    if (canOpenModalCreateCTorComponent()) {\n      emitEvent(`willCreate${upperFirst(camelCase(type))}`);\n\n      await wait();\n      const search = makeSearch({\n        modalType,\n        kind,\n        actionType: 'create',\n        settingType: 'base',\n        forTarget: modalType,\n        headerId: getTrad(`modalForm.${type}.header-create`),\n        header_icon_isCustom_1: 'false',\n        header_icon_name_1: type,\n        header_label_1: 'null',\n      });\n      push({\n        search,\n      });\n    } else {\n      displayNotificationCTNotSaved();\n    }\n  };\n\n  const displayedContentTypes = useMemo(() => {\n    return sortedContentTypesList\n      .filter(obj => obj.editable)\n      .map(obj => {\n        if (obj.plugin) {\n          return {\n            ...obj,\n            CustomComponent: () => (\n              <p style={{ justifyContent: 'normal' }}>\n                {obj.title}&nbsp;\n                <Text\n                  as=\"span\"\n                  ellipsis\n                  // This is needed here\n                  style={{ fontStyle: 'italic' }}\n                  fontWeight=\"inherit\"\n                  lineHeight=\"inherit\"\n                >\n                  ({formatMessage({ id: getTrad('from') })}: {obj.plugin})&nbsp;\n                </Text>\n              </p>\n            ),\n          };\n        }\n\n        return obj;\n      });\n  }, [sortedContentTypesList, formatMessage]);\n\n  const data = [\n    {\n      name: 'models',\n      title: {\n        id: `${pluginId}.menu.section.models.name.`,\n      },\n      searchable: true,\n      customLink: isInDevelopmentMode\n        ? {\n            Component: CustomLink,\n            componentProps: {\n              id: `${pluginId}.button.model.create`,\n              onClick: () => {\n                handleClickOpenModal('contentType', 'collectionType');\n              },\n            },\n          }\n        : null,\n      links: displayedContentTypes.filter(contentType => contentType.kind === 'collectionType'),\n    },\n    {\n      name: 'singleTypes',\n      title: {\n        id: `${pluginId}.menu.section.single-types.name.`,\n      },\n      searchable: true,\n      customLink: isInDevelopmentMode\n        ? {\n            Component: CustomLink,\n            componentProps: {\n              id: `${pluginId}.button.single-types.create`,\n              onClick: () => {\n                handleClickOpenModal('contentType', 'singleType');\n              },\n            },\n          }\n        : null,\n      links: displayedContentTypes.filter(singleType => singleType.kind === 'singleType'),\n    },\n    {\n      name: 'components',\n      title: {\n        id: `${pluginId}.menu.section.components.name.`,\n      },\n      searchable: true,\n      customLink: isInDevelopmentMode\n        ? {\n            Component: CustomLink,\n            componentProps: {\n              id: `${pluginId}.button.component.create`,\n              onClick: () => {\n                handleClickOpenModal('component');\n              },\n            },\n          }\n        : null,\n      links: componentsData,\n    },\n  ];\n\n  return (\n    <Wrapper className=\"col-md-3\">\n      {data.map(list => {\n        return <LeftMenuList {...list} key={list.name} />;\n      })}\n    </Wrapper>\n  );\n}\n\nLeftMenu.defaultProps = {\n  wait: () => {},\n};\n\nLeftMenu.propTypes = {\n  wait: PropTypes.func,\n};\n\nexport default LeftMenu;\n",
    "packages/strapi-plugin-content-type-builder/controllers/ComponentCategories.js": "'use strict';\n\nconst validateComponentCategory = require('./validation/component-category');\n\nmodule.exports = {\n  async editCategory(ctx) {\n    const { body } = ctx.request;\n\n    try {\n      await validateComponentCategory(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    const { name } = ctx.params;\n\n    strapi.reload.isWatching = false;\n\n    const componentCategoryService =\n      strapi.plugins['content-type-builder'].services.componentcategories;\n\n    const newName = await componentCategoryService.editCategory(name, body);\n\n    setImmediate(() => strapi.reload());\n\n    ctx.send({ name: newName });\n  },\n\n  async deleteCategory(ctx) {\n    const { name } = ctx.params;\n\n    strapi.reload.isWatching = false;\n\n    const componentCategoryService =\n      strapi.plugins['content-type-builder'].services.componentcategories;\n\n    await componentCategoryService.deleteCategory(name);\n\n    setImmediate(() => strapi.reload());\n\n    ctx.send({ name });\n  },\n};\n",
    "packages/strapi-plugin-content-type-builder/controllers/Components.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst {\n  validateComponentInput,\n  validateUpdateComponentInput,\n} = require('./validation/component');\n\n/**\n * Components controller\n */\n\nmodule.exports = {\n  /**\n   * GET /components handler\n   * Returns a list of available components\n   * @param {Object} ctx - koa context\n   */\n  async getComponents(ctx) {\n    const componentService =\n      strapi.plugins['content-type-builder'].services.components;\n\n    const data = Object.keys(strapi.components).map(uid => {\n      return componentService.formatComponent(strapi.components[uid]);\n    });\n\n    ctx.send({ data });\n  },\n\n  /**\n   * GET /components/:uid\n   * Returns a specific component\n   * @param {Object} ctx - koa context\n   */\n  async getComponent(ctx) {\n    const { uid } = ctx.params;\n\n    const component = strapi.components[uid];\n\n    if (!component) {\n      return ctx.send({ error: 'component.notFound' }, 404);\n    }\n\n    const componentService =\n      strapi.plugins['content-type-builder'].services.components;\n\n    ctx.send({ data: componentService.formatComponent(component) });\n  },\n\n  /**\n   * POST /components\n   * Creates a component and returns its infos\n   * @param {Object} ctx - koa context\n   */\n  async createComponent(ctx) {\n    const { body } = ctx.request;\n\n    try {\n      await validateComponentInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const componentService =\n        strapi.plugins['content-type-builder'].services.components;\n\n      const component = await componentService.createComponent({\n        component: body.component,\n        components: body.components,\n      });\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } }, 201);\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: error.message }, 400);\n    }\n  },\n\n  /**\n   * PUT /components/:uid\n   * Updates a component and return its infos\n   * @param {Object} ctx - koa context - enhanced koa context\n   */\n  async updateComponent(ctx) {\n    const { uid } = ctx.params;\n    const { body } = ctx.request;\n\n    if (!_.has(strapi.components, uid)) {\n      return ctx.send({ error: 'component.notFound' }, 404);\n    }\n\n    try {\n      await validateUpdateComponentInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const componentService =\n        strapi.plugins['content-type-builder'].services.components;\n\n      const component = await componentService.editComponent(uid, {\n        component: body.component,\n        components: body.components,\n      });\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } });\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: error.message }, 400);\n    }\n  },\n\n  /**\n   * DELETE /components/:uid\n   * Deletes a components and returns its old infos\n   * @param {Object} ctx - koa context\n   */\n  async deleteComponent(ctx) {\n    const { uid } = ctx.params;\n\n    if (!_.has(strapi.components, uid)) {\n      return ctx.send({ error: 'component.notFound' }, 404);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const componentService =\n        strapi.plugins['content-type-builder'].services.components;\n\n      const component = await componentService.deleteComponent(uid);\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } });\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: error.message }, 400);\n    }\n  },\n};\n",
    "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst {\n  validateContentTypeInput,\n  validateUpdateContentTypeInput,\n  validateKind,\n} = require('./validation/content-type');\n\nmodule.exports = {\n  async getContentTypes(ctx) {\n    const { kind } = ctx.query;\n\n    try {\n      await validateKind(kind);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    const contentTypeService = strapi.plugins['content-type-builder'].services.contenttypes;\n\n    const contentTypes = Object.keys(strapi.contentTypes)\n      .filter(uid => !kind || _.get(strapi.contentTypes[uid], 'kind', 'collectionType') === kind)\n      .map(uid => contentTypeService.formatContentType(strapi.contentTypes[uid]));\n\n    ctx.send({\n      data: contentTypes,\n    });\n  },\n\n  getContentType(ctx) {\n    const { uid } = ctx.params;\n\n    const contentType = strapi.contentTypes[uid];\n\n    if (!contentType) {\n      return ctx.send({ error: 'contentType.notFound' }, 404);\n    }\n\n    const contentTypeService = strapi.plugins['content-type-builder'].services.contenttypes;\n\n    ctx.send({ data: contentTypeService.formatContentType(contentType) });\n  },\n\n  async createContentType(ctx) {\n    const { body } = ctx.request;\n\n    try {\n      await validateContentTypeInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const contentTypeService = strapi.plugins['content-type-builder'].services.contenttypes;\n\n      const contentType = await contentTypeService.createContentType({\n        contentType: body.contentType,\n        components: body.components,\n      });\n\n      if (_.isEmpty(strapi.api)) {\n        await strapi.telemetry.send('didCreateFirstContentType', { kind: contentType.kind });\n      } else {\n        await strapi.telemetry.send('didCreateContentType', { kind: contentType.kind });\n      }\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: contentType.uid } }, 201);\n    } catch (error) {\n      strapi.log.error(error);\n      await strapi.telemetry.send('didNotCreateContentType', { error: error.message });\n      ctx.send({ error: error.message }, 400);\n    }\n  },\n\n  async updateContentType(ctx) {\n    const { uid } = ctx.params;\n    const { body } = ctx.request;\n\n    if (!_.has(strapi.contentTypes, uid)) {\n      return ctx.send({ error: 'contentType.notFound' }, 404);\n    }\n\n    try {\n      await validateUpdateContentTypeInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const contentTypeService = strapi.plugins['content-type-builder'].services.contenttypes;\n\n      const component = await contentTypeService.editContentType(uid, {\n        contentType: body.contentType,\n        components: body.components,\n      });\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } }, 201);\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: error.message }, 400);\n    }\n  },\n\n  async deleteContentType(ctx) {\n    const { uid } = ctx.params;\n\n    if (!_.has(strapi.contentTypes, uid)) {\n      return ctx.send({ error: 'contentType.notFound' }, 404);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const contentTypeService = strapi.plugins['content-type-builder'].services.contenttypes;\n\n      const component = await contentTypeService.deleteContentType(uid);\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } });\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: error.message }, 400);\n    }\n  },\n};\n",
    "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js": "'use strict';\n\nconst {\n  validateKind,\n  validateUpdateContentTypeInput,\n  validateContentTypeInput,\n} = require('../content-type');\n\ndescribe('Content type validator', () => {\n  global.strapi = {\n    contentTypes: {},\n    plugins: {\n      'content-type-builder': {\n        services: {\n          builder: {\n            getReservedNames() {\n              return {\n                models: [],\n                attributes: ['thisIsReserved'],\n              };\n            },\n          },\n        },\n      },\n    },\n  };\n\n  describe('validateKind', () => {\n    it('Only allows for single and collection types', async () => {\n      await expect(validateKind('wrong')).rejects.toBeDefined();\n    });\n\n    it('allows singleType and collectionType', async () => {\n      await expect(validateKind('singleType')).resolves.toBe('singleType');\n      await expect(validateKind('collectionType')).resolves.toBe('collectionType');\n    });\n\n    it('allows undefined', async () => {\n      await expect(validateKind()).resolves.toBeUndefined();\n    });\n  });\n\n  describe('Prevents use of reservedNames', () => {\n    test('Throws when reserved names are used', async () => {\n      const data = {\n        contentType: {\n          name: 'test',\n          attributes: {\n            thisIsReserved: {\n              type: 'string',\n              default: '',\n            },\n          },\n        },\n      };\n\n      await validateUpdateContentTypeInput(data).catch(err => {\n        expect(err).toMatchObject({\n          'contentType.attributes.thisIsReserved': [\n            expect.stringMatching('Attribute keys cannot be one of'),\n          ],\n        });\n      });\n    });\n  });\n\n  describe('Prevents use of names without plural form', () => {\n    test('Throws when using name without plural form', async () => {\n      const data = {\n        contentType: {\n          name: 'news',\n          attributes: {\n            title: {\n              type: 'string',\n            },\n          },\n        },\n      };\n\n      await validateContentTypeInput(data).catch(err => {\n        expect(err).toMatchObject({\n          'contentType.name': [expect.stringMatching('cannot be pluralized')],\n        });\n      });\n    });\n  });\n\n  describe('validateUpdateContentTypeInput', () => {\n    test('Deletes empty defaults', async () => {\n      const data = {\n        contentType: {\n          name: 'test',\n          attributes: {\n            slug: {\n              type: 'string',\n              default: '',\n            },\n          },\n        },\n        components: [\n          {\n            uid: 'edit',\n            icon: 'star',\n            name: 'test',\n            category: 'test',\n            attributes: {\n              title: {\n                type: 'string',\n                default: '',\n              },\n            },\n          },\n          {\n            tmpUID: 'random',\n            icon: 'star',\n            name: 'test2',\n            category: 'test',\n            attributes: {\n              title: {\n                type: 'string',\n                default: '',\n              },\n            },\n          },\n        ],\n      };\n\n      await validateUpdateContentTypeInput(data).then(() => {\n        expect(data.contentType.attributes.slug.default).toBeUndefined();\n        expect(data.components[0].attributes.title.default).toBeUndefined();\n        expect(data.components[1].attributes.title.default).toBe('');\n      });\n    });\n\n    test('Deleted UID target fields are removed from input data', async () => {\n      const data = {\n        contentType: {\n          name: 'test',\n          attributes: {\n            slug: {\n              type: 'uid',\n              targetField: 'deletedField',\n            },\n          },\n        },\n      };\n\n      expect.assertions(1);\n\n      await validateUpdateContentTypeInput(data).then(() => {\n        expect(data.contentType.attributes.slug.targetField).toBeUndefined();\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-type-builder/services/ComponentCategories.js": "'use strict';\n\nconst { join } = require('path');\n\nconst { nameToSlug } = require('strapi-utils');\nconst createBuilder = require('./schema-builder');\n\n/**\n * Edit a category name and move components to the write folder\n * @param {string} name category name\n * @param {Object} infos new category data\n */\nconst editCategory = async (name, infos) => {\n  const componentsDir = join(strapi.dir, 'components');\n  const newName = nameToSlug(infos.name);\n\n  // don't do anything the name doesn't change\n  if (name === newName) return;\n\n  if (!categoryExists(name)) {\n    throw strapi.errors.notFound('cateogry.notFound');\n  }\n\n  if (categoryExists(newName)) {\n    throw strapi.errors.badRequest('Name already taken');\n  }\n\n  const builder = createBuilder();\n\n  builder.components.forEach(component => {\n    const oldUID = component.uid;\n    const newUID = `${newName}.${component.modelName}`;\n\n    // only edit the components in this specific category\n    if (component.category !== name) return;\n\n    component.setUID(newUID).setDir(join(componentsDir, newName));\n\n    builder.components.forEach(compo => {\n      compo.updateComponent(oldUID, newUID);\n    });\n\n    builder.contentTypes.forEach(ct => {\n      ct.updateComponent(oldUID, newUID);\n    });\n  });\n\n  await builder.writeFiles();\n\n  return newName;\n};\n\n/**\n * Deletes a category and its components\n * @param {string} name category name to delete\n */\nconst deleteCategory = async name => {\n  if (!categoryExists(name)) {\n    throw strapi.errors.notFound('cateogry.notFound');\n  }\n\n  const builder = createBuilder();\n\n  builder.components.forEach(component => {\n    if (component.category === name) {\n      builder.deleteComponent(component.uid);\n    }\n  });\n\n  await builder.writeFiles();\n};\n\n/**\n * Checks if a category exists\n * @param {string} name category name to serach for\n */\nconst categoryExists = name => {\n  const matchingIndex = Object.values(strapi.components).findIndex(\n    component => component.category === name\n  );\n\n  return matchingIndex > -1;\n};\n\nmodule.exports = {\n  editCategory,\n  deleteCategory,\n};\n",
    "packages/strapi-plugin-content-type-builder/services/Components.js": "'use strict';\n\nconst _ = require('lodash');\nconst pluralize = require('pluralize');\n\nconst { formatAttributes, replaceTemporaryUIDs } = require('../utils/attributes');\nconst createBuilder = require('./schema-builder');\n\n/**\n * Formats a component attributes\n * @param {string} uid - string\n * @param {Object} component - strapi component model\n */\nconst formatComponent = component => {\n  const { uid, modelName, connection, collectionName, info, category } = component;\n\n  return {\n    uid,\n    category,\n    apiId: modelName,\n    schema: {\n      icon: _.get(info, 'icon'),\n      name: _.get(info, 'name') || _.upperFirst(pluralize(uid)),\n      description: _.get(info, 'description', ''),\n      connection,\n      collectionName,\n      attributes: formatAttributes(component),\n    },\n  };\n};\n\n/**\n * Creates a component and handle the nested components sent with it\n * @param {Object} params params object\n * @param {Object} params.component Main component to create\n * @param {Array<Object>} params.components List of nested components to created or edit\n */\nconst createComponent = async ({ component, components = [] }) => {\n  const builder = createBuilder();\n\n  const uidMap = builder.createNewComponentUIDMap(components);\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const newComponent = builder.createComponent(replaceTmpUIDs(component));\n\n  components.forEach(component => {\n    if (!_.has(component, 'uid')) {\n      return builder.createComponent(replaceTmpUIDs(component));\n    }\n\n    return builder.editComponent(replaceTmpUIDs(component));\n  });\n\n  await builder.writeFiles();\n  return newComponent;\n};\n\n/**\n * Edits a component and handle the nested components sent with it\n * @param {Object} params params object\n * @param {Object} params.component Main component to create\n * @param {Array<Object>} params.components List of nested components to created or edit\n */\nconst editComponent = async (uid, { component, components = [] }) => {\n  const builder = createBuilder();\n\n  const uidMap = builder.createNewComponentUIDMap(components);\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const updatedComponent = builder.editComponent({\n    uid,\n    ...replaceTmpUIDs(component),\n  });\n\n  components.forEach(component => {\n    if (!_.has(component, 'uid')) {\n      return builder.createComponent(replaceTmpUIDs(component));\n    }\n\n    return builder.editComponent(replaceTmpUIDs(component));\n  });\n\n  await builder.writeFiles();\n  return updatedComponent;\n};\n\nconst deleteComponent = async uid => {\n  const builder = createBuilder();\n\n  const deletedComponent = builder.deleteComponent(uid);\n\n  await builder.writeFiles();\n  return deletedComponent;\n};\n\nmodule.exports = {\n  createComponent,\n  editComponent,\n  deleteComponent,\n\n  formatComponent,\n};\n",
    "packages/strapi-plugin-content-type-builder/services/api-handler.js": "'use strict';\n\nconst path = require('path');\nconst fse = require('fs-extra');\nconst _ = require('lodash');\n\n/**\n * Deletes the API folder of a contentType\n * @param {string} uid content type uid\n */\nasync function clear(uid) {\n  const { apiName, __filename__ } = strapi.contentTypes[uid];\n\n  const apiFolder = path.join(strapi.dir, 'api', apiName);\n\n  // base name of the model file that will be use as comparator\n  const baseName = path.basename(__filename__, '.settings.json');\n\n  await recursiveRemoveFiles(apiFolder, createDeleteApiFunction(baseName));\n  await deleteBackup(uid);\n}\n\n/**\n * Backups the API folder of a contentType\n * @param {string} uid content type uid\n */\nasync function backup(uid) {\n  const { apiName } = strapi.contentTypes[uid];\n\n  const apiFolder = path.join(strapi.dir, 'api', apiName);\n  const backupFolder = path.join(strapi.dir, 'api', '.backup', apiName);\n\n  // backup the api folder\n  await fse.copy(apiFolder, backupFolder);\n}\n\n/**\n * Deletes an API backup folder\n * @param {string} uid content type uid\n */\nasync function deleteBackup(uid) {\n  const { apiName } = strapi.contentTypes[uid];\n\n  const backupFolder = path.join(strapi.dir, 'api', '.backup');\n  const apiBackupFolder = path.join(strapi.dir, 'api', '.backup', apiName);\n\n  await fse.remove(apiBackupFolder);\n\n  const list = await fse.readdir(backupFolder);\n  if (list.length === 0) {\n    await fse.remove(backupFolder);\n  }\n}\n\n/**\n * Rollbacks the API folder of a contentType\n * @param {string} uid content type uid\n */\nasync function rollback(uid) {\n  const { apiName } = strapi.contentTypes[uid];\n\n  const apiFolder = path.join(strapi.dir, 'api', apiName);\n  const backupFolder = path.join(strapi.dir, 'api', '.backup', apiName);\n\n  const exists = await fse.exists(backupFolder);\n\n  if (!exists) {\n    throw new Error('Cannot rollback api that was not backed up');\n  }\n\n  await fse.remove(apiFolder);\n  await fse.copy(backupFolder, apiFolder);\n  await deleteBackup(uid);\n}\n\n/**\n * Creates a delete function to clear an api folder\n * @param {string} baseName\n */\nconst createDeleteApiFunction = baseName => {\n  const startWithBaseName = startWithName(baseName + '.');\n\n  /**\n   * Delets a file in an api.\n   * Will only update routes.json instead of deleting it if other routes are present\n   * @param {string} filePath file path to delete\n   */\n  return async filePath => {\n    const fileName = path.basename(filePath);\n\n    if (startWithBaseName(fileName)) return fse.remove(filePath);\n\n    if (fileName === 'routes.json') {\n      const { routes } = await fse.readJSON(filePath);\n\n      const routesToKeep = routes.filter(route => !startWithBaseName(route.handler));\n\n      if (routesToKeep.length === 0) {\n        return fse.remove(filePath);\n      }\n\n      await fse.writeJSON(\n        filePath,\n        {\n          routes: routesToKeep,\n        },\n        {\n          spaces: 2,\n        }\n      );\n    }\n  };\n};\n\n/**\n * Returns a function that checks if the passed string starts with the name\n * @param {string} prefix\n * @returns {Function} a comparing function\n */\nconst startWithName = prefix => {\n  /**\n   * Checks if str starts with prefix case insensitive\n   * @param {string} str string to compare\n   */\n  return str => _.startsWith(_.toLower(str), _.toLower(prefix));\n};\n\n/**\n * Deletes a folder recursively using a delete function\n * @param {string} folder folder to delete\n * @param {Function} deleteFn function to call with the file path to delete\n */\nconst recursiveRemoveFiles = async (folder, deleteFn) => {\n  const filesName = await fse.readdir(folder);\n\n  for (const fileName of filesName) {\n    const filePath = path.join(folder, fileName);\n\n    const stat = await fse.stat(filePath);\n\n    if (stat.isDirectory()) {\n      await recursiveRemoveFiles(filePath, deleteFn);\n    } else {\n      await deleteFn(filePath);\n    }\n  }\n\n  const files = await fse.readdir(folder);\n  if (files.length === 0) {\n    await fse.remove(folder);\n  }\n};\n\nmodule.exports = {\n  clear,\n  backup,\n  rollback,\n};\n",
    "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js": "'use strict';\n\nconst path = require('path');\nconst fse = require('fs-extra');\nconst _ = require('lodash');\nconst { toUID, isConfigurable } = require('../../utils/attributes');\n\nmodule.exports = function createSchemaHandler(infos) {\n  const { category, modelName, plugin, uid, dir, filename, schema } = infos;\n\n  const initialState = {\n    modelName,\n    plugin,\n    category,\n    uid,\n    dir,\n    filename,\n    schema: schema || {\n      info: {},\n      options: {},\n      attributes: {},\n    },\n  };\n\n  const state = _.cloneDeep(initialState);\n\n  // always keep it the same to rollback\n  Object.freeze(initialState.schema);\n\n  let modified = false;\n  let deleted = false;\n\n  return {\n    get modelName() {\n      return initialState.modelName;\n    },\n\n    get plugin() {\n      return initialState.plugin;\n    },\n\n    get category() {\n      return initialState.category;\n    },\n\n    get kind() {\n      return _.get(state.schema, 'kind', 'collectionType');\n    },\n\n    get uid() {\n      return state.uid;\n    },\n\n    get writable() {\n      return _.get(state, 'plugin') !== 'admin';\n    },\n\n    setUID(val) {\n      modified = true;\n\n      state.uid = val;\n      return this;\n    },\n\n    setDir(val) {\n      modified = true;\n\n      state.dir = val;\n      return this;\n    },\n\n    get schema() {\n      return _.cloneDeep(state.schema);\n    },\n\n    setSchema(val) {\n      modified = true;\n\n      state.schema = _.cloneDeep(val);\n      return this;\n    },\n\n    // get a particuar path inside the schema\n    get(path) {\n      return _.get(state.schema, path);\n    },\n\n    // set a particuar path inside the schema\n    set(path, val) {\n      modified = true;\n\n      const value = _.defaultTo(val, _.get(state.schema, path));\n      _.set(state.schema, path, value);\n\n      return this;\n    },\n\n    // delete a particuar path inside the schema\n    unset(path) {\n      modified = true;\n\n      _.unset(state.schema, path);\n\n      return this;\n    },\n\n    delete() {\n      deleted = true;\n      return this;\n    },\n\n    getAttribute(key) {\n      return this.get(['attributes', key]);\n    },\n\n    setAttribute(key, attribute) {\n      return this.set(['attributes', key], attribute);\n    },\n\n    deleteAttribute(key) {\n      return this.unset(['attributes', key]);\n    },\n\n    setAttributes(newAttributes) {\n      // delete old configurable attributes\n      for (let key in this.schema.attributes) {\n        if (isConfigurable(this.schema.attributes[key])) {\n          this.deleteAttribute(key);\n        }\n      }\n\n      // set new Attributes\n      for (let key in newAttributes) {\n        this.setAttribute(key, newAttributes[key]);\n      }\n\n      return this;\n    },\n\n    removeContentType(uid) {\n      const { attributes } = state.schema;\n\n      Object.keys(attributes).forEach(key => {\n        const attr = attributes[key];\n        const target = attr.model || attr.collection;\n        const plugin = attr.plugin;\n\n        const relationUID = toUID(target, plugin);\n\n        if (relationUID === uid) {\n          this.deleteAttribute(key);\n        }\n      });\n\n      return this;\n    },\n\n    // utils\n    removeComponent(uid) {\n      const { attributes } = state.schema;\n\n      Object.keys(attributes).forEach(key => {\n        const attr = attributes[key];\n\n        if (attr.type === 'component' && attr.component === uid) {\n          this.deleteAttribute(key);\n        }\n\n        if (\n          attr.type === 'dynamiczone' &&\n          Array.isArray(attr.components) &&\n          attr.components.includes(uid)\n        ) {\n          const updatedComponentList = attributes[key].components.filter(val => val !== uid);\n          this.set(['attributes', key, 'components'], updatedComponentList);\n        }\n      });\n\n      return this;\n    },\n\n    updateComponent(uid, newUID) {\n      const { attributes } = state.schema;\n\n      Object.keys(attributes).forEach(key => {\n        const attr = attributes[key];\n\n        if (attr.type === 'component' && attr.component === uid) {\n          this.set(['attributes', key, 'component'], newUID);\n        }\n\n        if (\n          attr.type === 'dynamiczone' &&\n          Array.isArray(attr.components) &&\n          attr.components.includes(uid)\n        ) {\n          const updatedComponentList = attr.components.map(val => (val === uid ? newUID : val));\n\n          this.set(['attributes', key, 'components'], updatedComponentList);\n        }\n      });\n\n      return this;\n    },\n\n    // save the schema to disk\n    async flush() {\n      if (!this.writable) {\n        return;\n      }\n\n      const initialPath = path.join(initialState.dir, initialState.filename);\n      const filePath = path.join(state.dir, state.filename);\n\n      if (deleted === true) {\n        await fse.remove(initialPath);\n\n        const list = await fse.readdir(initialState.dir);\n        if (list.length === 0) {\n          await fse.remove(initialState.dir);\n        }\n\n        return;\n      }\n\n      if (modified === true) {\n        await fse.ensureFile(filePath);\n\n        await fse.writeJSON(\n          filePath,\n          {\n            kind: state.schema.kind,\n            connection: state.schema.connection,\n            collectionName: state.schema.collectionName,\n            info: state.schema.info,\n            options: state.schema.options,\n            attributes: state.schema.attributes,\n          },\n          { spaces: 2 }\n        );\n\n        // remove from oldPath\n        if (initialPath !== filePath) {\n          await fse.remove(initialPath);\n\n          const list = await fse.readdir(initialState.dir);\n          if (list.length === 0) {\n            await fse.remove(initialState.dir);\n          }\n        }\n\n        return;\n      }\n\n      return Promise.resolve();\n    },\n\n    // reset the schema to its initial value\n    async rollback() {\n      if (!this.writable) {\n        return;\n      }\n\n      const initialPath = path.join(initialState.dir, initialState.filename);\n      const filePath = path.join(state.dir, state.filename);\n\n      // it was a creation so it needs to be deleted\n      if (!initialState.uid) {\n        await fse.remove(filePath);\n\n        const list = await fse.readdir(state.dir);\n        if (list.length === 0) {\n          await fse.remove(state.dir);\n        }\n        return;\n      }\n\n      if (modified === true || deleted === true) {\n        await fse.ensureFile(initialPath);\n        await fse.writeJSON(initialPath, initialState.schema, { spaces: 2 });\n\n        // remove\n        if (initialPath !== filePath) {\n          await fse.remove(filePath);\n\n          const list = await fse.readdir(state.dir);\n          if (list.length === 0) {\n            await fse.remove(state.dir);\n          }\n        }\n      }\n\n      return Promise.resolve();\n    },\n  };\n};\n",
    "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js": "'use strict';\n\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\n\nlet strapi;\nlet rq;\n\nconst restart = async () => {\n  await strapi.destroy();\n  strapi = await createStrapiInstance();\n  rq = await createAuthRequest({ strapi });\n};\n\ndescribe('Content Type Builder - Components', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  describe('POST /components', () => {\n    test('Validates input and return 400 in case of invalid input', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/components',\n        body: {\n          component: {},\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        error: {\n          'component.category': ['category.required'],\n          'component.icon': ['icon.required'],\n          'component.attributes': ['attributes.required'],\n          'component.name': ['name.required'],\n        },\n      });\n    });\n\n    test('Creates a component properly', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/components',\n        body: {\n          component: {\n            category: 'default',\n            icon: 'default',\n            name: 'Some Component',\n            attributes: {\n              title: {\n                type: 'string',\n              },\n              pic: {\n                type: 'media',\n              },\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: 'default.some-component',\n        },\n      });\n\n      await restart();\n    }, 60000);\n\n    test('Errors on already existing components', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/components',\n        body: {\n          component: {\n            category: 'default',\n            icon: 'default',\n            name: 'someComponent',\n            attributes: {},\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        error: 'component.alreadyExists',\n      });\n    });\n  });\n\n  describe('Get /components', () => {\n    test('Returns valid enveloppe', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: expect.any(Array),\n      });\n\n      res.body.data.forEach(el => {\n        expect(el).toMatchObject({\n          uid: expect.any(String),\n          schema: expect.objectContaining({\n            name: expect.any(String),\n            description: expect.any(String),\n            connection: expect.any(String),\n            collectionName: expect.any(String),\n            attributes: expect.objectContaining({}),\n          }),\n        });\n      });\n    });\n  });\n\n  describe('GET /components/:uid', () => {\n    test('Returns 404 on not found', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components/nonexistent-component',\n      });\n\n      expect(res.statusCode).toBe(404);\n      expect(res.body).toEqual({\n        error: 'component.notFound',\n      });\n    });\n\n    test('Returns correct format', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components/default.some-component',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          uid: 'default.some-component',\n          category: 'default',\n          schema: {\n            icon: 'default',\n            name: 'Some Component',\n            description: '',\n            connection: 'default',\n            collectionName: 'components_default_some_components',\n            attributes: {\n              title: {\n                type: 'string',\n              },\n              pic: {\n                type: 'media',\n                multiple: false,\n                required: false,\n              },\n            },\n          },\n        },\n      });\n    });\n  });\n\n  describe('PUT /components/:uid', () => {\n    test('Throws 404 on updating non existent component', async () => {\n      const res = await rq({\n        method: 'PUT',\n        url: '/content-type-builder/components/nonexistent-components',\n      });\n\n      expect(res.statusCode).toBe(404);\n      expect(res.body).toEqual({\n        error: 'component.notFound',\n      });\n    });\n\n    test('Validates input and return 400 in case of invalid input', async () => {\n      const res = await rq({\n        method: 'PUT',\n        url: '/content-type-builder/components/default.some-component',\n        body: {\n          component: {\n            attributes: {},\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        error: {\n          'component.category': ['category.required'],\n          'component.icon': ['icon.required'],\n          'component.name': ['name.required'],\n        },\n      });\n    });\n\n    test('Updates a component properly', async () => {\n      const res = await rq({\n        method: 'PUT',\n        url: '/content-type-builder/components/default.some-component',\n        body: {\n          component: {\n            category: 'default',\n            icon: 'default',\n            name: 'New Component',\n            attributes: {},\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          uid: 'default.some-component',\n        },\n      });\n\n      await restart();\n\n      const getRes = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components/default.some-component',\n      });\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        data: {\n          uid: 'default.some-component',\n          schema: {\n            name: 'New Component',\n          },\n        },\n      });\n    }, 60000);\n  });\n\n  describe('DELETE /components/:uid', () => {\n    test('Throws 404 on non existent component', async () => {\n      const res = await rq({\n        method: 'DELETE',\n        url: '/content-type-builder/components/nonexistent-components',\n      });\n\n      expect(res.statusCode).toBe(404);\n      expect(res.body).toEqual({\n        error: 'component.notFound',\n      });\n    });\n\n    test('Deletes a component correctly', async () => {\n      const res = await rq({\n        method: 'DELETE',\n        url: '/content-type-builder/components/default.some-component',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          uid: 'default.some-component',\n        },\n      });\n\n      await restart();\n\n      const tryGet = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components/default.some-component',\n      });\n\n      expect(tryGet.statusCode).toBe(404);\n      expect(tryGet.body).toEqual({\n        error: 'component.notFound',\n      });\n    }, 60000);\n  });\n});\n",
    "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js": "/**\n * Integration test for the content-type-builder content types management apis\n */\n'use strict';\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst modelsUtils = require('../../../test/helpers/models');\n\nlet strapi;\nlet rq;\n\nconst restart = async () => {\n  await strapi.destroy();\n  strapi = await createStrapiInstance();\n  rq = await createAuthRequest({ strapi });\n};\n\ndescribe('Content Type Builder - Content types', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterEach(async () => {\n    await restart();\n  }, 60000);\n\n  afterAll(async () => {\n    const modelsName = [\n      'test-collection-type',\n      'test-collection',\n      'test-single-type',\n      'ct-with-dp',\n    ];\n\n    await modelsUtils.cleanupModels(modelsName, { strapi });\n    await modelsUtils.deleteContentTypes(modelsName, { strapi });\n\n    await strapi.destroy();\n  }, 60000);\n\n  describe('Collection Types', () => {\n    const testCollectionTypeUID = 'application::test-collection-type.test-collection-type';\n    const ctWithDpUID = 'application::ct-with-dp.ct-with-dp';\n\n    test('Successful creation of a collection type', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            name: 'Test Collection Type',\n            attributes: {\n              title: {\n                type: 'string',\n              },\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: testCollectionTypeUID,\n        },\n      });\n    });\n\n    test('Get collection type returns full schema and information', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: `/content-type-builder/content-types/${testCollectionTypeUID}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchSnapshot();\n    });\n\n    test('Successfull creation of a collection type with draftAndPublish enabled', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            name: 'CT with DP',\n            draftAndPublish: true,\n            attributes: {\n              title: {\n                type: 'string',\n              },\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: ctWithDpUID,\n        },\n      });\n    });\n\n    test('Get collection type returns full schema and informations with draftAndPublish', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: `/content-type-builder/content-types/${ctWithDpUID}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchSnapshot();\n    });\n  });\n\n  describe('Single Types', () => {\n    const singleTypeUID = 'application::test-single-type.test-single-type';\n\n    test('Successful creation of a single type', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            kind: 'singleType',\n            name: 'Test Single Type',\n            attributes: {\n              title: {\n                type: 'string',\n              },\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: singleTypeUID,\n        },\n      });\n    });\n\n    test('Get single type returns full schema and information', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: `/content-type-builder/content-types/${singleTypeUID}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchSnapshot();\n    });\n\n    test('Fails on invalid relations', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            kind: 'singleType',\n            name: 'test-st',\n            attributes: {\n              relation: {\n                nature: 'oneToOne',\n                target: 'plugins::users-permissions.user',\n                targetAttribute: 'test',\n              },\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        error: {\n          ['contentType.attributes.relation.nature']: expect.arrayContaining([\n            expect.stringMatching('must be one of the following values: oneWay, manyWay'),\n          ]),\n        },\n      });\n    });\n\n    test('Cannot switch collectionType to singleType when multiple entries in DB', async () => {\n      const createRes = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            kind: 'collectionType',\n            name: 'test-collection',\n            attributes: {\n              title: {\n                type: 'string',\n              },\n            },\n          },\n        },\n      });\n\n      expect(createRes.statusCode).toBe(201);\n\n      await restart();\n\n      const { uid } = createRes.body.data;\n\n      // create data\n      for (let i = 0; i < 2; i++) {\n        const res = await rq({\n          method: 'POST',\n          url: `/test-collections`,\n          body: {\n            title: 'Test',\n          },\n        });\n\n        expect(res.statusCode).toBe(200);\n      }\n\n      const updateRes = await rq({\n        method: 'PUT',\n        url: `/content-type-builder/content-types/${uid}`,\n        body: {\n          contentType: {\n            kind: 'singleType',\n            name: 'test-collection',\n            attributes: {\n              title: {\n                type: 'string',\n              },\n            },\n          },\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n      expect(updateRes.body.error).toMatch('multiple entries in DB');\n    }, 60000);\n  });\n\n  describe('Private relation field', () => {\n    const singleTypeUID = 'application::test-single-type.test-single-type';\n\n    test('should add a relation field', async () => {\n      const res = await rq({\n        method: 'PUT',\n        url: `/content-type-builder/content-types/${singleTypeUID}`,\n        body: {\n          contentType: {\n            kind: 'singleType',\n            name: 'test-collection',\n            attributes: {\n              relation: {\n                private: true,\n                nature: 'oneWay',\n                target: 'plugins::users-permissions.user',\n                targetAttribute: 'test',\n              },\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: singleTypeUID,\n        },\n      });\n    });\n\n    test('should contain a private relation field', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: `/content-type-builder/content-types/${singleTypeUID}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.schema.attributes.relation).toBeDefined();\n      expect(res.body.data.schema.attributes.relation.private).toBeTruthy();\n    });\n  });\n});\n",
    "packages/strapi-plugin-documentation/config/functions/bootstrap.js": "'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst _ = require('lodash');\n\nmodule.exports = async () => {\n  // Check if the plugin users-permissions is installed because the documentation needs it\n  if (Object.keys(strapi.plugins).indexOf('users-permissions') === -1) {\n    throw new Error(\n      'In order to make the documentation plugin works the users-permissions one is required'\n    );\n  }\n\n  const pluginStore = strapi.store({\n    environment: '',\n    type: 'plugin',\n    name: 'documentation',\n  });\n  const restrictedAccess = await pluginStore.get({ key: 'config' });\n\n  if (!restrictedAccess) {\n    pluginStore.set({ key: 'config', value: { restrictedAccess: false } });\n  }\n\n  let shouldUpdateFullDoc = false;\n  const services = strapi.plugins['documentation'].services.documentation;\n  // Generate plugins' documentation\n  const pluginsWithDocumentationNeeded = services.getPluginsWithDocumentationNeeded();\n  pluginsWithDocumentationNeeded.forEach(plugin => {\n    const isDocExisting = services.checkIfPluginDocumentationFolderExists(plugin);\n\n    if (!isDocExisting) {\n      services.createDocumentationDirectory(services.getPluginDocumentationPath(plugin));\n      // create the overrides directory\n      services.createDocumentationDirectory(services.getPluginOverrideDocumentationPath(plugin));\n      services.createPluginDocumentationFile(plugin);\n      shouldUpdateFullDoc = true;\n    } else {\n      const needToUpdatePluginDoc = services.checkIfPluginDocNeedsUpdate(plugin);\n\n      if (needToUpdatePluginDoc) {\n        services.createPluginDocumentationFile(plugin);\n        shouldUpdateFullDoc = true;\n      }\n    }\n  });\n\n  // Retrieve all the apis from the apis directory\n  const apis = services.getApis();\n  // Generate APIS' documentation\n  apis.forEach(api => {\n    const isDocExisting = services.checkIfDocumentationFolderExists(api);\n\n    if (!isDocExisting) {\n      // If the documentation directory doesn't exist create it\n      services.createDocumentationDirectory(services.getDocumentationPath(api));\n      // Create the overrides directory\n      services.createDocumentationDirectory(services.getDocumentationOverridesPath(api));\n      // Create the documentation files per version\n      services.createDocumentationFile(api); // Then create the {api}.json documentation file\n      shouldUpdateFullDoc = true;\n    } else {\n      const needToUpdateAPIDoc = services.checkIfAPIDocNeedsUpdate(api);\n\n      if (needToUpdateAPIDoc) {\n        services.createDocumentationFile(api);\n        shouldUpdateFullDoc = true;\n      }\n    }\n  });\n\n  const fullDoc = services.generateFullDoc();\n  // Verify that the correct documentation folder exists in the documentation plugin\n  const isMergedDocumentationExists = services.checkIfMergedDocumentationFolderExists();\n  const documentationPath = services.getMergedDocumentationPath();\n\n  if (isMergedDocumentationExists) {\n    /**\n     * Retrieve all tags from the documentation and join them\n     * @param {Object} documentation\n     * @returns {String}\n     */\n    const getDocTagsToString = documentation => {\n      return _.get(documentation, 'tags', [])\n        .map(tag => {\n          return tag.name.toLowerCase();\n        })\n        .sort((a, b) => a - b)\n        .join('.');\n    };\n    const oldDoc = require(path.resolve(documentationPath, 'full_documentation.json'));\n    const oldDocTags = getDocTagsToString(oldDoc);\n    const currentDocTags = getDocTagsToString(fullDoc);\n\n    // If the tags are different (an api has been deleted) we need to rebuild the documentation\n    if (oldDocTags !== currentDocTags) {\n      shouldUpdateFullDoc = true;\n    }\n  }\n\n  if (!isMergedDocumentationExists || shouldUpdateFullDoc) {\n    // Create the folder\n    services.createDocumentationDirectory(documentationPath);\n    // Write the file\n    fs.writeFileSync(\n      path.resolve(documentationPath, 'full_documentation.json'),\n      JSON.stringify(fullDoc, null, 2),\n      'utf8'\n    );\n  }\n\n  // Add permissions\n  const actions = [\n    {\n      section: 'plugins',\n      displayName: 'Access the Documentation',\n      uid: 'read',\n      pluginName: 'documentation',\n    },\n    {\n      section: 'plugins',\n      displayName: 'Update and delete',\n      uid: 'settings.update',\n      subCategory: 'settings',\n      pluginName: 'documentation',\n    },\n    {\n      section: 'plugins',\n      displayName: 'Regenerate',\n      uid: 'settings.regenerate',\n      subCategory: 'settings',\n      pluginName: 'documentation',\n    },\n  ];\n\n  const { actionProvider } = strapi.admin.services.permission;\n  actionProvider.register(actions);\n};\n",
    "packages/strapi-plugin-documentation/config/policies/index.js": "'use strict';\n\nmodule.exports = async (ctx, next) => {\n  const pluginStore = strapi.store({\n    environment: '',\n    type: 'plugin',\n    name: 'documentation',\n  });\n  const config = await pluginStore.get({ key: 'config' });\n\n  if (!config.restrictedAccess) {\n    return await next();\n  }\n\n  if (!ctx.session.documentation) {\n    const querystring = ctx.querystring ? `?${ctx.querystring}` : '';\n\n    return ctx.redirect(\n      `${strapi.config.server.url}${strapi.plugins.documentation.config['x-strapi-config'].path}/login${querystring}`\n    );\n  }\n  const isValid = await strapi.plugins['users-permissions'].services.user.validatePassword(\n    ctx.session.documentation,\n    config.password\n  );\n\n  if (!isValid) {\n    ctx.session.documentation = null;\n  }\n\n  // Execute the action.\n  await next();\n};\n",
    "packages/strapi-plugin-documentation/controllers/Documentation.js": "'use strict';\n\n/**\n * Documentation.js controller\n *\n * @description: A set of functions called \"actions\" of the `documentation` plugin.\n */\n\n// Core dependencies.\nconst path = require('path');\n\n// Public dependencies.\nconst fs = require('fs-extra');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\nconst koaStatic = require('koa-static');\n\nmodule.exports = {\n  getInfos: async ctx => {\n    try {\n      const service = strapi.plugins.documentation.services.documentation;\n      const docVersions = service.retrieveDocumentationVersions();\n      const form = await service.retrieveFrontForm();\n\n      ctx.send({\n        docVersions,\n        currentVersion: service.getDocumentationVersion(),\n        prefix: strapi.plugins.documentation.config['x-strapi-config'].path,\n        form,\n      });\n    } catch (err) {\n      ctx.badRequest(null, err.message);\n    }\n  },\n\n  async index(ctx, next) {\n    try {\n      /**\n       * We don't expose the specs using koa-static or something else due to security reasons.\n       * That's why, we need to read the file localy and send the specs through it when we serve the Swagger UI.\n       */\n      const { major, minor, patch } = ctx.params;\n      const version =\n        major && minor && patch\n          ? `${major}.${minor}.${patch}`\n          : strapi.plugins.documentation.config.info.version;\n      const openAPISpecsPath = path.join(\n        strapi.config.appPath,\n        'extensions',\n        'documentation',\n        'documentation',\n        version,\n        'full_documentation.json'\n      );\n\n      try {\n        const documentation = fs.readFileSync(openAPISpecsPath, 'utf8');\n        const layout = fs.readFileSync(\n          path.resolve(__dirname, '..', 'public', 'index.html'),\n          'utf8'\n        );\n        const filledLayout = _.template(layout)({\n          backendUrl: strapi.config.server.url,\n          spec: JSON.stringify(JSON.parse(documentation)),\n        });\n\n        try {\n          const layoutPath = path.resolve(\n            strapi.config.appPath,\n            'extensions',\n            'documentation',\n            'public',\n            'index.html'\n          );\n          await fs.ensureFile(layoutPath);\n          await fs.writeFile(layoutPath, filledLayout);\n\n          // Serve the file.\n          ctx.url = path.basename(`${ctx.url}/index.html`);\n\n          try {\n            const staticFolder = path.resolve(\n              strapi.config.appPath,\n              'extensions',\n              'documentation',\n              'public'\n            );\n            return await koaStatic(staticFolder)(ctx, next);\n          } catch (e) {\n            strapi.log.error(e);\n          }\n        } catch (e) {\n          strapi.log.error(e);\n        }\n      } catch (e) {\n        strapi.log.error(e);\n      }\n    } catch (e) {\n      strapi.log.error(e);\n    }\n  },\n\n  async loginView(ctx, next) {\n    const { error } = ctx.query;\n\n    try {\n      const layout = fs.readFileSync(path.join(__dirname, '..', 'public', 'login.html'));\n      const filledLayout = _.template(layout)({\n        actionUrl: `${strapi.config.server.url}${strapi.plugins.documentation.config['x-strapi-config'].path}/login`,\n      });\n      const $ = cheerio.load(filledLayout);\n\n      $('.error').text(_.isEmpty(error) ? '' : 'Wrong password...');\n\n      try {\n        const layoutPath = path.resolve(\n          strapi.config.appPath,\n          'extensions',\n          'documentation',\n          'public',\n          'login.html'\n        );\n        await fs.ensureFile(layoutPath);\n        await fs.writeFile(layoutPath, $.html());\n\n        ctx.url = path.basename(`${ctx.url}/login.html`);\n\n        try {\n          const staticFolder = path.resolve(\n            strapi.config.appPath,\n            'extensions',\n            'documentation',\n            'public'\n          );\n          return await koaStatic(staticFolder)(ctx, next);\n        } catch (e) {\n          strapi.log.error(e);\n        }\n      } catch (e) {\n        strapi.log.error(e);\n      }\n    } catch (e) {\n      strapi.log.error(e);\n    }\n  },\n\n  async login(ctx) {\n    const {\n      body: { password },\n    } = ctx.request;\n\n    const { password: storedPassword } = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'documentation',\n        key: 'config',\n      })\n      .get();\n\n    const isValid = await strapi.plugins['users-permissions'].services.user.validatePassword(\n      password,\n      storedPassword\n    );\n    let querystring = '?error=password';\n\n    if (isValid) {\n      ctx.session.documentation = password;\n      querystring = '';\n    }\n\n    ctx.redirect(\n      `${strapi.config.server.url}${strapi.plugins.documentation.config['x-strapi-config'].path}${querystring}`\n    );\n  },\n\n  regenerateDoc: async ctx => {\n    const service = strapi.plugins.documentation.services.documentation;\n    const documentationVersions = service.retrieveDocumentationVersions().map(el => el.version);\n    const {\n      request: {\n        body: { version },\n        admin,\n      },\n    } = ctx;\n\n    if (_.isEmpty(version)) {\n      return ctx.badRequest(\n        null,\n        admin ? 'documentation.error.noVersion' : 'Please provide a version.'\n      );\n    }\n\n    if (!documentationVersions.includes(version)) {\n      return ctx.badRequest(\n        null,\n        admin\n          ? 'documentation.error.regenerateDoc.versionMissing'\n          : 'The version you are trying to generate does not exist.'\n      );\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n      const fullDoc = service.generateFullDoc(version);\n      const documentationPath = service.getMergedDocumentationPath(version);\n      // Write the file\n      fs.writeFileSync(\n        path.resolve(documentationPath, 'full_documentation.json'),\n        JSON.stringify(fullDoc, null, 2),\n        'utf8'\n      );\n      ctx.send({ ok: true });\n    } catch (err) {\n      ctx.badRequest(null, admin ? 'documentation.error.regenerateDoc' : 'An error occured');\n    } finally {\n      strapi.reload.isWatching = true;\n    }\n  },\n\n  deleteDoc: async ctx => {\n    strapi.reload.isWatching = false;\n    const service = strapi.plugins.documentation.services.documentation;\n    const documentationVersions = service.retrieveDocumentationVersions().map(el => el.version);\n    const {\n      request: {\n        params: { version },\n        admin,\n      },\n    } = ctx;\n\n    if (_.isEmpty(version)) {\n      return ctx.badRequest(\n        null,\n        admin ? 'documentation.error.noVersion' : 'Please provide a version.'\n      );\n    }\n\n    if (!documentationVersions.includes(version)) {\n      return ctx.badRequest(\n        null,\n        admin\n          ? 'documentation.error.deleteDoc.versionMissing'\n          : 'The version you are trying to delete does not exist.'\n      );\n    }\n\n    try {\n      await service.deleteDocumentation(version);\n      ctx.send({ ok: true });\n    } catch (err) {\n      ctx.badRequest(null, admin ? 'notification.error' : err.message);\n    } finally {\n      strapi.reload.isWatching = true;\n    }\n  },\n\n  updateSettings: async ctx => {\n    const {\n      admin,\n      body: { restrictedAccess, password },\n    } = ctx.request;\n    const usersPermService = strapi.plugins['users-permissions'].services;\n    const pluginStore = strapi.store({\n      environment: '',\n      type: 'plugin',\n      name: 'documentation',\n    });\n    const prevConfig = await pluginStore.get({ key: 'config' });\n\n    if (restrictedAccess && _.isEmpty(password)) {\n      return ctx.badRequest(\n        null,\n        admin ? 'users-permissions.Auth.form.error.password.provide' : 'Please provide a password'\n      );\n    }\n\n    const isNewPassword = !_.isEmpty(password) && password !== prevConfig.password;\n\n    if (isNewPassword && usersPermService.user.isHashed(password)) {\n      // Throw an error if the password selected by the user\n      // contains more than two times the symbol '$'.\n      return ctx.badRequest(\n        null,\n        admin\n          ? 'users-permissions.Auth.form.error.password.format'\n          : 'our password cannot contain more than three times the symbol `$`.'\n      );\n    }\n\n    if (isNewPassword) {\n      prevConfig.password = await usersPermService.user.hashPassword({\n        password,\n      });\n    }\n\n    _.set(prevConfig, 'restrictedAccess', restrictedAccess);\n\n    await pluginStore.set({ key: 'config', value: prevConfig });\n\n    return ctx.send({ ok: true });\n  },\n};\n",
    "packages/strapi-plugin-documentation/middlewares/documentation/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst path = require('path');\nconst _ = require('lodash');\nconst swaggerUi = require('swagger-ui-dist');\nconst koaStatic = require('koa-static');\n\n// Variables.\nconst initialRoutes = [];\n\nmodule.exports = strapi => {\n  return {\n    beforeInitialize() {\n      strapi.config.middleware.load.before.push('documentation');\n\n      initialRoutes.push(..._.cloneDeep(strapi.plugins.documentation.config.routes));\n    },\n\n    initialize() {\n      // Find the plugins routes.\n      strapi.plugins.documentation.config.routes = strapi.plugins.documentation.config.routes.map(\n        (route, index) => {\n          if (route.handler === 'Documentation.getInfos') {\n            return route;\n          }\n\n          if (route.handler === 'Documentation.index' || route.path === '/login') {\n            route.config.policies = initialRoutes[index].config.policies;\n          }\n\n          // Set prefix to empty to be able to customise it.\n          if (_.get(strapi.plugins, ['documentation', 'config', 'x-strapi-config', 'path'])) {\n            route.config.prefix = '';\n            route.path = `/${strapi.plugins.documentation.config['x-strapi-config'].path}${route.path}`.replace(\n              '//',\n              '/'\n            );\n          }\n\n          return route;\n        }\n      );\n\n      strapi.router.get('/plugins/documentation/*', async (ctx, next) => {\n        ctx.url = path.basename(ctx.url);\n\n        return await koaStatic(swaggerUi.getAbsoluteFSPath(), {\n          maxage: strapi.config.middleware.settings.public.maxAge,\n          defer: true,\n        })(ctx, next);\n      });\n    },\n  };\n};\n",
    "packages/strapi-plugin-documentation/services/Documentation.js": "'use strict';\n\n/**\n * Documentation.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\nconst fs = require('fs');\nconst path = require('path');\nconst _ = require('lodash');\nconst moment = require('moment');\nconst pathToRegexp = require('path-to-regexp');\nconst defaultSettings = require('../config/settings.json');\nconst defaultComponents = require('./utils/components.json');\nconst form = require('./utils/forms.json');\nconst parametersOptions = require('./utils/parametersOptions.json');\n\n// keys to pick from the extended config\nconst defaultSettingsKeys = Object.keys(defaultSettings);\nconst customIsEqual = (obj1, obj2) => _.isEqualWith(obj1, obj2, customComparator);\n\nconst customComparator = (value1, value2) => {\n  if (_.isArray(value1) && _.isArray(value2)) {\n    if (value1.length !== value2.length) {\n      return false;\n    }\n    return value1.every(el1 => value2.findIndex(el2 => customIsEqual(el1, el2)) >= 0);\n  }\n};\n\nmodule.exports = {\n  areObjectsEquals: function(obj1, obj2) {\n    // stringify to remove nested empty objects\n    return customIsEqual(this.cleanObject(obj1), this.cleanObject(obj2));\n  },\n\n  cleanObject: obj => JSON.parse(JSON.stringify(obj)),\n\n  arrayCustomizer: (objValue, srcValue) => {\n    if (_.isArray(objValue)) return objValue.concat(srcValue);\n  },\n\n  checkIfAPIDocNeedsUpdate: function(apiName) {\n    const prevDocumentation = this.createDocObject(this.retrieveDocumentation(apiName));\n    const currentDocumentation = this.createDocObject(this.createDocumentationFile(apiName, false));\n\n    return !this.areObjectsEquals(prevDocumentation, currentDocumentation);\n  },\n\n  /**\n   * Check if the documentation folder with its related version of an API exists\n   * @param {String} apiName\n   */\n  checkIfDocumentationFolderExists: function(apiName) {\n    try {\n      fs.accessSync(this.getDocumentationPath(apiName));\n      return true;\n    } catch (err) {\n      return false;\n    }\n  },\n\n  checkIfPluginDocumentationFolderExists: function(pluginName) {\n    try {\n      fs.accessSync(this.getPluginDocumentationPath(pluginName));\n      return true;\n    } catch (err) {\n      return false;\n    }\n  },\n\n  checkIfPluginDocNeedsUpdate: function(pluginName) {\n    const prevDocumentation = this.createDocObject(this.retrieveDocumentation(pluginName, true));\n    const currentDocumentation = this.createDocObject(\n      this.createPluginDocumentationFile(pluginName, false)\n    );\n\n    return !this.areObjectsEquals(prevDocumentation, currentDocumentation);\n  },\n\n  checkIfApiDefaultDocumentationFileExist: function(apiName, docName) {\n    try {\n      fs.accessSync(this.getAPIOverrideDocumentationPath(apiName, docName));\n      return true;\n    } catch (err) {\n      return false;\n    }\n  },\n\n  checkIfPluginDefaultDocumentFileExists: function(pluginName, docName) {\n    try {\n      fs.accessSync(this.getPluginOverrideDocumentationPath(pluginName, docName));\n      return true;\n    } catch (err) {\n      return false;\n    }\n  },\n\n  /**\n   * Check if the documentation folder exists in the documentation plugin\n   * @returns {Boolean}\n   */\n  checkIfMergedDocumentationFolderExists: function() {\n    try {\n      fs.accessSync(this.getMergedDocumentationPath());\n      return true;\n    } catch (err) {\n      return false;\n    }\n  },\n\n  /**\n   * Recursively create missing directories\n   * @param {String} targetDir\n   *\n   */\n  createDocumentationDirectory: function(targetDir) {\n    const sep = path.sep;\n    const initDir = path.isAbsolute(targetDir) ? sep : '';\n    const baseDir = '.';\n\n    return targetDir.split(sep).reduce((parentDir, childDir) => {\n      const curDir = path.resolve(baseDir, parentDir, childDir);\n\n      try {\n        fs.mkdirSync(curDir);\n      } catch (err) {\n        if (err.code === 'EEXIST') {\n          // curDir already exists!\n          return curDir;\n        }\n\n        // To avoid `EISDIR` error on Mac and `EACCES`-->`ENOENT` and `EPERM` on Windows.\n        if (err.code === 'ENOENT') {\n          // Throw the original parentDir error on curDir `ENOENT` failure.\n          throw new Error(\n            `Impossible to create the documentation folder in '${parentDir}', please check the permissions.`\n          );\n        }\n\n        const caughtErr = ['EACCES', 'EPERM', 'EISDIR'].indexOf(err.code) > -1;\n\n        if (!caughtErr || (caughtErr && targetDir === curDir)) {\n          throw err; // Throw if it's just the last created dir.\n        }\n      }\n\n      return curDir;\n    }, initDir);\n  },\n\n  /**\n   * Create the apiName.json and unclassified.json files inside an api's documentation/version folder\n   * @param {String} apiName\n   */\n  createDocumentationFile: function(apiName, writeFile = true) {\n    // Retrieve all the routes from an API\n    const apiRoutes = this.getApiRoutes(apiName);\n    const apiDocumentation = this.generateApiDocumentation(apiName, apiRoutes);\n\n    return Object.keys(apiDocumentation).reduce((acc, docName) => {\n      const targetFile = path.resolve(this.getDocumentationPath(apiName), `${docName}.json`);\n      // Create the components object in each documentation file when we can create it\n      const components =\n        strapi.models[docName] !== undefined ? this.generateResponseComponent(docName) : {};\n      const tags = docName.split('-').length > 1 ? [] : this.generateTags(apiName, docName);\n      const documentation = Object.assign(apiDocumentation[docName], components, { tags });\n\n      try {\n        if (writeFile) {\n          return fs.writeFileSync(targetFile, JSON.stringify(documentation, null, 2), 'utf8');\n        } else {\n          return acc.concat(documentation);\n        }\n      } catch (err) {\n        return acc;\n      }\n    }, []);\n  },\n\n  createPluginDocumentationFile: function(pluginName, writeFile = true) {\n    const pluginRoutes = this.getPluginRoutesWithDescription(pluginName);\n    const pluginDocumentation = this.generatePluginDocumentation(pluginName, pluginRoutes);\n\n    return Object.keys(pluginDocumentation).reduce((acc, docName) => {\n      const targetFile = path.resolve(\n        this.getPluginDocumentationPath(pluginName),\n        `${docName}.json`\n      );\n      const components =\n        _.get(strapi, this.getModelForPlugin(docName, pluginName)) !== undefined &&\n        pluginName !== 'upload'\n          ? this.generateResponseComponent(docName, pluginName, true)\n          : {};\n      const [plugin, name] = this.getModelAndNameForPlugin(docName, pluginName);\n      const tags =\n        docName !== 'unclassified'\n          ? this.generateTags(plugin, docName, _.upperFirst(this.formatTag(plugin, name)), true)\n          : [];\n      const documentation = Object.assign(pluginDocumentation[docName], components, { tags });\n\n      try {\n        if (writeFile) {\n          return fs.writeFileSync(targetFile, JSON.stringify(documentation, null, 2), 'utf8');\n        } else {\n          return acc.concat(documentation);\n        }\n      } catch (err) {\n        // Silent\n      }\n    }, []);\n  },\n\n  createDocObject: function(array) {\n    // use custom merge for arrays\n    return array.reduce((acc, curr) => _.mergeWith(acc, curr, this.arrayCustomizer), {});\n  },\n\n  deleteDocumentation: async function(version = this.getDocumentationVersion()) {\n    const recursiveDeleteFiles = async (folderPath, removeCompleteFolder = true) => {\n      // Check if folderExist\n      try {\n        const arrayOfPromises = [];\n        fs.accessSync(folderPath);\n        const items = fs.readdirSync(folderPath).filter(x => x[0] !== '.');\n\n        items.forEach(item => {\n          const itemPath = path.join(folderPath, item);\n\n          // Check if directory\n          if (fs.lstatSync(itemPath).isDirectory()) {\n            if (removeCompleteFolder) {\n              return arrayOfPromises.push(recursiveDeleteFiles(itemPath), removeCompleteFolder);\n            } else if (!itemPath.includes('overrides')) {\n              return arrayOfPromises.push(recursiveDeleteFiles(itemPath), removeCompleteFolder);\n            }\n          } else {\n            // Delete all files\n            try {\n              fs.unlinkSync(itemPath);\n            } catch (err) {\n              console.log('Cannot delete file', err);\n            }\n          }\n        });\n\n        await Promise.all(arrayOfPromises);\n\n        try {\n          if (removeCompleteFolder) {\n            fs.rmdirSync(folderPath);\n          }\n        } catch (err) {\n          // console.log(err);\n        }\n      } catch (err) {\n        // console.log('The folder does not exist');\n      }\n    };\n\n    const arrayOfPromises = [];\n\n    // Delete api's documentation\n    const apis = this.getApis();\n    const plugins = this.getPluginsWithDocumentationNeeded();\n\n    apis.forEach(api => {\n      const apiPath = path.join(strapi.config.appPath, 'api', api, 'documentation', version);\n      arrayOfPromises.push(recursiveDeleteFiles(apiPath));\n    });\n\n    plugins.forEach(plugin => {\n      const pluginPath = path.join(\n        strapi.config.appPath,\n        'extensions',\n        plugin,\n        'documentation',\n        version\n      );\n\n      if (version !== '1.0.0') {\n        arrayOfPromises.push(recursiveDeleteFiles(pluginPath));\n      } else {\n        arrayOfPromises.push(recursiveDeleteFiles(pluginPath, false));\n      }\n    });\n\n    const fullDocPath = path.join(\n      strapi.config.appPath,\n      'extensions',\n      'documentation',\n      'documentation',\n      version\n    );\n    arrayOfPromises.push(recursiveDeleteFiles(fullDocPath));\n\n    return await Promise.all(arrayOfPromises);\n  },\n\n  /**\n   *\n   * Wrap endpoints variables in curly braces\n   * @param {String} endPoint\n   * @returns {String} (/products/{id})\n   */\n  formatApiEndPoint: endPoint => {\n    return pathToRegexp\n      .parse(endPoint)\n      .map(token => {\n        if (_.isObject(token)) {\n          return token.prefix + '{' + token.name + '}'; // eslint-disable-line prefer-template\n        }\n\n        return token;\n      })\n      .join('');\n  },\n\n  /**\n   * Format a plugin model for example users-permissions, user => Users-Permissions - User\n   * @param {Sting} plugin\n   * @param {String} name\n   * @param {Boolean} withoutSpace\n   * @return {String}\n   */\n  formatTag: (plugin, name, withoutSpace = false) => {\n    const formattedPluginName = plugin\n      .split('-')\n      .map(i => _.upperFirst(i))\n      .join('');\n    const formattedName = _.upperFirst(name);\n\n    if (withoutSpace) {\n      return `${formattedPluginName}${formattedName}`;\n    }\n\n    return `${formattedPluginName} - ${formattedName}`;\n  },\n\n  generateAssociationSchema: function(attributes, getter) {\n    return Object.keys(attributes).reduce(\n      (acc, curr) => {\n        const attribute = attributes[curr];\n        const isField = !_.has(attribute, 'model') && !_.has(attribute, 'collection');\n\n        if (attribute.required) {\n          acc.required.push(curr);\n        }\n\n        if (isField) {\n          acc.properties[curr] = { type: this.getType(attribute.type) };\n        } else {\n          const newGetter = getter.slice();\n          newGetter.splice(newGetter.length - 1, 1, 'associations');\n          const relationNature = _.get(strapi, newGetter).filter(\n            association => association.alias === curr\n          )[0].nature;\n\n          switch (relationNature) {\n            case 'manyToMany':\n            case 'oneToMany':\n            case 'manyToManyMorph':\n              acc.properties[curr] = {\n                type: 'array',\n                items: { type: 'string' },\n              };\n              break;\n            default:\n              acc.properties[curr] = { type: 'string' };\n          }\n        }\n\n        return acc;\n      },\n      { required: ['id'], properties: { id: { type: 'string' } } }\n    );\n  },\n\n  /**\n   * Creates the paths object with all the needed information\n   * The object has the following structure { apiName: { paths: {} }, knownTag1: { paths: {} }, unclassified: { paths: {} } }\n   * Each key will create a documentation.json file\n   *\n   * @param {String} apiName\n   * @param {Array} routes\n   * @returns {Object}\n   */\n  generateApiDocumentation: function(apiName, routes) {\n    return routes.reduce((acc, current) => {\n      const [controllerName, controllerMethod] = current.handler.split('.');\n      // Retrieve the tag key in the config object\n      const routeTagConfig = _.get(current, ['config', 'tag']);\n      // Add curly braces between dynamic params\n      const endPoint = this.formatApiEndPoint(current.path);\n      let verb;\n\n      if (Array.isArray(current.method)) {\n        verb = current.method.map(method => method.toLowerCase());\n      } else {\n        verb = current.method.toLowerCase();\n      }\n      // The key corresponds to firsts keys of the returned object\n      let key;\n      let tags;\n\n      if (controllerName.toLowerCase() === apiName && !_.isObject(routeTagConfig)) {\n        key = apiName;\n      } else if (routeTagConfig !== undefined) {\n        if (_.isObject(routeTagConfig)) {\n          const { name, plugin } = routeTagConfig;\n          const referencePlugin = !_.isEmpty(plugin);\n\n          key = referencePlugin ? `${plugin}-${name}` : name.toLowerCase();\n          tags = referencePlugin ? this.formatTag(plugin, name) : _.upperFirst(name);\n        } else {\n          key = routeTagConfig.toLowerCase();\n        }\n      } else {\n        key = 'unclassified';\n      }\n\n      const verbObject = {\n        deprecated: false,\n        description: this.generateVerbDescription(\n          verb,\n          current.handler,\n          key,\n          endPoint.split('/')[1],\n          _.get(current, 'config.description')\n        ),\n        responses: this.generateResponses(verb, current, key),\n        summary: '',\n        tags: _.isEmpty(tags) ? [_.upperFirst(key)] : [_.upperFirst(tags)],\n      };\n\n      // Swagger is not support key with ',' symbol, for array of methods need generate documentation for each method\n      if (Array.isArray(verb)) {\n        verb.forEach(method => {\n          _.set(acc, [key, 'paths', endPoint, method], verbObject);\n        });\n      } else {\n        _.set(acc, [key, 'paths', endPoint, verb], verbObject);\n      }\n\n      if (verb.includes('post') || verb.includes('put')) {\n        let requestBody;\n\n        if (controllerMethod === 'create' || controllerMethod === 'update') {\n          requestBody = {\n            description: '',\n            required: true,\n            content: {\n              'application/json': {\n                schema: {\n                  $ref: `#/components/schemas/New${_.upperFirst(key)}`,\n                },\n              },\n            },\n          };\n        } else {\n          requestBody = {\n            description: '',\n            required: true,\n            content: {\n              'application/json': {\n                schema: {\n                  properties: {\n                    foo: {\n                      type: 'string',\n                    },\n                  },\n                },\n              },\n            },\n          };\n        }\n\n        if (Array.isArray(verb)) {\n          verb.forEach(method => {\n            _.set(acc, [key, 'paths', endPoint, method, 'requestBody'], requestBody);\n          });\n        } else {\n          _.set(acc, [key, 'paths', endPoint, verb, 'requestBody'], requestBody);\n        }\n      }\n\n      // Refer to https://swagger.io/specification/#pathItemObject\n      const parameters = this.generateVerbParameters(verb, controllerMethod, current.path);\n\n      if (!verb.includes('post')) {\n        if (Array.isArray(verb)) {\n          verb.forEach(method => {\n            _.set(acc, [key, 'paths', endPoint, method, 'parameters'], parameters);\n          });\n        } else {\n          _.set(acc, [key, 'paths', endPoint, verb, 'parameters'], parameters);\n        }\n      }\n\n      return acc;\n    }, {});\n  },\n\n  generateFullDoc: function(version = this.getDocumentationVersion()) {\n    const apisDoc = this.retrieveDocumentationFiles(false, version);\n    const pluginsDoc = this.retrieveDocumentationFiles(true, version);\n    const appDoc = [...apisDoc, ...pluginsDoc];\n    const defaultSettings = _.cloneDeep(\n      _.pick(strapi.plugins.documentation.config, defaultSettingsKeys)\n    );\n    _.set(defaultSettings, ['info', 'x-generation-date'], moment().format('L LTS'));\n    _.set(defaultSettings, ['info', 'version'], version);\n    const tags = appDoc.reduce((acc, current) => {\n      const tags = current.tags.filter(el => {\n        return _.findIndex(acc, ['name', el.name || '']) === -1;\n      });\n\n      return acc.concat(tags);\n    }, []);\n    const fullDoc = _.merge(\n      appDoc.reduce((acc, current) => {\n        return _.merge(acc, current);\n      }, defaultSettings),\n      defaultComponents\n      // { tags },\n    );\n\n    fullDoc.tags = tags;\n\n    return fullDoc;\n  },\n  /**\n   * Generate the main component that has refs to sub components\n   * @param {Object} attributes\n   * @param {Array} associations\n   * @returns {Object}\n   */\n  generateMainComponent: function(attributes, associations) {\n    return Object.keys(attributes).reduce(\n      (acc, current) => {\n        const attribute = attributes[current];\n        // Refer to https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#dataTypes\n        const type = this.getType(attribute.type);\n        const {\n          description,\n          default: defaultValue,\n          minimum,\n          maxmimun,\n          maxLength,\n          minLength,\n          enum: enumeration,\n        } = attribute;\n\n        if (attribute.required === true) {\n          acc.required.push(current);\n        }\n\n        if (attribute.model || attribute.collection) {\n          const currentAssociation = associations.filter(\n            association => association.alias === current\n          )[0];\n          const relationNature = currentAssociation.nature;\n          const name = currentAssociation.model || currentAssociation.collection;\n          const getter =\n            currentAssociation.plugin !== undefined\n              ? currentAssociation.plugin === 'admin'\n                ? ['admin', 'models', name, 'attributes']\n                : ['plugins', currentAssociation.plugin, 'models', name, 'attributes']\n              : ['models', name.toLowerCase(), 'attributes'];\n          const associationAttributes = _.get(strapi, getter);\n          const associationSchema = this.generateAssociationSchema(associationAttributes, getter);\n\n          switch (relationNature) {\n            case 'manyToMany':\n            case 'oneToMany':\n            case 'manyToManyMorph':\n              acc.properties[current] = {\n                type: 'array',\n                items: associationSchema,\n              };\n              break;\n            default:\n              acc.properties[current] = associationSchema;\n          }\n        } else if (type === 'component') {\n          const { repeatable, component, min, max } = attribute;\n\n          const cmp = this.generateMainComponent(\n            strapi.components[component].attributes,\n            strapi.components[component].associations\n          );\n\n          if (repeatable) {\n            acc.properties[current] = {\n              type: 'array',\n              items: {\n                type: 'object',\n                ...cmp,\n              },\n              minItems: min,\n              maxItems: max,\n            };\n          } else {\n            acc.properties[current] = {\n              type: 'object',\n              ...cmp,\n              description,\n            };\n          }\n        } else if (type === 'dynamiczone') {\n          const { components, min, max } = attribute;\n\n          const cmps = components.map(component => {\n            const schema = this.generateMainComponent(\n              strapi.components[component].attributes,\n              strapi.components[component].associations\n            );\n\n            return _.merge(\n              {\n                properties: {\n                  __component: {\n                    type: 'string',\n                    enum: components,\n                  },\n                },\n              },\n              schema\n            );\n          });\n\n          acc.properties[current] = {\n            type: 'array',\n            items: {\n              oneOf: cmps,\n            },\n            minItems: min,\n            maxItems: max,\n          };\n        } else {\n          acc.properties[current] = {\n            type,\n            format: this.getFormat(attribute.type),\n            description,\n            default: defaultValue,\n            minimum,\n            maxmimun,\n            maxLength,\n            minLength,\n            enum: enumeration,\n          };\n        }\n\n        return acc;\n      },\n      { required: ['id'], properties: { id: { type: 'string' } } }\n    );\n  },\n\n  generatePluginDocumentation: function(pluginName, routes) {\n    return routes.reduce((acc, current) => {\n      const {\n        config: { description, prefix },\n      } = current;\n      const endPoint =\n        prefix === undefined\n          ? this.formatApiEndPoint(`/${pluginName}${current.path}`)\n          : this.formatApiEndPoint(`${prefix}${current.path}`);\n      let verb;\n\n      if (Array.isArray(current.method)) {\n        verb = current.method.map(method => method.toLowerCase());\n      } else {\n        verb = current.method.toLowerCase();\n      }\n\n      const actionType = _.get(current, ['config', 'tag', 'actionType'], '');\n      let key;\n      let tags;\n\n      if (_.isObject(current.config.tag)) {\n        const { name, plugin } = current.config.tag;\n        key = plugin ? `${plugin}-${name}` : name;\n        tags = plugin ? [this.formatTag(plugin, name)] : [name];\n      } else {\n        const tag = current.config.tag;\n        key = !_.isEmpty(tag) ? tag : 'unclassified';\n        tags = !_.isEmpty(tag) ? [tag] : ['Unclassified'];\n      }\n\n      const hasDefaultDocumentation = this.checkIfPluginDefaultDocumentFileExists(pluginName, key);\n      const defaultDocumentation = hasDefaultDocumentation\n        ? this.getPluginDefaultVerbDocumentation(pluginName, key, endPoint, verb)\n        : null;\n      const verbObject = {\n        deprecated: false,\n        description,\n        responses: this.generatePluginVerbResponses(current),\n        summary: '',\n        tags,\n      };\n\n      _.set(acc, [key, 'paths', endPoint, verb], verbObject);\n\n      const parameters = this.generateVerbParameters(\n        verb,\n        actionType,\n        `/${pluginName}${current.path}`\n      );\n\n      if (_.isEmpty(defaultDocumentation)) {\n        if (!verb.includes('post')) {\n          if (Array.isArray(verb)) {\n            verb.forEach(method => {\n              _.set(acc, [key, 'paths', endPoint, method, 'parameters'], parameters);\n            });\n          } else {\n            _.set(acc, [key, 'paths', endPoint, verb, 'parameters'], parameters);\n          }\n        }\n\n        if (verb.includes('post') || verb.includes('put')) {\n          let requestBody;\n\n          if (actionType === 'create' || actionType === 'update') {\n            const { name, plugin } = _.isObject(current.config.tag)\n              ? current.config.tag\n              : { tag: current.config.tag };\n            const $ref = plugin\n              ? `#/components/schemas/New${this.formatTag(plugin, name, true)}`\n              : `#/components/schemas/New${_.upperFirst(name)}`;\n            requestBody = {\n              description: '',\n              required: true,\n              content: {\n                'application/json': {\n                  schema: {\n                    $ref,\n                  },\n                },\n              },\n            };\n          } else {\n            requestBody = {\n              description: '',\n              required: true,\n              content: {\n                'application/json': {\n                  schema: {\n                    properties: {\n                      foo: {\n                        type: 'string',\n                      },\n                    },\n                  },\n                },\n              },\n            };\n          }\n\n          if (Array.isArray(verb)) {\n            verb.forEach(method => {\n              _.set(acc, [key, 'paths', endPoint, method, 'requestBody'], requestBody);\n            });\n          } else {\n            _.set(acc, [key, 'paths', endPoint, verb, 'requestBody'], requestBody);\n          }\n        }\n      }\n\n      return acc;\n    }, {});\n  },\n\n  generatePluginResponseSchema: function(tag) {\n    const { actionType, name, plugin } = _.isObject(tag) ? tag : { tag };\n    const getter = plugin ? ['plugins', plugin, 'models', name.toLowerCase()] : ['models', name];\n    const isModelRelated =\n      _.get(strapi, getter) !== undefined &&\n      ['find', 'findOne', 'create', 'search', 'update', 'destroy', 'count'].includes(actionType);\n    const $ref = plugin\n      ? `#/components/schemas/${this.formatTag(plugin, name, true)}`\n      : `#/components/schemas/${_.upperFirst(name)}`;\n\n    if (isModelRelated) {\n      switch (actionType) {\n        case 'find':\n          return {\n            type: 'array',\n            items: {\n              $ref,\n            },\n          };\n        case 'count':\n          return {\n            properties: {\n              count: {\n                type: 'integer',\n              },\n            },\n          };\n        case 'findOne':\n        case 'update':\n        case 'create':\n          return {\n            $ref,\n          };\n        default:\n          return {\n            properties: {\n              foo: {\n                type: 'string',\n              },\n            },\n          };\n      }\n    }\n\n    return {\n      properties: {\n        foo: {\n          type: 'string',\n        },\n      },\n    };\n  },\n\n  generatePluginVerbResponses: function(routeObject) {\n    const {\n      config: { tag },\n    } = routeObject;\n    const actionType = _.get(tag, 'actionType');\n    let schema;\n\n    if (!tag || !actionType) {\n      schema = {\n        properties: {\n          foo: {\n            type: 'string',\n          },\n        },\n      };\n    } else {\n      schema = this.generatePluginResponseSchema(tag);\n    }\n\n    const response = {\n      200: {\n        description: 'response',\n        content: {\n          'application/json': {\n            schema,\n          },\n        },\n      },\n      403: {\n        description: 'Forbidden',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      },\n      404: {\n        description: 'Not found',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      },\n    };\n\n    const { generateDefaultResponse } = strapi.plugins.documentation.config['x-strapi-config'];\n\n    if (generateDefaultResponse) {\n      response.default = {\n        description: 'unexpected error',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      };\n    }\n\n    return response;\n  },\n\n  /**\n   * Create the response object https://swagger.io/specification/#responsesObject\n   * @param {String} verb\n   * @param {Object} routeObject\n   * @param {String} tag\n   * @returns {Object}\n   */\n  generateResponses: function(verb, routeObject, tag) {\n    const endPoint = routeObject.path.split('/')[1];\n    const description = this.generateResponseDescription(verb, tag, endPoint);\n    const schema = this.generateResponseSchema(verb, routeObject, tag, endPoint);\n\n    const response = {\n      200: {\n        description,\n        content: {\n          'application/json': {\n            schema,\n          },\n        },\n      },\n      403: {\n        description: 'Forbidden',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      },\n      404: {\n        description: 'Not found',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      },\n    };\n\n    const { generateDefaultResponse } = strapi.plugins.documentation.config['x-strapi-config'];\n\n    if (generateDefaultResponse) {\n      response.default = {\n        description: 'unexpected error',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      };\n    }\n\n    return response;\n  },\n\n  /**\n   * Retrieve all privates attributes from a model\n   * @param {Object} attributes\n   */\n  getPrivateAttributes: function(attributes) {\n    const privateAttributes = Object.keys(attributes).reduce((acc, current) => {\n      if (attributes[current].private === true) {\n        acc.push(current);\n      }\n      return acc;\n    }, []);\n\n    return privateAttributes;\n  },\n\n  /**\n   * Create a component object with the model's attributes and relations\n   * Refer to https://swagger.io/docs/specification/components/\n   * @param {String} tag\n   * @returns {Object}\n   */\n  generateResponseComponent: function(tag, pluginName = '', isPlugin = false) {\n    // The component's name have to be capitalised\n    const [plugin, name] = isPlugin ? this.getModelAndNameForPlugin(tag, pluginName) : [null, null];\n    const upperFirstTag = isPlugin ? this.formatTag(plugin, name, true) : _.upperFirst(tag);\n    const attributesGetter = isPlugin\n      ? [...this.getModelForPlugin(tag, plugin), 'attributes']\n      : ['models', tag, 'attributes'];\n    const associationGetter = isPlugin\n      ? [...this.getModelForPlugin(tag, plugin), 'associations']\n      : ['models', tag, 'associations'];\n    const attributesObject = _.get(strapi, attributesGetter);\n    const privateAttributes = this.getPrivateAttributes(attributesObject);\n    const modelAssociations = _.get(strapi, associationGetter);\n    const { attributes } = this.getModelAttributes(attributesObject);\n    const associationsWithUpload = modelAssociations\n      .filter(association => {\n        return association.plugin === 'upload';\n      })\n      .map(obj => obj.alias);\n\n    // We always create two nested components from the main one\n    const mainComponent = this.generateMainComponent(attributes, modelAssociations, upperFirstTag);\n\n    // Get Component that doesn't display the privates attributes since a mask is applied\n    // Please refer https://github.com/strapi/strapi/blob/585800b7b98093f596759b296a43f89c491d4f4f/packages/strapi/lib/middlewares/mask/index.js#L92-L100\n    const getComponent = Object.keys(mainComponent.properties).reduce(\n      (acc, current) => {\n        if (privateAttributes.indexOf(current) === -1) {\n          acc.properties[current] = mainComponent.properties[current];\n        }\n        return acc;\n      },\n      { required: mainComponent.required, properties: {} }\n    );\n\n    // Special component only for POST || PUT verbs since the upload is made with a different route\n    const postComponent = Object.keys(mainComponent).reduce((acc, current) => {\n      if (current === 'required') {\n        const required = mainComponent.required.slice().filter(attr => {\n          return associationsWithUpload.indexOf(attr) === -1 && attr !== 'id' && attr !== '_id';\n        });\n\n        if (required.length > 0) {\n          acc.required = required;\n        }\n      }\n\n      if (current === 'properties') {\n        const properties = Object.keys(mainComponent.properties).reduce((acc, current) => {\n          if (\n            associationsWithUpload.indexOf(current) === -1 &&\n            current !== 'id' &&\n            current !== '_id'\n          ) {\n            // The post request shouldn't include nested relations of type 2\n            // For instance if a product has many tags\n            // we expect to find an array of tags objects containing other relations in the get response\n            // and since we use to getComponent to generate this one we need to\n            // remove this object since we only send an array of tag ids.\n            if (_.find(modelAssociations, ['alias', current])) {\n              const isArrayProperty =\n                _.get(mainComponent, ['properties', current, 'type']) !== undefined;\n\n              if (isArrayProperty) {\n                acc[current] = { type: 'array', items: { type: 'string' } };\n              } else {\n                acc[current] = { type: 'string' };\n              }\n            } else {\n              // If the field is not an association we take the one from the component\n              acc[current] = mainComponent.properties[current];\n            }\n          }\n\n          return acc;\n        }, {});\n\n        acc.properties = properties;\n      }\n\n      return acc;\n    }, {});\n\n    return {\n      components: {\n        schemas: {\n          [upperFirstTag]: getComponent,\n          [`New${upperFirstTag}`]: postComponent,\n        },\n      },\n    };\n  },\n\n  /**\n   * Generate a better description for a response when we can guess what's the user is going to retrieve\n   * @param {String} verb\n   * @param {String} tag\n   * @param {String} endPoint\n   * @returns {String}\n   */\n  generateResponseDescription: function(verb, tag, endPoint) {\n    const isModelRelated = strapi.models[tag] !== undefined && tag === endPoint;\n\n    if (Array.isArray(verb)) {\n      verb = verb.map(method => method.toLocaleLowerCase());\n    }\n\n    if (verb.includes('get') || verb.includes('put') || verb.includes('post')) {\n      return isModelRelated ? `Retrieve ${tag} document(s)` : 'response';\n    } else if (verb.includes('delete')) {\n      return isModelRelated\n        ? `deletes a single ${tag} based on the ID supplied`\n        : 'deletes a single record based on the ID supplied';\n    } else {\n      return 'response';\n    }\n  },\n\n  /**\n   * For each response generate its schema\n   * Its schema is either a component when we know what the routes returns otherwise, it returns a dummy schema\n   * that the user will modify later\n   * @param {String} verb\n   * @param {Object} route\n   * @param {String} tag\n   * @param {String} endPoint\n   * @returns {Object}\n   */\n  generateResponseSchema: function(verb, routeObject, tag) {\n    const { handler } = routeObject;\n    let [controller, handlerMethod] = handler.split('.');\n    let upperFirstTag = _.upperFirst(tag);\n\n    if (verb === 'delete') {\n      return {\n        type: 'integer',\n        format: 'int64',\n      };\n    }\n\n    // A tag key might be added to a route to tell if a custom endPoint in an api/<model>/config/routes.json\n    // Retrieves data from another model it is a faster way to generate the response\n    const routeReferenceTag = _.get(routeObject, ['config', 'tag']);\n    let isModelRelated = false;\n    const shouldCheckIfACustomEndPointReferencesAnotherModel =\n      _.isObject(routeReferenceTag) && !_.isEmpty(_.get(routeReferenceTag, 'name'));\n\n    if (shouldCheckIfACustomEndPointReferencesAnotherModel) {\n      const { actionType, name, plugin } = routeReferenceTag;\n      // A model could be in either a plugin or the api folder\n      // The path is different depending on the case\n      const getter = !_.isEmpty(plugin)\n        ? ['plugins', plugin, 'models', name.toLowerCase()]\n        : ['models', name.toLowerCase()];\n\n      // An actionType key might be added to the tag object to guide the algorithm is generating an automatic response\n      const isKnownAction = [\n        'find',\n        'findOne',\n        'create',\n        'search',\n        'update',\n        'destroy',\n        'count',\n      ].includes(actionType);\n\n      // Check if a route points to a model\n      isModelRelated = _.get(strapi, getter) !== undefined && isKnownAction;\n\n      if (isModelRelated && isKnownAction) {\n        // We need to change the handlerMethod name if it is know to generate the good schema\n        handlerMethod = actionType;\n\n        // This is to retrieve the correct component if a custom endpoints references a plugin model\n        if (!_.isEmpty(plugin)) {\n          upperFirstTag = this.formatTag(plugin, name, true);\n        }\n      }\n    } else {\n      // Normal way there's no tag object\n      isModelRelated = strapi.models[tag] !== undefined && tag === _.lowerCase(controller);\n    }\n\n    // We create a component when we are sure that we can 'guess' what's needed to be sent\n    // https://swagger.io/specification/#referenceObject\n    if (isModelRelated) {\n      switch (handlerMethod) {\n        case 'find':\n          return {\n            type: 'array',\n            items: {\n              $ref: `#/components/schemas/${upperFirstTag}`,\n            },\n          };\n        case 'count':\n          return {\n            properties: {\n              count: {\n                type: 'integer',\n              },\n            },\n          };\n        case 'findOne':\n        case 'update':\n        case 'create':\n          return {\n            $ref: `#/components/schemas/${upperFirstTag}`,\n          };\n        default:\n          return {\n            properties: {\n              foo: {\n                type: 'string',\n              },\n            },\n          };\n      }\n    }\n\n    return {\n      properties: {\n        foo: {\n          type: 'string',\n        },\n      },\n    };\n  },\n\n  generateTags: function(name, docName, tag = '', isPlugin = false) {\n    return [\n      {\n        name: isPlugin ? tag : _.upperFirst(docName),\n      },\n    ];\n  },\n\n  /**\n   * Add a default description when it's implied\n   *\n   * @param {String} verb\n   * @param {String} handler\n   * @param {String} tag\n   * @param {String} endPoint\n   * @returns {String}\n   */\n  generateVerbDescription: (verb, handler, tag, endPoint, description) => {\n    const isModelRelated = strapi.models[tag] !== undefined && tag === endPoint;\n\n    if (description) {\n      return description;\n    }\n\n    if (Array.isArray(verb)) {\n      const [, controllerMethod] = handler.split('.');\n\n      if ((verb.includes('get') && verb.includes('post')) || controllerMethod === 'findOrCreate') {\n        return `Find or create ${tag} record`;\n      }\n\n      if (\n        (verb.includes('put') && verb.includes('post')) ||\n        controllerMethod === 'createOrUpdate'\n      ) {\n        return `Create or update ${tag} record`;\n      }\n\n      return '';\n    }\n\n    switch (verb) {\n      case 'get': {\n        const [, controllerMethod] = handler.split('.');\n\n        if (isModelRelated) {\n          switch (controllerMethod) {\n            case 'count':\n              return `Retrieve the numver of ${tag} documents`;\n            case 'findOne':\n              return `Find one ${tag} record`;\n            case 'find':\n              return `Find all the ${tag}'s records`;\n            default:\n              return '';\n          }\n        }\n\n        return '';\n      }\n      case 'delete':\n        return isModelRelated ? `Delete a single ${tag} record` : 'Delete a record';\n      case 'post':\n        return isModelRelated ? `Create a new ${tag} record` : 'Create a new record';\n      case 'put':\n        return isModelRelated ? `Update a single ${tag} record` : 'Update a record';\n      case 'patch':\n        return '';\n      case 'head':\n        return '';\n      default:\n        return '';\n    }\n  },\n\n  /**\n   * Generate the verb parameters object\n   * Refer to https://swagger.io/specification/#pathItemObject\n   * @param {Sting} verb\n   * @param {String} controllerMethod\n   * @param {String} endPoint\n   */\n  generateVerbParameters: function(verb, controllerMethod, endPoint) {\n    const params = pathToRegexp\n      .parse(endPoint)\n      .filter(token => _.isObject(token))\n      .reduce((acc, current) => {\n        const param = {\n          name: current.name,\n          in: 'path',\n          description: '',\n          deprecated: false,\n          required: true,\n          schema: { type: 'string' },\n        };\n\n        return acc.concat(param);\n      }, []);\n\n    if (verb === 'get' && controllerMethod === 'find') {\n      // parametersOptions corresponds to this section\n      // of the documentation https://strapi.io/documentation/guides/filters.html\n      return [...params, ...parametersOptions];\n    }\n\n    return params;\n  },\n\n  /**\n   * Retrieve the apis in /api\n   * @returns {Array}\n   */\n  getApis: () => {\n    return Object.keys(strapi.api || {});\n  },\n\n  getAPIOverrideComponentsDocumentation: function(apiName, docName) {\n    try {\n      const documentation = JSON.parse(\n        fs.readFileSync(this.getAPIOverrideDocumentationPath(apiName, docName), 'utf8')\n      );\n\n      return _.get(documentation, 'components', null);\n    } catch (err) {\n      return null;\n    }\n  },\n\n  getAPIDefaultTagsDocumentation: function(name, docName) {\n    try {\n      const documentation = JSON.parse(\n        fs.readFileSync(this.getAPIOverrideDocumentationPath(name, docName), 'utf8')\n      );\n\n      return _.get(documentation, 'tags', null);\n    } catch (err) {\n      return null;\n    }\n  },\n\n  getAPIDefaultVerbDocumentation: function(apiName, docName, routePath, verb) {\n    try {\n      const documentation = JSON.parse(\n        fs.readFileSync(this.getAPIOverrideDocumentationPath(apiName, docName), 'utf8')\n      );\n\n      return _.get(documentation, ['paths', routePath, verb], null);\n    } catch (err) {\n      return null;\n    }\n  },\n\n  getAPIOverrideDocumentationPath: function(apiName, docName) {\n    return path.join(\n      strapi.config.appPath,\n      'api',\n      apiName,\n      'documentation',\n      'overrides',\n      this.getDocumentationVersion(),\n      `${docName}.json`\n    );\n  },\n\n  /**\n   * Given an api retrieve its endpoints\n   * @param {String}\n   * @returns {Array}\n   */\n  getApiRoutes: apiName => {\n    return _.get(strapi, ['api', apiName, 'config', 'routes'], []);\n  },\n\n  getDocumentationOverridesPath: function(apiName) {\n    return path.join(\n      strapi.config.appPath,\n      'api',\n      apiName,\n      'documentation',\n      this.getDocumentationVersion(),\n      'overrides'\n    );\n  },\n\n  /**\n   * Given an api from /api retrieve its version directory\n   * @param {String} apiName\n   * @returns {Path}\n   */\n  getDocumentationPath: function(apiName) {\n    return path.join(\n      strapi.config.appPath,\n      'api',\n      apiName,\n      'documentation',\n      this.getDocumentationVersion()\n    );\n  },\n\n  getFullDocumentationPath: () => {\n    return path.join(strapi.config.appPath, 'extensions', 'documentation', 'documentation');\n  },\n\n  /**\n   * Retrieve the plugin's configuration version\n   */\n  getDocumentationVersion: () => {\n    const version = strapi.plugins['documentation'].config.info.version;\n\n    return version;\n  },\n\n  /**\n   * Retrieve the documentation plugin documentation directory\n   */\n  getMergedDocumentationPath: function(version = this.getDocumentationVersion()) {\n    return path.join(\n      strapi.config.appPath,\n      'extensions',\n      'documentation',\n      'documentation',\n      version\n    );\n  },\n\n  /**\n   * Retrieve the model's attributes\n   * @param {Objet} modelAttributes\n   * @returns {Object} { associations: [{ name: 'foo', getter: [], tag: 'foos' }], attributes }\n   */\n  getModelAttributes: function(modelAttributes) {\n    const associations = [];\n    const attributes = Object.keys(modelAttributes)\n      .map(attr => {\n        const attribute = modelAttributes[attr];\n        const isField = !_.has(attribute, 'model') && !_.has(attribute, 'collection');\n\n        if (!isField) {\n          const name = attribute.model || attribute.collection;\n          const getter =\n            attribute.plugin !== undefined\n              ? ['plugins', attribute.plugin, 'models', name, 'attributes']\n              : ['models', name, 'attributes'];\n          associations.push({ name, getter, tag: attr });\n        }\n\n        return attr;\n      })\n      .reduce((acc, current) => {\n        acc[current] = modelAttributes[current];\n\n        return acc;\n      }, {});\n\n    return { associations, attributes };\n  },\n\n  /**\n   * Refer to https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#dataTypes\n   * @param {String} type\n   * @returns {String}\n   */\n  getType: type => {\n    switch (type) {\n      case 'string':\n      case 'byte':\n      case 'binary':\n      case 'password':\n      case 'email':\n      case 'text':\n      case 'enumeration':\n      case 'date':\n      case 'datetime':\n      case 'time':\n      case 'richtext':\n        return 'string';\n      case 'float':\n      case 'decimal':\n      case 'double':\n        return 'number';\n      case 'integer':\n      case 'biginteger':\n      case 'long':\n        return 'integer';\n      case 'json':\n        return 'object';\n      default:\n        return type;\n    }\n  },\n\n  /**\n   * Refer to https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#dataTypes\n   * @param {String} type\n   * @returns {String}\n   */\n  getFormat: type => {\n    switch (type) {\n      case 'date':\n        return 'date';\n      case 'datetime':\n        return 'date-time';\n      case 'password':\n        return 'password';\n      default:\n        return undefined;\n    }\n  },\n\n  getPluginDefaultVerbDocumentation: function(pluginName, docName, routePath, verb) {\n    try {\n      const documentation = JSON.parse(\n        fs.readFileSync(this.getPluginOverrideDocumentationPath(pluginName, docName), 'utf8')\n      );\n\n      return _.get(documentation, ['paths', routePath, verb], null);\n    } catch (err) {\n      return null;\n    }\n  },\n\n  getPluginDefaultTagsDocumentation: function(pluginName, docName) {\n    try {\n      const documentation = JSON.parse(\n        fs.readFileSync(this.getPluginOverrideDocumentationPath(pluginName, docName), 'utf8')\n      );\n\n      return _.get(documentation, ['tags'], null);\n    } catch (err) {\n      return null;\n    }\n  },\n\n  getPluginOverrideComponents: function(pluginName, docName) {\n    try {\n      const documentation = JSON.parse(\n        fs.readFileSync(this.getPluginOverrideDocumentationPath(pluginName, docName), 'utf8')\n      );\n\n      return _.get(documentation, 'components', null);\n    } catch (err) {\n      return null;\n    }\n  },\n\n  getPluginOverrideDocumentationPath: function(pluginName, docName) {\n    const defaultPath = path.join(\n      strapi.config.appPath,\n      'extensions',\n      pluginName,\n      'documentation',\n      this.getDocumentationVersion(),\n      'overrides'\n    );\n\n    if (docName) {\n      return path.resolve(defaultPath, `${docName.json}`);\n    } else {\n      return defaultPath;\n    }\n  },\n\n  /**\n   * Given a plugin retrieve its documentation version\n   */\n  getPluginDocumentationPath: function(pluginName) {\n    return path.join(\n      strapi.config.appPath,\n      'extensions',\n      pluginName,\n      'documentation',\n      this.getDocumentationVersion()\n    );\n  },\n\n  /**\n   * Retrieve all plugins that have a description inside one of its route\n   * @return {Arrray}\n   */\n  getPluginsWithDocumentationNeeded: function() {\n    return Object.keys(strapi.plugins).reduce((acc, current) => {\n      const isDocumentationNeeded = this.isPluginDocumentationNeeded(current);\n\n      if (isDocumentationNeeded) {\n        return acc.concat(current);\n      }\n\n      return acc;\n    }, []);\n  },\n\n  /**\n   * Retrieve all the routes that have a description from a plugin\n   * @param {String} pluginName\n   * @returns {Array}\n   */\n  getPluginRoutesWithDescription: function(pluginName) {\n    return _.get(strapi, ['plugins', pluginName, 'config', 'routes'], []).filter(\n      route => _.get(route, ['config', 'description']) !== undefined\n    );\n  },\n\n  /**\n   * Given a string and a pluginName retrieve the model and the pluginName\n   * @param {String} string\n   * @param {Sting} pluginName\n   * @returns {Array}\n   */\n  getModelAndNameForPlugin: (string, pluginName) => {\n    return _.replace(string, `${pluginName}-`, `${pluginName}.`).split('.');\n  },\n\n  /**\n   * Retrieve the path needed to get a model from a plugin\n   * @param (String) string\n   * @param {String} plugin\n   * @returns {Array}\n   */\n  getModelForPlugin: function(string, pluginName) {\n    const [plugin, model] = this.getModelAndNameForPlugin(string, pluginName);\n\n    return ['plugins', plugin, 'models', _.lowerCase(model)];\n  },\n\n  /**\n   * Check whether or not a plugin needs documentation\n   * @param {String} pluginName\n   * @returns {Boolean}\n   */\n  isPluginDocumentationNeeded: function(pluginName) {\n    const { pluginsForWhichToGenerateDoc } = strapi.plugins.documentation.config['x-strapi-config'];\n    if (\n      Array.isArray(pluginsForWhichToGenerateDoc) &&\n      !pluginsForWhichToGenerateDoc.includes(pluginName)\n    ) {\n      return false;\n    } else {\n      return this.getPluginRoutesWithDescription(pluginName).length > 0;\n    }\n  },\n\n  /**\n   * Merge two components by replacing the default ones by the overides and keeping the others\n   * @param {Object} initObj\n   * @param {Object} srcObj\n   * @returns {Object}\n   */\n  mergeComponents: (initObj, srcObj) => {\n    const cleanedObj = Object.keys(_.get(initObj, 'schemas', {})).reduce((acc, current) => {\n      const targetObj = _.has(_.get(srcObj, ['schemas'], {}), current) ? srcObj : initObj;\n\n      _.set(acc, ['schemas', current], _.get(targetObj, ['schemas', current], {}));\n\n      return acc;\n    }, {});\n\n    return _.merge(cleanedObj, srcObj);\n  },\n\n  mergePaths: function(initObj, srcObj) {\n    return Object.keys(initObj.paths).reduce((acc, current) => {\n      if (_.has(_.get(srcObj, ['paths'], {}), current)) {\n        const verbs = Object.keys(initObj.paths[current]).reduce((acc1, curr) => {\n          const verb = this.mergeVerbObject(\n            initObj.paths[current][curr],\n            _.get(srcObj, ['paths', current, curr], {})\n          );\n          _.set(acc1, [curr], verb);\n\n          return acc1;\n        }, {});\n        _.set(acc, ['paths', current], verbs);\n      } else {\n        _.set(acc, ['paths', current], _.get(initObj, ['paths', current], {}));\n      }\n\n      return acc;\n    }, {});\n  },\n\n  mergeTags: (initObj, srcObj) => {\n    return _.get(srcObj, 'tags', _.get(initObj, 'tags', []));\n  },\n\n  /**\n   * Merge two verb objects with a customizer\n   * @param {Object} initObj\n   * @param {Object} srcObj\n   * @returns {Object}\n   */\n  mergeVerbObject: function(initObj, srcObj) {\n    return _.mergeWith(initObj, srcObj, (objValue, srcValue) => {\n      if (_.isPlainObject(objValue)) {\n        return Object.assign(objValue, srcValue);\n      }\n\n      return srcValue;\n    });\n  },\n\n  retrieveDocumentation: function(name, isPlugin = false) {\n    const documentationPath = isPlugin\n      ? [strapi.config.appPath, 'extensions', name, 'documentation', this.getDocumentationVersion()]\n      : [strapi.config.appPath, 'api', name, 'documentation', this.getDocumentationVersion()];\n\n    try {\n      const documentationFiles = fs\n        .readdirSync(path.resolve(documentationPath.join('/')))\n        .filter(el => el.includes('.json'));\n\n      return documentationFiles.reduce((acc, current) => {\n        try {\n          const doc = JSON.parse(\n            fs.readFileSync(path.resolve([...documentationPath, current].join('/')), 'utf8')\n          );\n          acc.push(doc);\n        } catch (err) {\n          // console.log(path.resolve([...documentationPath, current].join('/')), err);\n        }\n\n        return acc;\n      }, []);\n    } catch (err) {\n      return [];\n    }\n  },\n\n  /**\n   * Retrieve all documentation files from either the APIs or the plugins\n   * @param {Boolean} isPlugin\n   * @returns {Array}\n   */\n  retrieveDocumentationFiles: function(isPlugin = false, version = this.getDocumentationVersion()) {\n    const array = isPlugin ? this.getPluginsWithDocumentationNeeded() : this.getApis();\n\n    return array.reduce((acc, current) => {\n      const documentationPath = isPlugin\n        ? [strapi.config.appPath, 'extensions', current, 'documentation', version]\n        : [strapi.config.appPath, 'api', current, 'documentation', version];\n\n      try {\n        const documentationFiles = fs\n          .readdirSync(path.resolve(documentationPath.join('/')))\n          .filter(el => el.includes('.json'));\n\n        documentationFiles.forEach(el => {\n          try {\n            let documentation = JSON.parse(\n              fs.readFileSync(path.resolve([...documentationPath, el].join('/')), 'utf8')\n            );\n            /* eslint-disable indent */\n            const overrideDocumentationPath = isPlugin\n              ? path.resolve(\n                  strapi.config.appPath,\n                  'extensions',\n                  current,\n                  'documentation',\n                  version,\n                  'overrides',\n                  el\n                )\n              : path.resolve(\n                  strapi.config.appPath,\n                  'api',\n                  current,\n                  'documentation',\n                  version,\n                  'overrides',\n                  el\n                );\n            /* eslint-enable indent */\n            let overrideDocumentation;\n\n            try {\n              overrideDocumentation = JSON.parse(\n                fs.readFileSync(overrideDocumentationPath, 'utf8')\n              );\n            } catch (err) {\n              overrideDocumentation = null;\n            }\n\n            if (!_.isEmpty(overrideDocumentation)) {\n              documentation.paths = this.mergePaths(documentation, overrideDocumentation).paths;\n              documentation.tags = _.cloneDeep(\n                this.mergeTags(documentation, overrideDocumentation)\n              );\n              const documentationComponents = _.get(documentation, 'components', {});\n              const overrideComponents = _.get(overrideDocumentation, 'components', {});\n              const mergedComponents = this.mergeComponents(\n                documentationComponents,\n                overrideComponents\n              );\n\n              if (!_.isEmpty(mergedComponents)) {\n                documentation.components = mergedComponents;\n              }\n            }\n\n            acc.push(documentation);\n          } catch (err) {\n            strapi.log.error(err);\n            console.log(\n              `Unable to access the documentation for ${[...documentationPath, el].join('/')}`\n            );\n          }\n        });\n      } catch (err) {\n        strapi.log.error(err);\n        console.log(\n          `Unable to retrieve documentation for the ${isPlugin ? 'plugin' : 'api'} ${current}`\n        );\n      }\n\n      return acc;\n    }, []);\n  },\n\n  retrieveDocumentationVersions: function() {\n    return fs\n      .readdirSync(this.getFullDocumentationPath())\n      .map(version => {\n        try {\n          const doc = JSON.parse(\n            fs.readFileSync(\n              path.resolve(this.getFullDocumentationPath(), version, 'full_documentation.json')\n            )\n          );\n          const generatedDate = _.get(doc, ['info', 'x-generation-date'], null);\n\n          return { version, generatedDate, url: '' };\n        } catch (err) {\n          return null;\n        }\n      })\n      .filter(x => x);\n  },\n\n  retrieveFrontForm: async function() {\n    const config = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'documentation',\n        key: 'config',\n      })\n      .get();\n    const forms = JSON.parse(JSON.stringify(form));\n\n    _.set(forms, [0, 0, 'value'], config.restrictedAccess);\n    _.set(forms, [0, 1, 'value'], config.password || '');\n\n    return forms;\n  },\n};\n",
    "packages/strapi-plugin-email/controllers/Email.js": "'use strict';\n\n/**\n * Email.js controller\n *\n * @description: A set of functions called \"actions\" of the `email` plugin.\n */\nmodule.exports = {\n  send: async ctx => {\n    let options = ctx.request.body;\n    try {\n      await strapi.plugins.email.services.email.send(options);\n    } catch (e) {\n      if (e.statusCode === 400) {\n        return ctx.badRequest(e.message);\n      } else {\n        throw new Error(`Couldn't send email: ${e.message}.`);\n      }\n    }\n\n    // Send 200 `ok`\n    ctx.send({});\n  },\n};\n",
    "packages/strapi-plugin-graphql/hooks/graphql/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst _ = require('lodash');\nconst { ApolloServer } = require('apollo-server-koa');\nconst depthLimit = require('graphql-depth-limit');\nconst { graphqlUploadKoa } = require('graphql-upload');\nconst loadConfigs = require('./load-config');\n\nconst attachMetadataToResolvers = (schema, { api, plugin }) => {\n  const { resolver = {} } = schema;\n  if (_.isEmpty(resolver)) return schema;\n\n  Object.keys(resolver).forEach(type => {\n    if (!_.isPlainObject(resolver[type])) return;\n\n    Object.keys(resolver[type]).forEach(resolverName => {\n      if (!_.isPlainObject(resolver[type][resolverName])) return;\n\n      resolver[type][resolverName]['_metadatas'] = {\n        api,\n        plugin,\n      };\n    });\n  });\n\n  return schema;\n};\n\nmodule.exports = strapi => {\n  const { appPath, installedPlugins } = strapi.config;\n\n  return {\n    async beforeInitialize() {\n      // Try to inject this hook just after the others hooks to skip the router processing.\n      if (!strapi.config.get('hook.load.after')) {\n        _.set(strapi.config.hook.load, 'after', []);\n      }\n\n      strapi.config.hook.load.after.push('graphql');\n      // Load core utils.\n\n      const { api, plugins, extensions } = await loadConfigs({\n        appPath,\n        installedPlugins,\n      });\n      _.merge(strapi, { api, plugins });\n\n      /*\n       * Create a merge of all the GraphQL configuration.\n       */\n      const apisSchemas = Object.keys(strapi.api || {}).map(key => {\n        const schema = _.get(strapi.api[key], 'config.schema.graphql', {});\n        return attachMetadataToResolvers(schema, { api: key });\n      });\n\n      const pluginsSchemas = Object.keys(strapi.plugins || {}).map(key => {\n        const schema = _.get(strapi.plugins[key], 'config.schema.graphql', {});\n        return attachMetadataToResolvers(schema, { plugin: key });\n      });\n\n      const extensionsSchemas = Object.keys(extensions || {}).map(key => {\n        const schema = _.get(extensions[key], 'config.schema.graphql', {});\n        return attachMetadataToResolvers(schema, { plugin: key });\n      });\n\n      const baseSchema = mergeSchemas([...apisSchemas, ...pluginsSchemas, ...extensionsSchemas]);\n\n      // save the final schema in the plugin's config\n      _.set(strapi, ['plugins', 'graphql', 'config', '_schema', 'graphql'], baseSchema);\n    },\n\n    initialize() {\n      const schema = strapi.plugins.graphql.services['schema-generator'].generateSchema();\n\n      if (_.isEmpty(schema)) {\n        strapi.log.warn('The GraphQL schema has not been generated because it is empty');\n\n        return;\n      }\n\n      const config = _.get(strapi.plugins.graphql, 'config', {});\n\n      // TODO: Remove these deprecated options in favor of `apolloServer` in the next major version\n      const deprecatedApolloServerConfig = {\n        tracing: _.get(config, 'tracing', false),\n        introspection: _.get(config, 'introspection', true),\n        engine: _.get(config, 'engine', false),\n      };\n\n      if (['tracing', 'introspection', 'engine'].some(key => _.has(config, key))) {\n        strapi.log.warn(\n          'The `tracing`, `introspection` and `engine` options are deprecated in favor of the `apolloServer` object and they will be removed in the next major version.'\n        );\n      }\n\n      const apolloServerConfig = _.get(config, 'apolloServer', {});\n\n      const serverParams = {\n        schema,\n        uploads: false,\n        context: ({ ctx }) => {\n          // Initiliase loaders for this request.\n          // TODO: set loaders in the context not globally\n\n          strapi.plugins.graphql.services['data-loaders'].initializeLoader();\n\n          return {\n            context: ctx,\n          };\n        },\n        formatError: err => {\n          const formatError = _.get(config, 'formatError', null);\n\n          return typeof formatError === 'function' ? formatError(err) : err;\n        },\n        validationRules: [depthLimit(config.depthLimit)],\n        playground: false,\n        cors: false,\n        bodyParserConfig: true,\n        // TODO: Remove these deprecated options in favor of `apolloServerConfig` in the next major version\n        ...deprecatedApolloServerConfig,\n        ...apolloServerConfig,\n      };\n\n      // Disable GraphQL Playground in production environment.\n      if (strapi.config.environment !== 'production' || config.playgroundAlways) {\n        serverParams.playground = {\n          endpoint: `${strapi.config.server.url}${config.endpoint}`,\n          shareEnabled: config.shareEnabled,\n        };\n      }\n\n      const server = new ApolloServer(serverParams);\n\n      const uploadMiddleware = graphqlUploadKoa();\n      strapi.app.use((ctx, next) => {\n        if (ctx.path === config.endpoint) {\n          return uploadMiddleware(ctx, next);\n        }\n\n        return next();\n      });\n      server.applyMiddleware({\n        app: strapi.app,\n        path: config.endpoint,\n      });\n\n      strapi.plugins.graphql.destroy = async () => {\n        await server.stop();\n      };\n    },\n  };\n};\n\n/**\n * Merges a  list of schemas\n * @param {Array<Object>} schemas - The list of schemas to merge\n */\nconst mergeSchemas = schemas => {\n  return schemas.reduce((acc, el) => {\n    const { definition, query, mutation, type, resolver } = el;\n\n    return _.merge(acc, {\n      definition: `${acc.definition || ''} ${definition || ''}`,\n      query: `${acc.query || ''} ${query || ''}`,\n      mutation: `${acc.mutation || ''} ${mutation || ''}`,\n      type,\n      resolver,\n    });\n  }, {});\n};\n",
    "packages/strapi-plugin-graphql/hooks/graphql/load-config.js": "'use strict';\n\n// eslint-disable-next-line node/no-extraneous-require\nconst loadUtils = require('strapi/lib/load');\nconst _ = require('lodash');\n\nconst loadApisGraphqlConfig = appPath =>\n  loadUtils.loadFiles(appPath, 'api/**/config/*.graphql?(.js)');\n\nconst loadPluginsGraphqlConfig = async installedPlugins => {\n  const root = {};\n\n  for (let pluginName of installedPlugins) {\n    const pluginDir = loadUtils.findPackagePath(`strapi-plugin-${pluginName}`);\n\n    const result = await loadUtils.loadFiles(pluginDir, 'config/*.graphql?(.js)');\n\n    _.set(root, ['plugins', pluginName], result);\n  }\n\n  return root;\n};\n\nconst loadLocalPluginsGraphqlConfig = async appPath =>\n  loadUtils.loadFiles(appPath, 'plugins/**/config/*.graphql?(.js)');\n\nconst loadExtensions = async appPath =>\n  loadUtils.loadFiles(appPath, 'extensions/**/config/*.graphql?(.js)');\n\n/**\n * Loads the graphql config files\n */\nmodule.exports = async ({ appPath, installedPlugins }) => {\n  const [apis, plugins, localPlugins, extensions] = await Promise.all([\n    loadApisGraphqlConfig(appPath),\n    loadPluginsGraphqlConfig(installedPlugins),\n    loadLocalPluginsGraphqlConfig(appPath),\n    loadExtensions(appPath),\n  ]);\n\n  return _.merge({}, apis, plugins, extensions, localPlugins);\n};\n",
    "packages/strapi-plugin-graphql/services/build-aggregation.js": "/**\n * Aggregator.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\n\n'use strict';\n\nconst _ = require('lodash');\nconst pluralize = require('pluralize');\nconst { convertRestQueryParams, buildQuery } = require('strapi-utils');\n\nconst { buildQuery: buildQueryResolver } = require('./resolvers-builder');\nconst { convertToParams, convertToQuery, nonRequired } = require('./utils');\nconst { toSDL } = require('./schema-definitions');\n\n/**\n * Returns all fields of type primitive\n *\n * @returns {Boolean}\n */\nconst isPrimitiveType = type => {\n  const nonRequiredType = nonRequired(type);\n  return (\n    nonRequiredType === 'Int' ||\n    nonRequiredType === 'Float' ||\n    nonRequiredType === 'String' ||\n    nonRequiredType === 'Boolean' ||\n    nonRequiredType === 'DateTime' ||\n    nonRequiredType === 'JSON'\n  );\n};\n\n/**\n * Checks if the field is of type enum\n *\n * @returns {Boolean}\n */\nconst isEnumType = type => {\n  return type === 'enumeration';\n};\n\n/**\n * Returns all fields that are not of type array\n *\n * @returns {Boolean}\n *\n * @example\n *\n * isNotOfTypeArray([String])\n * // => false\n * isNotOfTypeArray(String!)\n * // => true\n */\nconst isNotOfTypeArray = type => {\n  return !/(\\[\\w+!?\\])/.test(type);\n};\n\n/**\n * Returns all fields of type Integer or float\n */\nconst isNumberType = type => {\n  const nonRequiredType = nonRequired(type);\n  return nonRequiredType === 'Int' || nonRequiredType === 'Float';\n};\n\n/**\n * Returns a list of fields that have type included in fieldTypes.\n */\nconst getFieldsByTypes = (fields, typeCheck, returnType) => {\n  return _.reduce(\n    fields,\n    (acc, fieldType, fieldName) => {\n      if (typeCheck(fieldType)) {\n        acc[fieldName] = returnType(fieldType, fieldName);\n      }\n      return acc;\n    },\n    {}\n  );\n};\n\n/**\n * Use the field resolver otherwise fall through the field value\n *\n * @returns {function}\n */\nconst fieldResolver = (field, key) => {\n  return object => {\n    const resolver =\n      field.resolve ||\n      function resolver(obj) {\n        // eslint-disable-line no-unused-vars\n        return obj[key];\n      };\n    return resolver(object);\n  };\n};\n\n/**\n * Create fields resolvers\n *\n * @return {Object}\n */\nconst createFieldsResolver = function(fields, resolverFn, typeCheck) {\n  const resolver = Object.keys(fields).reduce((acc, fieldKey) => {\n    const field = fields[fieldKey];\n    // Check if the field is of the correct type\n    if (typeCheck(field)) {\n      return _.set(acc, fieldKey, (obj, options, context) => {\n        return resolverFn(\n          obj,\n          options,\n          context,\n          fieldResolver(field, fieldKey),\n          fieldKey,\n          obj,\n          field\n        );\n      });\n    }\n    return acc;\n  }, {});\n\n  return resolver;\n};\n\n/**\n * Convert non-primitive type to string (non-primitive types corresponds to a reference to an other model)\n *\n * @returns {String}\n *\n * @example\n *\n * extractType(String!)\n * // => String\n *\n * extractType(user)\n * // => ID\n *\n * extractType(ENUM_TEST_FIELD, enumeration)\n * // => String\n *\n */\nconst extractType = function(_type, attributeType) {\n  return isPrimitiveType(_type)\n    ? _type.replace('!', '')\n    : isEnumType(attributeType)\n    ? 'String'\n    : 'ID';\n};\n\n/**\n * Create the resolvers for each aggregation field\n *\n * @return {Object}\n *\n * @example\n *\n * const model = // Strapi model\n *\n * const fields = {\n *   username: String,\n *   age: Int,\n * }\n *\n * const typeCheck = (type) => type === 'Int' || type === 'Float',\n *\n * const fieldsResoler = createAggregationFieldsResolver(model, fields, 'sum', typeCheck);\n *\n * // => {\n *   age: function ageResolver() { .... }\n * }\n */\nconst createAggregationFieldsResolver = function(model, fields, operation, typeCheck) {\n  return createFieldsResolver(\n    fields,\n    async (obj, options, context, fieldResolver, fieldKey) => {\n      const filters = convertRestQueryParams({\n        ...convertToParams(_.omit(obj, 'where')),\n        ...convertToQuery(obj.where),\n      });\n\n      if (model.orm === 'mongoose') {\n        return buildQuery({ model, filters, aggregate: true })\n          .group({\n            _id: null,\n            [fieldKey]: { [`$${operation}`]: `$${fieldKey}` },\n          })\n          .exec()\n          .then(result => _.get(result, [0, fieldKey]));\n      }\n\n      if (model.orm === 'bookshelf') {\n        return model\n          .query(qb => {\n            // apply filters\n            buildQuery({ model, filters })(qb);\n\n            // `sum, avg, min, max` pass nicely to knex :->\n            qb[operation](`${fieldKey} as ${operation}_${fieldKey}`);\n          })\n          .fetch()\n          .then(result => result.get(`${operation}_${fieldKey}`));\n      }\n    },\n    typeCheck\n  );\n};\n\n/**\n * Correctly format the data returned by the group by\n */\nconst preProcessGroupByData = function({ result, fieldKey, filters }) {\n  const _result = _.toArray(result).filter(value => Boolean(value._id));\n  return _.map(_result, value => {\n    return {\n      key: value._id.toString(),\n      connection: () => {\n        // filter by the grouped by value in next connection\n\n        return {\n          ...filters,\n          where: {\n            ...(filters.where || {}),\n            [fieldKey]: value._id.toString(),\n          },\n        };\n      },\n    };\n  });\n};\n\n/**\n * Create the resolvers for each group by field\n *\n * @return {Object}\n *\n * @example\n *\n * const model = // Strapi model\n * const fields = {\n *   username: [UserConnectionUsername],\n *   email: [UserConnectionEmail],\n * }\n * const fieldsResoler = createGroupByFieldsResolver(model, fields);\n *\n * // => {\n *   username: function usernameResolver() { .... }\n *   email: function emailResolver() { .... }\n * }\n */\nconst createGroupByFieldsResolver = function(model, fields) {\n  const resolver = async (filters, options, context, fieldResolver, fieldKey) => {\n    const params = convertRestQueryParams({\n      ...convertToParams(_.omit(filters, 'where')),\n      ...convertToQuery(filters.where),\n    });\n\n    if (model.orm === 'mongoose') {\n      const result = await buildQuery({\n        model,\n        filters: params,\n        aggregate: true,\n      }).group({\n        _id: `$${fieldKey === 'id' ? model.primaryKey : fieldKey}`,\n      });\n\n      return preProcessGroupByData({\n        result,\n        fieldKey,\n        filters,\n      });\n    }\n\n    if (model.orm === 'bookshelf') {\n      return model\n        .query(qb => {\n          buildQuery({ model, filters: params })(qb);\n          qb.groupBy(fieldKey);\n          qb.select(fieldKey);\n        })\n        .fetchAll()\n        .then(result => {\n          let values = result.models\n            .map(m => m.get(fieldKey)) // extract aggregate field\n            .filter(v => !!v) // remove null\n            .map(v => '' + v); // convert to string\n          return values.map(v => ({\n            key: v,\n            connection: () => {\n              return {\n                ..._.omit(filters, ['limit']), // we shouldn't carry limit to sub-field\n                where: {\n                  ...(filters.where || {}),\n                  [fieldKey]: v,\n                },\n              };\n            },\n          }));\n        });\n    }\n  };\n\n  return createFieldsResolver(fields, resolver, () => true);\n};\n/**\n * Generate the connection type of each non-array field of the model\n *\n * @return {String}\n */\nconst generateConnectionFieldsTypes = function(fields, model) {\n  const { globalId, attributes } = model;\n  const primitiveFields = getFieldsByTypes(fields, isNotOfTypeArray, (type, name) =>\n    extractType(type, (attributes[name] || {}).type)\n  );\n\n  const connectionFields = _.mapValues(primitiveFields, fieldType => ({\n    key: fieldType,\n    connection: `${globalId}Connection`,\n  }));\n\n  return Object.keys(primitiveFields)\n    .map(\n      fieldKey =>\n        `type ${globalId}Connection${_.upperFirst(fieldKey)} {${toSDL(connectionFields[fieldKey])}}`\n    )\n    .join('\\n\\n');\n};\n\nconst formatConnectionGroupBy = function(fields, model) {\n  const { globalId } = model;\n  const groupByGlobalId = `${globalId}GroupBy`;\n\n  // Extract all primitive fields and change their types\n  const groupByFields = getFieldsByTypes(\n    fields,\n    isNotOfTypeArray,\n    (fieldType, fieldName) => `[${globalId}Connection${_.upperFirst(fieldName)}]`\n  );\n\n  // Get the generated field types\n  let groupByTypes = `type ${groupByGlobalId} {${toSDL(groupByFields)}}\\n\\n`;\n  groupByTypes += generateConnectionFieldsTypes(fields, model);\n\n  return {\n    globalId: groupByGlobalId,\n    type: groupByTypes,\n    resolver: {\n      [groupByGlobalId]: createGroupByFieldsResolver(model, groupByFields),\n    },\n  };\n};\n\nconst formatConnectionAggregator = function(fields, model, modelName) {\n  const { globalId } = model;\n\n  // Extract all fields of type Integer and Float and change their type to Float\n  const numericFields = getFieldsByTypes(fields, isNumberType, () => 'Float');\n\n  // Don't create an aggregator field if the model has not number fields\n  const aggregatorGlobalId = `${globalId}Aggregator`;\n  const initialFields = {\n    count: 'Int',\n    totalCount: 'Int',\n  };\n\n  // Only add the aggregator's operations if there are some numeric fields\n  if (!_.isEmpty(numericFields)) {\n    ['sum', 'avg', 'min', 'max'].forEach(agg => {\n      initialFields[agg] = `${aggregatorGlobalId}${_.startCase(agg)}`;\n    });\n  }\n\n  const gqlNumberFormat = toSDL(numericFields);\n  let aggregatorTypes = `type ${aggregatorGlobalId} {${toSDL(initialFields)}}\\n\\n`;\n\n  let resolvers = {\n    [aggregatorGlobalId]: {\n      count(obj) {\n        const opts = convertToQuery(obj.where);\n\n        if (opts._q) {\n          // allow search param\n          return strapi.query(modelName, model.plugin).countSearch(opts);\n        }\n        return strapi.query(modelName, model.plugin).count(opts);\n      },\n      totalCount() {\n        return strapi.query(modelName, model.plugin).count({});\n      },\n    },\n  };\n\n  // Only add the aggregator's operations types and resolver if there are some numeric fields\n  if (!_.isEmpty(numericFields)) {\n    // Returns the actual object and handle aggregation in the query resolvers\n    const defaultAggregatorFunc = obj => {\n      // eslint-disable-line no-unused-vars\n      return obj;\n    };\n\n    aggregatorTypes += `type ${aggregatorGlobalId}Sum {${gqlNumberFormat}}\\n\\n`;\n    aggregatorTypes += `type ${aggregatorGlobalId}Avg {${gqlNumberFormat}}\\n\\n`;\n    aggregatorTypes += `type ${aggregatorGlobalId}Min {${gqlNumberFormat}}\\n\\n`;\n    aggregatorTypes += `type ${aggregatorGlobalId}Max {${gqlNumberFormat}}\\n\\n`;\n\n    _.merge(resolvers[aggregatorGlobalId], {\n      sum: defaultAggregatorFunc,\n      avg: defaultAggregatorFunc,\n      min: defaultAggregatorFunc,\n      max: defaultAggregatorFunc,\n    });\n\n    resolvers = {\n      ...resolvers,\n      [`${aggregatorGlobalId}Sum`]: createAggregationFieldsResolver(\n        model,\n        fields,\n        'sum',\n        isNumberType\n      ),\n      [`${aggregatorGlobalId}Avg`]: createAggregationFieldsResolver(\n        model,\n        fields,\n        'avg',\n        isNumberType\n      ),\n      [`${aggregatorGlobalId}Min`]: createAggregationFieldsResolver(\n        model,\n        fields,\n        'min',\n        isNumberType\n      ),\n      [`${aggregatorGlobalId}Max`]: createAggregationFieldsResolver(\n        model,\n        fields,\n        'max',\n        isNumberType\n      ),\n    };\n  }\n\n  return {\n    globalId: aggregatorGlobalId,\n    type: aggregatorTypes,\n    resolver: resolvers,\n  };\n};\n\n/**\n * This method is the entry point to the GraphQL's Aggregation.\n * It takes as param the model and its fields and it'll create the aggregation types and resolver to it\n * Example:\n *  type User {\n *     username: String,\n *     age: Int,\n *  }\n *\n * It'll create\n *  type UserConnection {\n *    values: [User],\n *    groupBy: UserGroupBy,\n *    aggreate: UserAggregate\n *  }\n *\n *  type UserAggregate {\n *     count: Int\n *     sum: UserAggregateSum\n *     avg: UserAggregateAvg\n *  }\n *\n *  type UserAggregateSum {\n *     age: Float\n *  }\n *\n *  type UserAggregateAvg {\n *    age: Float\n *  }\n *\n *  type UserGroupBy {\n *     username: [UserConnectionUsername]\n *     age: [UserConnectionAge]\n *  }\n *\n *  type UserConnectionUsername {\n *    key: String\n *    connection: UserConnection\n *  }\n *\n *  type UserConnectionAge {\n *    key: Int\n *    connection: UserConnection\n *  }\n *\n */\nconst formatModelConnectionsGQL = function({ fields, model, name, resolver }) {\n  const { globalId } = model;\n\n  const connectionGlobalId = `${globalId}Connection`;\n\n  const aggregatorFormat = formatConnectionAggregator(fields, model, name);\n  const groupByFormat = formatConnectionGroupBy(fields, model);\n  const connectionFields = {\n    values: `[${globalId}]`,\n    groupBy: `${globalId}GroupBy`,\n    aggregate: `${globalId}Aggregator`,\n  };\n  const pluralName = pluralize.plural(_.camelCase(name));\n\n  let modelConnectionTypes = `type ${connectionGlobalId} {${toSDL(connectionFields)}}\\n\\n`;\n  if (aggregatorFormat) {\n    modelConnectionTypes += aggregatorFormat.type;\n  }\n  modelConnectionTypes += groupByFormat.type;\n\n  const queryName = `${pluralName}Connection(sort: String, limit: Int, start: Int, where: JSON)`;\n\n  const connectionResolver = buildQueryResolver(`${pluralName}Connection.values`, resolver);\n\n  const connectionQueryName = `${pluralName}Connection`;\n\n  return {\n    globalId: connectionGlobalId,\n    definition: modelConnectionTypes,\n    query: {\n      [queryName]: connectionGlobalId,\n    },\n    resolvers: {\n      Query: {\n        [connectionQueryName]: buildQueryResolver(connectionQueryName, {\n          resolverOf: resolver.resolverOf || resolver.resolver,\n          resolver(obj, options) {\n            return options;\n          },\n        }),\n      },\n      [connectionGlobalId]: {\n        values(obj, options, gqlCtx) {\n          return connectionResolver(obj, obj, gqlCtx);\n        },\n        groupBy(obj) {\n          return obj;\n        },\n        aggregate(obj) {\n          return obj;\n        },\n      },\n      ...aggregatorFormat.resolver,\n      ...groupByFormat.resolver,\n    },\n  };\n};\n\nmodule.exports = {\n  formatModelConnectionsGQL,\n};\n",
    "packages/strapi-plugin-graphql/services/resolvers-builder.js": "/**\n * Build queries and mutation resolvers\n */\n\n'use strict';\n\nconst _ = require('lodash');\nconst compose = require('koa-compose');\n\nconst { policy: policyUtils } = require('strapi-utils');\nconst {\n  convertToParams,\n  convertToQuery,\n  amountLimiting,\n  getAction,\n  getActionDetails,\n  isResolvablePath,\n} = require('./utils');\n\nconst buildMutation = (mutationName, config) => {\n  const { resolver, resolverOf, transformOutput = _.identity } = config;\n\n  if (_.isFunction(resolver) && !isResolvablePath(resolverOf)) {\n    throw new Error(\n      `Cannot create mutation \"${mutationName}\". Missing \"resolverOf\" option with custom resolver.`\n    );\n  }\n\n  const policiesMiddleware = compose(getPolicies(config));\n\n  // custom resolvers\n  if (_.isFunction(resolver)) {\n    return async (root, options = {}, graphqlContext, info) => {\n      const ctx = buildMutationContext({ options, graphqlContext });\n\n      await policiesMiddleware(ctx);\n      graphqlContext.context = ctx;\n\n      return resolver(root, options, graphqlContext, info);\n    };\n  }\n\n  const action = getAction(resolver);\n\n  return async (root, options = {}, graphqlContext) => {\n    const ctx = buildMutationContext({ options, graphqlContext });\n\n    await policiesMiddleware(ctx);\n\n    const values = await action(ctx);\n    const result = ctx.body || values;\n\n    if (_.isError(result)) {\n      throw result;\n    }\n\n    return transformOutput(result);\n  };\n};\n\nconst buildMutationContext = ({ options, graphqlContext }) => {\n  const { context } = graphqlContext;\n\n  const ctx = cloneKoaContext(context);\n\n  if (options.input && options.input.where) {\n    ctx.params = convertToParams(options.input.where || {});\n  } else {\n    ctx.params = {};\n  }\n\n  if (options.input && options.input.data) {\n    ctx.request.body = options.input.data || {};\n  } else {\n    ctx.request.body = options;\n  }\n\n  return ctx;\n};\n\nconst buildQuery = (queryName, config) => {\n  const { resolver } = config;\n\n  try {\n    validateResolverOption(config);\n  } catch (error) {\n    throw new Error(`Cannot create query \"${queryName}\": ${error.message}`);\n  }\n\n  const policiesMiddleware = compose(getPolicies(config));\n\n  // custom resolvers\n  if (_.isFunction(resolver)) {\n    return async (root, options = {}, graphqlContext, info) => {\n      const { ctx, opts } = buildQueryContext({ options, graphqlContext });\n\n      await policiesMiddleware(ctx);\n      graphqlContext.context = ctx;\n\n      return resolver(root, opts, graphqlContext, info);\n    };\n  }\n\n  const action = getAction(resolver);\n\n  return async (root, options = {}, graphqlContext) => {\n    const { ctx } = buildQueryContext({ options, graphqlContext });\n\n    // duplicate context\n    await policiesMiddleware(ctx);\n\n    const values = await action(ctx);\n    const result = ctx.body || values;\n\n    if (_.isError(result)) {\n      throw result;\n    }\n\n    return result;\n  };\n};\n\nconst validateResolverOption = config => {\n  const { resolver, resolverOf, policies } = config;\n\n  if (_.isFunction(resolver) && !isResolvablePath(resolverOf)) {\n    throw new Error(`Missing \"resolverOf\" option with custom resolver.`);\n  }\n\n  if (!_.isUndefined(policies) && (!Array.isArray(policies) || !_.every(policies, _.isString))) {\n    throw new Error('Policies option must be an array of string.');\n  }\n\n  return true;\n};\n\nconst cloneKoaContext = ctx => {\n  return Object.assign(ctx.app.createContext(_.clone(ctx.req), _.clone(ctx.res)), {\n    state: {\n      ...ctx.state,\n    },\n  });\n};\n\nconst buildQueryContext = ({ options, graphqlContext }) => {\n  const { context } = graphqlContext;\n  const _options = _.cloneDeep(options);\n\n  const ctx = cloneKoaContext(context);\n\n  const opts = amountLimiting(_options);\n\n  ctx.query = {\n    ...convertToParams(_.omit(opts, 'where')),\n    ...convertToQuery(opts.where),\n  };\n\n  ctx.params = convertToParams(opts);\n\n  return { ctx, opts };\n};\n\n/**\n * Checks if a resolverPath (resolver or resovlerOf) might be resolved\n */\nconst getPolicies = config => {\n  const { resolver, policies = [], resolverOf } = config;\n\n  const { api, plugin } = config['_metadatas'] || {};\n\n  const policyFns = [];\n\n  const { controller, action, plugin: pathPlugin } = isResolvablePath(resolverOf)\n    ? getActionDetails(resolverOf)\n    : getActionDetails(resolver);\n\n  const globalPolicy = policyUtils.globalPolicy({\n    controller,\n    action,\n    plugin: pathPlugin,\n  });\n\n  policyFns.push(globalPolicy);\n\n  if (strapi.plugins['users-permissions']) {\n    policies.unshift('plugins::users-permissions.permissions');\n  }\n\n  policies.forEach(policy => {\n    const policyFn = policyUtils.get(policy, plugin, api);\n    policyFns.push(policyFn);\n  });\n\n  return policyFns;\n};\n\nmodule.exports = {\n  buildQuery,\n  buildMutation,\n};\n",
    "packages/strapi-plugin-graphql/services/type-definitions.js": "'use strict';\n\n/**\n * GraphQL.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\n\nconst _ = require('lodash');\nconst { contentTypes } = require('strapi-utils');\n\nconst {\n  hasDraftAndPublish,\n  constants: { DP_PUB_STATE_LIVE },\n} = contentTypes;\n\nconst DynamicZoneScalar = require('../types/dynamiczoneScalar');\n\nconst { formatModelConnectionsGQL } = require('./build-aggregation');\nconst types = require('./type-builder');\nconst { mergeSchemas, convertToParams, convertToQuery, amountLimiting } = require('./utils');\nconst { toSDL, getTypeDescription } = require('./schema-definitions');\nconst { toSingular, toPlural } = require('./naming');\nconst { buildQuery, buildMutation } = require('./resolvers-builder');\nconst { actionExists } = require('./utils');\n\nconst OPTIONS = Symbol();\n\nconst FIND_QUERY_ARGUMENTS = `(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState)`;\nconst FIND_ONE_QUERY_ARGUMENTS = `(id: ID!, publicationState: PublicationState)`;\n\nconst assignOptions = (element, parent) => {\n  if (Array.isArray(element)) {\n    return element.map(el => assignOptions(el, parent));\n  }\n\n  return _.set(element, OPTIONS, _.get(parent, OPTIONS, {}));\n};\n\nconst isQueryEnabled = (schema, name) => {\n  return _.get(schema, `resolver.Query.${name}`) !== false;\n};\n\nconst isMutationEnabled = (schema, name) => {\n  return _.get(schema, `resolver.Mutation.${name}`) !== false;\n};\n\nconst isNotPrivate = _.curry((model, attributeName) => {\n  return !contentTypes.isPrivateAttribute(model, attributeName);\n});\n\nconst wrapPublicationStateResolver = query => async (parent, args, ctx, ast) => {\n  const results = await query(parent, args, ctx, ast);\n\n  const queryOptions = _.pick(args, 'publicationState');\n  return assignOptions(results, { [OPTIONS]: queryOptions });\n};\n\nconst buildTypeDefObj = model => {\n  const { associations = [], attributes, primaryKey, globalId } = model;\n\n  const typeDef = {\n    id: 'ID!',\n    [primaryKey]: 'ID!',\n  };\n\n  // Add timestamps attributes.\n  if (_.isArray(_.get(model, 'options.timestamps'))) {\n    const [createdAtKey, updatedAtKey] = model.options.timestamps;\n    typeDef[createdAtKey] = 'DateTime!';\n    typeDef[updatedAtKey] = 'DateTime!';\n  }\n\n  Object.keys(attributes)\n    .filter(isNotPrivate(model))\n    .forEach(attributeName => {\n      const attribute = attributes[attributeName];\n      // Convert our type to the GraphQL type.\n      typeDef[attributeName] = types.convertType({\n        attribute,\n        modelName: globalId,\n        attributeName,\n      });\n    });\n\n  // Change field definition for collection relations\n  associations\n    .filter(association => association.type === 'collection')\n    .filter(association => isNotPrivate(model, association.alias))\n    .forEach(association => {\n      typeDef[`${association.alias}(sort: String, limit: Int, start: Int, where: JSON)`] =\n        typeDef[association.alias];\n\n      delete typeDef[association.alias];\n    });\n\n  return typeDef;\n};\n\nconst generateEnumDefinitions = (attributes, globalId) => {\n  return Object.keys(attributes)\n    .filter(attribute => attributes[attribute].type === 'enumeration')\n    .map(attribute => {\n      const definition = attributes[attribute];\n\n      const name = types.convertEnumType(definition, globalId, attribute);\n      const values = definition.enum.map(v => `\\t${v}`).join('\\n');\n      return `enum ${name} {\\n${values}\\n}\\n`;\n    })\n    .join('');\n};\n\nconst generateDynamicZoneDefinitions = (attributes, globalId, schema) => {\n  Object.keys(attributes)\n    .filter(attribute => attributes[attribute].type === 'dynamiczone')\n    .forEach(attribute => {\n      const { components } = attributes[attribute];\n\n      const typeName = `${globalId}${_.upperFirst(_.camelCase(attribute))}DynamicZone`;\n\n      if (components.length === 0) {\n        // Create dummy type because graphql doesn't support empty ones\n\n        schema.definition += `type ${typeName} { _:Boolean}`;\n        schema.definition += `\\nscalar EmptyQuery\\n`;\n      } else {\n        const componentsTypeNames = components.map(componentUID => {\n          const compo = strapi.components[componentUID];\n          if (!compo) {\n            throw new Error(\n              `Trying to creating dynamiczone type with unkown component ${componentUID}`\n            );\n          }\n\n          return compo.globalId;\n        });\n\n        const unionType = `union ${typeName} = ${componentsTypeNames.join(' | ')}`;\n\n        schema.definition += `\\n${unionType}\\n`;\n      }\n\n      const inputTypeName = `${typeName}Input`;\n      schema.definition += `\\nscalar ${inputTypeName}\\n`;\n\n      schema.resolvers[typeName] = {\n        __resolveType(obj) {\n          return strapi.components[obj.__component].globalId;\n        },\n      };\n\n      schema.resolvers[inputTypeName] = new DynamicZoneScalar({\n        name: inputTypeName,\n        attribute,\n        globalId,\n        components,\n      });\n    });\n};\n\nconst initQueryOptions = (targetModel, parent) => {\n  if (hasDraftAndPublish(targetModel)) {\n    return {\n      _publicationState: _.get(parent, [OPTIONS, 'publicationState'], DP_PUB_STATE_LIVE),\n    };\n  }\n\n  return {};\n};\n\nconst buildAssocResolvers = model => {\n  const { primaryKey, associations = [] } = model;\n\n  return associations\n    .filter(association => isNotPrivate(model, association.alias))\n    .reduce((resolver, association) => {\n      const target = association.model || association.collection;\n      const targetModel = strapi.getModel(target, association.plugin);\n\n      const { nature, alias } = association;\n\n      switch (nature) {\n        case 'oneToManyMorph':\n        case 'manyMorphToOne':\n        case 'manyMorphToMany':\n        case 'manyToManyMorph': {\n          resolver[alias] = async obj => {\n            if (obj[alias]) {\n              return assignOptions(obj[alias], obj);\n            }\n\n            const params = {\n              ...initQueryOptions(targetModel, obj),\n              id: obj[primaryKey],\n            };\n\n            const entry = await strapi.query(model.uid).findOne(params, [alias]);\n\n            return assignOptions(entry[alias], obj);\n          };\n          break;\n        }\n        default: {\n          resolver[alias] = async (obj, options) => {\n            const loader = strapi.plugins.graphql.services['data-loaders'].loaders[targetModel.uid];\n\n            const localId = obj[model.primaryKey];\n            const targetPK = targetModel.primaryKey;\n            const foreignId = _.get(obj[alias], targetModel.primaryKey, obj[alias]);\n\n            const params = {\n              ...initQueryOptions(targetModel, obj),\n              ...convertToParams(_.omit(amountLimiting(options), 'where')),\n              ...convertToQuery(options.where),\n            };\n\n            if (['oneToOne', 'oneWay', 'manyToOne'].includes(nature)) {\n              if (!_.has(obj, alias) || _.isNil(foreignId)) {\n                return null;\n              }\n\n              // check this is an entity and not a mongo ID\n              if (_.has(obj[alias], targetPK)) {\n                return assignOptions(obj[alias], obj);\n              }\n\n              const query = {\n                single: true,\n                filters: {\n                  ...params,\n                  [targetPK]: foreignId,\n                },\n              };\n\n              return loader.load(query).then(r => assignOptions(r, obj));\n            }\n\n            if (['oneToMany', 'manyToMany'].includes(nature)) {\n              const { via } = association;\n\n              const filters = {\n                ...params,\n                [`${via}.id`]: localId,\n              };\n\n              return loader.load({ filters }).then(r => assignOptions(r, obj));\n            }\n\n            if (nature === 'manyWay') {\n              let targetIds = [];\n\n              // find the related ids to query them and apply the filters\n              if (Array.isArray(obj[alias])) {\n                targetIds = obj[alias].map(value => value[targetPK] || value);\n              } else {\n                const entry = await strapi\n                  .query(model.uid)\n                  .findOne({ [primaryKey]: obj[primaryKey] }, [alias]);\n\n                if (_.isEmpty(entry[alias])) {\n                  return [];\n                }\n\n                targetIds = entry[alias].map(el => el[targetPK]);\n              }\n\n              const filters = {\n                ...params,\n                [`${targetPK}_in`]: targetIds.map(_.toString),\n              };\n\n              return loader.load({ filters }).then(r => assignOptions(r, obj));\n            }\n          };\n          break;\n        }\n      }\n\n      return resolver;\n    }, {});\n};\n\n/**\n * Construct the GraphQL query & definition and apply the right resolvers.\n *\n * @return Object\n */\nconst buildModels = models => {\n  return models.map(model => {\n    const { kind, modelType } = model;\n\n    if (modelType === 'component') {\n      return buildComponent(model);\n    }\n\n    switch (kind) {\n      case 'singleType':\n        return buildSingleType(model);\n      default:\n        return buildCollectionType(model);\n    }\n  });\n};\n\nconst buildModelDefinition = (model, globalType = {}) => {\n  const { globalId, primaryKey } = model;\n\n  const schema = {\n    definition: '',\n    query: {},\n    mutation: {},\n    resolvers: {\n      Query: {},\n      Mutation: {},\n      [globalId]: {\n        id: parent => parent[primaryKey] || parent.id,\n        ...buildAssocResolvers(model),\n      },\n    },\n  };\n\n  const typeDefObj = buildTypeDefObj(model);\n\n  schema.definition += generateEnumDefinitions(model.attributes, globalId);\n  generateDynamicZoneDefinitions(model.attributes, globalId, schema);\n\n  const description = getTypeDescription(globalType, model);\n  const fields = toSDL(typeDefObj, globalType, model);\n  const typeDef = `${description}type ${globalId} {${fields}}\\n`;\n\n  schema.definition += typeDef;\n  return schema;\n};\n\nconst buildComponent = component => {\n  const { globalId } = component;\n  const schema = buildModelDefinition(component);\n\n  schema.definition += types.generateInputModel(component, globalId, {\n    allowIds: true,\n  });\n\n  return schema;\n};\n\nconst buildSingleType = model => {\n  const { uid, modelName } = model;\n\n  const singularName = toSingular(modelName);\n\n  const _schema = _.cloneDeep(_.get(strapi.plugins, 'graphql.config._schema.graphql', {}));\n\n  const globalType = _.get(_schema, `type.${model.globalId}`, {});\n\n  const localSchema = buildModelDefinition(model, globalType);\n\n  // Add definition to the schema but this type won't be \"queriable\" or \"mutable\".\n  if (globalType === false) {\n    return localSchema;\n  }\n\n  if (isQueryEnabled(_schema, singularName)) {\n    const resolver = buildQuery(singularName, {\n      resolver: `${uid}.find`,\n      ..._.get(_schema, `resolver.Query.${singularName}`, {}),\n    });\n\n    _.merge(localSchema, {\n      query: {\n        [`${singularName}(publicationState: PublicationState)`]: model.globalId,\n      },\n      resolvers: {\n        Query: {\n          [singularName]: wrapPublicationStateResolver(resolver),\n        },\n      },\n    });\n  }\n\n  // Add model Input definition.\n  localSchema.definition += types.generateInputModel(model, modelName);\n\n  // build every mutation\n  ['update', 'delete'].forEach(action => {\n    const mutationSchema = buildMutationTypeDef({ model, action }, { _schema });\n\n    mergeSchemas(localSchema, mutationSchema);\n  });\n\n  return localSchema;\n};\n\nconst buildCollectionType = model => {\n  const { globalId, plugin, modelName, uid } = model;\n\n  const singularName = toSingular(modelName);\n  const pluralName = toPlural(modelName);\n\n  const _schema = _.cloneDeep(_.get(strapi.plugins, 'graphql.config._schema.graphql', {}));\n\n  const globalType = _.get(_schema, `type.${model.globalId}`, {});\n\n  const localSchema = {\n    definition: '',\n    query: {},\n    mutation: {},\n    resolvers: {\n      Query: {},\n      Mutation: {},\n      // define default resolver for this model\n      [globalId]: {\n        id: parent => parent[model.primaryKey] || parent.id,\n        ...buildAssocResolvers(model),\n      },\n    },\n  };\n\n  const typeDefObj = buildTypeDefObj(model);\n\n  localSchema.definition += generateEnumDefinitions(model.attributes, globalId);\n  generateDynamicZoneDefinitions(model.attributes, globalId, localSchema);\n\n  const description = getTypeDescription(globalType, model);\n  const fields = toSDL(typeDefObj, globalType, model);\n  const typeDef = `${description}type ${globalId} {${fields}}\\n`;\n\n  localSchema.definition += typeDef;\n\n  // Add definition to the schema but this type won't be \"queriable\" or \"mutable\".\n  if (globalType === false) {\n    return localSchema;\n  }\n\n  if (isQueryEnabled(_schema, singularName)) {\n    const resolverOpts = {\n      resolver: `${uid}.findOne`,\n      ..._.get(_schema, `resolver.Query.${singularName}`, {}),\n    };\n    if (actionExists(resolverOpts)) {\n      const resolver = buildQuery(singularName, resolverOpts);\n      _.merge(localSchema, {\n        query: {\n          // TODO: support all the unique fields\n          [`${singularName}${FIND_ONE_QUERY_ARGUMENTS}`]: model.globalId,\n        },\n        resolvers: {\n          Query: {\n            [singularName]: wrapPublicationStateResolver(resolver),\n          },\n        },\n      });\n    }\n  }\n\n  if (isQueryEnabled(_schema, pluralName)) {\n    const resolverOpts = {\n      resolver: `${uid}.find`,\n      ..._.get(_schema, `resolver.Query.${pluralName}`, {}),\n    };\n    if (actionExists(resolverOpts)) {\n      const resolver = buildQuery(pluralName, resolverOpts);\n      _.merge(localSchema, {\n        query: {\n          [`${pluralName}${FIND_QUERY_ARGUMENTS}`]: `[${model.globalId}]`,\n        },\n        resolvers: {\n          Query: {\n            [pluralName]: wrapPublicationStateResolver(resolver),\n          },\n        },\n      });\n\n      if (isQueryEnabled(_schema, `${pluralName}Connection`)) {\n        // Generate the aggregation for the given model\n        const aggregationSchema = formatModelConnectionsGQL({\n          fields: typeDefObj,\n          model,\n          name: modelName,\n          resolver: resolverOpts,\n          plugin,\n        });\n\n        mergeSchemas(localSchema, aggregationSchema);\n      }\n    }\n  }\n\n  // Add model Input definition.\n  localSchema.definition += types.generateInputModel(model, modelName);\n\n  // build every mutation\n  ['create', 'update', 'delete'].forEach(action => {\n    const mutationSchema = buildMutationTypeDef({ model, action }, { _schema });\n    mergeSchemas(localSchema, mutationSchema);\n  });\n\n  return localSchema;\n};\n\n// TODO:\n// - Implement batch methods (need to update the content-manager as well).\n// - Implement nested transactional methods (create/update).\nconst buildMutationTypeDef = ({ model, action }, { _schema }) => {\n  const capitalizedName = _.upperFirst(toSingular(model.modelName));\n  const mutationName = `${action}${capitalizedName}`;\n\n  const resolverOpts = {\n    resolver: `${model.uid}.${action}`,\n    transformOutput: result => ({ [toSingular(model.modelName)]: result }),\n    ..._.get(_schema, `resolver.Mutation.${mutationName}`, {}),\n  };\n\n  if (!actionExists(resolverOpts)) {\n    return {};\n  }\n\n  const definition = types.generateInputPayloadArguments({\n    model,\n    name: model.modelName,\n    mutationName,\n    action,\n  });\n\n  // ignore if disabled\n  if (!isMutationEnabled(_schema, mutationName)) {\n    return {\n      definition,\n    };\n  }\n\n  const { kind } = model;\n\n  let mutationDef = `${mutationName}(input: ${mutationName}Input)`;\n  if (kind === 'singleType' && action === 'delete') {\n    mutationDef = mutationName;\n  }\n\n  return {\n    definition,\n    mutation: {\n      [mutationDef]: `${mutationName}Payload`,\n    },\n    resolvers: {\n      Mutation: {\n        [mutationName]: buildMutation(mutationName, resolverOpts),\n      },\n    },\n  };\n};\n\nmodule.exports = {\n  buildModels,\n};\n",
    "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet graphqlQuery;\n\nconst postModel = {\n  attributes: {\n    name: {\n      type: 'richtext',\n    },\n    bigint: {\n      type: 'biginteger',\n    },\n    nullable: {\n      type: 'string',\n    },\n  },\n  connection: 'default',\n  name: 'post',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Test Graphql API End to End', () => {\n  beforeAll(async () => {\n    await builder.addContentType(postModel).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    graphqlQuery = body => {\n      return rq({\n        url: '/graphql',\n        method: 'POST',\n        body,\n      });\n    };\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Test CRUD', () => {\n    const postsPayload = [\n      { name: 'post 1', bigint: 1316130638171, nullable: 'value' },\n      { name: 'post 2', bigint: 1416130639261, nullable: null },\n    ];\n    let data = {\n      posts: [],\n    };\n\n    test.each(postsPayload)('Create Post %o', async post => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation createPost($input: createPostInput) {\n            createPost(input: $input) {\n              post {\n                name\n                bigint\n                nullable\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            data: post,\n          },\n        },\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toEqual({\n        data: {\n          createPost: {\n            post,\n          },\n        },\n      });\n    });\n\n    test('List posts', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            posts {\n              id\n              name\n              bigint\n              nullable\n            }\n          }\n        `,\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          posts: postsPayload,\n        },\n      });\n\n      // assign for later use\n      data.posts = res.body.data.posts;\n    });\n\n    test('List posts with limit', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            posts(limit: 1) {\n              id\n              name\n              bigint\n              nullable\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          posts: [data.posts[0]],\n        },\n      });\n    });\n\n    test('List posts with sort', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            posts(sort: \"name:desc\") {\n              id\n              name\n              bigint\n              nullable\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          posts: [...data.posts].reverse(),\n        },\n      });\n    });\n\n    test('List posts with start', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            posts(start: 1) {\n              id\n              name\n              bigint\n              nullable\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          posts: [data.posts[1]],\n        },\n      });\n    });\n\n    test.skip('List posts with `created_by` and `updated_by`', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            posts(start: 1) {\n              id\n              name\n              bigint\n              nullable\n              created_by {\n                username\n              }\n              updated_by {\n                username\n              }\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(200);\n\n      // no errors should be present in the response\n      expect(res.body.error).toBeUndefined();\n\n      // since the posts are created without AdminUser, it should return null\n      expect(res.body.data.posts[0].created_by).toBeNull();\n    });\n\n    test.each([\n      [\n        {\n          name: 'post 1',\n          bigint: 1316130638171,\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          name_eq: 'post 1',\n          bigint_eq: 1316130638171,\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          name_ne: 'post 1',\n          bigint_ne: 1316130638171,\n        },\n        [postsPayload[1]],\n      ],\n      [\n        {\n          name_contains: 'Post',\n        },\n        postsPayload,\n      ],\n      [\n        {\n          name_contains: 'Post 1',\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          name_containss: 'post',\n        },\n        postsPayload,\n      ],\n      [\n        {\n          name_ncontainss: 'post 1',\n        },\n        [postsPayload[1]],\n      ],\n      [\n        {\n          name_in: ['post 1', 'post 2', 'post 3'],\n        },\n        postsPayload,\n      ],\n      [\n        {\n          name_nin: ['post 2'],\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          nullable_null: true,\n        },\n        [postsPayload[1]],\n      ],\n      [\n        {\n          nullable_null: false,\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          _or: [{ name_in: ['post 2'] }, { bigint_eq: 1316130638171 }],\n        },\n        [postsPayload[0], postsPayload[1]],\n      ],\n      [\n        {\n          _where: { nullable_null: false },\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          _where: { _or: { nullable_null: false } },\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          _where: [{ nullable_null: false }],\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          _where: [{ _or: [{ name_in: ['post 2'] }, { bigint_eq: 1316130638171 }] }],\n        },\n        [postsPayload[0], postsPayload[1]],\n      ],\n      [\n        {\n          _where: [\n            {\n              _or: [\n                { name_in: ['post 2'] },\n                { _or: [{ bigint_eq: 1316130638171 }, { nullable_null: false }] },\n              ],\n            },\n          ],\n        },\n        [postsPayload[0], postsPayload[1]],\n      ],\n    ])('List posts with where clause %o', async (where, expected) => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          query findPosts($where: JSON) {\n            posts(where: $where) {\n              name\n              bigint\n              nullable\n            }\n          }\n        `,\n        variables: {\n          where,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n\n      // same length\n      expect(res.body.data.posts.length).toBe(expected.length);\n\n      // all the posts returned are in the expected array\n      res.body.data.posts.forEach(post => {\n        expect(expected).toEqual(expect.arrayContaining([post]));\n      });\n\n      // all expected values are in the result\n      expected.forEach(expectedPost => {\n        expect(res.body.data.posts).toEqual(expect.arrayContaining([expectedPost]));\n      });\n    });\n\n    test('Get One Post', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          query getPost($id: ID!) {\n            post(id: $id) {\n              id\n              name\n              bigint\n              nullable\n            }\n          }\n        `,\n        variables: {\n          id: data.posts[0].id,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          post: data.posts[0],\n        },\n      });\n    });\n\n    test('Update Post', async () => {\n      const newName = 'new post name';\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation updatePost($input: updatePostInput) {\n            updatePost(input: $input) {\n              post {\n                id\n                name\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            where: {\n              id: data.posts[0].id,\n            },\n            data: {\n              name: newName,\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          updatePost: {\n            post: {\n              id: data.posts[0].id,\n              name: newName,\n            },\n          },\n        },\n      });\n\n      data.posts[0] = res.body.data.updatePost.post;\n    });\n\n    test('Delete Posts', async () => {\n      for (let post of data.posts) {\n        const res = await graphqlQuery({\n          query: /* GraphQL */ `\n            mutation deletePost($input: deletePostInput) {\n              deletePost(input: $input) {\n                post {\n                  id\n                  name\n                  bigint\n                }\n              }\n            }\n          `,\n          variables: {\n            input: {\n              where: {\n                id: post.id,\n              },\n            },\n          },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject({\n          data: {\n            deletePost: {\n              post: {\n                id: post.id,\n              },\n            },\n          },\n        });\n      }\n    });\n  });\n});\n",
    "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js": "'use strict';\n\n// Helpers.\nconst _ = require('lodash');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet graphqlQuery;\n\n// utils\nconst selectFields = doc => _.pick(doc, ['id', 'name', 'color']);\n\nconst rgbColorComponent = {\n  attributes: {\n    name: {\n      type: 'text',\n    },\n    red: {\n      type: 'integer',\n    },\n    green: {\n      type: 'integer',\n    },\n    blue: {\n      type: 'integer',\n    },\n  },\n  name: 'rgbColor',\n};\n\nconst documentModel = {\n  attributes: {\n    name: {\n      type: 'richtext',\n    },\n    content: {\n      type: 'richtext',\n    },\n  },\n  connection: 'default',\n  name: 'document',\n  description: '',\n  collectionName: '',\n};\n\nconst labelModel = {\n  attributes: {\n    name: {\n      type: 'richtext',\n    },\n    documents: {\n      dominant: true,\n      nature: 'manyToMany',\n      target: 'application::document.document',\n      targetAttribute: 'labels',\n    },\n    color: {\n      type: 'component',\n      component: 'default.rgb-color',\n      repeatable: false,\n    },\n  },\n  connection: 'default',\n  name: 'label',\n  description: '',\n  collectionName: '',\n};\n\nconst carModel = {\n  attributes: {\n    name: {\n      type: 'text',\n    },\n  },\n  connection: 'default',\n  name: 'car',\n  description: '',\n  collectionName: '',\n};\n\nconst personModel = {\n  attributes: {\n    name: {\n      type: 'text',\n    },\n    privateName: {\n      type: 'text',\n      private: true,\n    },\n    privateCars: {\n      nature: 'oneToMany',\n      target: 'application::car.car',\n      dominant: false,\n      targetAttribute: 'person',\n      private: true,\n    },\n  },\n  connection: 'default',\n  name: 'person',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Test Graphql Relations API End to End', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(rgbColorComponent)\n      .addContentTypes([documentModel, labelModel, carModel, personModel])\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    graphqlQuery = body => {\n      return rq({\n        url: '/graphql',\n        method: 'POST',\n        body,\n      });\n    };\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Test relations features', () => {\n    let data = {\n      labels: [],\n      documents: [],\n      people: [],\n      cars: [],\n    };\n    const labelsPayload = [\n      { name: 'label 1', color: null },\n      { name: 'label 2', color: null },\n      { name: 'labelWithColor', color: { name: 'tomato', red: 255, green: 99, blue: 71 } },\n    ];\n    const documentsPayload = [{ name: 'document 1' }, { name: 'document 2' }];\n\n    test.each(labelsPayload)('Create label %o', async label => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation createLabel($input: createLabelInput) {\n            createLabel(input: $input) {\n              label {\n                name\n                color {\n                  name\n                  red\n                  green\n                  blue\n                }\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            data: label,\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          createLabel: {\n            label,\n          },\n        },\n      });\n    });\n\n    test('List labels', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            labels {\n              id\n              name\n              color {\n                name\n                red\n                green\n                blue\n              }\n            }\n          }\n        `,\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          labels: labelsPayload,\n        },\n      });\n\n      // assign for later use\n      data.labels = data.labels.concat(res.body.data.labels);\n    });\n\n    test.each(documentsPayload)('Create document linked to every labels %o', async document => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation createDocument($input: createDocumentInput) {\n            createDocument(input: $input) {\n              document {\n                name\n                labels {\n                  id\n                  name\n                  color {\n                    name\n                    red\n                    green\n                    blue\n                  }\n                }\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            data: {\n              ...document,\n              labels: data.labels.map(t => t.id),\n            },\n          },\n        },\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n\n      expect(body).toMatchObject({\n        data: {\n          createDocument: {\n            document: {\n              ...selectFields(document),\n              labels: expect.arrayContaining(data.labels.map(selectFields)),\n            },\n          },\n        },\n      });\n    });\n\n    test('List documents with labels', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            documents {\n              id\n              name\n              labels {\n                id\n                name\n                color {\n                  name\n                  red\n                  green\n                  blue\n                }\n              }\n            }\n          }\n        `,\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          documents: expect.arrayContaining(\n            data.documents.map(document => ({\n              ...selectFields(document),\n              labels: expect.arrayContaining(data.labels.map(selectFields)),\n            }))\n          ),\n        },\n      });\n\n      // assign for later use\n      data.documents = res.body.data.documents;\n    });\n\n    test('List Labels with documents', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            labels {\n              id\n              name\n              color {\n                name\n                red\n                green\n                blue\n              }\n              documents {\n                id\n                name\n              }\n            }\n          }\n        `,\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          labels: expect.arrayContaining(\n            data.labels.map(label => ({\n              ...selectFields(label),\n              documents: expect.arrayContaining(data.documents.map(selectFields)),\n            }))\n          ),\n        },\n      });\n\n      // assign for later use\n      data.labels = res.body.data.labels;\n    });\n\n    test('Deep query', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            documents(where: { labels: { name_contains: \"label 1\" } }) {\n              id\n              name\n              labels {\n                id\n                name\n                color {\n                  name\n                  red\n                  green\n                  blue\n                }\n              }\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          documents: expect.arrayContaining(data.documents),\n        },\n      });\n    });\n\n    test('Update Document relations removes correctly a relation', async () => {\n      // if I remove a label from an document is it working\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation updateDocument($input: updateDocumentInput) {\n            updateDocument(input: $input) {\n              document {\n                id\n                name\n                labels {\n                  id\n                  name\n                  color {\n                    name\n                    red\n                    green\n                    blue\n                  }\n                }\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            where: {\n              id: data.documents[0].id,\n            },\n            data: {\n              labels: [data.labels[0].id],\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          updateDocument: {\n            document: {\n              ...selectFields(data.documents[0]),\n              labels: [selectFields(data.labels[0])],\n            },\n          },\n        },\n      });\n    });\n\n    test('Delete Labels and test Documents relations', async () => {\n      for (let label of data.labels) {\n        const res = await graphqlQuery({\n          query: /* GraphQL */ `\n            mutation deleteLabel($input: deleteLabelInput) {\n              deleteLabel(input: $input) {\n                label {\n                  id\n                  name\n                  color {\n                    name\n                    red\n                    green\n                    blue\n                  }\n                }\n              }\n            }\n          `,\n          variables: {\n            input: {\n              where: {\n                id: label.id,\n              },\n            },\n          },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject({\n          data: {\n            deleteLabel: {\n              label: {\n                id: label.id,\n              },\n            },\n          },\n        });\n      }\n\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            documents {\n              id\n              name\n              labels {\n                id\n                name\n                color {\n                  name\n                  red\n                  green\n                  blue\n                }\n              }\n            }\n          }\n        `,\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          documents: expect.arrayContaining(\n            data.documents.map(document => ({\n              ...selectFields(document),\n              labels: [],\n            }))\n          ),\n        },\n      });\n    });\n\n    test('Delete Documents', async () => {\n      for (let document of data.documents) {\n        const res = await graphqlQuery({\n          query: /* GraphQL */ `\n            mutation deleteDocument($input: deleteDocumentInput) {\n              deleteDocument(input: $input) {\n                document {\n                  id\n                  name\n                }\n              }\n            }\n          `,\n          variables: {\n            input: {\n              where: {\n                id: document.id,\n              },\n            },\n          },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject({\n          data: {\n            deleteDocument: {\n              document: {\n                id: document.id,\n              },\n            },\n          },\n        });\n      }\n    });\n\n    test('Create person', async () => {\n      const person = {\n        name: 'Chuck Norris',\n        privateName: 'Jean-Eude',\n      };\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation createPerson($input: createPersonInput) {\n            createPerson(input: $input) {\n              person {\n                id\n                name\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            data: person,\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          createPerson: {\n            person: {\n              id: expect.anything(),\n              name: person.name,\n            },\n          },\n        },\n      });\n      data.people.push(res.body.data.createPerson.person);\n    });\n\n    test(\"Can't list a private field\", async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            people {\n              name\n              privateName\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        errors: [\n          {\n            message: 'Cannot query field \"privateName\" on type \"Person\".',\n          },\n        ],\n      });\n    });\n\n    test('Create a car linked to a person (oneToMany)', async () => {\n      const car = {\n        name: 'Peugeot 508',\n        person: data.people[0].id,\n      };\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation createCar($input: createCarInput) {\n            createCar(input: $input) {\n              car {\n                id\n                name\n                person {\n                  id\n                  name\n                }\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            data: {\n              ...car,\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          createCar: {\n            car: {\n              id: expect.anything(),\n              name: car.name,\n              person: data.people[0],\n            },\n          },\n        },\n      });\n\n      data.cars.push({ id: res.body.data.createCar.car.id });\n    });\n\n    test(\"Can't list a private oneToMany relation\", async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            people {\n              name\n              privateCars\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        errors: [\n          {\n            message: 'Cannot query field \"privateCars\" on type \"Person\".',\n          },\n        ],\n      });\n    });\n\n    test('Edit person/cars relations removes correctly a car', async () => {\n      const newPerson = {\n        name: 'Check Norris Junior',\n        privateCars: [],\n      };\n\n      const mutationRes = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation updatePerson($input: updatePersonInput) {\n            updatePerson(input: $input) {\n              person {\n                id\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            where: {\n              id: data.people[0].id,\n            },\n            data: {\n              ...newPerson,\n            },\n          },\n        },\n      });\n      expect(mutationRes.statusCode).toBe(200);\n\n      const queryRes = await graphqlQuery({\n        query: /* GraphQL */ `\n          query($id: ID!) {\n            car(id: $id) {\n              person {\n                id\n              }\n            }\n          }\n        `,\n        variables: {\n          id: data.cars[0].id,\n        },\n      });\n      expect(queryRes.statusCode).toBe(200);\n      expect(queryRes.body).toEqual({\n        data: {\n          car: {\n            person: null,\n          },\n        },\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet graphqlQuery;\nconst data = {};\n\nconst homePageModel = {\n  name: 'home-page',\n  kind: 'singleType',\n  attributes: {\n    title: {\n      type: 'string',\n    },\n  },\n};\n\nconst updateContent = data => {\n  return graphqlQuery({\n    query: /* GraphQL */ `\n      mutation updateHomePage($input: updateHomePageInput) {\n        updateHomePage(input: $input) {\n          homePage {\n            id\n          }\n        }\n      }\n    `,\n    variables: {\n      input: {\n        data,\n      },\n    },\n  });\n};\n\ndescribe('Single type Graphql support', () => {\n  beforeAll(async () => {\n    await builder.addContentType(homePageModel).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    graphqlQuery = body => {\n      return rq({\n        url: '/graphql',\n        method: 'POST',\n        body,\n      });\n    };\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Queries', () => {\n    test('No list available', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            homePages {\n              id\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body.errors).toMatchObject(\n        expect.arrayContaining([\n          expect.objectContaining({\n            message: expect.stringMatching('Cannot query field \"homePages\"'),\n          }),\n        ])\n      );\n    });\n\n    test('Access the single type without args', async () => {\n      await updateContent({\n        title: 'Test',\n      });\n\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            homePage {\n              id\n              title\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toEqual({\n        homePage: {\n          id: expect.anything(),\n          title: 'Test',\n        },\n      });\n\n      data.id = res.body.data.homePage.id;\n    });\n  });\n\n  describe('Mutations', () => {\n    test('Cannot create', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation {\n            createHomePage(input: { data: { title: \"Test\" } }) {\n              id\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body.errors).toMatchObject(\n        expect.arrayContaining([\n          expect.objectContaining({\n            message: expect.stringMatching('Cannot query field \"createHomePage\"'),\n          }),\n        ])\n      );\n    });\n\n    test('update a single type does not require id', async () => {\n      const updateRes = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation updateHomePage($input: updateHomePageInput) {\n            updateHomePage(input: $input) {\n              homePage {\n                id\n                title\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            data: {\n              title: 'New Title',\n            },\n          },\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toEqual({\n        updateHomePage: {\n          homePage: {\n            id: data.id,\n            title: 'New Title',\n          },\n        },\n      });\n\n      const getRes = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            homePage {\n              id\n              title\n            }\n          }\n        `,\n      });\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toEqual({\n        homePage: {\n          id: data.id,\n          title: 'New Title',\n        },\n      });\n    });\n\n    test('Can delete without params', async () => {\n      const deleteRes = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation {\n            deleteHomePage {\n              homePage {\n                id\n                title\n              }\n            }\n          }\n        `,\n      });\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body.data).toEqual({\n        deleteHomePage: {\n          homePage: {\n            id: data.id,\n            title: 'New Title',\n          },\n        },\n      });\n\n      const getRes = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            homePage {\n              id\n              title\n            }\n          }\n        `,\n      });\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toEqual({\n        homePage: null,\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-upload/admin/src/containers/HomePage/index.js": "import React, { useCallback, useReducer, useRef, useState, useEffect } from 'react';\nimport { get, includes, toString, isEqual, intersectionWith } from 'lodash';\nimport { useHistory, useLocation } from 'react-router-dom';\nimport { Header } from '@buffetjs/custom';\nimport { Button } from '@buffetjs/core';\nimport {\n  PopUpWarning,\n  useGlobalContext,\n  generateFiltersFromSearch,\n  generateSearchFromFilters,\n  request,\n  useQuery,\n} from 'strapi-helper-plugin';\nimport { formatFileForEditing, getRequestUrl, getTrad, getFileModelTimestamps } from '../../utils';\nimport Container from '../../components/Container';\nimport HomePageContent from './HomePageContent';\nimport Padded from '../../components/Padded';\nimport { useAppContext } from '../../hooks';\nimport ModalStepper from '../ModalStepper';\nimport { generateStringFromParams, getHeaderLabel } from './utils';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\n\nconst HomePage = () => {\n  const { allowedActions } = useAppContext();\n  const { canRead } = allowedActions;\n  const { formatMessage, plugins } = useGlobalContext();\n  const [, updated_at] = getFileModelTimestamps(plugins);\n  const [reducerState, dispatch] = useReducer(reducer, initialState, () =>\n    init(initialState, allowedActions)\n  );\n  const query = useQuery();\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  const [isPopupOpen, setIsPopupOpen] = useState(false);\n  const [fileToEdit, setFileToEdit] = useState(null);\n  const [shouldRefetch, setShouldRefetch] = useState(false);\n  const [modalInitialStep, setModalInitialStep] = useState('browse');\n  const { push } = useHistory();\n  const { search } = useLocation();\n  const isMounted = useRef(true);\n  const {\n    data,\n    dataCount,\n    dataToDelete,\n    isLoading,\n    shouldRefetchData,\n    showModalConfirmButtonLoading,\n  } = reducerState.toJS();\n  const pluginName = formatMessage({ id: getTrad('plugin.name') });\n  const paramsKeys = ['_limit', '_start', '_q', '_sort'];\n\n  useEffect(() => {\n    return () => (isMounted.current = false);\n  }, []);\n\n  useEffect(() => {\n    fetchListData();\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [search]);\n\n  const deleteMedia = async id => {\n    const requestURL = getRequestUrl(`files/${id}`);\n\n    try {\n      await request(requestURL, {\n        method: 'DELETE',\n      });\n\n      return Promise.resolve();\n    } catch (err) {\n      const errorMessage = get(err, 'response.payload.message', 'An error occured');\n\n      return Promise.reject(errorMessage);\n    }\n  };\n\n  const fetchData = async () => {\n    const dataRequestURL = getRequestUrl('files');\n    const params = generateStringFromParams(query);\n\n    const paramsToSend = params.includes('_sort')\n      ? params\n      : params.concat(`&_sort=${updated_at}:DESC`);\n\n    try {\n      const data = await request(`${dataRequestURL}?${paramsToSend}`, {\n        method: 'GET',\n      });\n\n      return Promise.resolve(data);\n    } catch (err) {\n      if (isMounted.current) {\n        dispatch({ type: 'GET_DATA_ERROR' });\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      }\n    }\n\n    return [];\n  };\n\n  const fetchDataCount = async () => {\n    const params = generateStringFromParams(query, ['_limit', '_sort', '_start']);\n    const requestURL = getRequestUrl('files/count');\n\n    try {\n      const { count } = await request(`${requestURL}?${params}`, {\n        method: 'GET',\n      });\n\n      return Promise.resolve(count);\n    } catch (err) {\n      if (isMounted.current) {\n        dispatch({ type: 'GET_DATA_ERROR' });\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      }\n    }\n\n    return null;\n  };\n\n  const fetchListData = async () => {\n    if (canRead) {\n      dispatch({ type: 'GET_DATA' });\n\n      const [data, count] = await Promise.all([fetchData(), fetchDataCount()]);\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data,\n          count,\n        });\n      }\n    }\n  };\n\n  const generateNewSearch = (updatedParams = {}) => {\n    return {\n      ...getSearchParams(),\n      filters: generateFiltersFromSearch(search),\n      ...updatedParams,\n    };\n  };\n\n  const getSearchParams = () => {\n    const params = {};\n\n    query.forEach((value, key) => {\n      if (includes(paramsKeys, key)) {\n        params[key] = value;\n      }\n    });\n\n    return params;\n  };\n\n  const handleChangeCheck = ({ target: { name } }) => {\n    dispatch({\n      type: 'ON_CHANGE_DATA_TO_DELETE',\n      id: name,\n    });\n  };\n\n  const handleChangeParams = ({ target: { name, value } }) => {\n    let updatedQueryParams = generateNewSearch({ [name]: value });\n\n    if (name === 'filters') {\n      const existingFilters = generateFiltersFromSearch(search);\n      const canAddFilter = intersectionWith(existingFilters, [value], isEqual).length === 0;\n      updatedQueryParams = generateNewSearch({ [name]: existingFilters });\n\n      if (canAddFilter) {\n        const filters = [...existingFilters, value];\n\n        updatedQueryParams = generateNewSearch({ [name]: filters });\n      }\n    }\n\n    if (name === '_limit') {\n      updatedQueryParams = generateNewSearch({ [name]: value, _start: 0 });\n    }\n\n    const newSearch = generateSearchFromFilters(updatedQueryParams);\n\n    push({ search: newSearch });\n  };\n\n  const handleClickEditFile = id => {\n    if (allowedActions.canUpdate) {\n      const file = formatFileForEditing(data.find(file => toString(file.id) === toString(id)));\n\n      setFileToEdit(file);\n      setModalInitialStep('edit');\n      handleClickToggleModal();\n    }\n  };\n\n  const handleClickToggleModal = (refetch = false) => {\n    setIsModalOpen(prev => !prev);\n    setShouldRefetch(refetch);\n  };\n\n  const handleClickTogglePopup = () => {\n    setIsPopupOpen(prev => !prev);\n  };\n\n  const handleDeleteFilter = index => {\n    const filters = generateFiltersFromSearch(search).filter(\n      (filter, filterIndex) => filterIndex !== index\n    );\n\n    const updatedQueryParams = generateNewSearch({ filters });\n\n    const newSearch = generateSearchFromFilters(updatedQueryParams);\n\n    push({ search: newSearch });\n  };\n\n  const handleConfirmDeleteMedias = useCallback(async () => {\n    dispatch({ type: 'ON_DELETE_MEDIAS' });\n\n    try {\n      await Promise.all(dataToDelete.map(item => deleteMedia(item.id)));\n\n      dispatch({\n        type: 'ON_DELETE_MEDIAS_SUCCEEDED',\n      });\n    } catch (err) {\n      strapi.notification.toggle({\n        type: 'warning',\n        message: err,\n      });\n\n      dispatch({\n        type: 'ON_DELETE_MEDIAS_ERROR',\n      });\n    } finally {\n      setIsPopupOpen(false);\n    }\n  }, [dataToDelete]);\n\n  const handleClosedModalDeleteAll = useCallback(() => {\n    if (shouldRefetchData) {\n      fetchListData();\n    } else {\n      dispatch({ type: 'RESET_DATA_TO_DELETE' });\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [shouldRefetchData]);\n\n  const handleModalClose = () => {\n    resetModalState();\n\n    if (shouldRefetch) {\n      fetchListData();\n      setShouldRefetch(false);\n    }\n  };\n\n  const handleSelectAll = () => {\n    dispatch({\n      type: 'TOGGLE_SELECT_ALL',\n    });\n  };\n\n  const resetModalState = () => {\n    setModalInitialStep('browse');\n    setFileToEdit(null);\n  };\n\n  const headerProps = {\n    title: {\n      label: pluginName,\n    },\n    /* eslint-disable indent */\n    content: canRead\n      ? formatMessage(\n          {\n            id: getTrad(getHeaderLabel(dataCount)),\n          },\n          { number: dataCount }\n        )\n      : null,\n    /* eslint-enable indent */\n    actions: [\n      {\n        disabled: dataToDelete.length === 0,\n        color: 'delete',\n        // TradId from the strapi-admin package\n        label: formatMessage({ id: 'app.utils.delete' }),\n        onClick: () => setIsPopupOpen(true),\n        type: 'button',\n        Component: buttonProps => {\n          if (!allowedActions.canUpdate) {\n            return null;\n          }\n\n          return <Button {...buttonProps} />;\n        },\n      },\n      {\n        disabled: false,\n        color: 'primary',\n        label: formatMessage({ id: getTrad('header.actions.upload-assets') }),\n        onClick: () => handleClickToggleModal(),\n        type: 'button',\n        Component: buttonProps => {\n          if (!allowedActions.canCreate) {\n            return null;\n          }\n\n          return <Button {...buttonProps} />;\n        },\n      },\n    ],\n  };\n\n  const handleRemoveFileFromDataToDelete = useCallback(id => {\n    dispatch({\n      type: 'ON_CHANGE_DATA_TO_DELETE',\n      id,\n    });\n  }, []);\n\n  const content = canRead ? (\n    <HomePageContent\n      data={data}\n      dataCount={dataCount}\n      dataToDelete={dataToDelete}\n      isLoading={isLoading}\n      onCardCheck={handleChangeCheck}\n      onCardClick={handleClickEditFile}\n      onClick={handleClickToggleModal}\n      onFilterDelete={handleDeleteFilter}\n      onParamsChange={handleChangeParams}\n      onSelectAll={handleSelectAll}\n    />\n  ) : null;\n\n  return (\n    <Container>\n      <Header {...headerProps} isLoading={isLoading} />\n      {content}\n      <ModalStepper\n        initialFileToEdit={fileToEdit}\n        initialStep={modalInitialStep}\n        isOpen={isModalOpen}\n        onClosed={handleModalClose}\n        onRemoveFileFromDataToDelete={handleRemoveFileFromDataToDelete}\n        onToggle={handleClickToggleModal}\n        refetchData={fetchListData}\n      />\n      <PopUpWarning\n        isOpen={isPopupOpen}\n        isConfirmButtonLoading={showModalConfirmButtonLoading}\n        onConfirm={handleConfirmDeleteMedias}\n        onClosed={handleClosedModalDeleteAll}\n        toggleModal={handleClickTogglePopup}\n        popUpWarningType=\"danger\"\n      />\n      <Padded bottom size=\"md\" />\n      <Padded bottom size=\"md\" />\n    </Container>\n  );\n};\n\nexport default HomePage;\n",
    "packages/strapi-plugin-upload/admin/src/containers/Initializer/index.js": "/**\n *\n * Initializer\n *\n */\n\nimport { useEffect, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { request } from 'strapi-helper-plugin';\nimport pluginId from '../../pluginId';\n\nconst Initializer = ({ updatePlugin }) => {\n  const ref = useRef();\n  ref.current = updatePlugin;\n\n  useEffect(() => {\n    const getData = async () => {\n      const requestURL = '/content-manager/content-types';\n\n      try {\n        const { data } = await request(requestURL, { method: 'GET' });\n        const fileModel = data.find(model => model.uid === 'plugins::upload.file');\n\n        ref.current(pluginId, 'fileModel', fileModel);\n        ref.current(pluginId, 'isReady', true);\n      } catch (err) {\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'content-manager.error.model.fetch' },\n        });\n      }\n    };\n\n    getData();\n  }, []);\n\n  return null;\n};\n\nInitializer.propTypes = {\n  updatePlugin: PropTypes.func.isRequired,\n};\n\nexport default Initializer;\n",
    "packages/strapi-plugin-upload/admin/src/containers/InputModalStepper/InputModalStepper.js": "import React, { useEffect, useState, useRef, memo } from 'react';\nimport PropTypes from 'prop-types';\nimport { Modal, ModalFooter, PopUpWarning, useGlobalContext, request } from 'strapi-helper-plugin';\nimport { Button } from '@buffetjs/core';\nimport { get, isEmpty, isEqual } from 'lodash';\nimport { getRequestUrl, getTrad } from '../../utils';\nimport ModalHeader from '../../components/ModalHeader';\nimport pluginId from '../../pluginId';\nimport stepper from './stepper';\nimport useModalContext from '../../hooks/useModalContext';\n\nconst InputModalStepper = ({\n  allowedActions,\n  isOpen,\n  onToggle,\n  noNavigation,\n  onInputMediaChange,\n}) => {\n  const { emitEvent, formatMessage } = useGlobalContext();\n  const [shouldDeleteFile, setShouldDeleteFile] = useState(false);\n  const [displayNextButton, setDisplayNextButton] = useState(false);\n  const {\n    addFilesToUpload,\n    currentStep,\n    downloadFiles,\n    fetchMediaLib,\n    filesToDownload,\n    filesToUpload,\n    fileToEdit,\n    formErrors,\n    goTo,\n    handleAbortUpload,\n    handleCancelFileToUpload,\n    handleCleanFilesError,\n    handleClearFilesToUploadAndDownload,\n    handleClickNextButton,\n    handleClose,\n    handleEditExistingFile,\n    handleFileSelection,\n    handleFileToEditChange,\n    handleFormDisabled,\n    handleGoToEditNewFile,\n    handleRemoveFileToUpload,\n    handleResetFileToEdit,\n    handleSetCropResult,\n    handleSetFileToEditError,\n    handleUploadFiles,\n    initialFileToEdit,\n    initialSelectedFiles,\n    isFormDisabled,\n    isWarningDeleteOpen,\n    multiple,\n    selectedFiles,\n    submitEditNewFile,\n    submitEditExistingFile,\n    toggleModalWarning,\n  } = useModalContext();\n  const {\n    backButtonDestination,\n    Component,\n    components,\n    headerBreadcrumbs,\n    next,\n    prev,\n    withBackButton,\n    HeaderComponent,\n  } = stepper[currentStep];\n  const filesToUploadLength = filesToUpload.length;\n  const editModalRef = useRef();\n\n  const handleReplaceMedia = () => {\n    emitEvent('didReplaceMedia', { location: 'upload' });\n\n    editModalRef.current.click();\n  };\n\n  useEffect(() => {\n    if (currentStep === 'upload') {\n      // Go to the modal list view when file uploading is over\n\n      if (filesToUploadLength === 0) {\n        goToList();\n      } else {\n        downloadFiles();\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [filesToUploadLength, currentStep]);\n\n  const addFilesToUploadList = ({ target: { value } }) => {\n    addFilesToUpload({ target: { value } });\n\n    goNext();\n  };\n\n  const goBack = (elementName = null) => {\n    const hasFilesToUpload = !isEmpty(filesToUpload);\n\n    // Redirect the user to the list modal from the upload one\n    if (elementName === 'backButton' && backButtonDestination && currentStep === 'upload') {\n      if (hasFilesToUpload) {\n        // eslint-disable-next-line no-alert\n        const confirm = window.confirm(\n          formatMessage({ id: getTrad('window.confirm.close-modal.files') })\n        );\n\n        if (!confirm) {\n          return;\n        }\n      }\n\n      goTo(backButtonDestination);\n      handleClearFilesToUploadAndDownload();\n\n      return;\n    }\n\n    if (\n      elementName === 'backButton' &&\n      backButtonDestination &&\n      currentStep === 'browse' &&\n      hasFilesToUpload\n    ) {\n      goTo(backButtonDestination);\n\n      return;\n    }\n\n    goTo(prev);\n  };\n\n  const goNext = () => {\n    if (next === null) {\n      onToggle();\n\n      return;\n    }\n\n    goTo(next);\n  };\n\n  const goToList = () => {\n    fetchMediaLib();\n    goTo('list');\n  };\n\n  const handleClickDeleteFile = async () => {\n    toggleModalWarning();\n  };\n\n  const handleClickDeleteFileToUpload = fileIndex => {\n    handleRemoveFileToUpload(fileIndex);\n\n    if (currentStep === 'edit-new') {\n      handleResetFileToEdit();\n\n      goNext();\n    }\n  };\n\n  const handleCloseModal = () => {\n    setDisplayNextButton(false);\n    handleClose();\n  };\n\n  const handleConfirmDeleteFile = () => {\n    setShouldDeleteFile(true);\n    toggleModalWarning();\n  };\n\n  const handleGoToAddBrowseFiles = () => {\n    handleCleanFilesError();\n\n    goBack();\n  };\n\n  const handleSubmitEditNewFile = e => {\n    e.preventDefault();\n    submitEditNewFile();\n    goNext();\n  };\n\n  const handleSubmit = e => {\n    e.preventDefault();\n    onInputMediaChange(multiple ? selectedFiles : selectedFiles[0]);\n    goNext();\n  };\n\n  const handleCloseModalWarning = async () => {\n    if (shouldDeleteFile) {\n      const { id } = fileToEdit;\n\n      try {\n        const requestURL = getRequestUrl(`files/${id}`);\n\n        await request(requestURL, { method: 'DELETE' });\n\n        setShouldDeleteFile(false);\n\n        // Remove file from selected files on delete and go back to the list.\n        handleFileSelection({ target: { name: id } });\n        goToList();\n      } catch (err) {\n        console.error(err);\n\n        const status = get(err, 'response.status', get(err, 'status', null));\n        const statusText = get(err, 'response.statusText', get(err, 'statusText', null));\n        const errorMessage = get(\n          err,\n          ['response', 'payload', 'message', '0', 'messages', '0', 'message'],\n          get(err, ['response', 'payload', 'message'], statusText)\n        );\n        strapi.notification.toggle({\n          type: 'warning',\n          message: errorMessage,\n        });\n\n        if (status) {\n          handleSetFileToEditError(errorMessage);\n        }\n      }\n    }\n  };\n\n  const handleSubmitEditExistingFile = async (\n    e,\n    shouldDuplicateMedia = false,\n    file = fileToEdit.file,\n    isSubmittingAfterCrop = false\n  ) => {\n    e.preventDefault();\n\n    submitEditExistingFile();\n\n    if (isSubmittingAfterCrop) {\n      emitEvent('didCropFile', {\n        duplicatedFile: shouldDuplicateMedia,\n        location: 'content-manager',\n      });\n    }\n\n    const headers = {};\n    const formData = new FormData();\n\n    // If the file has been cropped we need to add it to the formData\n    // otherwise we just don't send it\n    const didCropFile = file instanceof File;\n    const { abortController, id, fileInfo } = fileToEdit;\n    const requestURL = shouldDuplicateMedia ? `/${pluginId}` : `/${pluginId}?id=${id}`;\n\n    if (didCropFile) {\n      formData.append('files', file);\n    }\n\n    formData.append('fileInfo', JSON.stringify(fileInfo));\n\n    try {\n      const editedFile = await request(\n        requestURL,\n        {\n          method: 'POST',\n          headers,\n          body: formData,\n          signal: abortController.signal,\n        },\n        false,\n        false\n      );\n\n      handleEditExistingFile(editedFile);\n      goToList();\n    } catch (err) {\n      const status = get(err, 'response.status', get(err, 'status', null));\n      const statusText = get(err, 'response.statusText', get(err, 'statusText', null));\n      let errorMessage = get(\n        err,\n        ['response', 'payload', 'message', '0', 'messages', '0', 'message'],\n        get(err, ['response', 'payload', 'message'], statusText)\n      );\n\n      // TODO fix errors globally when the back-end sends readable one\n      if (status === 413) {\n        errorMessage = formatMessage({ id: 'app.utils.errors.file-too-big.message' });\n      }\n\n      if (status) {\n        handleSetFileToEditError(errorMessage);\n      }\n    }\n  };\n\n  const handleToggle = () => {\n    if (filesToUploadLength > 0) {\n      // eslint-disable-next-line no-alert\n      const confirm = window.confirm(\n        formatMessage({ id: getTrad('window.confirm.close-modal.files') })\n      );\n\n      if (!confirm) {\n        return;\n      }\n    }\n\n    if (\n      (currentStep === 'list' && !isEqual(selectedFiles, initialSelectedFiles)) ||\n      (currentStep === 'edit' && initialFileToEdit && !isEqual(fileToEdit, initialFileToEdit)) ||\n      (currentStep === 'edit' && selectedFiles.length > 0)\n    ) {\n      // eslint-disable-next-line no-alert\n      const confirm = window.confirm(\n        formatMessage({ id: getTrad('window.confirm.close-modal.file') })\n      );\n\n      if (!confirm) {\n        return;\n      }\n    }\n\n    onToggle(true);\n  };\n\n  const shouldDisplayNextButton = currentStep === 'browse' && displayNextButton;\n  const isFinishButtonDisabled = filesToUpload.some(file => file.isDownloading || file.isUploading);\n  const areButtonsDisabledOnEditExistingFile =\n    currentStep === 'edit' && fileToEdit.isUploading === true;\n\n  return (\n    <>\n      <Modal isOpen={isOpen} onToggle={handleToggle} onClosed={handleCloseModal}>\n        {/* header title */}\n        <ModalHeader\n          goBack={goBack}\n          HeaderComponent={HeaderComponent}\n          headerBreadcrumbs={headerBreadcrumbs}\n          withBackButton={withBackButton}\n        />\n        {/* body of the modal */}\n        {Component && (\n          <Component\n            {...allowedActions}\n            addFilesToUpload={addFilesToUploadList}\n            components={components}\n            filesToDownload={filesToDownload}\n            filesToUpload={filesToUpload}\n            fileToEdit={fileToEdit}\n            formErrors={formErrors}\n            isEditingUploadedFile={currentStep === 'edit'}\n            isFormDisabled={isFormDisabled}\n            noNavigation={noNavigation}\n            onAbortUpload={handleAbortUpload}\n            onChange={handleFileToEditChange}\n            onClickCancelUpload={handleCancelFileToUpload}\n            onClickDeleteFileToUpload={\n              currentStep === 'edit' ? handleClickDeleteFile : handleClickDeleteFileToUpload\n            }\n            onSubmitEdit={\n              currentStep === 'edit' ? handleSubmitEditExistingFile : handleSubmitEditNewFile\n            }\n            onClickEditNewFile={handleGoToEditNewFile}\n            onGoToAddBrowseFiles={handleGoToAddBrowseFiles}\n            onSubmitEditNewFile={handleSubmitEditNewFile}\n            ref={currentStep === 'edit' ? editModalRef : null}\n            toggleDisableForm={handleFormDisabled}\n            onToggle={handleToggle}\n            setCropResult={handleSetCropResult}\n            setShouldDisplayNextButton={setDisplayNextButton}\n            withBackButton={withBackButton}\n          />\n        )}\n\n        <ModalFooter>\n          <section>\n            <Button type=\"button\" color=\"cancel\" onClick={handleToggle}>\n              {formatMessage({ id: 'app.components.Button.cancel' })}\n            </Button>\n            {currentStep === 'upload' && (\n              <Button\n                type=\"button\"\n                color=\"success\"\n                onClick={handleUploadFiles}\n                disabled={isFinishButtonDisabled}\n              >\n                {formatMessage(\n                  {\n                    id: getTrad(\n                      `modal.upload-list.footer.button.${\n                        filesToUploadLength > 1 ? 'plural' : 'singular'\n                      }`\n                    ),\n                  },\n                  { number: filesToUploadLength }\n                )}\n              </Button>\n            )}\n            {shouldDisplayNextButton && (\n              <Button\n                type=\"button\"\n                color=\"primary\"\n                onClick={handleClickNextButton}\n                disabled={isEmpty(filesToDownload)}\n              >\n                {formatMessage({ id: getTrad('button.next') })}\n              </Button>\n            )}\n            {currentStep === 'edit-new' && (\n              <Button color=\"success\" type=\"button\" onClick={handleSubmitEditNewFile}>\n                {formatMessage({ id: 'form.button.finish' })}\n              </Button>\n            )}\n            {currentStep === 'edit' && (\n              <div style={{ margin: 'auto 0' }}>\n                <Button\n                  disabled={isFormDisabled || areButtonsDisabledOnEditExistingFile}\n                  color=\"primary\"\n                  onClick={handleReplaceMedia}\n                  style={{ marginRight: 10 }}\n                >\n                  {formatMessage({ id: getTrad('control-card.replace-media') })}\n                </Button>\n\n                <Button\n                  disabled={isFormDisabled || areButtonsDisabledOnEditExistingFile}\n                  color=\"success\"\n                  type=\"button\"\n                  onClick={handleSubmitEditExistingFile}\n                >\n                  {formatMessage({ id: 'form.button.finish' })}\n                </Button>\n              </div>\n            )}\n            {currentStep === 'list' && (\n              <Button color=\"success\" type=\"button\" onClick={handleSubmit}>\n                {formatMessage({ id: 'form.button.finish' })}\n              </Button>\n            )}\n          </section>\n        </ModalFooter>\n      </Modal>\n      <PopUpWarning\n        onClosed={handleCloseModalWarning}\n        isOpen={isWarningDeleteOpen}\n        toggleModal={toggleModalWarning}\n        popUpWarningType=\"danger\"\n        onConfirm={handleConfirmDeleteFile}\n      />\n    </>\n  );\n};\n\nInputModalStepper.defaultProps = {\n  allowedActions: {\n    canCopyLink: true,\n    canCreate: true,\n    canDownload: true,\n    canMain: true,\n    canRead: true,\n    canSettings: true,\n    canUpdate: true,\n  },\n  noNavigation: false,\n  onToggle: () => {},\n};\n\nInputModalStepper.propTypes = {\n  allowedActions: PropTypes.shape({\n    canCopyLink: PropTypes.bool,\n    canCreate: PropTypes.bool,\n    canDownload: PropTypes.bool,\n    canMain: PropTypes.bool,\n    canRead: PropTypes.bool,\n    canSettings: PropTypes.bool,\n    canUpdate: PropTypes.bool,\n  }),\n  isOpen: PropTypes.bool.isRequired,\n  noNavigation: PropTypes.bool,\n  onInputMediaChange: PropTypes.func.isRequired,\n  onToggle: PropTypes.func,\n};\n\nexport default memo(InputModalStepper);\n",
    "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js": "import React, { useReducer, useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { request, generateSearchFromFilters, useGlobalContext } from 'strapi-helper-plugin';\nimport { clone, get, isEmpty, set } from 'lodash';\nimport { useIntl } from 'react-intl';\nimport axios from 'axios';\nimport pluginId from '../../pluginId';\nimport {\n  getFilesToDownload,\n  getRequestUrl,\n  getYupError,\n  compactParams,\n  createNewFilesToUploadArray,\n  urlSchema,\n  getFileModelTimestamps,\n  formatFilters,\n} from '../../utils';\nimport InputModalStepperContext from '../../contexts/InputModal/InputModalDataManager';\n\nimport init from './init';\nimport reducer, { initialState } from './reducer';\n\n/* eslint-disable indent */\n\nconst InputModalStepperProvider = ({\n  allowedActions,\n  allowedTypes,\n  children,\n  initialFilesToUpload,\n  initialFileToEdit,\n  isOpen,\n  multiple,\n  noNavigation,\n  onClosed,\n  onInputMediaChange,\n  selectedFiles,\n  step,\n}) => {\n  const [formErrors, setFormErrors] = useState(null);\n\n  const { formatMessage } = useIntl();\n  const { emitEvent, plugins } = useGlobalContext();\n  const [, updated_at] = getFileModelTimestamps(plugins);\n  const [reducerState, dispatch] = useReducer(reducer, initialState, state =>\n    init({\n      ...state,\n      allowedTypes,\n      currentStep: step,\n      initialFileToEdit,\n      fileToEdit: initialFileToEdit,\n      initialSelectedFiles: Array.isArray(selectedFiles) ? selectedFiles : [selectedFiles],\n      selectedFiles: Array.isArray(selectedFiles) ? selectedFiles : [selectedFiles],\n      filesToUpload: initialFilesToUpload\n        ? createNewFilesToUploadArray(initialFilesToUpload).map((file, index) => ({\n            ...file,\n            originalIndex: index,\n          }))\n        : [],\n      params: {\n        ...state.params,\n        _sort: `${updated_at}:DESC`,\n      },\n    })\n  );\n  const { params, filesToDownload, filesToUpload, fileToEdit } = reducerState;\n\n  useEffect(() => {\n    if (isOpen) {\n      fetchMediaLib();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen, params]);\n\n  const downloadFiles = async () => {\n    const files = getFilesToDownload(filesToUpload);\n\n    // Emit event when the users download files from url\n    if (files.length > 0) {\n      emitEvent('didSelectFile', { source: 'url', location: 'content-manager' });\n    }\n\n    try {\n      await Promise.all(\n        files.map(file => {\n          const { source } = file;\n\n          return axios\n            .get(file.fileURL, {\n              responseType: 'blob',\n              cancelToken: source.token,\n              timeout: 60000,\n            })\n            .then(({ data }) => {\n              const createdFile = new File([data], file.fileURL, {\n                type: data.type,\n              });\n\n              dispatch({\n                type: 'FILE_DOWNLOADED',\n                blob: createdFile,\n                originalIndex: file.originalIndex,\n                fileTempId: file.tempId,\n              });\n            })\n            .catch(err => {\n              console.error('fetch file error', err);\n\n              dispatch({\n                type: 'SET_FILE_TO_DOWNLOAD_ERROR',\n                originalIndex: file.originalIndex,\n                fileTempId: file.tempId,\n              });\n            });\n        })\n      );\n    } catch (err) {\n      // Silent\n    }\n  };\n\n  const handleRemoveFileToUpload = fileIndex => {\n    dispatch({\n      type: 'REMOVE_FILE_TO_UPLOAD',\n      fileIndex,\n    });\n  };\n\n  const handleModalTabChange = to => {\n    dispatch({\n      type: 'ON_CHANGE_MODAL_TAB',\n      to,\n    });\n  };\n\n  const handleClickNextButton = async () => {\n    try {\n      await urlSchema.validate(\n        { filesToDownload: filesToDownload.filter(url => !isEmpty(url)) },\n        { abortEarly: false }\n      );\n\n      setFormErrors(null);\n      // Navigate to next step\n      dispatch({\n        type: 'ADD_URLS_TO_FILES_TO_UPLOAD',\n        nextStep: 'upload',\n      });\n    } catch (err) {\n      const formattedErrors = getYupError(err);\n\n      setFormErrors(formattedErrors.filesToDownload);\n    }\n  };\n\n  const handleFileToEditChange = ({ target: { name, value } }) => {\n    let val = value;\n    let type = 'ON_CHANGE';\n\n    if (name === 'url') {\n      setFormErrors(null);\n\n      val = value.split('\\n');\n      type = 'ON_CHANGE_URLS_TO_DOWNLOAD';\n    }\n\n    dispatch({\n      type,\n      keys: name,\n      value: val,\n    });\n  };\n\n  const handleMoveAsset = (dragIndex, hoverIndex) => {\n    dispatch({\n      type: 'MOVE_ASSET',\n      dragIndex,\n      hoverIndex,\n    });\n  };\n\n  const toggleModalWarning = () => {\n    dispatch({\n      type: 'TOGGLE_MODAL_WARNING',\n    });\n  };\n\n  const submitEditNewFile = () => {\n    dispatch({\n      type: 'ON_SUBMIT_EDIT_NEW_FILE',\n    });\n  };\n\n  const submitEditExistingFile = () => {\n    dispatch({\n      type: 'ON_SUBMIT_EDIT_EXISTING_FILE',\n    });\n  };\n\n  const handleEditExistingFile = file => {\n    dispatch({\n      type: 'EDIT_EXISTING_FILE',\n      file,\n    });\n  };\n\n  const handleResetFileToEdit = () => {\n    dispatch({\n      type: 'RESET_FILE_TO_EDIT',\n    });\n  };\n\n  const removeFilter = index => {\n    dispatch({\n      type: 'REMOVE_FILTER',\n      filterToRemove: index,\n    });\n  };\n\n  const handleClose = () => {\n    setFormErrors(null);\n\n    dispatch({\n      type: 'RESET_PROPS',\n      defaultSort: `${updated_at}:DESC`,\n    });\n    onClosed();\n  };\n\n  const handleFileSelection = ({ target: { name } }) => {\n    dispatch({\n      type: 'ON_FILE_SELECTION',\n      id: name,\n    });\n  };\n\n  const handleAllFilesSelection = () => {\n    dispatch({\n      type: 'TOGGLE_SELECT_ALL',\n    });\n  };\n\n  const setParam = param => {\n    dispatch({\n      type: 'SET_PARAM',\n      param,\n    });\n  };\n\n  const goTo = to => {\n    dispatch({\n      type: 'GO_TO',\n      to,\n    });\n  };\n\n  const handleGoToEditNewFile = fileIndex => {\n    dispatch({\n      type: 'SET_NEW_FILE_TO_EDIT',\n      fileIndex,\n    });\n\n    goTo('edit-new');\n  };\n\n  const handleGoToEditFile = fileId => {\n    dispatch({\n      type: 'SET_FILE_TO_EDIT',\n      fileId,\n    });\n\n    goTo('edit');\n  };\n\n  const handleCleanFilesError = () => {\n    dispatch({\n      type: 'CLEAN_FILES_ERROR',\n    });\n  };\n\n  const handleSetCropResult = blob => {\n    // Emit event : the user cropped a file that is not uploaded\n    emitEvent('didCropFile', { duplicatedFile: null, location: 'content-manager' });\n\n    dispatch({\n      type: 'SET_CROP_RESULT',\n      blob,\n    });\n  };\n\n  const handleFormDisabled = isFormDisabled => {\n    dispatch({\n      type: 'SET_FORM_DISABLED',\n      isFormDisabled,\n    });\n  };\n\n  const handleAbortUpload = () => {\n    const { abortController } = fileToEdit;\n\n    abortController.abort();\n\n    dispatch({\n      type: 'ON_ABORT_UPLOAD',\n    });\n  };\n\n  const handleCancelFileToUpload = fileIndex => {\n    const fileToCancel = get(filesToUpload, fileIndex, {});\n\n    const { source } = fileToCancel;\n\n    // Cancel upload\n    if (source) {\n      // Cancel dowload file upload with axios\n      source.cancel('Operation canceled by the user.');\n    } else {\n      // Cancel uplodad file with fetch\n      fileToCancel.abortController.abort();\n    }\n\n    handleRemoveFileToUpload(fileIndex);\n  };\n\n  const getFilters = (filtersToOmit = []) => {\n    const compactedParams = compactParams(params);\n    const searchParams = generateSearchFromFilters(compactedParams, filtersToOmit);\n\n    return formatFilters(searchParams);\n  };\n\n  const fetchMediaLibFilesCount = async () => {\n    const requestURL = getRequestUrl('files/count');\n    const paramsToSend = getFilters(['_limit', '_sort', '_start']);\n\n    try {\n      return await request(`${requestURL}?${paramsToSend}`, {\n        method: 'GET',\n      });\n    } catch (err) {\n      console.error(err);\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n\n      return 0;\n    }\n  };\n\n  const fetchMediaLib = async () => {\n    if (allowedActions.canRead) {\n      const [files, count] = await Promise.all([fetchMediaLibFiles(), fetchMediaLibFilesCount()]);\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        files,\n        countData: count,\n      });\n    }\n  };\n\n  const fetchMediaLibFiles = async () => {\n    const requestURL = getRequestUrl('files');\n    const paramsToSend = getFilters();\n\n    try {\n      return await request(`${requestURL}?${paramsToSend}`, {\n        method: 'GET',\n      });\n    } catch (err) {\n      console.error(err);\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n\n      return [];\n    }\n  };\n\n  const addFilesToUpload = ({ target: { value } }) => {\n    emitEvent('didSelectFile', { source: 'computer', location: 'content-manager' });\n\n    dispatch({\n      type: 'ADD_FILES_TO_UPLOAD',\n      filesToUpload: value,\n    });\n  };\n\n  const handleClearFilesToUploadAndDownload = () => {\n    dispatch({\n      type: 'CLEAR_FILES_TO_UPLOAD_AND_DOWNLOAD',\n    });\n  };\n\n  const handleSetFileToEditError = errorMessage => {\n    dispatch({\n      type: 'SET_FILE_TO_EDIT_ERROR',\n      errorMessage,\n    });\n  };\n\n  const handleUploadFiles = async () => {\n    dispatch({\n      type: 'SET_FILES_UPLOADING_STATE',\n    });\n\n    const requests = filesToUpload.map(\n      async ({ file, fileInfo, originalIndex, originalName, abortController }) => {\n        const formData = new FormData();\n        const headers = {};\n        const infos = clone(fileInfo);\n\n        if (originalName === infos.name) {\n          set(infos, 'name', null);\n        }\n\n        formData.append('files', file);\n        formData.append('fileInfo', JSON.stringify(infos));\n\n        try {\n          const uploadedFile = await request(\n            `/${pluginId}`,\n            {\n              method: 'POST',\n              headers,\n              body: formData,\n              signal: abortController.signal,\n            },\n            false,\n            false\n          );\n\n          const filesToSelect = uploadedFile.filter(file => {\n            const fileType = file.mime.split('/')[0];\n\n            if (allowedTypes.includes('file') && !['video', 'image'].includes(fileType)) {\n              return true;\n            }\n\n            return allowedTypes.length === 0 || allowedTypes.includes(fileType);\n          });\n\n          dispatch({\n            type: 'REMOVE_FILE_TO_UPLOAD',\n            fileIndex: originalIndex,\n            addToSelectedFiles: filesToSelect,\n            multiple,\n          });\n        } catch (err) {\n          const status = get(err, 'response.status', get(err, 'status', null));\n          const statusText = get(err, 'response.statusText', get(err, 'statusText', null));\n          let errorMessage = get(\n            err,\n            ['response', 'payload', 'message', '0', 'messages', '0', 'message'],\n            get(err, ['response', 'payload', 'message'], statusText)\n          );\n\n          // TODO fix errors globally when the back-end sends readable one\n          if (status === 413) {\n            errorMessage = formatMessage({ id: 'app.utils.errors.file-too-big.message' });\n          }\n\n          if (status) {\n            dispatch({\n              type: 'SET_FILE_ERROR',\n              fileIndex: originalIndex,\n              errorMessage,\n            });\n          }\n        }\n      }\n    );\n\n    await Promise.all(requests);\n  };\n\n  return (\n    <InputModalStepperContext.Provider\n      value={{\n        ...reducerState,\n        allowedActions,\n        addFilesToUpload,\n        downloadFiles,\n        fetchMediaLib,\n        formErrors,\n        goTo,\n        handleAbortUpload,\n        handleAllFilesSelection,\n        handleCancelFileToUpload,\n        handleClickNextButton,\n        handleCleanFilesError,\n        handleClearFilesToUploadAndDownload,\n        handleClose,\n        handleEditExistingFile,\n        handleFileSelection,\n        handleFileToEditChange,\n        handleFormDisabled,\n        handleGoToEditFile,\n        handleGoToEditNewFile,\n        handleModalTabChange,\n        handleRemoveFileToUpload,\n        handleResetFileToEdit,\n        handleSetCropResult,\n        handleUploadFiles,\n        handleSetFileToEditError,\n        moveAsset: handleMoveAsset,\n        multiple,\n        noNavigation,\n        onInputMediaChange,\n        removeFilter,\n        setParam,\n        submitEditNewFile,\n        submitEditExistingFile,\n        toggleModalWarning,\n      }}\n    >\n      {children}\n    </InputModalStepperContext.Provider>\n  );\n};\n\nInputModalStepperProvider.propTypes = {\n  allowedActions: PropTypes.shape({\n    canCopyLink: PropTypes.bool,\n    canCreate: PropTypes.bool,\n    canDownload: PropTypes.bool,\n    canMain: PropTypes.bool,\n    canRead: PropTypes.bool,\n    canSettings: PropTypes.bool,\n    canUpdate: PropTypes.bool,\n  }),\n  allowedTypes: PropTypes.arrayOf(PropTypes.string),\n  children: PropTypes.node.isRequired,\n  initialFilesToUpload: PropTypes.object,\n  initialFileToEdit: PropTypes.object,\n  isOpen: PropTypes.bool,\n  multiple: PropTypes.bool.isRequired,\n  noNavigation: PropTypes.bool,\n  onClosed: PropTypes.func.isRequired,\n  onInputMediaChange: PropTypes.func,\n  selectedFiles: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),\n  step: PropTypes.string.isRequired,\n};\n\nInputModalStepperProvider.defaultProps = {\n  allowedActions: {\n    canCopyLink: true,\n    canCreate: true,\n    canDownload: true,\n    canMain: true,\n    canRead: true,\n    canSettings: true,\n    canUpdate: true,\n  },\n  initialFileToEdit: null,\n  initialFilesToUpload: null,\n  isOpen: false,\n  noNavigation: false,\n  onInputMediaChange: () => {},\n  selectedFiles: null,\n  allowedTypes: [],\n};\n\nexport default InputModalStepperProvider;\n",
    "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js": "import React, { useCallback, useEffect, useState, useReducer, useRef } from 'react';\nimport axios from 'axios';\nimport PropTypes from 'prop-types';\nimport { isEqual, isEmpty, get, set } from 'lodash';\nimport { Modal, ModalFooter, PopUpWarning, useGlobalContext, request } from 'strapi-helper-plugin';\nimport { Button } from '@buffetjs/core';\nimport pluginId from '../../pluginId';\nimport { getFilesToDownload, getTrad, getYupError, urlSchema } from '../../utils';\nimport { useAppContext } from '../../hooks';\nimport ModalHeader from '../../components/ModalHeader';\nimport stepper from './stepper';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\n\nconst ModalStepper = ({\n  initialFileToEdit,\n  initialStep,\n  isOpen,\n  onClosed,\n  onRemoveFileFromDataToDelete,\n  onToggle,\n}) => {\n  const { allowedActions } = useAppContext();\n  const { emitEvent, formatMessage } = useGlobalContext();\n  const [isWarningDeleteOpen, setIsWarningDeleteOpen] = useState(false);\n  const [showModalConfirmButtonLoading, setShowModalConfirmButtonLoading] = useState(false);\n  const [isFormDisabled, setIsFormDisabled] = useState(false);\n  const [formErrors, setFormErrors] = useState(null);\n  const [shouldRefetch, setShouldRefetch] = useState(false);\n  const [displayNextButton, setDisplayNextButton] = useState(false);\n  const [reducerState, dispatch] = useReducer(reducer, initialState, init);\n  const { currentStep, fileToEdit, filesToDownload, filesToUpload } = reducerState.toJS();\n  const { Component, components, headerBreadcrumbs, next, prev, withBackButton } = stepper[\n    currentStep\n  ];\n  const filesToUploadLength = filesToUpload.length;\n  const toggleRef = useRef(onToggle);\n  const editModalRef = useRef();\n  const downloadFilesRef = useRef();\n\n  useEffect(() => {\n    if (currentStep === 'upload') {\n      // Close the modal\n      if (filesToUploadLength === 0) {\n        // Passing true to the onToggle prop will refetch the data when the modal closes\n        toggleRef.current(true);\n      } else {\n        // Download files from url\n        downloadFilesRef.current();\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [filesToUploadLength, currentStep]);\n\n  useEffect(() => {\n    if (isOpen) {\n      goTo(initialStep);\n\n      if (initialFileToEdit) {\n        dispatch({\n          type: 'INIT_FILE_TO_EDIT',\n          fileToEdit: initialFileToEdit,\n        });\n      }\n    }\n    // Disabling the rule because we just want to let the ability to open the modal\n    // at a specific step then we will let the stepper handle the navigation\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen]);\n\n  const addFilesToUpload = ({ target: { value } }) => {\n    emitEvent('didSelectFile', { source: 'computer', location: 'upload' });\n\n    dispatch({\n      type: 'ADD_FILES_TO_UPLOAD',\n      filesToUpload: value,\n    });\n\n    goTo(next);\n  };\n\n  downloadFilesRef.current = async () => {\n    const files = getFilesToDownload(filesToUpload);\n\n    // Emit event when the users download files from url\n    if (files.length > 0) {\n      emitEvent('didSelectFile', { source: 'url', location: 'upload' });\n    }\n\n    try {\n      await Promise.all(\n        files.map(file => {\n          const { source } = file;\n\n          return axios\n            .get(file.fileURL, {\n              responseType: 'blob',\n              cancelToken: source.token,\n              timeout: 60000,\n            })\n            .then(({ data }) => {\n              const fileName = file.fileInfo.name;\n              const createdFile = new File([data], fileName, {\n                type: data.type,\n              });\n\n              dispatch({\n                type: 'FILE_DOWNLOADED',\n                blob: createdFile,\n                originalIndex: file.originalIndex,\n                fileTempId: file.tempId,\n              });\n            })\n            .catch(err => {\n              console.error('fetch file error', err);\n\n              dispatch({\n                type: 'SET_FILE_TO_DOWNLOAD_ERROR',\n                originalIndex: file.originalIndex,\n                fileTempId: file.tempId,\n              });\n            });\n        })\n      );\n    } catch (err) {\n      // Silent\n    }\n  };\n\n  const handleAbortUpload = () => {\n    const { abortController } = fileToEdit;\n\n    abortController.abort();\n\n    dispatch({\n      type: 'ON_ABORT_UPLOAD',\n    });\n  };\n\n  const handleCancelFileToUpload = fileOriginalIndex => {\n    const fileToCancel = filesToUpload.find(file => file.originalIndex === fileOriginalIndex);\n    const { source } = fileToCancel;\n\n    // Cancel\n    if (source) {\n      // Cancel dowload file upload with axios\n      source.cancel('Operation canceled by the user.');\n    } else {\n      // Cancel upload with fetch\n      fileToCancel.abortController.abort();\n    }\n\n    dispatch({\n      type: 'REMOVE_FILE_TO_UPLOAD',\n      fileIndex: fileOriginalIndex,\n    });\n  };\n\n  const handleChange = ({ target: { name, value } }) => {\n    let val = value;\n    let type = 'ON_CHANGE';\n\n    if (name === 'url') {\n      setFormErrors(null);\n\n      val = value.split('\\n');\n      type = 'ON_CHANGE_URLS_TO_DOWNLOAD';\n    }\n\n    dispatch({\n      type,\n      keys: name,\n      value: val,\n    });\n  };\n\n  const handleConfirmDeleteFile = useCallback(async () => {\n    const { id } = fileToEdit;\n    // Remove the file from the selected data to delete\n    onRemoveFileFromDataToDelete(id);\n\n    // Show a loader in the popup warning\n    setShowModalConfirmButtonLoading(true);\n\n    try {\n      await request(`/${pluginId}/files/${id}`, {\n        method: 'DELETE',\n      });\n\n      setShouldRefetch(true);\n    } catch (err) {\n      const errorMessage = get(err, 'response.payload.message', 'An error occured');\n\n      strapi.notification.toggle({\n        type: 'warning',\n        message: errorMessage,\n      });\n    } finally {\n      setShowModalConfirmButtonLoading(true);\n      toggleModalWarning();\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [fileToEdit]);\n\n  const handleClickNextButton = async () => {\n    try {\n      await urlSchema.validate(\n        { filesToDownload: filesToDownload.filter(url => !isEmpty(url)) },\n        { abortEarly: false }\n      );\n\n      setFormErrors(null);\n      // Navigate to next step\n      dispatch({\n        type: 'ADD_URLS_TO_FILES_TO_UPLOAD',\n        nextStep: next,\n      });\n    } catch (err) {\n      const formattedErrors = getYupError(err);\n\n      setFormErrors(formattedErrors.filesToDownload);\n    }\n  };\n\n  const handleClickDeleteFile = async () => {\n    toggleModalWarning();\n  };\n\n  const handleClickDeleteFileToUpload = fileIndex => {\n    dispatch({\n      type: 'REMOVE_FILE_TO_UPLOAD',\n      fileIndex,\n    });\n\n    if (currentStep === 'edit-new') {\n      dispatch({\n        type: 'RESET_FILE_TO_EDIT',\n      });\n\n      goNext();\n    }\n  };\n\n  const handleClose = () => {\n    onClosed();\n    setIsFormDisabled(false);\n    setDisplayNextButton(false);\n    setFormErrors(null);\n    setShouldRefetch(false);\n\n    dispatch({\n      type: 'RESET_PROPS',\n    });\n  };\n\n  const handleCloseModalWarning = async () => {\n    setShowModalConfirmButtonLoading(false);\n\n    onToggle(shouldRefetch);\n  };\n\n  const handleGoToEditNewFile = fileIndex => {\n    dispatch({\n      type: 'SET_FILE_TO_EDIT',\n      fileIndex,\n    });\n\n    goTo('edit-new');\n  };\n\n  const handleGoToAddBrowseFiles = () => {\n    dispatch({\n      type: 'CLEAN_FILES_ERROR',\n    });\n\n    goBack();\n  };\n\n  const handleSetCropResult = blob => {\n    // Emit event : the user cropped a file that is not uploaded\n    emitEvent('didCropFile', { duplicatedFile: null, location: 'upload' });\n\n    dispatch({\n      type: 'SET_CROP_RESULT',\n      blob,\n    });\n  };\n\n  const handleSubmitEditNewFile = e => {\n    e.preventDefault();\n\n    dispatch({\n      type: 'ON_SUBMIT_EDIT_NEW_FILE',\n    });\n\n    goNext();\n  };\n\n  const handleSubmitEditExistingFile = async (\n    e,\n    shouldDuplicateMedia = false,\n    file = fileToEdit.file,\n    isSubmittingAfterCrop = false\n  ) => {\n    e.preventDefault();\n\n    if (isSubmittingAfterCrop) {\n      emitEvent('didCropFile', { duplicatedFile: shouldDuplicateMedia, location: 'upload' });\n    }\n\n    dispatch({\n      type: 'ON_SUBMIT_EDIT_EXISTING_FILE',\n    });\n\n    const headers = {};\n    const formData = new FormData();\n\n    // If the file has been cropped we need to add it to the formData\n    // otherwise we just don't send it\n    const didCropFile = file instanceof File;\n    const { abortController, id, fileInfo } = fileToEdit;\n    const requestURL = shouldDuplicateMedia ? `/${pluginId}` : `/${pluginId}?id=${id}`;\n\n    if (didCropFile) {\n      formData.append('files', file);\n    }\n\n    formData.append('fileInfo', JSON.stringify(fileInfo));\n\n    try {\n      await request(\n        requestURL,\n        {\n          method: 'POST',\n          headers,\n          body: formData,\n          signal: abortController.signal,\n        },\n        false,\n        false\n      );\n      // Close the modal and refetch data\n      toggleRef.current(true);\n    } catch (err) {\n      console.error(err);\n      const status = get(err, 'response.status', get(err, 'status', null));\n      const statusText = get(err, 'response.statusText', get(err, 'statusText', null));\n      let errorMessage = get(\n        err,\n        ['response', 'payload', 'message', '0', 'messages', '0', 'message'],\n        get(err, ['response', 'payload', 'message'], statusText)\n      );\n\n      // TODO fix errors globally when the back-end sends readable one\n      if (status === 413) {\n        errorMessage = formatMessage({ id: 'app.utils.errors.file-too-big.message' });\n      }\n\n      if (status) {\n        dispatch({\n          type: 'SET_FILE_TO_EDIT_ERROR',\n          errorMessage,\n        });\n      }\n    }\n  };\n\n  const handleReplaceMedia = () => {\n    emitEvent('didReplaceMedia', { location: 'upload' });\n    editModalRef.current.click();\n  };\n\n  const handleToggle = () => {\n    if (filesToUploadLength > 0) {\n      // eslint-disable-next-line no-alert\n      const confirm = window.confirm(\n        formatMessage({ id: getTrad('window.confirm.close-modal.files') })\n      );\n\n      if (!confirm) {\n        return;\n      }\n    }\n\n    if (!isEqual(initialFileToEdit, fileToEdit) && currentStep === 'edit') {\n      // eslint-disable-next-line no-alert\n      const confirm = window.confirm(\n        formatMessage({ id: getTrad('window.confirm.close-modal.file') })\n      );\n\n      if (!confirm) {\n        return;\n      }\n    }\n\n    onToggle(shouldRefetch);\n  };\n\n  const handleUploadFiles = async () => {\n    dispatch({\n      type: 'SET_FILES_UPLOADING_STATE',\n    });\n\n    const requests = filesToUpload.map(\n      async ({ file, fileInfo, originalName, originalIndex, abortController }) => {\n        const formData = new FormData();\n        const headers = {};\n\n        if (originalName === fileInfo.name) {\n          set(fileInfo, 'name', null);\n        }\n\n        formData.append('files', file);\n        formData.append('fileInfo', JSON.stringify(fileInfo));\n\n        try {\n          await request(\n            `/${pluginId}`,\n            {\n              method: 'POST',\n              headers,\n              body: formData,\n              signal: abortController.signal,\n            },\n            false,\n            false\n          );\n\n          setShouldRefetch(true);\n\n          dispatch({\n            type: 'REMOVE_FILE_TO_UPLOAD',\n            fileIndex: originalIndex,\n          });\n        } catch (err) {\n          console.error(err);\n          const status = get(err, 'response.status', get(err, 'status', null));\n          const statusText = get(err, 'response.statusText', get(err, 'statusText', null));\n          let errorMessage = get(\n            err,\n            ['response', 'payload', 'message', '0', 'messages', '0', 'message'],\n            get(err, ['response', 'payload', 'message'], statusText)\n          );\n\n          // TODO fix errors globally when the back-end sends readable one\n          if (status === 413) {\n            errorMessage = formatMessage({ id: 'app.utils.errors.file-too-big.message' });\n          }\n\n          if (status) {\n            dispatch({\n              type: 'SET_FILE_ERROR',\n              fileIndex: originalIndex,\n              errorMessage,\n            });\n          }\n        }\n      }\n    );\n\n    await Promise.all(requests);\n  };\n\n  const goBack = () => {\n    goTo(prev);\n  };\n\n  const goNext = () => {\n    if (next === null) {\n      onToggle();\n\n      return;\n    }\n\n    goTo(next);\n  };\n\n  const goTo = to => {\n    dispatch({\n      type: 'GO_TO',\n      to,\n    });\n  };\n\n  const toggleModalWarning = () => {\n    setIsWarningDeleteOpen(prev => !prev);\n  };\n\n  const shouldDisplayNextButton = currentStep === 'browse' && displayNextButton;\n  const isFinishButtonDisabled = filesToUpload.some(file => file.isDownloading || file.isUploading);\n  const areButtonsDisabledOnEditExistingFile =\n    currentStep === 'edit' && fileToEdit.isUploading === true;\n\n  return (\n    <>\n      <Modal isOpen={isOpen} onToggle={handleToggle} onClosed={handleClose}>\n        {/* header title */}\n        <ModalHeader\n          goBack={goBack}\n          headerBreadcrumbs={headerBreadcrumbs}\n          withBackButton={withBackButton}\n        />\n\n        {/* body of the modal */}\n        {Component && (\n          <Component\n            {...allowedActions}\n            onAbortUpload={handleAbortUpload}\n            addFilesToUpload={addFilesToUpload}\n            fileToEdit={fileToEdit}\n            filesToDownload={filesToDownload}\n            filesToUpload={filesToUpload}\n            formErrors={formErrors}\n            components={components}\n            isEditingUploadedFile={currentStep === 'edit'}\n            isFormDisabled={isFormDisabled}\n            onChange={handleChange}\n            onClickCancelUpload={handleCancelFileToUpload}\n            onClickDeleteFileToUpload={\n              currentStep === 'edit' ? handleClickDeleteFile : handleClickDeleteFileToUpload\n            }\n            onClickEditNewFile={handleGoToEditNewFile}\n            onGoToAddBrowseFiles={handleGoToAddBrowseFiles}\n            onSubmitEdit={\n              currentStep === 'edit' ? handleSubmitEditExistingFile : handleSubmitEditNewFile\n            }\n            onToggle={handleToggle}\n            toggleDisableForm={setIsFormDisabled}\n            ref={currentStep === 'edit' ? editModalRef : null}\n            setCropResult={handleSetCropResult}\n            setShouldDisplayNextButton={setDisplayNextButton}\n            withBackButton={withBackButton}\n          />\n        )}\n\n        <ModalFooter>\n          <section>\n            <Button type=\"button\" color=\"cancel\" onClick={handleToggle}>\n              {formatMessage({ id: 'app.components.Button.cancel' })}\n            </Button>\n            {shouldDisplayNextButton && (\n              <Button\n                type=\"button\"\n                color=\"primary\"\n                onClick={handleClickNextButton}\n                disabled={isEmpty(filesToDownload)}\n              >\n                {formatMessage({ id: getTrad('button.next') })}\n              </Button>\n            )}\n            {currentStep === 'upload' && (\n              <Button\n                type=\"button\"\n                color=\"success\"\n                onClick={handleUploadFiles}\n                disabled={isFinishButtonDisabled}\n              >\n                {formatMessage(\n                  {\n                    id: getTrad(\n                      `modal.upload-list.footer.button.${\n                        filesToUploadLength > 1 ? 'plural' : 'singular'\n                      }`\n                    ),\n                  },\n                  { number: filesToUploadLength }\n                )}\n              </Button>\n            )}\n            {currentStep === 'edit-new' && (\n              <Button color=\"success\" type=\"button\" onClick={handleSubmitEditNewFile}>\n                {formatMessage({ id: 'form.button.finish' })}\n              </Button>\n            )}\n            {currentStep === 'edit' && (\n              <div style={{ margin: 'auto 0' }}>\n                <Button\n                  disabled={isFormDisabled || areButtonsDisabledOnEditExistingFile}\n                  color=\"primary\"\n                  onClick={handleReplaceMedia}\n                  style={{ marginRight: 10 }}\n                >\n                  {formatMessage({ id: getTrad('control-card.replace-media') })}\n                </Button>\n\n                <Button\n                  disabled={isFormDisabled || areButtonsDisabledOnEditExistingFile}\n                  color=\"success\"\n                  type=\"button\"\n                  onClick={handleSubmitEditExistingFile}\n                >\n                  {formatMessage({ id: 'form.button.finish' })}\n                </Button>\n              </div>\n            )}\n          </section>\n        </ModalFooter>\n      </Modal>\n      <PopUpWarning\n        onClosed={handleCloseModalWarning}\n        isOpen={isWarningDeleteOpen}\n        toggleModal={toggleModalWarning}\n        popUpWarningType=\"danger\"\n        onConfirm={handleConfirmDeleteFile}\n        isConfirmButtonLoading={showModalConfirmButtonLoading}\n      />\n    </>\n  );\n};\n\nModalStepper.defaultProps = {\n  initialFileToEdit: null,\n  initialStep: 'browse',\n  onClosed: () => {},\n  onRemoveFileFromDataToDelete: () => {},\n  onToggle: () => {},\n};\n\nModalStepper.propTypes = {\n  initialFileToEdit: PropTypes.object,\n  initialStep: PropTypes.string,\n  isOpen: PropTypes.bool.isRequired,\n  onClosed: PropTypes.func,\n  onRemoveFileFromDataToDelete: PropTypes.func,\n  onToggle: PropTypes.func,\n};\n\nexport default ModalStepper;\n",
    "packages/strapi-plugin-upload/admin/src/containers/SettingsPage/index.js": "import React, { useEffect, useReducer, useRef } from 'react';\nimport { Header, Inputs } from '@buffetjs/custom';\nimport { isEqual } from 'lodash';\nimport { LoadingIndicatorPage, useGlobalContext, request } from 'strapi-helper-plugin';\n\nimport { getRequestUrl, getTrad } from '../../utils';\nimport Text from '../../components/Text';\n// import Divider from './Divider';\nimport SectionTitleWrapper from './SectionTitleWrapper';\nimport Wrapper from './Wrapper';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\n\nconst SettingsPage = () => {\n  const { formatMessage } = useGlobalContext();\n  const [reducerState, dispatch] = useReducer(reducer, initialState, init);\n  const { initialData, isLoading, modifiedData } = reducerState.toJS();\n  const isMounted = useRef(true);\n  const getDataRef = useRef();\n  const abortController = new AbortController();\n\n  getDataRef.current = async () => {\n    try {\n      const { signal } = abortController;\n      const { data } = await request(getRequestUrl('settings', { method: 'GET', signal }));\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data,\n        });\n      }\n    } catch (err) {\n      console.error(err);\n    }\n  };\n\n  useEffect(() => {\n    getDataRef.current();\n\n    return () => {\n      abortController.abort();\n      isMounted.current = false;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const handleSubmit = async () => {\n    try {\n      await request(getRequestUrl('settings'), {\n        method: 'PUT',\n        body: modifiedData,\n      });\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'SUBMIT_SUCCEEDED',\n        });\n      }\n\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: 'notification.form.success.fields' },\n      });\n    } catch (err) {\n      console.error(err);\n    }\n  };\n\n  const headerProps = {\n    title: {\n      label: formatMessage({ id: getTrad('settings.header.label') }),\n    },\n    content: formatMessage({\n      id: getTrad('settings.sub-header.label'),\n    }),\n    actions: [\n      {\n        color: 'cancel',\n        disabled: isEqual(initialData, modifiedData),\n        // TradId from the strapi-admin package\n        label: formatMessage({ id: 'app.components.Button.cancel' }),\n        onClick: () => {\n          dispatch({\n            type: 'CANCEL_CHANGES',\n          });\n        },\n        type: 'button',\n      },\n      {\n        disabled: false,\n        color: 'success',\n        // TradId from the strapi-admin package\n        label: formatMessage({ id: 'app.components.Button.save' }),\n        onClick: handleSubmit,\n        type: 'button',\n      },\n    ],\n  };\n\n  const handleChange = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: name,\n      value,\n    });\n  };\n\n  if (isLoading) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <>\n      <Header {...headerProps} />\n      <Wrapper>\n        <div className=\"container-fluid\">\n          <div className=\"row\">\n            <SectionTitleWrapper className=\"col-12\">\n              <Text fontSize=\"xs\" fontWeight=\"semiBold\" color=\"#787E8F\">\n                {formatMessage({ id: getTrad('settings.section.image.label') })}\n              </Text>\n            </SectionTitleWrapper>\n            <div className=\"col-6\">\n              <Inputs\n                label={formatMessage({\n                  id: getTrad('settings.form.responsiveDimensions.label'),\n                })}\n                description={formatMessage({\n                  id: getTrad('settings.form.responsiveDimensions.description'),\n                })}\n                name=\"responsiveDimensions\"\n                onChange={handleChange}\n                type=\"bool\"\n                value={modifiedData.responsiveDimensions}\n              />\n            </div>\n            <div className=\"col-6\">\n              <Inputs\n                label={formatMessage({\n                  id: getTrad('settings.form.sizeOptimization.label'),\n                })}\n                name=\"sizeOptimization\"\n                onChange={handleChange}\n                type=\"bool\"\n                value={modifiedData.sizeOptimization}\n              />\n            </div>\n          </div>\n          <div className=\"row\">\n            <div className=\"col-6\">\n              <Inputs\n                label={formatMessage({\n                  id: getTrad('settings.form.autoOrientation.label'),\n                })}\n                description={formatMessage({\n                  id: getTrad('settings.form.autoOrientation.description'),\n                })}\n                name=\"autoOrientation\"\n                onChange={handleChange}\n                type=\"bool\"\n                value={modifiedData.autoOrientation}\n              />\n            </div>\n          </div>\n\n          {/*\n          <Divider />\n          <div className=\"row\">\n            <SectionTitleWrapper className=\"col-12\">\n              <Text fontSize=\"xs\" fontWeight=\"semiBold\" color=\"#787E8F\">\n                {formatMessage({ id: getTrad('settings.section.video.label') })}\n              </Text>\n            </SectionTitleWrapper>\n            <div className=\"col-6\">\n              <Inputs\n                label={formatMessage({\n                  id: getTrad('settings.form.videoPreview.label'),\n                })}\n                description={formatMessage({\n                  id: getTrad('settings.form.videoPreview.description'),\n                })}\n                name=\"videoPreview\"\n                onChange={handleChange}\n                type=\"bool\"\n                value={modifiedData.videoPreview}\n              />\n            </div>\n          </div> */}\n        </div>\n      </Wrapper>\n    </>\n  );\n};\n\nexport default SettingsPage;\n",
    "packages/strapi-plugin-upload/config/functions/bootstrap.js": "'use strict';\n\nconst { convertToStrapiError } = require('../../errors');\n\nmodule.exports = async () => {\n  // set plugin store\n  const configurator = strapi.store({\n    type: 'plugin',\n    name: 'upload',\n    key: 'settings',\n  });\n\n  strapi.plugins.upload.provider = createProvider(strapi.plugins.upload.config || {});\n\n  // if provider config does not exist set one by default\n  const config = await configurator.get();\n\n  if (!config) {\n    await configurator.set({\n      value: {\n        sizeOptimization: true,\n        responsiveDimensions: true,\n      },\n    });\n  }\n\n  await pruneObsoleteRelations();\n  registerPermissionActions();\n};\n\nconst wrapFunctionForErrors = fn => async (...args) => {\n  try {\n    return await fn(...args);\n  } catch (err) {\n    throw convertToStrapiError(err);\n  }\n};\n\nconst createProvider = ({ provider, providerOptions, actionOptions = {} }) => {\n  try {\n    const providerInstance = require(`strapi-provider-upload-${provider}`).init(providerOptions);\n\n    return Object.assign(Object.create(baseProvider), {\n      ...providerInstance,\n      upload: wrapFunctionForErrors((file, options = actionOptions.upload) => {\n        return providerInstance.upload(file, options);\n      }),\n      delete: wrapFunctionForErrors((file, options = actionOptions.delete) => {\n        return providerInstance.delete(file, options);\n      }),\n    });\n  } catch (err) {\n    strapi.log.error(err);\n    throw new Error(\n      `The provider package isn't installed. Please run \\`npm install strapi-provider-upload-${provider}\\``\n    );\n  }\n};\n\nconst baseProvider = {\n  extend(obj) {\n    Object.assign(this, obj);\n  },\n  upload() {\n    throw new Error('Provider upload method is not implemented');\n  },\n  delete() {\n    throw new Error('Provider delete method is not implemented');\n  },\n};\n\nconst pruneObsoleteRelations = async () => {\n  const { upload: plugin } = strapi.plugins;\n  const modelIsNotDefined = !plugin || !plugin.models || !plugin.models.file;\n\n  if (modelIsNotDefined) {\n    return Promise.resolve();\n  }\n\n  await strapi.query('file', 'upload').custom(pruneObsoleteRelationsQuery)();\n};\n\nconst pruneObsoleteRelationsQuery = ({ model }) => {\n  if (model.orm !== 'mongoose') {\n    return Promise.resolve();\n  }\n\n  const models = Array.from(strapi.db.models.values());\n  const modelsId = models.map(model => model.globalId);\n\n  return model.updateMany(\n    { related: { $elemMatch: { kind: { $nin: modelsId } } } },\n    { $pull: { related: { kind: { $nin: modelsId } } } }\n  );\n};\n\nconst registerPermissionActions = () => {\n  const actions = [\n    {\n      section: 'plugins',\n      displayName: 'Access the Media Library',\n      uid: 'read',\n      pluginName: 'upload',\n    },\n    {\n      section: 'plugins',\n      displayName: 'Create (upload)',\n      uid: 'assets.create',\n      subCategory: 'assets',\n      pluginName: 'upload',\n    },\n    {\n      section: 'plugins',\n      displayName: 'Update (crop, details, replace) + delete',\n      uid: 'assets.update',\n      subCategory: 'assets',\n      pluginName: 'upload',\n    },\n    {\n      section: 'plugins',\n      displayName: 'Download',\n      uid: 'assets.download',\n      subCategory: 'assets',\n      pluginName: 'upload',\n    },\n    {\n      section: 'plugins',\n      displayName: 'Copy link',\n      uid: 'assets.copy-link',\n      subCategory: 'assets',\n      pluginName: 'upload',\n    },\n    {\n      section: 'settings',\n      displayName: 'Access the Media Library settings page',\n      uid: 'settings.read',\n      category: 'media library',\n      pluginName: 'upload',\n    },\n  ];\n\n  const { actionProvider } = strapi.admin.services.permission;\n  actionProvider.register(actions);\n};\n",
    "packages/strapi-plugin-upload/config/schema.graphql.js": "'use strict';\n\nconst _ = require('lodash');\nconst { streamToBuffer } = require('../utils/file');\n\nmodule.exports = {\n  definition: `\n    input FileInfoInput {\n      name: String\n      alternativeText: String\n      caption: String\n    }\n  `,\n  mutation: `\n    upload(refId: ID, ref: String, field: String, source: String, info: FileInfoInput, file: Upload!): UploadFile!\n    multipleUpload(refId: ID, ref: String, field: String, source: String, files: [Upload]!): [UploadFile]!\n    updateFileInfo(id: ID!, info: FileInfoInput!): UploadFile!\n  `,\n  resolver: {\n    Query: {\n      file: false,\n      files: {\n        resolver: 'plugins::upload.upload.find',\n      },\n    },\n    Mutation: {\n      createFile: false,\n      updateFile: false,\n      upload: {\n        description: 'Upload one file',\n        resolverOf: 'plugins::upload.upload.upload',\n        resolver: async (obj, { file: upload, info, ...fields }) => {\n          const file = await formatFile(upload, info, fields);\n\n          const uploadedFiles = await strapi.plugins.upload.services.upload.uploadFileAndPersist(\n            file\n          );\n\n          // Return response.\n          return uploadedFiles.length === 1 ? uploadedFiles[0] : uploadedFiles;\n        },\n      },\n      multipleUpload: {\n        description: 'Upload one file',\n        resolverOf: 'plugins::upload.upload.upload',\n        resolver: async (obj, { files: uploads, ...fields }) => {\n          const files = await Promise.all(uploads.map(upload => formatFile(upload, {}, fields)));\n\n          const uploadService = strapi.plugins.upload.services.upload;\n\n          return Promise.all(files.map(file => uploadService.uploadFileAndPersist(file)));\n        },\n      },\n      updateFileInfo: {\n        description: 'Update file information',\n        resolverOf: 'plugins::upload.upload.upload',\n        resolver: async (obj, { id, info }) => {\n          return await strapi.plugins.upload.services.upload.updateFileInfo(id, info);\n        },\n      },\n      deleteFile: {\n        description: 'Delete one file',\n        resolverOf: 'plugins::upload.upload.destroy',\n        resolver: async (obj, options, { context }) => {\n          const file = await strapi.plugins.upload.services.upload.fetch({ id: context.params.id });\n          if (file) {\n            const fileResult = await strapi.plugins.upload.services.upload.remove(file);\n            return { file: fileResult };\n          }\n        },\n      },\n    },\n  },\n};\n\nconst formatFile = async (upload, extraInfo, metas) => {\n  const { filename, mimetype, createReadStream } = await upload;\n\n  const { optimize } = strapi.plugins.upload.services['image-manipulation'];\n  const readBuffer = await streamToBuffer(createReadStream());\n\n  const { buffer, info } = await optimize(readBuffer);\n\n  const uploadService = strapi.plugins.upload.services.upload;\n  const fileInfo = uploadService.formatFileInfo(\n    {\n      filename,\n      type: mimetype,\n      size: buffer.length,\n    },\n    extraInfo || {},\n    metas\n  );\n\n  return _.assign(fileInfo, info, { buffer });\n};\n",
    "packages/strapi-plugin-upload/controllers/Upload.js": "'use strict';\n\n/**\n * Upload.js controller\n *\n */\n\nconst _ = require('lodash');\nconst { sanitizeEntity } = require('strapi-utils');\nconst apiUploadController = require('./upload/api');\nconst adminUploadController = require('./upload/admin');\n\nconst resolveController = ctx => {\n  const {\n    state: { isAuthenticatedAdmin },\n  } = ctx;\n\n  return isAuthenticatedAdmin ? adminUploadController : apiUploadController;\n};\n\nconst resolveControllerMethod = method => ctx => {\n  const controller = resolveController(ctx);\n  const callbackFn = controller[method];\n\n  if (!_.isFunction(callbackFn)) {\n    return ctx.notFound();\n  }\n\n  return callbackFn(ctx);\n};\n\nmodule.exports = {\n  find: resolveControllerMethod('find'),\n  findOne: resolveControllerMethod('findOne'),\n  count: resolveControllerMethod('count'),\n  destroy: resolveControllerMethod('destroy'),\n  updateSettings: resolveControllerMethod('updateSettings'),\n  getSettings: resolveControllerMethod('getSettings'),\n\n  async upload(ctx) {\n    const isUploadDisabled = _.get(strapi.plugins, 'upload.config.enabled', true) === false;\n\n    if (isUploadDisabled) {\n      throw strapi.errors.badRequest(null, {\n        errors: [{ id: 'Upload.status.disabled', message: 'File upload is disabled' }],\n      });\n    }\n\n    const {\n      query: { id },\n      request: { files: { files } = {} },\n    } = ctx;\n    const controller = resolveController(ctx);\n\n    if (id && (_.isEmpty(files) || files.size === 0)) {\n      return controller.updateFileInfo(ctx);\n    }\n\n    if (_.isEmpty(files) || files.size === 0) {\n      throw strapi.errors.badRequest(null, {\n        errors: [{ id: 'Upload.status.empty', message: 'Files are empty' }],\n      });\n    }\n\n    await (id ? controller.replaceFile : controller.uploadFiles)(ctx);\n  },\n\n  async search(ctx) {\n    const { id } = ctx.params;\n    const model = strapi.getModel('file', 'upload');\n    const entries = await strapi.query('file', 'upload').custom(searchQueries)({\n      id,\n    });\n\n    ctx.body = sanitizeEntity(entries, { model });\n  },\n};\n\nconst searchQueries = {\n  bookshelf({ model }) {\n    return ({ id }) => {\n      return model\n        .query(qb => {\n          qb.whereRaw('LOWER(hash) LIKE ?', [`%${id}%`]).orWhereRaw('LOWER(name) LIKE ?', [\n            `%${id}%`,\n          ]);\n        })\n        .fetchAll()\n        .then(results => results.toJSON());\n    };\n  },\n  mongoose({ model }) {\n    return ({ id }) => {\n      const re = new RegExp(id, 'i');\n\n      return model\n        .find({\n          $or: [{ hash: re }, { name: re }],\n        })\n        .lean();\n    };\n  },\n};\n",
    "packages/strapi-plugin-upload/controllers/upload/admin.js": "'use strict';\n\nconst _ = require('lodash');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\nconst validateSettings = require('../validation/settings');\nconst validateUploadBody = require('../validation/upload');\n\nconst { CREATED_BY_ATTRIBUTE } = contentTypesUtils.constants;\n\nconst ACTIONS = {\n  read: 'plugins::upload.read',\n  readSettings: 'plugins::upload.settings.read',\n  create: 'plugins::upload.assets.create',\n  update: 'plugins::upload.assets.update',\n  download: 'plugins::upload.assets.download',\n  copyLink: 'plugins::upload.assets.copy-link',\n};\n\nconst fileModel = 'plugins::upload.file';\n\nmodule.exports = {\n  async find(ctx) {\n    const {\n      state: { userAbility },\n    } = ctx;\n\n    const pm = strapi.admin.services.permission.createPermissionsManager({\n      ability: userAbility,\n      action: ACTIONS.read,\n      model: fileModel,\n    });\n\n    if (!pm.isAllowed) {\n      return ctx.forbidden();\n    }\n\n    const method = _.has(ctx.query, '_q') ? 'search' : 'fetchAll';\n\n    const query = pm.queryFrom(ctx.query);\n    const files = await strapi.plugins.upload.services.upload[method](query);\n\n    ctx.body = pm.sanitize(files, { withPrivate: false });\n  },\n\n  async findOne(ctx) {\n    const {\n      state: { userAbility },\n      params: { id },\n    } = ctx;\n\n    const { pm, file } = await findEntityAndCheckPermissions(\n      userAbility,\n      ACTIONS.read,\n      fileModel,\n      id\n    );\n\n    ctx.body = pm.sanitize(file, { withPrivate: false });\n  },\n\n  async count(ctx) {\n    const pm = strapi.admin.services.permission.createPermissionsManager({\n      ability: ctx.state.userAbility,\n      action: ACTIONS.read,\n      model: fileModel,\n    });\n\n    if (!pm.isAllowed) {\n      return ctx.forbidden();\n    }\n\n    const method = _.has(ctx.query, '_q') ? 'countSearch' : 'count';\n    const query = pm.queryFrom(ctx.query);\n\n    const count = await strapi.plugins.upload.services.upload[method](query);\n\n    ctx.body = { count };\n  },\n\n  async destroy(ctx) {\n    const {\n      state: { userAbility },\n      params: { id },\n    } = ctx;\n\n    const { pm, file } = await findEntityAndCheckPermissions(\n      userAbility,\n      ACTIONS.update,\n      fileModel,\n      id\n    );\n\n    await strapi.plugins['upload'].services.upload.remove(file);\n\n    ctx.body = pm.sanitize(file, { action: ACTIONS.read, withPrivate: false });\n  },\n\n  async updateSettings(ctx) {\n    const {\n      request: { body },\n      state: { userAbility },\n    } = ctx;\n\n    if (userAbility.cannot(ACTIONS.readSettings, fileModel)) {\n      return ctx.forbidden();\n    }\n\n    const data = await validateSettings(body);\n\n    await strapi.plugins.upload.services.upload.setSettings(data);\n\n    ctx.body = { data };\n  },\n\n  async getSettings(ctx) {\n    const {\n      state: { userAbility },\n    } = ctx;\n\n    if (userAbility.cannot(ACTIONS.readSettings, fileModel)) {\n      return ctx.forbidden();\n    }\n\n    const data = await strapi.plugins.upload.services.upload.getSettings();\n\n    ctx.body = { data };\n  },\n\n  async updateFileInfo(ctx) {\n    const {\n      state: { userAbility, user },\n      query: { id },\n      request: { body },\n    } = ctx;\n\n    const uploadService = strapi.plugins.upload.services.upload;\n    const { pm } = await findEntityAndCheckPermissions(userAbility, ACTIONS.update, fileModel, id);\n\n    const data = await validateUploadBody(body);\n    const file = await uploadService.updateFileInfo(id, data.fileInfo, { user });\n\n    ctx.body = pm.sanitize(file, { action: ACTIONS.read, withPrivate: false });\n  },\n\n  async replaceFile(ctx) {\n    const {\n      state: { userAbility, user },\n      query: { id },\n      request: { body, files: { files } = {} },\n    } = ctx;\n\n    const uploadService = strapi.plugins.upload.services.upload;\n    const { pm } = await findEntityAndCheckPermissions(userAbility, ACTIONS.update, fileModel, id);\n\n    if (Array.isArray(files)) {\n      throw strapi.errors.badRequest(null, {\n        errors: [\n          { id: 'Upload.replace.single', message: 'Cannot replace a file with multiple ones' },\n        ],\n      });\n    }\n\n    const data = await validateUploadBody(body);\n    const replacedFiles = await uploadService.replace(id, { data, file: files }, { user });\n\n    ctx.body = pm.sanitize(replacedFiles, { action: ACTIONS.read, withPrivate: false });\n  },\n\n  async uploadFiles(ctx) {\n    const {\n      state: { userAbility, user },\n      request: { body, files: { files } = {} },\n    } = ctx;\n\n    const uploadService = strapi.plugins.upload.services.upload;\n    const pm = strapi.admin.services.permission.createPermissionsManager({\n      ability: userAbility,\n      action: ACTIONS.create,\n      model: fileModel,\n    });\n\n    if (!pm.isAllowed) {\n      throw strapi.errors.forbidden();\n    }\n\n    const data = await validateUploadBody(body);\n    const uploadedFiles = await uploadService.upload({ data, files }, { user });\n\n    ctx.body = pm.sanitize(uploadedFiles, { action: ACTIONS.read, withPrivate: false });\n  },\n};\n\nconst findEntityAndCheckPermissions = async (ability, action, model, id) => {\n  const file = await strapi.plugins.upload.services.upload.fetch({ id });\n\n  if (_.isNil(file)) {\n    throw strapi.errors.notFound();\n  }\n\n  const pm = strapi.admin.services.permission.createPermissionsManager({ ability, action, model });\n\n  const roles = _.has(file, 'created_by.id')\n    ? await strapi.query('role', 'admin').find({ 'users.id': file[CREATED_BY_ATTRIBUTE].id }, [])\n    : [];\n  const fileWithRoles = _.set(_.cloneDeep(file), 'created_by.roles', roles);\n\n  if (pm.ability.cannot(pm.action, pm.toSubject(fileWithRoles))) {\n    throw strapi.errors.forbidden();\n  }\n\n  return { pm, file };\n};\n",
    "packages/strapi-plugin-upload/controllers/upload/api.js": "'use strict';\n\nconst _ = require('lodash');\nconst { sanitizeEntity } = require('strapi-utils');\nconst validateSettings = require('../validation/settings');\nconst validateUploadBody = require('../validation/upload');\n\nconst sanitize = (data, options = {}) => {\n  return sanitizeEntity(data, {\n    model: strapi.getModel('file', 'upload'),\n    ...options,\n  });\n};\n\nmodule.exports = {\n  async find(ctx) {\n    const method = _.has(ctx.query, '_q') ? 'search' : 'fetchAll';\n\n    const files = await strapi.plugins.upload.services.upload[method](ctx.query);\n\n    ctx.body = sanitize(files);\n  },\n\n  async findOne(ctx) {\n    const {\n      params: { id },\n    } = ctx;\n\n    const file = await strapi.plugins.upload.services.upload.fetch({ id });\n\n    if (!file) {\n      return ctx.notFound('file.notFound');\n    }\n\n    ctx.body = sanitize(file);\n  },\n\n  async count(ctx) {\n    const method = _.has(ctx.query, '_q') ? 'countSearch' : 'count';\n\n    ctx.body = await strapi.plugins.upload.services.upload[method](ctx.query);\n  },\n\n  async destroy(ctx) {\n    const {\n      params: { id },\n    } = ctx;\n\n    const file = await strapi.plugins['upload'].services.upload.fetch({ id });\n\n    if (!file) {\n      return ctx.notFound('file.notFound');\n    }\n\n    await strapi.plugins['upload'].services.upload.remove(file);\n\n    ctx.body = sanitize(file);\n  },\n\n  async updateSettings(ctx) {\n    const {\n      request: { body },\n    } = ctx;\n\n    const data = await validateSettings(body);\n\n    await strapi.plugins.upload.services.upload.setSettings(data);\n\n    ctx.body = { data };\n  },\n\n  async getSettings(ctx) {\n    const data = await strapi.plugins.upload.services.upload.getSettings();\n\n    ctx.body = { data };\n  },\n\n  async updateFileInfo(ctx) {\n    const {\n      query: { id },\n      request: { body },\n    } = ctx;\n    const data = await validateUploadBody(body);\n\n    const result = await strapi.plugins.upload.services.upload.updateFileInfo(id, data.fileInfo);\n\n    ctx.body = sanitize(result);\n  },\n\n  async replaceFile(ctx) {\n    const {\n      query: { id },\n      request: { body, files: { files } = {} },\n    } = ctx;\n\n    // cannot replace with more than one file\n    if (Array.isArray(files)) {\n      throw strapi.errors.badRequest(null, {\n        errors: [\n          { id: 'Upload.replace.single', message: 'Cannot replace a file with multiple ones' },\n        ],\n      });\n    }\n\n    const replacedFiles = await strapi.plugins.upload.services.upload.replace(id, {\n      data: await validateUploadBody(body),\n      file: files,\n    });\n\n    ctx.body = sanitize(replacedFiles);\n  },\n\n  async uploadFiles(ctx) {\n    const {\n      request: { body, files: { files } = {} },\n    } = ctx;\n\n    const uploadedFiles = await strapi.plugins.upload.services.upload.upload({\n      data: await validateUploadBody(body),\n      files,\n    });\n\n    ctx.body = sanitize(uploadedFiles);\n  },\n};\n",
    "packages/strapi-plugin-upload/services/Upload.js": "'use strict';\n\n/**\n * Upload.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\nconst util = require('util');\nconst _ = require('lodash');\nconst {\n  nameToSlug,\n  contentTypes: contentTypesUtils,\n  sanitizeEntity,\n  webhook: webhookUtils,\n} = require('strapi-utils');\n\nconst { MEDIA_UPDATE, MEDIA_CREATE, MEDIA_DELETE } = webhookUtils.webhookEvents;\n\nconst { bytesToKbytes } = require('../utils/file');\n\nconst { UPDATED_BY_ATTRIBUTE, CREATED_BY_ATTRIBUTE } = contentTypesUtils.constants;\n\nconst randomSuffix = () => crypto.randomBytes(5).toString('hex');\n\nconst generateFileName = name => {\n  const baseName = nameToSlug(name, { separator: '_', lowercase: false });\n\n  return `${baseName}_${randomSuffix()}`;\n};\n\nconst sendMediaMetrics = data => {\n  if (_.has(data, 'caption') && !_.isEmpty(data.caption)) {\n    strapi.telemetry.send('didSaveMediaWithCaption');\n  }\n\n  if (_.has(data, 'alternativeText') && !_.isEmpty(data.alternativeText)) {\n    strapi.telemetry.send('didSaveMediaWithAlternativeText');\n  }\n};\n\nconst combineFilters = params => {\n  // FIXME: until we support boolean operators for querying we need to make mime_ncontains use AND instead of OR\n  if (_.has(params, 'mime_ncontains') && Array.isArray(params.mime_ncontains)) {\n    params._where = params.mime_ncontains.map(val => ({ mime_ncontains: val }));\n    delete params.mime_ncontains;\n  }\n};\n\nmodule.exports = {\n  formatFileInfo({ filename, type, size }, fileInfo = {}, metas = {}) {\n    const ext = path.extname(filename);\n    const basename = path.basename(fileInfo.name || filename, ext);\n\n    const usedName = fileInfo.name || filename;\n\n    const entity = {\n      name: usedName,\n      alternativeText: fileInfo.alternativeText,\n      caption: fileInfo.caption,\n      hash: generateFileName(basename),\n      ext,\n      mime: type,\n      size: bytesToKbytes(size),\n    };\n\n    const { refId, ref, source, field } = metas;\n\n    if (refId && ref && field) {\n      entity.related = [\n        {\n          refId,\n          ref,\n          source,\n          field,\n        },\n      ];\n    }\n\n    if (metas.path) {\n      entity.path = metas.path;\n    }\n\n    return entity;\n  },\n\n  async enhanceFile(file, fileInfo = {}, metas = {}) {\n    let readBuffer;\n    try {\n      readBuffer = await util.promisify(fs.readFile)(file.path);\n    } catch (e) {\n      if (e.code === 'ERR_FS_FILE_TOO_LARGE') {\n        throw strapi.errors.entityTooLarge('FileTooBig', {\n          errors: [\n            {\n              id: 'Upload.status.sizeLimit',\n              message: `${file.name} file is bigger than the limit size!`,\n              values: { file: file.name },\n            },\n          ],\n        });\n      }\n      throw e;\n    }\n\n    const { optimize } = strapi.plugins.upload.services['image-manipulation'];\n\n    const { buffer, info } = await optimize(readBuffer);\n\n    const formattedFile = this.formatFileInfo(\n      {\n        filename: file.name,\n        type: file.type,\n        size: file.size,\n      },\n      fileInfo,\n      metas\n    );\n\n    return _.assign(formattedFile, info, {\n      buffer,\n    });\n  },\n\n  async upload({ data, files }, { user } = {}) {\n    const { fileInfo, ...metas } = data;\n\n    const fileArray = Array.isArray(files) ? files : [files];\n    const fileInfoArray = Array.isArray(fileInfo) ? fileInfo : [fileInfo];\n\n    const doUpload = async (file, fileInfo) => {\n      const fileData = await this.enhanceFile(file, fileInfo, metas);\n\n      return this.uploadFileAndPersist(fileData, { user });\n    };\n\n    return await Promise.all(\n      fileArray.map((file, idx) => doUpload(file, fileInfoArray[idx] || {}))\n    );\n  },\n\n  async uploadFileAndPersist(fileData, { user } = {}) {\n    const config = strapi.plugins.upload.config;\n\n    const {\n      getDimensions,\n      generateThumbnail,\n      generateResponsiveFormats,\n    } = strapi.plugins.upload.services['image-manipulation'];\n\n    await strapi.plugins.upload.provider.upload(fileData);\n\n    const thumbnailFile = await generateThumbnail(fileData);\n    if (thumbnailFile) {\n      await strapi.plugins.upload.provider.upload(thumbnailFile);\n      delete thumbnailFile.buffer;\n      _.set(fileData, 'formats.thumbnail', thumbnailFile);\n    }\n\n    const formats = await generateResponsiveFormats(fileData);\n    if (Array.isArray(formats) && formats.length > 0) {\n      for (const format of formats) {\n        if (!format) continue;\n\n        const { key, file } = format;\n\n        await strapi.plugins.upload.provider.upload(file);\n        delete file.buffer;\n\n        _.set(fileData, ['formats', key], file);\n      }\n    }\n\n    const { width, height } = await getDimensions(fileData.buffer);\n\n    delete fileData.buffer;\n\n    _.assign(fileData, {\n      provider: config.provider,\n      width,\n      height,\n    });\n\n    return this.add(fileData, { user });\n  },\n\n  async updateFileInfo(id, { name, alternativeText, caption }, { user } = {}) {\n    const dbFile = await this.fetch({ id });\n\n    if (!dbFile) {\n      throw strapi.errors.notFound('file not found');\n    }\n\n    const newInfos = {\n      name: _.isNil(name) ? dbFile.name : name,\n      alternativeText: _.isNil(alternativeText) ? dbFile.alternativeText : alternativeText,\n      caption: _.isNil(caption) ? dbFile.caption : caption,\n    };\n\n    return this.update({ id }, newInfos, { user });\n  },\n\n  async replace(id, { data, file }, { user } = {}) {\n    const config = strapi.plugins.upload.config;\n\n    const {\n      getDimensions,\n      generateThumbnail,\n      generateResponsiveFormats,\n    } = strapi.plugins.upload.services['image-manipulation'];\n\n    const dbFile = await this.fetch({ id });\n\n    if (!dbFile) {\n      throw strapi.errors.notFound('file not found');\n    }\n\n    const { fileInfo } = data;\n    const fileData = await this.enhanceFile(file, fileInfo);\n\n    // keep a constant hash\n    _.assign(fileData, {\n      hash: dbFile.hash,\n      ext: dbFile.ext,\n    });\n\n    // execute delete function of the provider\n    if (dbFile.provider === config.provider) {\n      await strapi.plugins.upload.provider.delete(dbFile);\n\n      if (dbFile.formats) {\n        await Promise.all(\n          Object.keys(dbFile.formats).map(key => {\n            return strapi.plugins.upload.provider.delete(dbFile.formats[key]);\n          })\n        );\n      }\n    }\n\n    await strapi.plugins.upload.provider.upload(fileData);\n\n    // clear old formats\n    _.set(fileData, 'formats', {});\n\n    const thumbnailFile = await generateThumbnail(fileData);\n    if (thumbnailFile) {\n      await strapi.plugins.upload.provider.upload(thumbnailFile);\n      delete thumbnailFile.buffer;\n      _.set(fileData, 'formats.thumbnail', thumbnailFile);\n    }\n\n    const formats = await generateResponsiveFormats(fileData);\n    if (Array.isArray(formats) && formats.length > 0) {\n      for (const format of formats) {\n        if (!format) continue;\n\n        const { key, file } = format;\n\n        await strapi.plugins.upload.provider.upload(file);\n        delete file.buffer;\n\n        _.set(fileData, ['formats', key], file);\n      }\n    }\n\n    const { width, height } = await getDimensions(fileData.buffer);\n    delete fileData.buffer;\n\n    _.assign(fileData, {\n      provider: config.provider,\n      width,\n      height,\n    });\n\n    return this.update({ id }, fileData, { user });\n  },\n\n  async update(params, values, { user } = {}) {\n    const fileValues = { ...values };\n    if (user) {\n      fileValues[UPDATED_BY_ATTRIBUTE] = user.id;\n    }\n    sendMediaMetrics(fileValues);\n\n    const res = await strapi.query('file', 'upload').update(params, fileValues);\n    const modelDef = strapi.getModel('file', 'upload');\n    strapi.eventHub.emit(MEDIA_UPDATE, { media: sanitizeEntity(res, { model: modelDef }) });\n    return res;\n  },\n\n  async add(values, { user } = {}) {\n    const fileValues = { ...values };\n    if (user) {\n      fileValues[UPDATED_BY_ATTRIBUTE] = user.id;\n      fileValues[CREATED_BY_ATTRIBUTE] = user.id;\n    }\n    sendMediaMetrics(fileValues);\n\n    const res = await strapi.query('file', 'upload').create(fileValues);\n    const modelDef = strapi.getModel('file', 'upload');\n    strapi.eventHub.emit(MEDIA_CREATE, { media: sanitizeEntity(res, { model: modelDef }) });\n    return res;\n  },\n\n  fetch(params) {\n    return strapi.query('file', 'upload').findOne(params);\n  },\n\n  fetchAll(params) {\n    combineFilters(params);\n    return strapi.query('file', 'upload').find(params);\n  },\n\n  search(params) {\n    return strapi.query('file', 'upload').search(params);\n  },\n\n  countSearch(params) {\n    return strapi.query('file', 'upload').countSearch(params);\n  },\n\n  count(params) {\n    combineFilters(params);\n    return strapi.query('file', 'upload').count(params);\n  },\n\n  async remove(file) {\n    const config = strapi.plugins.upload.config;\n\n    // execute delete function of the provider\n    if (file.provider === config.provider) {\n      await strapi.plugins.upload.provider.delete(file);\n\n      if (file.formats) {\n        await Promise.all(\n          Object.keys(file.formats).map(key => {\n            return strapi.plugins.upload.provider.delete(file.formats[key]);\n          })\n        );\n      }\n    }\n\n    const media = await strapi.query('file', 'upload').findOne({\n      id: file.id,\n    });\n\n    const modelDef = strapi.getModel('file', 'upload');\n    strapi.eventHub.emit(MEDIA_DELETE, { media: sanitizeEntity(media, { model: modelDef }) });\n\n    return strapi.query('file', 'upload').delete({ id: file.id });\n  },\n\n  async uploadToEntity(params, files, source) {\n    const { id, model, field } = params;\n\n    const arr = Array.isArray(files) ? files : [files];\n    const enhancedFiles = await Promise.all(\n      arr.map(file => {\n        return this.enhanceFile(\n          file,\n          {},\n          {\n            refId: id,\n            ref: model,\n            source,\n            field,\n          }\n        );\n      })\n    );\n\n    await Promise.all(enhancedFiles.map(file => this.uploadFileAndPersist(file)));\n  },\n\n  getSettings() {\n    return strapi\n      .store({\n        type: 'plugin',\n        name: 'upload',\n        key: 'settings',\n      })\n      .get();\n  },\n\n  setSettings(value) {\n    if (value.responsiveDimensions === true) {\n      strapi.telemetry.send('didEnableResponsiveDimensions');\n    } else {\n      strapi.telemetry.send('didDisableResponsiveDimensions');\n    }\n\n    return strapi\n      .store({\n        type: 'plugin',\n        name: 'upload',\n        key: 'settings',\n      })\n      .set({ value });\n  },\n};\n",
    "packages/strapi-plugin-upload/services/image-manipulation.js": "'use strict';\n/**\n * Image manipulation functions\n */\nconst sharp = require('sharp');\n\nconst { bytesToKbytes } = require('../utils/file');\n\nconst getMetadatas = buffer =>\n  sharp(buffer)\n    .metadata()\n    .catch(() => ({})); // ignore errors\n\nconst getDimensions = buffer =>\n  getMetadatas(buffer)\n    .then(({ width = null, height = null }) => ({ width, height }))\n    .catch(() => ({})); // ignore errors\n\nconst THUMBNAIL_RESIZE_OPTIONS = {\n  width: 245,\n  height: 156,\n  fit: 'inside',\n};\n\nconst resizeTo = (buffer, options) =>\n  sharp(buffer)\n    .resize(options)\n    .toBuffer()\n    .catch(() => null);\n\nconst generateThumbnail = async file => {\n  if (!(await canBeProccessed(file.buffer))) {\n    return null;\n  }\n\n  const { width, height } = await getDimensions(file.buffer);\n\n  if (width > THUMBNAIL_RESIZE_OPTIONS.width || height > THUMBNAIL_RESIZE_OPTIONS.height) {\n    const newBuff = await resizeTo(file.buffer, THUMBNAIL_RESIZE_OPTIONS);\n\n    if (newBuff) {\n      const { width, height, size } = await getMetadatas(newBuff);\n\n      return {\n        name: `thumbnail_${file.name}`,\n        hash: `thumbnail_${file.hash}`,\n        ext: file.ext,\n        mime: file.mime,\n        width,\n        height,\n        size: bytesToKbytes(size),\n        buffer: newBuff,\n        path: file.path ? file.path : null,\n      };\n    }\n  }\n\n  return null;\n};\n\nconst optimize = async buffer => {\n  const {\n    sizeOptimization = false,\n    autoOrientation = false,\n  } = await strapi.plugins.upload.services.upload.getSettings();\n\n  if (!sizeOptimization || !(await canBeProccessed(buffer))) {\n    return { buffer };\n  }\n\n  const sharpInstance = autoOrientation ? sharp(buffer).rotate() : sharp(buffer);\n\n  return sharpInstance\n    .toBuffer({ resolveWithObject: true })\n    .then(({ data, info }) => {\n      const output = buffer.length < data.length ? buffer : data;\n\n      return {\n        buffer: output,\n        info: {\n          width: info.width,\n          height: info.height,\n          size: bytesToKbytes(output.length),\n        },\n      };\n    })\n    .catch(() => ({ buffer }));\n};\n\nconst DEFAULT_BREAKPOINTS = {\n  large: 1000,\n  medium: 750,\n  small: 500,\n};\n\nconst getBreakpoints = () => strapi.config.get('plugins.upload.breakpoints', DEFAULT_BREAKPOINTS);\n\nconst generateResponsiveFormats = async file => {\n  const {\n    responsiveDimensions = false,\n  } = await strapi.plugins.upload.services.upload.getSettings();\n\n  if (!responsiveDimensions) return [];\n\n  if (!(await canBeProccessed(file.buffer))) {\n    return [];\n  }\n\n  const originalDimensions = await getDimensions(file.buffer);\n\n  const breakpoints = getBreakpoints();\n  return Promise.all(\n    Object.keys(breakpoints).map(key => {\n      const breakpoint = breakpoints[key];\n\n      if (breakpointSmallerThan(breakpoint, originalDimensions)) {\n        return generateBreakpoint(key, { file, breakpoint, originalDimensions });\n      }\n    })\n  );\n};\n\nconst generateBreakpoint = async (key, { file, breakpoint }) => {\n  const newBuff = await resizeTo(file.buffer, {\n    width: breakpoint,\n    height: breakpoint,\n    fit: 'inside',\n  });\n\n  if (newBuff) {\n    const { width, height, size } = await getMetadatas(newBuff);\n\n    return {\n      key,\n      file: {\n        name: `${key}_${file.name}`,\n        hash: `${key}_${file.hash}`,\n        ext: file.ext,\n        mime: file.mime,\n        width,\n        height,\n        size: bytesToKbytes(size),\n        buffer: newBuff,\n        path: file.path ? file.path : null,\n      },\n    };\n  }\n};\n\nconst breakpointSmallerThan = (breakpoint, { width, height }) => {\n  return breakpoint < width || breakpoint < height;\n};\n\nconst formatsToProccess = ['jpeg', 'png', 'webp', 'tiff'];\nconst canBeProccessed = async buffer => {\n  const { format } = await getMetadatas(buffer);\n  return format && formatsToProccess.includes(format);\n};\n\nmodule.exports = {\n  getDimensions,\n  generateResponsiveFormats,\n  generateThumbnail,\n  bytesToKbytes,\n  optimize,\n};\n",
    "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js": "'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst data = {};\n\ndescribe('Upload plugin end to end tests', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  test('Upload a single file', async () => {\n    const formData = {\n      operations: JSON.stringify({\n        query: /* GraphQL */ `\n          mutation uploadFiles($file: Upload!) {\n            upload(file: $file) {\n              id\n              name\n              mime\n              url\n            }\n          }\n        `,\n        variables: {\n          file: null,\n        },\n      }),\n      map: JSON.stringify({\n        nFile1: ['variables.file'],\n      }),\n      nFile1: fs.createReadStream(path.join(__dirname, '/rec.jpg')),\n    };\n\n    const res = await rq({ method: 'POST', url: '/graphql', formData });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      data: {\n        upload: {\n          id: expect.anything(),\n          name: 'rec.jpg',\n        },\n      },\n    });\n\n    data.file = res.body.data.upload;\n  });\n\n  test('Upload multiple files', async () => {\n    const formData = {\n      operations: JSON.stringify({\n        query: /* GraphQL */ `\n          mutation uploadFiles($files: [Upload]!) {\n            multipleUpload(files: $files) {\n              id\n              name\n              mime\n              url\n            }\n          }\n        `,\n        variables: {\n          files: [null, null],\n        },\n      }),\n      map: JSON.stringify({\n        nFile0: ['variables.files.0'],\n        nFile1: ['variables.files.1'],\n      }),\n      nFile0: fs.createReadStream(path.join(__dirname, '/rec.jpg')),\n      nFile1: fs.createReadStream(path.join(__dirname, '/rec.jpg')),\n    };\n\n    const res = await rq({ method: 'POST', url: '/graphql', formData });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toEqual({\n      data: {\n        multipleUpload: expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'rec.jpg',\n          }),\n        ]),\n      },\n    });\n  });\n\n  test('Update file information', async () => {\n    const res = await rq({\n      url: '/graphql',\n      method: 'POST',\n      body: {\n        query: /* GraphQL */ `\n          mutation updateFileInfo($id: ID!, $info: FileInfoInput!) {\n            updateFileInfo(id: $id, info: $info) {\n              id\n              name\n              alternativeText\n              caption\n            }\n          }\n        `,\n        variables: {\n          id: data.file.id,\n          info: {\n            name: 'test name',\n            alternativeText: 'alternative text test',\n            caption: 'caption test',\n          },\n        },\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      data: {\n        updateFileInfo: {\n          id: data.file.id,\n          name: 'test name',\n          alternativeText: 'alternative text test',\n          caption: 'caption test',\n        },\n      },\n    });\n  });\n\n  test('Delete a file', async () => {\n    const res = await rq({\n      url: '/graphql',\n      method: 'POST',\n      body: {\n        query: /* GraphQL */ `\n          mutation removeFile($id: ID!) {\n            deleteFile(input: { where: { id: $id } }) {\n              file {\n                id\n              }\n            }\n          }\n        `,\n        variables: {\n          id: data.file.id,\n        },\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      data: {\n        deleteFile: {\n          file: {\n            id: data.file.id,\n          },\n        },\n      },\n    });\n  });\n\n  test('Delete a file that dont exist', async () => {\n    const res = await rq({\n      url: '/graphql',\n      method: 'POST',\n      body: {\n        query: /* GraphQL */ `\n          mutation removeFile($id: ID!) {\n            deleteFile(input: { where: { id: $id } }) {\n              file {\n                id\n              }\n            }\n          }\n        `,\n        variables: {\n          id: '404',\n        },\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      data: {\n        deleteFile: null,\n      },\n    });\n  });\n\n  test('Upload a single file with info', async () => {\n    const formData = {\n      operations: JSON.stringify({\n        query: /* GraphQL */ `\n          mutation uploadFilesWithInfo($file: Upload!, $info: FileInfoInput) {\n            upload(file: $file, info: $info) {\n              id\n              name\n              alternativeText\n              caption\n            }\n          }\n        `,\n        variables: {\n          file: null,\n          info: {\n            alternativeText: 'alternative text test',\n            caption: 'caption test',\n          },\n        },\n      }),\n      map: JSON.stringify({\n        nFile1: ['variables.file'],\n      }),\n      nFile1: fs.createReadStream(path.join(__dirname, '/rec.jpg')),\n    };\n\n    const res = await rq({ method: 'POST', url: '/graphql', formData });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      data: {\n        upload: {\n          id: expect.anything(),\n          name: 'rec.jpg',\n          alternativeText: 'alternative text test',\n          caption: 'caption test',\n        },\n      },\n    });\n  });\n});\n",
    "packages/strapi-plugin-upload/tests/upload.test.e2e.js": "'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\n// Helpers.\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\ndescribe('Upload plugin end to end tests', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  describe('GET /upload/settings => Get settings for an environment', () => {\n    test('Returns the settings', async () => {\n      const res = await rq({ method: 'GET', url: '/upload/settings' });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          sizeOptimization: true,\n          responsiveDimensions: true,\n        },\n      });\n    });\n  });\n\n  describe('PUT /upload/settings/:environment', () => {\n    test('Updates an environment config correctly', async () => {\n      const updateRes = await rq({\n        method: 'PUT',\n        url: '/upload/settings',\n        body: {\n          sizeOptimization: true,\n          responsiveDimensions: true,\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toEqual({\n        data: {\n          sizeOptimization: true,\n          responsiveDimensions: true,\n        },\n      });\n\n      const getRes = await rq({ method: 'GET', url: '/upload/settings' });\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toEqual({\n        data: {\n          sizeOptimization: true,\n          responsiveDimensions: true,\n        },\n      });\n    });\n  });\n\n  describe('POST /upload => Upload a file', () => {\n    test('Simple image upload', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/upload',\n        formData: {\n          files: fs.createReadStream(path.join(__dirname, 'rec.jpg')),\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(1);\n      expect(res.body[0]).toEqual(\n        expect.objectContaining({\n          id: expect.anything(),\n          name: 'rec.jpg',\n          ext: '.jpg',\n          mime: 'image/jpeg',\n          hash: expect.any(String),\n          size: expect.any(Number),\n          width: expect.any(Number),\n          height: expect.any(Number),\n          url: expect.any(String),\n          provider: 'local',\n        })\n      );\n    });\n\n    test('Rejects when no files are provided', async () => {\n      const res = await rq({ method: 'POST', url: '/upload', formData: {} });\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Generates a thumbnail on large enough files', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/upload',\n        formData: {\n          files: fs.createReadStream(path.join(__dirname, 'thumbnail_target.png')),\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(1);\n      expect(res.body[0]).toEqual(\n        expect.objectContaining({\n          id: expect.anything(),\n          name: 'thumbnail_target.png',\n          ext: '.png',\n          mime: 'image/png',\n          hash: expect.any(String),\n          size: expect.any(Number),\n          width: expect.any(Number),\n          height: expect.any(Number),\n          url: expect.any(String),\n          provider: 'local',\n          formats: {\n            thumbnail: {\n              name: 'thumbnail_thumbnail_target.png',\n              hash: expect.any(String),\n              ext: '.png',\n              mime: 'image/png',\n              size: expect.any(Number),\n              width: expect.any(Number),\n              height: expect.any(Number),\n              url: expect.any(String),\n              path: null,\n            },\n          },\n        })\n      );\n    });\n  });\n\n  describe('GET /upload/files => Find files', () => {});\n  describe('GET /upload/files/count => Count available files', () => {});\n  describe('GET /upload/files/:id => Find one file', () => {});\n  describe('GET /upload/search/:id => Search files', () => {});\n  describe('DELETE /upload/files/:id => Delete a file ', () => {});\n});\n",
    "packages/strapi-plugin-users-permissions/admin/src/containers/AdvancedSettings/index.js": "import React, { useCallback, useEffect, useMemo, useReducer, useRef, useState } from 'react';\nimport { useIntl } from 'react-intl';\nimport { Header } from '@buffetjs/custom';\nimport { isEqual } from 'lodash';\nimport {\n  FormBloc,\n  PopUpWarning,\n  SettingsPageTitle,\n  SizedInput,\n  useUserPermissions,\n  request,\n} from 'strapi-helper-plugin';\nimport pluginPermissions from '../../permissions';\nimport { getTrad, getRequestURL } from '../../utils';\nimport ListBaselineAlignment from '../../components/ListBaselineAlignment';\nimport form from './utils/form';\nimport reducer, { initialState } from './reducer';\n\nconst AdvancedSettingsPage = () => {\n  const { formatMessage } = useIntl();\n  const [showModalWarning, setShowModalWarning] = useState(false);\n  const pageTitle = formatMessage({ id: getTrad('HeaderNav.link.advancedSettings') });\n  const updatePermissions = useMemo(() => {\n    return { update: pluginPermissions.updateAdvancedSettings };\n  }, []);\n  const {\n    isLoading: isLoadingForPermissions,\n    allowedActions: { canUpdate },\n  } = useUserPermissions(updatePermissions);\n  const [\n    { initialData, isConfirmButtonLoading, isLoading, modifiedData, roles },\n    dispatch,\n  ] = useReducer(reducer, initialState);\n  const isMounted = useRef(true);\n  const abortController = new AbortController();\n  const { signal } = abortController;\n\n  useEffect(() => {\n    const getData = async () => {\n      try {\n        dispatch({\n          type: 'GET_DATA',\n        });\n\n        const data = await request(getRequestURL('advanced'), { method: 'GET', signal });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data,\n        });\n      } catch (err) {\n        if (isMounted.current) {\n          dispatch({\n            type: 'GET_DATA_ERROR',\n          });\n          console.error(err);\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      }\n    };\n\n    if (!isLoadingForPermissions) {\n      getData();\n    }\n\n    return () => {\n      abortController.abort();\n      isMounted.current = false;\n    };\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isLoadingForPermissions]);\n\n  const handleChange = useCallback(({ target }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: target.name,\n      value: target.value,\n    });\n  }, []);\n\n  const handleSubmit = useCallback(\n    async e => {\n      e.preventDefault();\n\n      try {\n        dispatch({\n          type: 'ON_SUBMIT',\n        });\n\n        strapi.lockAppWithOverlay();\n        await request(getRequestURL('advanced'), { method: 'PUT', body: modifiedData });\n\n        dispatch({\n          type: 'ON_SUBMIT_SUCCEEDED',\n        });\n\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('notification.success.submit') },\n        });\n      } catch (err) {\n        dispatch({\n          type: 'ON_SUBMIT_ERROR',\n        });\n        console.error(err);\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      }\n\n      strapi.unlockApp();\n    },\n    [modifiedData]\n  );\n\n  const handleConfirmReset = useCallback(() => {\n    dispatch({\n      type: 'ON_RESET',\n    });\n\n    setShowModalWarning(false);\n  }, []);\n\n  const handleToggleModal = useCallback(() => {\n    setShowModalWarning(prev => !prev);\n  }, []);\n\n  const headerActions = useMemo(() => {\n    const isDisabled = isEqual(initialData, modifiedData);\n\n    return [\n      {\n        disabled: isDisabled,\n        onClick: () => {\n          handleToggleModal();\n        },\n        color: 'cancel',\n        label: formatMessage({\n          id: 'app.components.Button.reset',\n        }),\n\n        type: 'button',\n        style: {\n          paddingLeft: 15,\n          paddingRight: 15,\n          fontWeight: 600,\n        },\n      },\n      {\n        disabled: isDisabled,\n        color: 'success',\n        label: formatMessage({\n          id: 'app.components.Button.save',\n        }),\n        isLoading: isConfirmButtonLoading,\n        type: 'submit',\n        style: {\n          minWidth: 150,\n          fontWeight: 600,\n        },\n      },\n    ];\n  }, [initialData, isConfirmButtonLoading, modifiedData, formatMessage, handleToggleModal]);\n\n  const showLoader = isLoadingForPermissions || isLoading;\n\n  return (\n    <>\n      <SettingsPageTitle name={pageTitle} />\n      <div>\n        <form onSubmit={handleSubmit}>\n          <Header actions={headerActions} title={{ label: pageTitle }} isLoading={showLoader} />\n          <ListBaselineAlignment />\n          <FormBloc title=\"Settings\" isLoading={showLoader}>\n            {form.map(input => {\n              return (\n                <SizedInput\n                  key={input.name}\n                  {...input}\n                  disabled={!canUpdate}\n                  onChange={handleChange}\n                  options={roles}\n                  value={modifiedData[input.name]}\n                />\n              );\n            })}\n          </FormBloc>\n        </form>\n      </div>\n      <PopUpWarning\n        isOpen={showModalWarning}\n        toggleModal={handleToggleModal}\n        content={{\n          title: getTrad('popUpWarning.title'),\n          message: getTrad('popUpWarning.warning.cancel'),\n          cancel: getTrad('popUpWarning.button.cancel'),\n          confirm: getTrad('popUpWarning.button.confirm'),\n        }}\n        popUpWarningType=\"danger\"\n        onConfirm={handleConfirmReset}\n      />\n    </>\n  );\n};\n\nexport default AdvancedSettingsPage;\n",
    "packages/strapi-plugin-users-permissions/admin/src/containers/EmailTemplates/index.js": "import React, { useCallback, useMemo, useRef, useState } from 'react';\nimport { useIntl } from 'react-intl';\nimport { Header, List } from '@buffetjs/custom';\nimport { Pencil } from '@buffetjs/icons';\nimport { get } from 'lodash';\nimport {\n  SettingsPageTitle,\n  SizedInput,\n  useGlobalContext,\n  request,\n  getYupInnerErrors,\n} from 'strapi-helper-plugin';\nimport { Row } from 'reactstrap';\nimport pluginPermissions from '../../permissions';\nimport { useForm } from '../../hooks';\nimport ListBaselineAlignment from '../../components/ListBaselineAlignment';\nimport ListRow from '../../components/ListRow';\nimport ModalForm from '../../components/ModalForm';\nimport { getRequestURL, getTrad } from '../../utils';\nimport forms from './utils/forms';\nimport schema from './utils/schema';\n\nconst EmailTemplatesPage = () => {\n  const { formatMessage } = useIntl();\n  const { emitEvent } = useGlobalContext();\n  const emitEventRef = useRef(emitEvent);\n  const buttonSubmitRef = useRef(null);\n  const pageTitle = formatMessage({ id: getTrad('HeaderNav.link.emailTemplates') });\n  const updatePermissions = useMemo(() => {\n    return { update: pluginPermissions.updateEmailTemplates };\n  }, []);\n  const [isOpen, setIsOpen] = useState(false);\n  const [isSubmiting, setIsSubmiting] = useState(false);\n  const [showForm, setShowForm] = useState(false);\n  const [templateToEdit, setTemplateToEdit] = useState(null);\n\n  const {\n    allowedActions: { canUpdate },\n    dispatchResetForm,\n    dispatchSetFormErrors,\n    dispatchSubmitSucceeded,\n    formErrors,\n    handleChange,\n    isLoading,\n    isLoadingForPermissions,\n    modifiedData,\n  } = useForm('email-templates', updatePermissions);\n\n  const emailTemplates = useMemo(() => {\n    return Object.keys(modifiedData).reduce((acc, current) => {\n      const { display, icon } = modifiedData[current];\n\n      acc.push({\n        id: current,\n        name: formatMessage({ id: getTrad(display) }),\n        icon: ['fas', icon],\n      });\n\n      return acc;\n    }, []);\n  }, [modifiedData, formatMessage]);\n\n  const listTitle = useMemo(() => {\n    const count = emailTemplates.length;\n\n    return formatMessage(\n      {\n        id: getTrad(`List.title.emailTemplates.${count > 1 ? 'plural' : 'singular'}`),\n      },\n      { number: count }\n    );\n  }, [emailTemplates.length, formatMessage]);\n\n  const handleClosed = useCallback(() => {\n    setTemplateToEdit(null);\n    setShowForm(false);\n    dispatchResetForm();\n  }, [dispatchResetForm]);\n\n  const handleToggle = useCallback(() => {\n    setIsOpen(prev => !prev);\n  }, []);\n\n  const handleClickEdit = useCallback(\n    template => {\n      setTemplateToEdit(template);\n      handleToggle();\n    },\n    [handleToggle]\n  );\n\n  const handleSubmit = useCallback(\n    async e => {\n      e.preventDefault();\n\n      let errors = {};\n\n      try {\n        setIsSubmiting(true);\n        await schema.validate(modifiedData[templateToEdit.id], { abortEarly: false });\n\n        strapi.lockAppWithOverlay();\n\n        try {\n          emitEventRef.current('willEditEmailTemplates');\n\n          await request(getRequestURL('email-templates'), {\n            method: 'PUT',\n            body: { 'email-templates': modifiedData },\n          });\n\n          emitEventRef.current('didEditEmailTemplates');\n\n          strapi.notification.toggle({\n            type: 'success',\n            message: { id: getTrad('notification.success.submit') },\n          });\n\n          dispatchSubmitSucceeded();\n\n          handleToggle();\n        } catch (err) {\n          console.error(err);\n\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      } catch (err) {\n        errors = getYupInnerErrors(err);\n      } finally {\n        setIsSubmiting(false);\n        strapi.unlockApp();\n      }\n\n      dispatchSetFormErrors(errors);\n    },\n    [dispatchSetFormErrors, dispatchSubmitSucceeded, modifiedData, templateToEdit, handleToggle]\n  );\n\n  const handleClick = useCallback(() => {\n    buttonSubmitRef.current.click();\n  }, []);\n\n  const handleOpened = useCallback(() => {\n    setShowForm(true);\n  }, []);\n\n  return (\n    <>\n      <SettingsPageTitle name={pageTitle} />\n      <div>\n        <Header title={{ label: pageTitle }} isLoading={isLoadingForPermissions || isLoading} />\n        <ListBaselineAlignment />\n        <List\n          title={listTitle}\n          items={emailTemplates}\n          isLoading={isLoadingForPermissions || isLoading}\n          customRowComponent={template => (\n            <ListRow\n              {...template}\n              onClick={() => {\n                if (canUpdate) {\n                  handleClickEdit(template);\n                }\n              }}\n              links={[\n                {\n                  icon: canUpdate ? <Pencil fill=\"#0e1622\" /> : null,\n                  onClick: e => {\n                    e.stopPropagation();\n                    handleClickEdit(template);\n                  },\n                },\n              ]}\n            />\n          )}\n        />\n      </div>\n      <ModalForm\n        isOpen={isOpen}\n        onOpened={handleOpened}\n        onToggle={handleToggle}\n        onClosed={handleClosed}\n        headerBreadcrumbs={[\n          getTrad('PopUpForm.header.edit.email-templates'),\n          get(templateToEdit, 'name', ''),\n        ]}\n        onClick={handleClick}\n        onCancel={handleToggle}\n        isLoading={isSubmiting}\n      >\n        {showForm && (\n          <form onSubmit={handleSubmit}>\n            <Row>\n              {forms.map(input => {\n                const id = get(templateToEdit, 'id');\n\n                return (\n                  <SizedInput\n                    key={input.name}\n                    {...input}\n                    error={formErrors[input.name]}\n                    name={`${id}.${input.name}`}\n                    onChange={handleChange}\n                    value={get(modifiedData, [id, ...input.name.split('.')], '')}\n                  />\n                );\n              })}\n            </Row>\n            <button type=\"submit\" style={{ display: 'none' }} ref={buttonSubmitRef}>\n              hidden button to use the native form event\n            </button>\n          </form>\n        )}\n      </ModalForm>\n    </>\n  );\n};\n\nexport default EmailTemplatesPage;\n",
    "packages/strapi-plugin-users-permissions/admin/src/containers/Providers/index.js": "import React, { useCallback, useMemo, useRef, useState } from 'react';\nimport { useIntl } from 'react-intl';\nimport { Header, List } from '@buffetjs/custom';\nimport { Text } from '@buffetjs/core';\nimport { Pencil } from '@buffetjs/icons';\nimport {\n  SettingsPageTitle,\n  SizedInput,\n  useGlobalContext,\n  getYupInnerErrors,\n  request,\n} from 'strapi-helper-plugin';\nimport { get, upperFirst, has } from 'lodash';\nimport { Row } from 'reactstrap';\nimport pluginPermissions from '../../permissions';\nimport { useForm } from '../../hooks';\nimport { getRequestURL, getTrad } from '../../utils';\nimport ListBaselineAlignment from '../../components/ListBaselineAlignment';\nimport ListRow from '../../components/ListRow';\nimport ModalForm from '../../components/ModalForm';\nimport createProvidersArray from './utils/createProvidersArray';\nimport forms from './utils/forms';\n\nconst ProvidersPage = () => {\n  const { formatMessage } = useIntl();\n  const { emitEvent } = useGlobalContext();\n  const emitEventRef = useRef(emitEvent);\n  const [isOpen, setIsOpen] = useState(false);\n  const [isSubmiting, setIsSubmiting] = useState(false);\n  const buttonSubmitRef = useRef(null);\n  const [showForm, setShowForm] = useState(false);\n  const [providerToEditName, setProviderToEditName] = useState(null);\n\n  const updatePermissions = useMemo(() => {\n    return { update: pluginPermissions.updateProviders };\n  }, []);\n\n  const {\n    allowedActions: { canUpdate },\n    dispatchResetForm,\n    dispatchSetFormErrors,\n    dispatchSubmitSucceeded,\n    formErrors,\n    handleChange,\n    isLoading,\n    isLoadingForPermissions,\n    modifiedData,\n  } = useForm('providers', updatePermissions);\n\n  const providers = useMemo(() => createProvidersArray(modifiedData), [modifiedData]);\n  const enabledProvidersCount = useMemo(\n    () => providers.filter(provider => provider.enabled).length,\n    [providers]\n  );\n  const isProviderWithSubdomain = useMemo(() => {\n    if (!providerToEditName) {\n      return false;\n    }\n\n    const providerToEdit = providers.find(obj => obj.name === providerToEditName);\n\n    return has(providerToEdit, 'subdomain');\n  }, [providers, providerToEditName]);\n  const disabledProvidersCount = useMemo(() => {\n    return providers.length - enabledProvidersCount;\n  }, [providers, enabledProvidersCount]);\n\n  const listTitle = useMemo(() => {\n    const enabledMessage = formatMessage(\n      {\n        id: getTrad(\n          `List.title.providers.enabled.${enabledProvidersCount > 1 ? 'plural' : 'singular'}`\n        ),\n      },\n      { number: enabledProvidersCount }\n    );\n    const disabledMessage = formatMessage(\n      {\n        id: getTrad(\n          `List.title.providers.disabled.${disabledProvidersCount > 1 ? 'plural' : 'singular'}`\n        ),\n      },\n      { number: disabledProvidersCount }\n    );\n\n    return `${enabledMessage} ${disabledMessage}`;\n  }, [formatMessage, enabledProvidersCount, disabledProvidersCount]);\n\n  const pageTitle = formatMessage({ id: getTrad('HeaderNav.link.providers') });\n\n  const formToRender = useMemo(() => {\n    if (providerToEditName === 'email') {\n      return forms.email;\n    }\n\n    if (isProviderWithSubdomain) {\n      return forms.providersWithSubdomain;\n    }\n\n    return forms.providers;\n  }, [providerToEditName, isProviderWithSubdomain]);\n\n  const handleClick = useCallback(() => {\n    buttonSubmitRef.current.click();\n  }, []);\n\n  const handleToggle = useCallback(() => {\n    setIsOpen(prev => !prev);\n  }, []);\n\n  const handleClickEdit = useCallback(\n    provider => {\n      if (canUpdate) {\n        setProviderToEditName(provider.name);\n        handleToggle();\n      }\n    },\n    [canUpdate, handleToggle]\n  );\n\n  const handleClosed = useCallback(() => {\n    setProviderToEditName(null);\n    setShowForm(false);\n    dispatchResetForm();\n  }, [dispatchResetForm]);\n\n  const handleOpened = useCallback(() => {\n    setShowForm(true);\n  }, []);\n\n  const handleSubmit = useCallback(\n    async e => {\n      e.preventDefault();\n      const { schema } = formToRender;\n      let errors = {};\n\n      setIsSubmiting(true);\n\n      try {\n        await schema.validate(modifiedData[providerToEditName], { abortEarly: false });\n        strapi.lockAppWithOverlay();\n\n        try {\n          emitEventRef.current('willEditAuthenticationProvider');\n\n          await request(getRequestURL('providers'), {\n            method: 'PUT',\n            body: { providers: modifiedData },\n          });\n\n          emitEventRef.current('didEditAuthenticationProvider');\n\n          strapi.notification.toggle({\n            type: 'success',\n            message: { id: getTrad('notification.success.submit') },\n          });\n\n          dispatchSubmitSucceeded();\n\n          handleToggle();\n        } catch (err) {\n          console.error(err);\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      } catch (err) {\n        console.error(err);\n        errors = getYupInnerErrors(err);\n        console.log(errors);\n      }\n\n      dispatchSetFormErrors(errors);\n\n      setIsSubmiting(false);\n      strapi.unlockApp();\n    },\n    [\n      dispatchSetFormErrors,\n      dispatchSubmitSucceeded,\n      formToRender,\n      handleToggle,\n      modifiedData,\n      providerToEditName,\n    ]\n  );\n\n  return (\n    <>\n      <SettingsPageTitle name={pageTitle} />\n      <div>\n        <Header title={{ label: pageTitle }} isLoading={isLoadingForPermissions || isLoading} />\n        <ListBaselineAlignment />\n        <List\n          title={listTitle}\n          items={providers}\n          isLoading={isLoadingForPermissions || isLoading}\n          customRowComponent={provider => (\n            <ListRow\n              {...provider}\n              onClick={() => handleClickEdit(provider)}\n              links={[\n                {\n                  icon: canUpdate ? <Pencil fill=\"#0e1622\" /> : null,\n                  onClick: e => {\n                    e.stopPropagation();\n                    handleClickEdit(provider);\n                  },\n                },\n              ]}\n            >\n              <td key=\"enabled\">\n                <Text\n                  fontWeight=\"semiBold\"\n                  lineHeight=\"18px\"\n                  color={provider.enabled ? 'green' : 'lightOrange'}\n                >\n                  {provider.enabled ? 'Enabled' : 'Disabled'}\n                </Text>\n              </td>\n            </ListRow>\n          )}\n        />\n      </div>\n      <ModalForm\n        isOpen={isOpen}\n        onClick={handleClick}\n        onCancel={handleToggle}\n        isLoading={isSubmiting}\n        onOpened={handleOpened}\n        onClosed={handleClosed}\n        onToggle={handleToggle}\n        headerBreadcrumbs={[\n          getTrad('PopUpForm.header.edit.providers'),\n          upperFirst(providerToEditName),\n        ]}\n      >\n        {showForm && (\n          <form onSubmit={handleSubmit}>\n            <Row>\n              {formToRender.form.map(input => {\n                const label = input.label.params\n                  ? { ...input.label, params: { provider: upperFirst(providerToEditName) } }\n                  : input.label;\n\n                const value =\n                  input.name === 'noName'\n                    ? `${strapi.backendURL}/connect/${providerToEditName}/callback`\n                    : get(modifiedData, [providerToEditName, ...input.name.split('.')], '');\n\n                return (\n                  <SizedInput\n                    key={input.name}\n                    {...input}\n                    label={label}\n                    error={formErrors[input.name]}\n                    name={`${providerToEditName}.${input.name}`}\n                    onChange={handleChange}\n                    value={value}\n                  />\n                );\n              })}\n            </Row>\n            <button type=\"submit\" style={{ display: 'none' }} ref={buttonSubmitRef}>\n              hidden button to use the native form event\n            </button>\n          </form>\n        )}\n      </ModalForm>\n    </>\n  );\n};\n\nexport default ProvidersPage;\n",
    "packages/strapi-plugin-users-permissions/admin/src/hooks/useFetchRole/index.js": "import { useCallback, useReducer, useEffect } from 'react';\nimport { request } from 'strapi-helper-plugin';\n\nimport reducer, { initialState } from './reducer';\n\nimport pluginId from '../../pluginId';\n\nconst useFetchRole = id => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  useEffect(() => {\n    if (id) {\n      fetchRole(id);\n    } else {\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        role: {},\n      });\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [id]);\n\n  const fetchRole = async roleId => {\n    try {\n      const { role } = await request(`/${pluginId}/roles/${roleId}`, { method: 'GET' });\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        role,\n      });\n    } catch (err) {\n      console.error(err);\n\n      dispatch({\n        type: 'GET_DATA_ERROR',\n      });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  const handleSubmitSucceeded = useCallback(data => {\n    dispatch({\n      type: 'ON_SUBMIT_SUCCEEDED',\n      ...data,\n    });\n  }, []);\n\n  return { ...state, onSubmitSucceeded: handleSubmitSucceeded };\n};\n\nexport default useFetchRole;\n",
    "packages/strapi-plugin-users-permissions/admin/src/hooks/useForm/index.js": "import { useCallback, useEffect, useReducer, useRef } from 'react';\nimport { useUserPermissions, request } from 'strapi-helper-plugin';\nimport { getRequestURL } from '../../utils';\nimport reducer, { initialState } from './reducer';\n\nconst useUserForm = (endPoint, permissions) => {\n  const { isLoading: isLoadingForPermissions, allowedActions } = useUserPermissions(permissions);\n  const [{ formErrors, initialData, isLoading, modifiedData }, dispatch] = useReducer(\n    reducer,\n    initialState\n  );\n\n  const isMounted = useRef(true);\n\n  const abortController = new AbortController();\n  const { signal } = abortController;\n\n  useEffect(() => {\n    const getData = async () => {\n      try {\n        dispatch({\n          type: 'GET_DATA',\n        });\n\n        const data = await request(getRequestURL(endPoint), { method: 'GET', signal });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data,\n        });\n      } catch (err) {\n        // The user aborted the request\n        if (isMounted.current) {\n          dispatch({\n            type: 'GET_DATA_ERROR',\n          });\n          console.error(err);\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      }\n    };\n\n    if (!isLoadingForPermissions) {\n      getData();\n    }\n\n    return () => {\n      abortController.abort();\n      isMounted.current = false;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isLoadingForPermissions, endPoint]);\n\n  const handleChange = useCallback(({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: name,\n      value,\n    });\n  }, []);\n\n  const dispatchResetForm = useCallback(() => {\n    dispatch({\n      type: 'RESET_FORM',\n    });\n  }, []);\n\n  const dispatchSetFormErrors = useCallback(errors => {\n    dispatch({ type: 'SET_ERRORS', errors });\n  }, []);\n\n  const dispatchSubmitSucceeded = useCallback(() => {\n    dispatch({\n      type: 'ON_SUBMIT_SUCCEEDED',\n    });\n  }, []);\n\n  return {\n    allowedActions,\n    dispatch,\n    dispatchResetForm,\n    dispatchSetFormErrors,\n    dispatchSubmitSucceeded,\n    formErrors,\n    handleChange,\n    initialData,\n    isLoading,\n    isLoadingForPermissions,\n    modifiedData,\n  };\n};\n\nexport default useUserForm;\n",
    "packages/strapi-plugin-users-permissions/admin/src/hooks/usePlugins/index.js": "import { useCallback, useEffect, useReducer } from 'react';\nimport { request } from 'strapi-helper-plugin';\nimport { useIntl } from 'react-intl';\nimport { get } from 'lodash';\nimport init from './init';\nimport pluginId from '../../pluginId';\nimport { cleanPermissions, formatPolicies, getTrad } from '../../utils';\nimport reducer, { initialState } from './reducer';\n\nconst usePlugins = (shouldFetchData = true) => {\n  const { formatMessage } = useIntl();\n  const [{ permissions, routes, policies, isLoading }, dispatch] = useReducer(\n    reducer,\n    initialState,\n    () => init(initialState, shouldFetchData)\n  );\n\n  const fetchPlugins = useCallback(async () => {\n    try {\n      dispatch({\n        type: 'GET_DATA',\n      });\n\n      const [{ permissions }, { routes }, { policies }] = await Promise.all(\n        [`/${pluginId}/permissions`, `/${pluginId}/routes`, `/${pluginId}/policies`].map(endpoint =>\n          request(endpoint, { method: 'GET' })\n        )\n      );\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        permissions: cleanPermissions(permissions),\n        routes,\n        policies: [\n          {\n            label: formatMessage({ id: getTrad('Policies.InputSelect.empty') }),\n            value: 'empty__string_value',\n          },\n          ...formatPolicies(policies),\n        ],\n      });\n    } catch (err) {\n      const message = get(err, ['response', 'payload', 'message'], 'An error occured');\n\n      dispatch({\n        type: 'GET_DATA_ERROR',\n      });\n\n      if (message !== 'Forbidden') {\n        strapi.notification.toggle({\n          type: 'warning',\n          message,\n        });\n      }\n    }\n  }, [formatMessage]);\n\n  useEffect(() => {\n    if (shouldFetchData) {\n      fetchPlugins();\n    }\n  }, [fetchPlugins, shouldFetchData]);\n\n  return {\n    permissions,\n    routes,\n    policies,\n    getData: fetchPlugins,\n    isLoading,\n  };\n};\n\nexport default usePlugins;\n",
    "packages/strapi-plugin-users-permissions/admin/src/hooks/useRolesList/index.js": "import { useEffect, useReducer, useRef } from 'react';\nimport { request } from 'strapi-helper-plugin';\nimport { get } from 'lodash';\nimport init from './init';\nimport pluginId from '../../pluginId';\nimport reducer, { initialState } from './reducer';\n\nconst useRolesList = (shouldFetchData = true) => {\n  const [{ roles, isLoading }, dispatch] = useReducer(reducer, initialState, () =>\n    init(initialState, shouldFetchData)\n  );\n\n  const isMounted = useRef(true);\n  const abortController = new AbortController();\n  const { signal } = abortController;\n\n  useEffect(() => {\n    if (shouldFetchData) {\n      fetchRolesList();\n    }\n\n    return () => {\n      abortController.abort();\n      isMounted.current = false;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [shouldFetchData]);\n\n  const fetchRolesList = async () => {\n    try {\n      dispatch({\n        type: 'GET_DATA',\n      });\n\n      const { roles } = await request(`/${pluginId}/roles`, { method: 'GET', signal });\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        data: roles,\n      });\n    } catch (err) {\n      const message = get(err, ['response', 'payload', 'message'], 'An error occured');\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'GET_DATA_ERROR',\n        });\n\n        if (message !== 'Forbidden') {\n          strapi.notification.toggle({\n            type: 'warning',\n            message,\n          });\n        }\n      }\n    }\n  };\n\n  return { roles, isLoading, getData: fetchRolesList };\n};\n\nexport default useRolesList;\n",
    "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js": "'use strict';\n\n/**\n * An asynchronous bootstrap function that runs before\n * your application gets started.\n *\n * This gives you an opportunity to set up your data model,\n * run jobs, or perform some special logic.\n */\nconst _ = require('lodash');\nconst uuid = require('uuid/v4');\n\nconst usersPermissionsActions = require('../users-permissions-actions');\n\nmodule.exports = async () => {\n  const pluginStore = strapi.store({\n    environment: '',\n    type: 'plugin',\n    name: 'users-permissions',\n  });\n\n  const grantConfig = {\n    email: {\n      enabled: true,\n      icon: 'envelope',\n    },\n    discord: {\n      enabled: false,\n      icon: 'discord',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/discord/callback`,\n      scope: ['identify', 'email'],\n    },\n    facebook: {\n      enabled: false,\n      icon: 'facebook-square',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/facebook/callback`,\n      scope: ['email'],\n    },\n    google: {\n      enabled: false,\n      icon: 'google',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/google/callback`,\n      scope: ['email'],\n    },\n    github: {\n      enabled: false,\n      icon: 'github',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/github/callback`,\n      scope: ['user', 'user:email'],\n    },\n    microsoft: {\n      enabled: false,\n      icon: 'windows',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/microsoft/callback`,\n      scope: ['user.read'],\n    },\n    twitter: {\n      enabled: false,\n      icon: 'twitter',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/twitter/callback`,\n    },\n    instagram: {\n      enabled: false,\n      icon: 'instagram',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/instagram/callback`,\n      scope: ['user_profile'],\n    },\n    vk: {\n      enabled: false,\n      icon: 'vk',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/vk/callback`,\n      scope: ['email'],\n    },\n    twitch: {\n      enabled: false,\n      icon: 'twitch',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/twitch/callback`,\n      scope: ['user:read:email'],\n    },\n    linkedin: {\n      enabled: false,\n      icon: 'linkedin',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/linkedin/callback`,\n      scope: ['r_liteprofile', 'r_emailaddress'],\n    },\n    cognito: {\n      enabled: false,\n      icon: 'aws',\n      key: '',\n      secret: '',\n      subdomain: 'my.subdomain.com',\n      callback: `${strapi.config.server.url}/auth/cognito/callback`,\n      scope: ['email', 'openid', 'profile'],\n    },\n    reddit: {\n      enabled: false,\n      icon: 'reddit',\n      key: '',\n      secret: '',\n      state: true,\n      callback: `${strapi.config.server.url}/auth/reddit/callback`,\n      scope: ['identity'],\n    },\n    auth0: {\n      enabled: false,\n      icon: '',\n      key: '',\n      secret: '',\n      subdomain: 'my-tenant.eu',\n      callback: `${strapi.config.server.url}/auth/auth0/callback`,\n      scope: ['openid', 'email', 'profile'],\n    },\n  };\n  const prevGrantConfig = (await pluginStore.get({ key: 'grant' })) || {};\n  // store grant auth config to db\n  // when plugin_users-permissions_grant is not existed in db\n  // or we have added/deleted provider here.\n  if (!prevGrantConfig || !_.isEqual(_.keys(prevGrantConfig), _.keys(grantConfig))) {\n    // merge with the previous provider config.\n    _.keys(grantConfig).forEach(key => {\n      if (key in prevGrantConfig) {\n        grantConfig[key] = _.merge(grantConfig[key], prevGrantConfig[key]);\n      }\n    });\n    await pluginStore.set({ key: 'grant', value: grantConfig });\n  }\n\n  if (!(await pluginStore.get({ key: 'email' }))) {\n    const value = {\n      reset_password: {\n        display: 'Email.template.reset_password',\n        icon: 'sync',\n        options: {\n          from: {\n            name: 'Administration Panel',\n            email: 'no-reply@strapi.io',\n          },\n          response_email: '',\n          object: 'Reset password',\n          message: `<p>We heard that you lost your password. Sorry about that!</p>\n\n<p>But dont worry! You can use the following link to reset your password:</p>\n<p><%= URL %>?code=<%= TOKEN %></p>\n\n<p>Thanks.</p>`,\n        },\n      },\n      email_confirmation: {\n        display: 'Email.template.email_confirmation',\n        icon: 'check-square',\n        options: {\n          from: {\n            name: 'Administration Panel',\n            email: 'no-reply@strapi.io',\n          },\n          response_email: '',\n          object: 'Account confirmation',\n          message: `<p>Thank you for registering!</p>\n\n<p>You have to confirm your email address. Please click on the link below.</p>\n\n<p><%= URL %>?confirmation=<%= CODE %></p>\n\n<p>Thanks.</p>`,\n        },\n      },\n    };\n\n    await pluginStore.set({ key: 'email', value });\n  }\n\n  if (!(await pluginStore.get({ key: 'advanced' }))) {\n    const value = {\n      unique_email: true,\n      allow_register: true,\n      email_confirmation: false,\n      email_reset_password: null,\n      email_confirmation_redirection: null,\n      default_role: 'authenticated',\n    };\n\n    await pluginStore.set({ key: 'advanced', value });\n  }\n\n  await strapi.plugins['users-permissions'].services.userspermissions.initialize();\n\n  if (!_.get(strapi.plugins['users-permissions'], 'config.jwtSecret')) {\n    const jwtSecret = uuid();\n    _.set(strapi.plugins['users-permissions'], 'config.jwtSecret', jwtSecret);\n\n    strapi.reload.isWatching = false;\n\n    await strapi.fs.writePluginFile(\n      'users-permissions',\n      'config/jwt.js',\n      `module.exports = {\\n  jwtSecret: process.env.JWT_SECRET || '${jwtSecret}'\\n};`\n    );\n\n    strapi.reload.isWatching = true;\n  }\n\n  const { actionProvider } = strapi.admin.services.permission;\n  actionProvider.register(usersPermissionsActions.actions);\n};\n",
    "packages/strapi-plugin-users-permissions/config/policies/isAuthenticated.js": "'use strict';\n\nmodule.exports = async (ctx, next) => {\n  if (!ctx.state.user) {\n    return ctx.unauthorized();\n  }\n\n  await next();\n};\n",
    "packages/strapi-plugin-users-permissions/config/policies/permissions.js": "'use strict';\n\nconst _ = require('lodash');\n\nmodule.exports = async (ctx, next) => {\n  let role;\n\n  if (ctx.state.user) {\n    // request is already authenticated in a different way\n    return next();\n  }\n\n  if (ctx.request && ctx.request.header && ctx.request.header.authorization) {\n    try {\n      const { id } = await strapi.plugins['users-permissions'].services.jwt.getToken(ctx);\n\n      if (id === undefined) {\n        throw new Error('Invalid token: Token did not contain required fields');\n      }\n\n      // fetch authenticated user\n      ctx.state.user = await strapi.plugins[\n        'users-permissions'\n      ].services.user.fetchAuthenticatedUser(id);\n    } catch (err) {\n      return handleErrors(ctx, err, 'unauthorized');\n    }\n\n    if (!ctx.state.user) {\n      return handleErrors(ctx, 'User Not Found', 'unauthorized');\n    }\n\n    role = ctx.state.user.role;\n\n    if (role.type === 'root') {\n      return await next();\n    }\n\n    const store = await strapi.store({\n      environment: '',\n      type: 'plugin',\n      name: 'users-permissions',\n    });\n\n    if (\n      _.get(await store.get({ key: 'advanced' }), 'email_confirmation') &&\n      !ctx.state.user.confirmed\n    ) {\n      return handleErrors(ctx, 'Your account email is not confirmed.', 'unauthorized');\n    }\n\n    if (ctx.state.user.blocked) {\n      return handleErrors(\n        ctx,\n        'Your account has been blocked by the administrator.',\n        'unauthorized'\n      );\n    }\n  }\n\n  // Retrieve `public` role.\n  if (!role) {\n    role = await strapi.query('role', 'users-permissions').findOne({ type: 'public' }, []);\n  }\n\n  const route = ctx.request.route;\n  const permission = await strapi.query('permission', 'users-permissions').findOne(\n    {\n      role: role.id,\n      type: route.plugin || 'application',\n      controller: route.controller,\n      action: route.action,\n      enabled: true,\n    },\n    []\n  );\n\n  if (!permission) {\n    return handleErrors(ctx, undefined, 'forbidden');\n  }\n\n  // Execute the policies.\n  if (permission.policy) {\n    return await strapi.plugins['users-permissions'].config.policies[permission.policy](ctx, next);\n  }\n\n  // Execute the action.\n  await next();\n};\n\nconst handleErrors = (ctx, err = undefined, type) => {\n  throw strapi.errors[type](err);\n};\n",
    "packages/strapi-plugin-users-permissions/config/schema.graphql.js": "'use strict';\n\nconst _ = require('lodash');\n\n/**\n * Throws an ApolloError if context body contains a bad request\n * @param contextBody - body of the context object given to the resolver\n * @throws ApolloError if the body is a bad request\n */\nfunction checkBadRequest(contextBody) {\n  if (_.get(contextBody, 'statusCode', 200) !== 200) {\n    const message = _.get(contextBody, 'error', 'Bad Request');\n    const exception = new Error(message);\n    exception.code = _.get(contextBody, 'statusCode', 400);\n    exception.data = contextBody;\n    throw exception;\n  }\n}\n\nmodule.exports = {\n  type: {\n    UsersPermissionsPermission: false, // Make this type NOT queriable.\n  },\n  definition: /* GraphQL */ `\n    type UsersPermissionsMe {\n      id: ID!\n      username: String!\n      email: String!\n      confirmed: Boolean\n      blocked: Boolean\n      role: UsersPermissionsMeRole\n    }\n\n    type UsersPermissionsMeRole {\n      id: ID!\n      name: String!\n      description: String\n      type: String\n    }\n\n    input UsersPermissionsRegisterInput {\n      username: String!\n      email: String!\n      password: String!\n    }\n\n    input UsersPermissionsLoginInput {\n      identifier: String!\n      password: String!\n      provider: String = \"local\"\n    }\n\n    type UsersPermissionsLoginPayload {\n      jwt: String\n      user: UsersPermissionsMe!\n    }\n\n    type UserPermissionsPasswordPayload {\n      ok: Boolean!\n    }\n  `,\n  query: `\n    me: UsersPermissionsMe\n  `,\n  mutation: `\n    login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!\n    register(input: UsersPermissionsRegisterInput!): UsersPermissionsLoginPayload!\n    forgotPassword(email: String!): UserPermissionsPasswordPayload\n    resetPassword(password: String!, passwordConfirmation: String!, code: String!): UsersPermissionsLoginPayload\n    emailConfirmation(confirmation: String!): UsersPermissionsLoginPayload\n  `,\n  resolver: {\n    Query: {\n      me: {\n        resolver: 'plugins::users-permissions.user.me',\n      },\n      role: {\n        resolverOf: 'plugins::users-permissions.userspermissions.getRole',\n        resolver: async (obj, options, { context }) => {\n          context.params = { ...context.params, ...options.input };\n\n          await strapi.plugins['users-permissions'].controllers.userspermissions.getRole(context);\n\n          return context.body.role;\n        },\n      },\n      roles: {\n        description: `Retrieve all the existing roles. You can't apply filters on this query.`,\n        resolverOf: 'plugins::users-permissions.userspermissions.getRoles', // Apply the `getRoles` permissions on the resolver.\n        resolver: async (obj, options, { context }) => {\n          context.params = { ...context.params, ...options.input };\n\n          await strapi.plugins['users-permissions'].controllers.userspermissions.getRoles(context);\n\n          return context.body.roles;\n        },\n      },\n    },\n    Mutation: {\n      createRole: {\n        description: 'Create a new role',\n        resolverOf: 'plugins::users-permissions.userspermissions.createRole',\n        resolver: async (obj, options, { context }) => {\n          await strapi.plugins['users-permissions'].controllers.userspermissions.createRole(\n            context\n          );\n\n          return { ok: true };\n        },\n      },\n      updateRole: {\n        description: 'Update an existing role',\n        resolverOf: 'plugins::users-permissions.userspermissions.updateRole',\n        resolver: async (obj, options, { context }) => {\n          context.params = { ...context.params, ...options.input };\n          context.params.role = context.params.id;\n\n          await strapi.plugins['users-permissions'].controllers.userspermissions.updateRole(\n            context\n          );\n\n          return { ok: true };\n        },\n      },\n      deleteRole: {\n        description: 'Delete an existing role',\n        resolverOf: 'plugins::users-permissions.userspermissions.deleteRole',\n        resolver: async (obj, options, { context }) => {\n          context.params = { ...context.params, ...options.input };\n          context.params.role = context.params.id;\n\n          await strapi.plugins['users-permissions'].controllers.userspermissions.deleteRole(\n            context\n          );\n\n          return { ok: true };\n        },\n      },\n      createUser: {\n        description: 'Create a new user',\n        resolverOf: 'plugins::users-permissions.user.create',\n        resolver: async (obj, options, { context }) => {\n          context.params = _.toPlainObject(options.input.where);\n          context.request.body = _.toPlainObject(options.input.data);\n\n          await strapi.plugins['users-permissions'].controllers.user.create(context);\n\n          return {\n            user: context.body.toJSON ? context.body.toJSON() : context.body,\n          };\n        },\n      },\n      updateUser: {\n        description: 'Update an existing user',\n        resolverOf: 'plugins::users-permissions.user.update',\n        resolver: async (obj, options, { context }) => {\n          context.params = _.toPlainObject(options.input.where);\n          context.request.body = _.toPlainObject(options.input.data);\n\n          await strapi.plugins['users-permissions'].controllers.user.update(context);\n\n          return {\n            user: context.body.toJSON ? context.body.toJSON() : context.body,\n          };\n        },\n      },\n      deleteUser: {\n        description: 'Delete an existing user',\n        resolverOf: 'plugins::users-permissions.user.destroy',\n        resolver: async (obj, options, { context }) => {\n          // Set parameters to context.\n          context.params = _.toPlainObject(options.input.where);\n          context.request.body = _.toPlainObject(options.input.data);\n\n          // Retrieve user to be able to return it because\n          // Bookshelf doesn't return the row once deleted.\n          await strapi.plugins['users-permissions'].controllers.user.findOne(context);\n          // Assign result to user.\n          const user = context.body.toJSON ? context.body.toJSON() : context.body;\n\n          // Run destroy query.\n          await strapi.plugins['users-permissions'].controllers.user.destroy(context);\n\n          return {\n            user,\n          };\n        },\n      },\n      register: {\n        description: 'Register a user',\n        resolverOf: 'plugins::users-permissions.auth.register',\n        resolver: async (obj, options, { context }) => {\n          context.request.body = _.toPlainObject(options.input);\n\n          await strapi.plugins['users-permissions'].controllers.auth.register(context);\n          let output = context.body.toJSON ? context.body.toJSON() : context.body;\n\n          checkBadRequest(output);\n          return {\n            user: output.user || output,\n            jwt: output.jwt,\n          };\n        },\n      },\n      login: {\n        resolverOf: 'plugins::users-permissions.auth.callback',\n        resolver: async (obj, options, { context }) => {\n          context.params = {\n            ...context.params,\n            provider: options.input.provider,\n          };\n          context.request.body = _.toPlainObject(options.input);\n\n          await strapi.plugins['users-permissions'].controllers.auth.callback(context);\n          let output = context.body.toJSON ? context.body.toJSON() : context.body;\n\n          checkBadRequest(output);\n          return {\n            user: output.user || output,\n            jwt: output.jwt,\n          };\n        },\n      },\n      forgotPassword: {\n        description: 'Request a reset password token',\n        resolverOf: 'plugins::users-permissions.auth.forgotPassword',\n        resolver: async (obj, options, { context }) => {\n          context.request.body = _.toPlainObject(options);\n\n          await strapi.plugins['users-permissions'].controllers.auth.forgotPassword(context);\n          let output = context.body.toJSON ? context.body.toJSON() : context.body;\n\n          checkBadRequest(output);\n\n          return {\n            ok: output.ok || output,\n          };\n        },\n      },\n      resetPassword: {\n        description: 'Reset user password. Confirm with a code (resetToken from forgotPassword)',\n        resolverOf: 'plugins::users-permissions.auth.resetPassword',\n        resolver: async (obj, options, { context }) => {\n          context.request.body = _.toPlainObject(options);\n\n          await strapi.plugins['users-permissions'].controllers.auth.resetPassword(context);\n          let output = context.body.toJSON ? context.body.toJSON() : context.body;\n\n          checkBadRequest(output);\n\n          return {\n            user: output.user || output,\n            jwt: output.jwt,\n          };\n        },\n      },\n      emailConfirmation: {\n        description: 'Confirm an email users email address',\n        resolverOf: 'plugins::users-permissions.auth.emailConfirmation',\n        resolver: async (obj, options, { context }) => {\n          context.query = _.toPlainObject(options);\n\n          await strapi.plugins['users-permissions'].controllers.auth.emailConfirmation(\n            context,\n            null,\n            true\n          );\n          let output = context.body.toJSON ? context.body.toJSON() : context.body;\n\n          checkBadRequest(output);\n\n          return {\n            user: output.user || output,\n            jwt: output.jwt,\n          };\n        },\n      },\n    },\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/controllers/Auth.js": "'use strict';\n\n/**\n * Auth.js controller\n *\n * @description: A set of functions called \"actions\" for managing `Auth`.\n */\n\n/* eslint-disable no-useless-escape */\nconst crypto = require('crypto');\nconst _ = require('lodash');\nconst grant = require('grant-koa');\nconst { sanitizeEntity } = require('strapi-utils');\n\nconst emailRegExp = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\nconst formatError = error => [\n  { messages: [{ id: error.id, message: error.message, field: error.field }] },\n];\n\nmodule.exports = {\n  async callback(ctx) {\n    const provider = ctx.params.provider || 'local';\n    const params = ctx.request.body;\n\n    const store = await strapi.store({\n      environment: '',\n      type: 'plugin',\n      name: 'users-permissions',\n    });\n\n    if (provider === 'local') {\n      if (!_.get(await store.get({ key: 'grant' }), 'email.enabled')) {\n        return ctx.badRequest(null, 'This provider is disabled.');\n      }\n\n      // The identifier is required.\n      if (!params.identifier) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.email.provide',\n            message: 'Please provide your username or your e-mail.',\n          })\n        );\n      }\n\n      // The password is required.\n      if (!params.password) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.password.provide',\n            message: 'Please provide your password.',\n          })\n        );\n      }\n\n      const query = { provider };\n\n      // Check if the provided identifier is an email or not.\n      const isEmail = emailRegExp.test(params.identifier);\n\n      // Set the identifier to the appropriate query field.\n      if (isEmail) {\n        query.email = params.identifier.toLowerCase();\n      } else {\n        query.username = params.identifier;\n      }\n\n      // Check if the user exists.\n      const user = await strapi.query('user', 'users-permissions').findOne(query);\n\n      if (!user) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.invalid',\n            message: 'Identifier or password invalid.',\n          })\n        );\n      }\n\n      if (\n        _.get(await store.get({ key: 'advanced' }), 'email_confirmation') &&\n        user.confirmed !== true\n      ) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.confirmed',\n            message: 'Your account email is not confirmed',\n          })\n        );\n      }\n\n      if (user.blocked === true) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.blocked',\n            message: 'Your account has been blocked by an administrator',\n          })\n        );\n      }\n\n      // The user never authenticated with the `local` provider.\n      if (!user.password) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.password.local',\n            message:\n              'This user never set a local password, please login with the provider used during account creation.',\n          })\n        );\n      }\n\n      const validPassword = await strapi.plugins[\n        'users-permissions'\n      ].services.user.validatePassword(params.password, user.password);\n\n      if (!validPassword) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.invalid',\n            message: 'Identifier or password invalid.',\n          })\n        );\n      } else {\n        ctx.send({\n          jwt: strapi.plugins['users-permissions'].services.jwt.issue({\n            id: user.id,\n          }),\n          user: sanitizeEntity(user.toJSON ? user.toJSON() : user, {\n            model: strapi.query('user', 'users-permissions').model,\n          }),\n        });\n      }\n    } else {\n      if (!_.get(await store.get({ key: 'grant' }), [provider, 'enabled'])) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'provider.disabled',\n            message: 'This provider is disabled.',\n          })\n        );\n      }\n\n      // Connect the user with the third-party provider.\n      let user, error;\n      try {\n        [user, error] = await strapi.plugins['users-permissions'].services.providers.connect(\n          provider,\n          ctx.query\n        );\n      } catch ([user, error]) {\n        return ctx.badRequest(null, error === 'array' ? error[0] : error);\n      }\n\n      if (!user) {\n        return ctx.badRequest(null, error === 'array' ? error[0] : error);\n      }\n\n      ctx.send({\n        jwt: strapi.plugins['users-permissions'].services.jwt.issue({\n          id: user.id,\n        }),\n        user: sanitizeEntity(user.toJSON ? user.toJSON() : user, {\n          model: strapi.query('user', 'users-permissions').model,\n        }),\n      });\n    }\n  },\n\n  async resetPassword(ctx) {\n    const params = _.assign({}, ctx.request.body, ctx.params);\n\n    if (\n      params.password &&\n      params.passwordConfirmation &&\n      params.password === params.passwordConfirmation &&\n      params.code\n    ) {\n      const user = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ resetPasswordToken: `${params.code}` });\n\n      if (!user) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.code.provide',\n            message: 'Incorrect code provided.',\n          })\n        );\n      }\n\n      const password = await strapi.plugins['users-permissions'].services.user.hashPassword({\n        password: params.password,\n      });\n\n      // Update the user.\n      await strapi\n        .query('user', 'users-permissions')\n        .update({ id: user.id }, { resetPasswordToken: null, password });\n\n      ctx.send({\n        jwt: strapi.plugins['users-permissions'].services.jwt.issue({\n          id: user.id,\n        }),\n        user: sanitizeEntity(user.toJSON ? user.toJSON() : user, {\n          model: strapi.query('user', 'users-permissions').model,\n        }),\n      });\n    } else if (\n      params.password &&\n      params.passwordConfirmation &&\n      params.password !== params.passwordConfirmation\n    ) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.password.matching',\n          message: 'Passwords do not match.',\n        })\n      );\n    } else {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.params.provide',\n          message: 'Incorrect params provided.',\n        })\n      );\n    }\n  },\n\n  async connect(ctx, next) {\n    const grantConfig = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'grant',\n      })\n      .get();\n\n    const [requestPath] = ctx.request.url.split('?');\n    const provider = requestPath.split('/')[2];\n\n    if (!_.get(grantConfig[provider], 'enabled')) {\n      return ctx.badRequest(null, 'This provider is disabled.');\n    }\n\n    if (!strapi.config.server.url.startsWith('http')) {\n      strapi.log.warn(\n        'You are using a third party provider for login. Make sure to set an absolute url in config/server.js. More info here: https://strapi.io/documentation/developer-docs/latest/plugins/users-permissions.html#setting-up-the-server-url'\n      );\n    }\n\n    // Ability to pass OAuth callback dynamically\n    grantConfig[provider].callback = _.get(ctx, 'query.callback') || grantConfig[provider].callback;\n    grantConfig[provider].redirect_uri = strapi.plugins[\n      'users-permissions'\n    ].services.providers.buildRedirectUri(provider);\n\n    return grant(grantConfig)(ctx, next);\n  },\n\n  async forgotPassword(ctx) {\n    let { email } = ctx.request.body;\n\n    // Check if the provided email is valid or not.\n    const isEmail = emailRegExp.test(email);\n\n    if (isEmail) {\n      email = email.toLowerCase();\n    } else {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.email.format',\n          message: 'Please provide valid email address.',\n        })\n      );\n    }\n\n    const pluginStore = await strapi.store({\n      environment: '',\n      type: 'plugin',\n      name: 'users-permissions',\n    });\n\n    // Find the user by email.\n    const user = await strapi\n      .query('user', 'users-permissions')\n      .findOne({ email: email.toLowerCase() });\n\n    // User not found.\n    if (!user) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.user.not-exist',\n          message: 'This email does not exist.',\n        })\n      );\n    }\n\n    // Generate random token.\n    const resetPasswordToken = crypto.randomBytes(64).toString('hex');\n\n    const settings = await pluginStore.get({ key: 'email' }).then(storeEmail => {\n      try {\n        return storeEmail['reset_password'].options;\n      } catch (error) {\n        return {};\n      }\n    });\n\n    const advanced = await pluginStore.get({\n      key: 'advanced',\n    });\n\n    const userInfo = sanitizeEntity(user, {\n      model: strapi.query('user', 'users-permissions').model,\n    });\n\n    settings.message = await strapi.plugins['users-permissions'].services.userspermissions.template(\n      settings.message,\n      {\n        URL: advanced.email_reset_password,\n        USER: userInfo,\n        TOKEN: resetPasswordToken,\n      }\n    );\n\n    settings.object = await strapi.plugins['users-permissions'].services.userspermissions.template(\n      settings.object,\n      {\n        USER: userInfo,\n      }\n    );\n\n    try {\n      // Send an email to the user.\n      await strapi.plugins['email'].services.email.send({\n        to: user.email,\n        from:\n          settings.from.email || settings.from.name\n            ? `${settings.from.name} <${settings.from.email}>`\n            : undefined,\n        replyTo: settings.response_email,\n        subject: settings.object,\n        text: settings.message,\n        html: settings.message,\n      });\n    } catch (err) {\n      return ctx.badRequest(null, err);\n    }\n\n    // Update the user.\n    await strapi.query('user', 'users-permissions').update({ id: user.id }, { resetPasswordToken });\n\n    ctx.send({ ok: true });\n  },\n\n  async register(ctx) {\n    const pluginStore = await strapi.store({\n      environment: '',\n      type: 'plugin',\n      name: 'users-permissions',\n    });\n\n    const settings = await pluginStore.get({\n      key: 'advanced',\n    });\n\n    if (!settings.allow_register) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.advanced.allow_register',\n          message: 'Register action is currently disabled.',\n        })\n      );\n    }\n\n    const params = {\n      ..._.omit(ctx.request.body, ['confirmed', 'confirmationToken', 'resetPasswordToken']),\n      provider: 'local',\n    };\n\n    // Password is required.\n    if (!params.password) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.password.provide',\n          message: 'Please provide your password.',\n        })\n      );\n    }\n\n    // Email is required.\n    if (!params.email) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.email.provide',\n          message: 'Please provide your email.',\n        })\n      );\n    }\n\n    // Throw an error if the password selected by the user\n    // contains more than three times the symbol '$'.\n    if (strapi.plugins['users-permissions'].services.user.isHashed(params.password)) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.password.format',\n          message: 'Your password cannot contain more than three times the symbol `$`.',\n        })\n      );\n    }\n\n    const role = await strapi\n      .query('role', 'users-permissions')\n      .findOne({ type: settings.default_role }, []);\n\n    if (!role) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.role.notFound',\n          message: 'Impossible to find the default role.',\n        })\n      );\n    }\n\n    // Check if the provided email is valid or not.\n    const isEmail = emailRegExp.test(params.email);\n\n    if (isEmail) {\n      params.email = params.email.toLowerCase();\n    } else {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.email.format',\n          message: 'Please provide valid email address.',\n        })\n      );\n    }\n\n    params.role = role.id;\n    params.password = await strapi.plugins['users-permissions'].services.user.hashPassword(params);\n\n    const user = await strapi.query('user', 'users-permissions').findOne({\n      email: params.email,\n    });\n\n    if (user && user.provider === params.provider) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.email.taken',\n          message: 'Email is already taken.',\n        })\n      );\n    }\n\n    if (user && user.provider !== params.provider && settings.unique_email) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.email.taken',\n          message: 'Email is already taken.',\n        })\n      );\n    }\n\n    try {\n      if (!settings.email_confirmation) {\n        params.confirmed = true;\n      }\n\n      const user = await strapi.query('user', 'users-permissions').create(params);\n\n      const sanitizedUser = sanitizeEntity(user, {\n        model: strapi.query('user', 'users-permissions').model,\n      });\n\n      if (settings.email_confirmation) {\n        try {\n          await strapi.plugins['users-permissions'].services.user.sendConfirmationEmail(user);\n        } catch (err) {\n          return ctx.badRequest(null, err);\n        }\n\n        return ctx.send({ user: sanitizedUser });\n      }\n\n      const jwt = strapi.plugins['users-permissions'].services.jwt.issue(_.pick(user, ['id']));\n\n      return ctx.send({\n        jwt,\n        user: sanitizedUser,\n      });\n    } catch (err) {\n      const adminError = _.includes(err.message, 'username')\n        ? {\n            id: 'Auth.form.error.username.taken',\n            message: 'Username already taken',\n          }\n        : { id: 'Auth.form.error.email.taken', message: 'Email already taken' };\n\n      ctx.badRequest(null, formatError(adminError));\n    }\n  },\n\n  async emailConfirmation(ctx, next, returnUser) {\n    const { confirmation: confirmationToken } = ctx.query;\n\n    const { user: userService, jwt: jwtService } = strapi.plugins['users-permissions'].services;\n\n    if (_.isEmpty(confirmationToken)) {\n      return ctx.badRequest('token.invalid');\n    }\n\n    const user = await userService.fetch({ confirmationToken }, []);\n\n    if (!user) {\n      return ctx.badRequest('token.invalid');\n    }\n\n    await userService.edit({ id: user.id }, { confirmed: true, confirmationToken: null });\n\n    if (returnUser) {\n      ctx.send({\n        jwt: jwtService.issue({ id: user.id }),\n        user: sanitizeEntity(user, {\n          model: strapi.query('user', 'users-permissions').model,\n        }),\n      });\n    } else {\n      const settings = await strapi\n        .store({\n          environment: '',\n          type: 'plugin',\n          name: 'users-permissions',\n          key: 'advanced',\n        })\n        .get();\n\n      ctx.redirect(settings.email_confirmation_redirection || '/');\n    }\n  },\n\n  async sendEmailConfirmation(ctx) {\n    const params = _.assign(ctx.request.body);\n\n    if (!params.email) {\n      return ctx.badRequest('missing.email');\n    }\n\n    const isEmail = emailRegExp.test(params.email);\n\n    if (isEmail) {\n      params.email = params.email.toLowerCase();\n    } else {\n      return ctx.badRequest('wrong.email');\n    }\n\n    const user = await strapi.query('user', 'users-permissions').findOne({\n      email: params.email,\n    });\n\n    if (user.confirmed) {\n      return ctx.badRequest('already.confirmed');\n    }\n\n    if (user.blocked) {\n      return ctx.badRequest('blocked.user');\n    }\n\n    try {\n      await strapi.plugins['users-permissions'].services.user.sendConfirmationEmail(user);\n      ctx.send({\n        email: user.email,\n        sent: true,\n      });\n    } catch (err) {\n      return ctx.badRequest(null, err);\n    }\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/controllers/User.js": "'use strict';\n\n/**\n * User.js controller\n *\n * @description: A set of functions called \"actions\" for managing `User`.\n */\n\nconst _ = require('lodash');\nconst { sanitizeEntity } = require('strapi-utils');\nconst adminUserController = require('./user/admin');\nconst apiUserController = require('./user/api');\n\nconst sanitizeUser = user =>\n  sanitizeEntity(user, {\n    model: strapi.query('user', 'users-permissions').model,\n  });\n\nconst resolveController = ctx => {\n  const {\n    state: { isAuthenticatedAdmin },\n  } = ctx;\n\n  return isAuthenticatedAdmin ? adminUserController : apiUserController;\n};\n\nconst resolveControllerMethod = method => ctx => {\n  const controller = resolveController(ctx);\n  const callbackFn = controller[method];\n\n  if (!_.isFunction(callbackFn)) {\n    return ctx.notFound();\n  }\n\n  return callbackFn(ctx);\n};\n\nmodule.exports = {\n  create: resolveControllerMethod('create'),\n  update: resolveControllerMethod('update'),\n\n  /**\n   * Retrieve user records.\n   * @return {Object|Array}\n   */\n  async find(ctx, next, { populate } = {}) {\n    let users;\n\n    if (_.has(ctx.query, '_q')) {\n      // use core strapi query to search for users\n      users = await strapi.query('user', 'users-permissions').search(ctx.query, populate);\n    } else {\n      users = await strapi.plugins['users-permissions'].services.user.fetchAll(ctx.query, populate);\n    }\n\n    ctx.body = users.map(sanitizeUser);\n  },\n\n  /**\n   * Retrieve a user record.\n   * @return {Object}\n   */\n  async findOne(ctx) {\n    const { id } = ctx.params;\n    let data = await strapi.plugins['users-permissions'].services.user.fetch({\n      id,\n    });\n\n    if (data) {\n      data = sanitizeUser(data);\n    }\n\n    // Send 200 `ok`\n    ctx.body = data;\n  },\n\n  /**\n   * Retrieve user count.\n   * @return {Number}\n   */\n  async count(ctx) {\n    if (_.has(ctx.query, '_q')) {\n      return await strapi.plugins['users-permissions'].services.user.countSearch(ctx.query);\n    }\n    ctx.body = await strapi.plugins['users-permissions'].services.user.count(ctx.query);\n  },\n\n  /**\n   * Destroy a/an user record.\n   * @return {Object}\n   */\n  async destroy(ctx) {\n    const { id } = ctx.params;\n    const data = await strapi.plugins['users-permissions'].services.user.remove({ id });\n    ctx.send(sanitizeUser(data));\n  },\n\n  async destroyAll(ctx) {\n    const {\n      request: { query },\n    } = ctx;\n\n    const toRemove = Object.values(_.omit(query, 'source'));\n    const { primaryKey } = strapi.query('user', 'users-permissions');\n    const finalQuery = { [`${primaryKey}_in`]: toRemove, _limit: 100 };\n\n    const data = await strapi.plugins['users-permissions'].services.user.removeAll(finalQuery);\n\n    ctx.send(data);\n  },\n\n  /**\n   * Retrieve authenticated user.\n   * @return {Object|Array}\n   */\n  async me(ctx) {\n    const user = ctx.state.user;\n\n    if (!user) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'No authorization header was found' }] }]);\n    }\n\n    ctx.body = sanitizeUser(user);\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js": "'use strict';\n\n/**\n * UsersPermissions.js controller\n *\n * @description: A set of functions called \"actions\" of the `users-permissions` plugin.\n */\n\nconst _ = require('lodash');\nconst { isValidEmailTemplate } = require('./validation/email-template');\n\nmodule.exports = {\n  /**\n   * Default action.\n   *\n   * @return {Object}\n   */\n  async createRole(ctx) {\n    if (_.isEmpty(ctx.request.body)) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Cannot be empty' }] }]);\n    }\n\n    try {\n      await strapi.plugins['users-permissions'].services.userspermissions.createRole(\n        ctx.request.body\n      );\n\n      ctx.send({ ok: true });\n    } catch (err) {\n      strapi.log.error(err);\n      ctx.badRequest(null, [{ messages: [{ id: 'An error occured' }] }]);\n    }\n  },\n\n  async deleteRole(ctx) {\n    // Fetch public role.\n    const publicRole = await strapi.query('role', 'users-permissions').findOne({ type: 'public' });\n\n    const publicRoleID = publicRole.id;\n\n    const roleID = ctx.params.role;\n\n    if (!roleID) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Bad request' }] }]);\n    }\n\n    // Prevent from removing the public role.\n    if (roleID.toString() === publicRoleID.toString()) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Unauthorized' }] }]);\n    }\n\n    try {\n      await strapi.plugins['users-permissions'].services.userspermissions.deleteRole(\n        roleID,\n        publicRoleID\n      );\n\n      ctx.send({ ok: true });\n    } catch (err) {\n      strapi.log.error(err);\n      ctx.badRequest(null, [{ messages: [{ id: 'Bad request' }] }]);\n    }\n  },\n\n  async getPermissions(ctx) {\n    try {\n      const permissions = await strapi.plugins[\n        'users-permissions'\n      ].services.userspermissions.getActions();\n\n      ctx.send({ permissions });\n    } catch (err) {\n      ctx.badRequest(null, [{ message: [{ id: 'Not Found' }] }]);\n    }\n  },\n\n  async getPolicies(ctx) {\n    ctx.send({\n      policies: _.without(\n        _.keys(strapi.plugins['users-permissions'].config.policies),\n        'permissions'\n      ),\n    });\n  },\n\n  async getRole(ctx) {\n    const { id } = ctx.params;\n    const { lang } = ctx.query;\n    const plugins = await strapi.plugins['users-permissions'].services.userspermissions.getPlugins(\n      lang\n    );\n    const role = await strapi.plugins['users-permissions'].services.userspermissions.getRole(\n      id,\n      plugins\n    );\n\n    if (_.isEmpty(role)) {\n      return ctx.badRequest(null, [{ messages: [{ id: `Role don't exist` }] }]);\n    }\n\n    ctx.send({ role });\n  },\n\n  async getRoles(ctx) {\n    try {\n      const roles = await strapi.plugins['users-permissions'].services.userspermissions.getRoles();\n\n      ctx.send({ roles });\n    } catch (err) {\n      ctx.badRequest(null, [{ messages: [{ id: 'Not found' }] }]);\n    }\n  },\n\n  async getRoutes(ctx) {\n    try {\n      const routes = await strapi.plugins[\n        'users-permissions'\n      ].services.userspermissions.getRoutes();\n\n      ctx.send({ routes });\n    } catch (err) {\n      ctx.badRequest(null, [{ messages: [{ id: 'Not found' }] }]);\n    }\n  },\n\n  async index(ctx) {\n    // Send 200 `ok`\n    ctx.send({ message: 'ok' });\n  },\n\n  async searchUsers(ctx) {\n    const { id } = ctx.params;\n\n    const data = await strapi.query('user', 'users-permissions').custom(searchQueries)({\n      id,\n    });\n\n    ctx.send(data);\n  },\n\n  async updateRole(ctx) {\n    const roleID = ctx.params.role;\n\n    if (_.isEmpty(ctx.request.body)) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Bad request' }] }]);\n    }\n\n    try {\n      await strapi.plugins['users-permissions'].services.userspermissions.updateRole(\n        roleID,\n        ctx.request.body\n      );\n\n      ctx.send({ ok: true });\n    } catch (err) {\n      strapi.log.error(err);\n      ctx.badRequest(null, [{ messages: [{ id: 'An error occurred' }] }]);\n    }\n  },\n\n  async getEmailTemplate(ctx) {\n    ctx.send(\n      await strapi\n        .store({\n          environment: '',\n          type: 'plugin',\n          name: 'users-permissions',\n          key: 'email',\n        })\n        .get()\n    );\n  },\n\n  async updateEmailTemplate(ctx) {\n    if (_.isEmpty(ctx.request.body)) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Cannot be empty' }] }]);\n    }\n\n    const emailTemplates = ctx.request.body['email-templates'];\n\n    for (let key in emailTemplates) {\n      const template = emailTemplates[key].options.message;\n\n      if (!isValidEmailTemplate(template)) {\n        return ctx.badRequest(null, [{ messages: [{ id: 'Invalid template' }] }]);\n      }\n    }\n\n    await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'email',\n      })\n      .set({ value: emailTemplates });\n\n    ctx.send({ ok: true });\n  },\n\n  async getAdvancedSettings(ctx) {\n    ctx.send({\n      settings: await strapi\n        .store({\n          environment: '',\n          type: 'plugin',\n          name: 'users-permissions',\n          key: 'advanced',\n        })\n        .get(),\n      roles: await strapi.plugins['users-permissions'].services.userspermissions.getRoles(),\n    });\n  },\n\n  async updateAdvancedSettings(ctx) {\n    if (_.isEmpty(ctx.request.body)) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Cannot be empty' }] }]);\n    }\n\n    await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'advanced',\n      })\n      .set({ value: ctx.request.body });\n\n    ctx.send({ ok: true });\n  },\n\n  async getProviders(ctx) {\n    const providers = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'grant',\n      })\n      .get();\n\n    for (const provider in providers) {\n      if (provider !== 'email') {\n        providers[provider].redirectUri = strapi.plugins[\n          'users-permissions'\n        ].services.providers.buildRedirectUri(provider);\n      }\n    }\n\n    ctx.send(providers);\n  },\n\n  async updateProviders(ctx) {\n    if (_.isEmpty(ctx.request.body)) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Cannot be empty' }] }]);\n    }\n\n    await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'grant',\n      })\n      .set({ value: ctx.request.body.providers });\n\n    ctx.send({ ok: true });\n  },\n};\n\nconst searchQueries = {\n  bookshelf({ model }) {\n    return ({ id }) => {\n      return model\n        .query(function(qb) {\n          qb.where('username', 'LIKE', `%${id}%`).orWhere('email', 'LIKE', `%${id}%`);\n        })\n        .fetchAll()\n        .then(results => results.toJSON());\n    };\n  },\n  mongoose({ model }) {\n    return ({ id }) => {\n      const re = new RegExp(id);\n\n      return model.find({\n        $or: [{ username: re }, { email: re }],\n      });\n    };\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/controllers/user/admin.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\n\nconst { UPDATED_BY_ATTRIBUTE, CREATED_BY_ATTRIBUTE } = contentTypesUtils.constants;\n\nconst formatError = error => [\n  { messages: [{ id: error.id, message: error.message, field: error.field }] },\n];\n\nconst userModel = 'plugins::users-permissions.user';\nconst ACTIONS = {\n  read: 'plugins::content-manager.explorer.read',\n  create: 'plugins::content-manager.explorer.create',\n  edit: 'plugins::content-manager.explorer.update',\n  delete: 'plugins::content-manager.explorer.delete',\n};\n\nconst findEntityAndCheckPermissions = async (ability, action, model, id) => {\n  const entity = await strapi.query('user', 'users-permissions').findOne({ id });\n\n  if (_.isNil(entity)) {\n    throw strapi.errors.notFound();\n  }\n\n  const pm = strapi.admin.services.permission.createPermissionsManager({ ability, action, model });\n\n  const roles = _.has(entity, `${CREATED_BY_ATTRIBUTE}.id`)\n    ? await strapi.query('role', 'admin').find({ 'users.id': entity[CREATED_BY_ATTRIBUTE].id }, [])\n    : [];\n  const entityWithRoles = _.set(_.cloneDeep(entity), `${CREATED_BY_ATTRIBUTE}.roles`, roles);\n\n  if (pm.ability.cannot(pm.action, pm.toSubject(entityWithRoles))) {\n    throw strapi.errors.forbidden();\n  }\n\n  return { pm, entity };\n};\n\nmodule.exports = {\n  /**\n   * Create a/an user record.\n   * @return {Object}\n   */\n  async create(ctx) {\n    const {\n      request: { body },\n      state: { userAbility, admin },\n    } = ctx;\n    const { email, username, password } = body;\n\n    const pm = strapi.admin.services.permission.createPermissionsManager({\n      ability: userAbility,\n      action: ACTIONS.create,\n      model: userModel,\n    });\n\n    if (!pm.isAllowed) {\n      throw strapi.errors.forbidden();\n    }\n\n    const sanitizedBody = pm.pickPermittedFieldsOf(body, { subject: userModel });\n\n    const advanced = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'advanced',\n      })\n      .get();\n\n    if (!email) return ctx.badRequest('missing.email');\n    if (!username) return ctx.badRequest('missing.username');\n    if (!password) return ctx.badRequest('missing.password');\n\n    const userWithSameUsername = await strapi\n      .query('user', 'users-permissions')\n      .findOne({ username });\n\n    if (userWithSameUsername) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.username.taken',\n          message: 'Username already taken.',\n          field: ['username'],\n        })\n      );\n    }\n\n    if (advanced.unique_email) {\n      const userWithSameEmail = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ email: email.toLowerCase() });\n\n      if (userWithSameEmail) {\n        return ctx.badRequest(\n          null,\n\n          formatError({\n            id: 'Auth.form.error.email.taken',\n            message: 'Email already taken.',\n            field: ['email'],\n          })\n        );\n      }\n    }\n\n    const user = {\n      ...sanitizedBody,\n      provider: 'local',\n      [CREATED_BY_ATTRIBUTE]: admin.id,\n      [UPDATED_BY_ATTRIBUTE]: admin.id,\n    };\n\n    user.email = user.email.toLowerCase();\n\n    if (!user.role) {\n      const defaultRole = await strapi\n        .query('role', 'users-permissions')\n        .findOne({ type: advanced.default_role }, []);\n\n      user.role = defaultRole.id;\n    }\n\n    try {\n      const data = await strapi.plugins['users-permissions'].services.user.add(user);\n\n      ctx.created(pm.sanitize(data, { action: ACTIONS.read }));\n    } catch (error) {\n      ctx.badRequest(null, formatError(error));\n    }\n  },\n  /**\n   * Update a/an user record.\n   * @return {Object}\n   */\n\n  async update(ctx) {\n    const advancedConfigs = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'advanced',\n      })\n      .get();\n\n    const {\n      params: { id },\n      request: { body },\n      state: { userAbility, admin },\n    } = ctx;\n    const { email, username, password } = body;\n\n    const { pm, entity: user } = await findEntityAndCheckPermissions(\n      userAbility,\n      ACTIONS.edit,\n      userModel,\n      id\n    );\n\n    if (_.has(body, 'email') && !email) {\n      return ctx.badRequest('email.notNull');\n    }\n\n    if (_.has(body, 'username') && !username) {\n      return ctx.badRequest('username.notNull');\n    }\n\n    if (_.has(body, 'password') && !password && user.provider === 'local') {\n      return ctx.badRequest('password.notNull');\n    }\n\n    if (_.has(body, 'username')) {\n      const userWithSameUsername = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ username });\n\n      if (userWithSameUsername && userWithSameUsername.id != id) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.username.taken',\n            message: 'username.alreadyTaken.',\n            field: ['username'],\n          })\n        );\n      }\n    }\n\n    if (_.has(body, 'email') && advancedConfigs.unique_email) {\n      const userWithSameEmail = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ email: email.toLowerCase() });\n\n      if (userWithSameEmail && userWithSameEmail.id != id) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.email.taken',\n            message: 'Email already taken',\n            field: ['email'],\n          })\n        );\n      }\n      body.email = body.email.toLowerCase();\n    }\n\n    const sanitizedData = pm.pickPermittedFieldsOf(body, { subject: pm.toSubject(user) });\n    const updateData = _.omit({ ...sanitizedData, updated_by: admin.id }, 'created_by');\n\n    if (_.has(body, 'password') && password === user.password) {\n      delete updateData.password;\n    }\n\n    const data = await strapi.plugins['users-permissions'].services.user.edit({ id }, updateData);\n\n    ctx.body = pm.sanitize(data, { action: ACTIONS.read });\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/controllers/user/api.js": "'use strict';\n\nconst _ = require('lodash');\nconst { sanitizeEntity } = require('strapi-utils');\n\nconst sanitizeUser = user =>\n  sanitizeEntity(user, {\n    model: strapi.query('user', 'users-permissions').model,\n  });\n\nconst formatError = error => [\n  { messages: [{ id: error.id, message: error.message, field: error.field }] },\n];\n\nmodule.exports = {\n  /**\n   * Create a/an user record.\n   * @return {Object}\n   */\n  async create(ctx) {\n    const advanced = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'advanced',\n      })\n      .get();\n\n    const { email, username, password, role } = ctx.request.body;\n\n    if (!email) return ctx.badRequest('missing.email');\n    if (!username) return ctx.badRequest('missing.username');\n    if (!password) return ctx.badRequest('missing.password');\n\n    const userWithSameUsername = await strapi\n      .query('user', 'users-permissions')\n      .findOne({ username });\n\n    if (userWithSameUsername) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.username.taken',\n          message: 'Username already taken.',\n          field: ['username'],\n        })\n      );\n    }\n\n    if (advanced.unique_email) {\n      const userWithSameEmail = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ email: email.toLowerCase() });\n\n      if (userWithSameEmail) {\n        return ctx.badRequest(\n          null,\n\n          formatError({\n            id: 'Auth.form.error.email.taken',\n            message: 'Email already taken.',\n            field: ['email'],\n          })\n        );\n      }\n    }\n\n    const user = {\n      ...ctx.request.body,\n      provider: 'local',\n    };\n\n    user.email = user.email.toLowerCase();\n\n    if (!role) {\n      const defaultRole = await strapi\n        .query('role', 'users-permissions')\n        .findOne({ type: advanced.default_role }, []);\n\n      user.role = defaultRole.id;\n    }\n\n    try {\n      const data = await strapi.plugins['users-permissions'].services.user.add(user);\n\n      ctx.created(sanitizeUser(data));\n    } catch (error) {\n      ctx.badRequest(null, formatError(error));\n    }\n  },\n  /**\n   * Update a/an user record.\n   * @return {Object}\n   */\n\n  async update(ctx) {\n    const advancedConfigs = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'advanced',\n      })\n      .get();\n\n    const { id } = ctx.params;\n    const { email, username, password } = ctx.request.body;\n\n    const user = await strapi.plugins['users-permissions'].services.user.fetch({\n      id,\n    });\n\n    if (_.has(ctx.request.body, 'email') && !email) {\n      return ctx.badRequest('email.notNull');\n    }\n\n    if (_.has(ctx.request.body, 'username') && !username) {\n      return ctx.badRequest('username.notNull');\n    }\n\n    if (_.has(ctx.request.body, 'password') && !password && user.provider === 'local') {\n      return ctx.badRequest('password.notNull');\n    }\n\n    if (_.has(ctx.request.body, 'username')) {\n      const userWithSameUsername = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ username });\n\n      if (userWithSameUsername && userWithSameUsername.id != id) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.username.taken',\n            message: 'username.alreadyTaken.',\n            field: ['username'],\n          })\n        );\n      }\n    }\n\n    if (_.has(ctx.request.body, 'email') && advancedConfigs.unique_email) {\n      const userWithSameEmail = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ email: email.toLowerCase() });\n\n      if (userWithSameEmail && userWithSameEmail.id != id) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.email.taken',\n            message: 'Email already taken',\n            field: ['email'],\n          })\n        );\n      }\n      ctx.request.body.email = ctx.request.body.email.toLowerCase();\n    }\n\n    let updateData = {\n      ...ctx.request.body,\n    };\n\n    if (_.has(ctx.request.body, 'password') && password === user.password) {\n      delete updateData.password;\n    }\n\n    const data = await strapi.plugins['users-permissions'].services.user.edit({ id }, updateData);\n\n    ctx.send(sanitizeUser(data));\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest, createRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet authReq;\nconst data = {};\n\ndescribe('Test Graphql user service', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    authReq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  describe('Check createUser authorizations', () => {\n    test('createUser is forbidden to public', async () => {\n      const rq = createRequest({ strapi });\n      const res = await rq({\n        url: '/graphql',\n        method: 'POST',\n        body: {\n          query: /* GraphQL */ `\n            mutation {\n              createUser(input: { data: { username: \"test\", email: \"test\", password: \"test\" } }) {\n                user {\n                  id\n                  username\n                }\n              }\n            }\n          `,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          createUser: null,\n        },\n        errors: [\n          {\n            message: 'Forbidden',\n          },\n        ],\n      });\n    });\n\n    test('createUser is authorized for admins', async () => {\n      const res = await authReq({\n        url: '/graphql',\n        method: 'POST',\n        body: {\n          query: /* GraphQL */ `\n            mutation {\n              createUser(\n                input: {\n                  data: { username: \"test\", email: \"test-graphql@strapi.io\", password: \"test\" }\n                }\n              ) {\n                user {\n                  id\n                  username\n                }\n              }\n            }\n          `,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          createUser: {\n            user: {\n              id: expect.anything(),\n              username: 'test',\n            },\n          },\n        },\n      });\n\n      data.user = res.body.data.createUser.user;\n    });\n  });\n\n  describe('Check updateUser authorizations', () => {\n    test('updateUser is forbidden to public', async () => {\n      const rq = createRequest({ strapi });\n      const res = await rq({\n        url: '/graphql',\n        method: 'POST',\n        body: {\n          query: /* GraphQL */ `\n            mutation {\n              updateUser(\n                input: {\n                  where: { id: 1 }\n                  data: { username: \"test\", email: \"test\", password: \"test\" }\n                }\n              ) {\n                user {\n                  id\n                  username\n                }\n              }\n            }\n          `,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          updateUser: null,\n        },\n        errors: [\n          {\n            message: 'Forbidden',\n          },\n        ],\n      });\n    });\n\n    test('updateUser is authorized for admins', async () => {\n      const res = await authReq({\n        url: '/graphql',\n        method: 'POST',\n        body: {\n          query: /* GraphQL */ `\n            mutation updateUser($id: ID!) {\n              updateUser(input: { where: { id: $id }, data: { username: \"newUsername\" } }) {\n                user {\n                  id\n                  username\n                }\n              }\n            }\n          `,\n          variables: {\n            id: data.user.id,\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          updateUser: {\n            user: {\n              id: expect.anything(),\n              username: 'newUsername',\n            },\n          },\n        },\n      });\n\n      data.user = res.body.data.updateUser.user;\n    });\n  });\n\n  describe('Check deleteUser authorizations', () => {\n    test('deleteUser is forbidden to public', async () => {\n      const rq = createRequest({ strapi });\n      const res = await rq({\n        url: '/graphql',\n        method: 'POST',\n        body: {\n          query: /* GraphQL */ `\n            mutation deleteUser($id: ID!) {\n              deleteUser(input: { where: { id: $id } }) {\n                user {\n                  id\n                  username\n                }\n              }\n            }\n          `,\n          variables: {\n            id: data.user.id,\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          deleteUser: null,\n        },\n        errors: [\n          {\n            message: 'Forbidden',\n          },\n        ],\n      });\n    });\n\n    test('deleteUser is authorized for admins', async () => {\n      const res = await authReq({\n        url: '/graphql',\n        method: 'POST',\n        body: {\n          query: /* GraphQL */ `\n            mutation deleteUser($id: ID!) {\n              deleteUser(input: { where: { id: $id } }) {\n                user {\n                  id\n                  username\n                }\n              }\n            }\n          `,\n          variables: {\n            id: data.user.id,\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          deleteUser: {\n            user: data.user,\n          },\n        },\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet rq;\nlet data = {};\nlet internals = {\n  user: {\n    username: 'User 1',\n    email: 'user1@strapi.io',\n    password: 'test1234',\n  },\n  role: {\n    name: 'Test Role',\n    description: 'Some random test role',\n  },\n};\n\n/**\n * Utils for this test files\n */\nconst createTestUser = () =>\n  rq({\n    method: 'POST',\n    url: '/auth/local/register',\n    body: internals.user,\n  });\n\nconst deleteTestUser = () =>\n  rq({\n    method: 'DELETE',\n    url: `/users/${data.user.id}`,\n  });\n\n/*****************************\n * TESTS\n *****************************/\ndescribe('Roles API', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    const res = await createTestUser();\n    data.user = res.body.user;\n  }, 60000);\n\n  afterAll(async () => {\n    await deleteTestUser();\n    await strapi.destroy();\n  });\n\n  test('Create Role', async () => {\n    const res = await rq({\n      method: 'POST',\n      url: '/users-permissions/roles',\n      body: {\n        ...internals.role,\n        permissions: [],\n        users: [data.user],\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({ ok: true });\n  });\n\n  test('List Roles', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/users-permissions/roles',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.roles).toEqual(\n      expect.arrayContaining([expect.objectContaining(internals.role)])\n    );\n\n    data.role = res.body.roles.find(r => r.name === internals.role.name);\n  });\n\n  test('Delete Role', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/users-permissions/roles/${data.role.id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n  });\n});\n",
    "packages/strapi-plugin-users-permissions/tests/users-api.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet rq;\nlet data = {};\n\ndescribe('Users API', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  test('Create User', async () => {\n    const user = {\n      username: 'User 1',\n      email: 'user1@strapi.io',\n      password: 'test1234',\n    };\n\n    const res = await rq({\n      method: 'POST',\n      url: '/auth/local/register',\n      body: user,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      jwt: expect.any(String),\n      user: {\n        username: user.username,\n        email: user.email,\n      },\n    });\n    data.user = res.body.user;\n  });\n\n  test('Delete user', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/users/${data.user.id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n  });\n});\n",
    "packages/strapi-plugin-users-permissions/tests/users-graphql.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet rq;\nlet graphqlQuery;\nlet data = {};\n\ndescribe('Test Graphql Users API End to End', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    graphqlQuery = body => {\n      return rq({\n        url: '/graphql',\n        method: 'POST',\n        body,\n      });\n    };\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  describe('Test register and login', () => {\n    const user = {\n      username: 'User 1',\n      email: 'user1@strapi.io',\n      password: 'test1234',\n    };\n\n    test('Register a user', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation register($input: UsersPermissionsRegisterInput!) {\n            register(input: $input) {\n              jwt\n              user {\n                id\n                email\n              }\n            }\n          }\n        `,\n        variables: {\n          input: user,\n        },\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          register: {\n            jwt: expect.any(String),\n            user: {\n              id: expect.any(String),\n              email: user.email,\n            },\n          },\n        },\n      });\n      data.user = res.body.data.register.user;\n    });\n\n    test('Log in a user', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation login($input: UsersPermissionsLoginInput!) {\n            login(input: $input) {\n              jwt\n              user {\n                id\n                email\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            identifier: user.username,\n            password: user.password,\n          },\n        },\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          login: {\n            jwt: expect.any(String),\n            user: {\n              id: expect.any(String),\n              email: user.email,\n            },\n          },\n        },\n      });\n      data.user = res.body.data.login.user;\n    });\n\n    test('Delete a user', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation deleteUser($input: deleteUserInput) {\n            deleteUser(input: $input) {\n              user {\n                email\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            where: {\n              id: data.user.id,\n            },\n          },\n        },\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          deleteUser: {\n            user: {\n              email: data.user.email,\n            },\n          },\n        },\n      });\n    });\n  });\n});\n",
    "packages/strapi-utils/lib/policy.js": "/**\n * Policies util\n */\n'use strict';\n\nconst _ = require('lodash');\n\nconst GLOBAL_PREFIX = 'global::';\nconst PLUGIN_PREFIX = 'plugins::';\nconst ADMIN_PREFIX = 'admin::';\nconst APPLICATION_PREFIX = 'application::';\n\nconst isPolicyFactory = _.isArray;\n\nconst getPolicyIn = (container, policy) =>\n  _.get(container, ['config', 'policies', _.toLower(policy)]);\n\nconst policyExistsIn = (container, policy) => !_.isUndefined(getPolicyIn(container, policy));\n\nconst stripPolicy = (policy, prefix) => policy.replace(prefix, '');\n\nconst createPolicy = (policyName, ...args) => ({ policyName, args });\n\nconst resolveHandler = policy => (_.isFunction(policy) ? policy : policy.handler);\n\nconst parsePolicy = policy =>\n  isPolicyFactory(policy) ? createPolicy(...policy) : createPolicy(policy);\n\nconst resolvePolicy = policyName => {\n  const resolver = policyResolvers.find(resolver => resolver.exists(policyName));\n\n  return resolver ? resolveHandler(resolver.get)(policyName) : undefined;\n};\n\nconst searchLocalPolicy = (policy, plugin, apiName) => {\n  let [absoluteApiName, policyName] = policy.split('.');\n  let absoluteApi = _.get(strapi.api, absoluteApiName);\n  const resolver = policyResolvers.find(({ name }) => name === 'plugin');\n\n  if (policyExistsIn(absoluteApi, policyName)) {\n    return resolveHandler(getPolicyIn(absoluteApi, policyName));\n  }\n\n  const pluginPolicy = `${PLUGIN_PREFIX}${plugin}.${policy}`;\n\n  if (plugin && resolver.exists(pluginPolicy)) {\n    return resolveHandler(resolver.get(pluginPolicy));\n  }\n\n  const api = _.get(strapi.api, apiName);\n  if (api && policyExistsIn(api, policy)) {\n    return resolveHandler(getPolicyIn(api, policy));\n  }\n\n  return undefined;\n};\n\nconst globalPolicy = ({ method, endpoint, controller, action, plugin }) => {\n  return async (ctx, next) => {\n    ctx.request.route = {\n      endpoint: `${method} ${endpoint}`,\n      controller: _.toLower(controller),\n      action: _.toLower(action),\n      verb: _.toLower(method),\n      plugin,\n    };\n\n    await next();\n  };\n};\n\nconst policyResolvers = [\n  {\n    name: 'api',\n    is(policy) {\n      return _.startsWith(policy, APPLICATION_PREFIX);\n    },\n    exists(policy) {\n      return this.is(policy) && !_.isUndefined(this.get(policy));\n    },\n    get: policy => {\n      const [, policyWithoutPrefix] = policy.split('::');\n      const [api = '', policyName = ''] = policyWithoutPrefix.split('.');\n      return getPolicyIn(_.get(strapi, ['api', api]), policyName);\n    },\n  },\n  {\n    name: 'admin',\n    is(policy) {\n      return _.startsWith(policy, ADMIN_PREFIX);\n    },\n    exists(policy) {\n      return this.is(policy) && !_.isUndefined(this.get(policy));\n    },\n    get: policy => {\n      return getPolicyIn(_.get(strapi, 'admin'), stripPolicy(policy, ADMIN_PREFIX));\n    },\n  },\n  {\n    name: 'plugin',\n    is(policy) {\n      return _.startsWith(policy, PLUGIN_PREFIX);\n    },\n    exists(policy) {\n      return this.is(policy) && !_.isUndefined(this.get(policy));\n    },\n    get(policy) {\n      const [plugin = '', policyName = ''] = stripPolicy(policy, PLUGIN_PREFIX).split('.');\n      return getPolicyIn(_.get(strapi, ['plugins', plugin]), policyName);\n    },\n  },\n  {\n    name: 'global',\n    is(policy) {\n      return _.startsWith(policy, GLOBAL_PREFIX);\n    },\n    exists(policy) {\n      return this.is(policy) && !_.isUndefined(this.get(policy));\n    },\n    get(policy) {\n      return getPolicyIn(strapi, stripPolicy(policy, GLOBAL_PREFIX));\n    },\n  },\n];\n\nconst get = (policy, plugin, apiName) => {\n  const { policyName, args } = parsePolicy(policy);\n\n  const resolvedPolicy = resolvePolicy(policyName);\n\n  if (resolvedPolicy !== undefined) {\n    return isPolicyFactory(policy) ? resolvedPolicy(...args) : resolvedPolicy;\n  }\n\n  const localPolicy = searchLocalPolicy(policy, plugin, apiName);\n\n  if (localPolicy !== undefined) {\n    return localPolicy;\n  }\n\n  throw new Error(`Could not find policy \"${policy}\"`);\n};\n\nconst createPolicyFactory = (factoryCallback, options) => {\n  const { validator, name = 'unnamed' } = options;\n\n  const validate = (...args) => {\n    try {\n      validator(...args);\n    } catch (e) {\n      throw new Error(`Invalid objects submitted to \"${name}\" policy.`);\n    }\n  };\n\n  return (...args) => {\n    if (validator) {\n      validate(...args);\n    }\n\n    return factoryCallback(...args);\n  };\n};\n\nmodule.exports = {\n  get,\n  globalPolicy,\n  createPolicyFactory,\n};\n",
    "scripts/front/reorder-admin-translation-files.js": "'use strict';\n\nconst { join } = require('path');\nconst { promisify } = require('util');\nconst fs = require('fs-extra');\nconst glob = promisify(require('glob').glob);\n\nasync function orderTrads({ mainTranslationFile, translationFiles }) {\n  const data = await fs.readJSON(mainTranslationFile);\n\n  const orderedData = Object.keys(data)\n    .sort()\n    .reduce((acc, current) => {\n      acc[current] = data[current];\n\n      return acc;\n    }, {});\n\n  await fs.writeJSON(mainTranslationFile, orderedData, { spaces: 2 });\n\n  const cleanFile = async trad => {\n    const cleanedFile = {};\n    const orderedDataKeys = Object.keys(orderedData);\n\n    for (let i in orderedDataKeys) {\n      try {\n        const currentTrad = await fs.readJson(trad);\n        const currentKey = orderedDataKeys[i];\n\n        if (currentTrad[currentKey]) {\n          cleanedFile[currentKey] = currentTrad[currentKey];\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    }\n\n    try {\n      await fs.writeJSON(trad, cleanedFile, { spaces: 2 });\n    } catch (err) {\n      console.error(err);\n    }\n  };\n\n  await Promise.all(translationFiles.map(trad => cleanFile(trad)));\n}\n\nasync function run() {\n  const packageDirs = await glob('packages/*');\n  const pathToTranslationsFolder = ['admin', 'src', 'translations'];\n\n  const pluginsWithTranslationFiles = packageDirs\n    .filter(\n      dir =>\n        (dir.startsWith('packages/strapi-plugin') || dir.startsWith('packages/strapi-admin')) &&\n        fs.existsSync(join(dir, ...pathToTranslationsFolder, 'index.js'))\n    )\n    .map(dir => {\n      const translationFiles = fs\n        .readdirSync(join(dir, ...pathToTranslationsFolder))\n        .filter(\n          file => !file.includes('.js') && !file.includes('en.json') && !file.includes('test')\n        )\n        .map(file => join(dir, ...pathToTranslationsFolder, file));\n\n      return {\n        translationFiles,\n        mainTranslationFile: join(dir, 'admin', 'src', 'translations', 'en.json'),\n      };\n    });\n\n  await Promise.all(pluginsWithTranslationFiles.map(t => orderTrads(t)));\n}\n\nrun().catch(err => console.error(err));\n",
    "scripts/link.js": "'use strict';\n\nconst { join } = require('path');\nconst { promisify } = require('util');\nconst execa = require('execa');\nconst fs = require('fs-extra');\nconst glob = promisify(require('glob').glob);\n\nasync function run() {\n  const packageDirs = await glob('packages/*');\n\n  console.log('Linking all packages');\n\n  const packages = packageDirs.map(dir => ({\n    dir,\n    pkgJSON: fs.readJSONSync(join(dir, 'package.json')),\n  }));\n\n  await Promise.all(packages.map(({ dir }) => execa('yarn', ['link'], { cwd: dir })));\n\n  const packageNames = packages.map(p => p.pkgJSON.name).join(' ');\n  console.log(`Package names: \\n ${packageNames}\\n`);\n}\n\nrun().catch(err => console.error(err));\n",
    "scripts/open-api/serve.js": "'use strict';\n\nconst http = require('http');\nconst path = require('path');\nconst fse = require('fs-extra');\nconst getPort = require('get-port');\n\nconst config = {\n  port: parseInt(process.env.PORT, 10) || 1339,\n};\n\nconst args = process.argv.slice(2);\n\nif (!args[0]) {\n  console.error('Missing required parameter <package-name>');\n  process.exit(1);\n}\n\nasync function run() {\n  const openAPISpecPath = path.join(__dirname, '../../packages', args[0], 'oas.yml');\n  const indexPagePath = path.join(__dirname, 'public', 'index.html');\n\n  if (!(await fse.pathExists(openAPISpecPath))) {\n    throw new Error(`No OAS configuration found at ${openAPISpecPath}`);\n  }\n\n  const server = http.createServer((req, res) => {\n    if (req.url == '/spec.yml') {\n      return fse.createReadStream(openAPISpecPath).pipe(res);\n    }\n\n    return fse.createReadStream(indexPagePath).pipe(res);\n  });\n\n  const port = await getPort({ port: config.port });\n\n  server.listen(port, () => {\n    console.log(`Server available at http://localhost:${port}`);\n  });\n}\n\nrun().catch(error => {\n  console.log('Unexpected Error:', error);\n  process.exit(1);\n});\n",
    "scripts/unlink.js": "'use strict';\n\nconst { join } = require('path');\nconst { promisify } = require('util');\nconst execa = require('execa');\nconst fs = require('fs-extra');\nconst glob = promisify(require('glob').glob);\n\nasync function run() {\n  const packageDirs = await glob('packages/*');\n\n  console.log('Unlinking all packages');\n\n  const packages = packageDirs.map(dir => ({\n    dir,\n    pkgJSON: fs.readJSONSync(join(dir, 'package.json')),\n  }));\n\n  await Promise.all(packages.map(({ dir }) => execa('yarn', ['unlink'], { cwd: dir })));\n\n  const packageNames = packages.map(p => p.pkgJSON.name).join(' ');\n  console.log(`Package names: \\n ${packageNames}\\n`);\n}\n\nrun().catch(err => console.error(err));\n",
    "test/e2e.js": "'use strict';\n\nconst execa = require('execa');\nconst yargs = require('yargs');\nconst { cleanTestApp, generateTestApp } = require('./helpers/test-app-generator');\n\nconst appName = 'testApp';\n\nconst databases = {\n  mongo: {\n    client: 'mongo',\n    host: '127.0.0.1',\n    port: 27017,\n    database: 'strapi_test',\n    username: 'root',\n    password: 'strapi',\n  },\n  postgres: {\n    client: 'postgres',\n    host: '127.0.0.1',\n    port: 5432,\n    database: 'strapi_test',\n    username: 'strapi',\n    password: 'strapi',\n  },\n  mysql: {\n    client: 'mysql',\n    host: '127.0.0.1',\n    port: 3306,\n    database: 'strapi_test',\n    username: 'strapi',\n    password: 'strapi',\n  },\n  sqlite: {\n    client: 'sqlite',\n    filename: './tmp/data.db',\n  },\n};\n\nconst runAllTests = async args => {\n  return execa('yarn', ['-s', 'test:e2e', 'test/all.test.e2e.js'], {\n    stdio: 'inherit',\n    env: {\n      STRAPI_TEST_PATHS: args,\n      FORCE_COLOR: 1,\n    },\n  });\n};\n\nconst main = async (database, args) => {\n  try {\n    await cleanTestApp(appName);\n    await generateTestApp({ appName, database });\n\n    await runAllTests(args).catch(() => {\n      process.stdout.write('Tests failed\\n', () => {\n        process.exit(1);\n      });\n    });\n\n    process.exit(0);\n  } catch (error) {\n    process.stdout.write('Tests failed\\n', () => {\n      process.exit(1);\n    });\n  }\n};\n\nyargs\n  .command(\n    '$0',\n    'run end to end tests',\n    yargs => {\n      yargs.option('database', {\n        alias: 'db',\n        describe: 'choose a database',\n        choices: Object.keys(databases),\n        default: 'sqlite',\n      });\n    },\n    argv => {\n      const { database, _: args } = argv;\n\n      main(databases[database], args.join(' '));\n    }\n  )\n  .help().argv;\n",
    "test/helpers/agent.js": "'use strict';\n\nconst { clone, has, concat, isNil } = require('lodash/fp');\nconst qs = require('qs');\nconst request = require('supertest');\nconst { createUtils } = require('./utils');\n\nconst createAgent = (strapi, initialState = {}) => {\n  const state = clone(initialState);\n  const utils = createUtils(strapi);\n\n  const agent = options => {\n    const { method, url, body, formData, qs: queryString } = options;\n    const supertestAgent = request.agent(strapi.server);\n\n    if (has('token', state)) {\n      supertestAgent.auth(state.token, { type: 'bearer' });\n    }\n\n    const fullUrl = concat(state.urlPrefix, url).join('');\n\n    const rq = supertestAgent[method.toLowerCase()](fullUrl);\n\n    if (queryString) {\n      rq.query(qs.stringify(queryString));\n    }\n\n    if (body) {\n      rq.send(body);\n    }\n\n    if (formData) {\n      const attachFieldToRequest = field => rq.field(field, formData[field]);\n      Object.keys(formData).forEach(attachFieldToRequest);\n    }\n\n    if (isNil(formData)) {\n      rq.type('application/json');\n    }\n\n    return rq;\n  };\n\n  const createShorthandMethod = method => (url, options = {}) => {\n    return agent({ ...options, url, method });\n  };\n\n  Object.assign(agent, {\n    assignState(newState) {\n      Object.assign(state, newState);\n      return agent;\n    },\n\n    setURLPrefix(path) {\n      return this.assignState({ urlPrefix: path });\n    },\n\n    setToken(token) {\n      return this.assignState({ token });\n    },\n\n    setLoggedUser(loggedUser) {\n      return this.assignState({ loggedUser });\n    },\n\n    getLoggedUser() {\n      return state.loggedUser;\n    },\n\n    async login(userInfo) {\n      const { token, user } = await utils.login(userInfo);\n\n      this.setToken(token).setLoggedUser(user);\n\n      return agent;\n    },\n\n    async registerOrLogin(userCredentials) {\n      const { token, user } = await utils.registerOrLogin(userCredentials);\n\n      this.setToken(token).setLoggedUser(user);\n\n      return agent;\n    },\n\n    get: createShorthandMethod('GET'),\n    post: createShorthandMethod('POST'),\n    put: createShorthandMethod('PUT'),\n    delete: createShorthandMethod('DELETE'),\n  });\n\n  return agent;\n};\n\nmodule.exports = {\n  createAgent,\n};\n",
    "test/helpers/auth.js": "'use strict';\n\nconst { createRequest } = require('./request');\n\nconst auth = {\n  email: 'admin@strapi.io',\n  firstname: 'admin',\n  lastname: 'admin',\n  password: 'Password123',\n};\n\nconst rq = createRequest();\n\nconst register = async () => {\n  await rq({\n    url: '/admin/register-admin',\n    method: 'POST',\n    body: auth,\n  }).catch(err => {\n    console.error(err);\n    if (err.message === 'You cannot register a new super admin') return;\n    throw err;\n  });\n};\n\nconst login = async () => {\n  const { body } = await rq({\n    url: '/admin/login',\n    method: 'POST',\n    body: {\n      email: auth.email,\n      password: auth.password,\n    },\n  });\n\n  return body.data;\n};\n\nmodule.exports = {\n  async registerAndLogin() {\n    // register\n    await register();\n\n    // login\n    const res = await login();\n\n    return res && res.token;\n  },\n  async login() {\n    const res = await login();\n\n    return res && res.token;\n  },\n  async getUser() {\n    const res = await login();\n\n    return res.user;\n  },\n};\n",
    "test/helpers/builder/index.js": "'use strict';\n\nconst { get } = require('lodash/fp');\n\nconst _ = require('lodash');\nconst modelsUtils = require('../models');\nconst { sanitizeEntity } = require('../../../packages/strapi-utils');\nconst actionRegistry = require('./action-registry');\nconst { createContext } = require('./context');\n\nconst createTestBuilder = (options = {}) => {\n  const { initialState } = options;\n  const ctx = createContext(initialState);\n\n  return {\n    get models() {\n      return ctx.state.models;\n    },\n\n    get fixtures() {\n      return ctx.state.fixtures;\n    },\n\n    sanitizedFixtures(strapi) {\n      return _.mapValues(this.fixtures, (value, key) => this.sanitizedFixturesFor(key, strapi));\n    },\n\n    sanitizedFixturesFor(modelName, strapi) {\n      const model = strapi.getModel(modelName);\n      const fixtures = this.fixturesFor(modelName);\n\n      return sanitizeEntity(fixtures, { model });\n    },\n\n    fixturesFor(modelName) {\n      return this.fixtures[modelName];\n    },\n\n    addAction(code, ...params) {\n      const actionCreator = get(code, actionRegistry);\n\n      ctx.addAction(actionCreator(...params));\n\n      return this;\n    },\n\n    addContentType(contentType) {\n      return this.addAction('contentType.create', contentType);\n    },\n\n    addContentTypes(contentTypes, { batch = true } = {}) {\n      return this.addAction(\n        batch ? 'contentType.createBatch' : 'contentType.createMany',\n        contentTypes\n      );\n    },\n\n    addComponent(component) {\n      return this.addAction('component.create', component);\n    },\n\n    addFixtures(model, entries) {\n      return this.addAction('fixtures.create', model, entries, () => this.fixtures);\n    },\n\n    async build() {\n      for (const action of ctx.state.actions) {\n        await action.build(ctx);\n      }\n\n      return this;\n    },\n\n    async cleanup(options = {}) {\n      const { enableTestDataAutoCleanup = true } = options;\n      const { models, actions } = ctx.state;\n\n      if (enableTestDataAutoCleanup) {\n        for (const model of models.reverse()) {\n          await modelsUtils.cleanupModel(model.uid || model.modelName);\n        }\n      }\n\n      for (const action of actions.reverse()) {\n        await action.cleanup(ctx);\n      }\n\n      ctx.resetState();\n\n      return this;\n    },\n  };\n};\n\nmodule.exports = { createTestBuilder };\n",
    "test/helpers/models.js": "'use strict';\n\nconst { isFunction, isNil, prop } = require('lodash/fp');\nconst { createStrapiInstance } = require('./strapi');\n\nconst createHelpers = async ({ strapi: strapiInstance = null, ...options } = {}) => {\n  const strapi = strapiInstance || (await createStrapiInstance(options));\n  const contentTypeService = strapi.plugins['content-type-builder'].services.contenttypes;\n  const componentsService = strapi.plugins['content-type-builder'].services.components;\n\n  const cleanup = async () => {\n    if (isNil(strapiInstance)) {\n      await strapi.destroy();\n    }\n  };\n\n  return {\n    strapi,\n    contentTypeService,\n    componentsService,\n    cleanup,\n  };\n};\n\nconst createContentType = async (model, { strapi } = {}) => {\n  const { contentTypeService, cleanup } = await createHelpers({ strapi });\n\n  const contentType = await contentTypeService.createContentType({\n    contentType: {\n      connection: 'default',\n      ...model,\n    },\n  });\n\n  await cleanup();\n\n  return contentType;\n};\n\nconst createContentTypes = async (models, { strapi } = {}) => {\n  const { contentTypeService, cleanup } = await createHelpers({ strapi });\n\n  const contentTypes = await contentTypeService.createContentTypes(\n    models.map(model => ({\n      contentType: {\n        connection: 'default',\n        ...model,\n      },\n    }))\n  );\n\n  await cleanup();\n\n  return contentTypes;\n};\n\nconst createComponent = async (component, { strapi } = {}) => {\n  const { componentsService, cleanup } = await createHelpers({ strapi });\n\n  const createdComponent = await componentsService.createComponent({\n    component: {\n      category: 'default',\n      icon: 'default',\n      connection: 'default',\n      ...component,\n    },\n  });\n\n  await cleanup();\n\n  return createdComponent;\n};\n\nconst createComponents = async (components, { strapi } = {}) => {\n  const createdComponents = [];\n\n  for (const component of components) {\n    createdComponents.push(await createComponent(component, { strapi }));\n  }\n\n  return createdComponents;\n};\n\nconst deleteComponent = async (componentUID, { strapi } = {}) => {\n  const { componentsService, cleanup } = await createHelpers({ strapi });\n\n  const component = await componentsService.deleteComponent(componentUID);\n\n  await cleanup();\n\n  return component;\n};\n\nconst deleteComponents = async (componentsUID, { strapi } = {}) => {\n  const deletedComponents = [];\n\n  for (const componentUID of componentsUID) {\n    deletedComponents.push(await deleteComponent(componentUID, { strapi }));\n  }\n\n  return deletedComponents;\n};\n\nconst deleteContentType = async (modelName, { strapi } = {}) => {\n  const { contentTypeService, cleanup } = await createHelpers({ strapi });\n  const uid = `application::${modelName}.${modelName}`;\n\n  const contentType = await contentTypeService.deleteContentType(uid);\n\n  await cleanup();\n\n  return contentType;\n};\n\nconst deleteContentTypes = async (modelsName, { strapi } = {}) => {\n  const { contentTypeService, cleanup } = await createHelpers({ strapi });\n  const toUID = name => `application::${name}.${name}`;\n\n  const contentTypes = await contentTypeService.deleteContentTypes(modelsName.map(toUID));\n\n  await cleanup();\n\n  return contentTypes;\n};\n\nasync function cleanupModels(models, { strapi } = {}) {\n  for (const model of models) {\n    await cleanupModel(model, { strapi });\n  }\n}\n\nasync function cleanupModel(model, { strapi: strapiIst } = {}) {\n  const { strapi, cleanup } = await createHelpers({ strapi: strapiIst });\n\n  await strapi.query(model).delete();\n\n  await cleanup();\n}\n\nasync function createFixtures(dataMap, { strapi: strapiIst } = {}) {\n  const { strapi, cleanup } = await createHelpers({ strapi: strapiIst });\n  const models = Object.keys(dataMap);\n  const resultMap = {};\n\n  for (const model of models) {\n    const entries = [];\n\n    for (const data of dataMap[model]) {\n      entries.push(await strapi.query(model).create(data));\n    }\n\n    resultMap[model] = entries;\n  }\n\n  await cleanup();\n\n  return resultMap;\n}\n\nasync function createFixturesFor(model, entries, { strapi: strapiIst } = {}) {\n  const { strapi, cleanup } = await createHelpers({ strapi: strapiIst });\n  const results = [];\n\n  for (const entry of entries) {\n    const dataToCreate = isFunction(entry) ? entry(results) : entry;\n    results.push(await strapi.query(model).create(dataToCreate));\n  }\n\n  await cleanup();\n\n  return results;\n}\n\nasync function deleteFixturesFor(model, entries, { strapi: strapiIst } = {}) {\n  const { strapi, cleanup } = await createHelpers({ strapi: strapiIst });\n\n  await strapi.query(model).delete({ id_in: entries.map(prop('id')) });\n\n  await cleanup();\n}\n\nasync function modifyContentType(data, { strapi } = {}) {\n  const { contentTypeService, cleanup } = await createHelpers({ strapi });\n\n  const sanitizedData = { ...data };\n  delete sanitizedData.editable;\n  delete sanitizedData.restrictRelationsTo;\n\n  const uid = `application::${sanitizedData.name}.${sanitizedData.name}`;\n\n  const ct = await contentTypeService.editContentType(uid, {\n    contentType: {\n      connection: 'default',\n      ...sanitizedData,\n    },\n  });\n\n  await cleanup();\n\n  return ct;\n}\n\nasync function getContentTypeSchema(modelName, { strapi: strapiIst } = {}) {\n  const { strapi, contentTypeService, cleanup } = await createHelpers({ strapi: strapiIst });\n\n  const uid = `application::${modelName}.${modelName}`;\n  const ct = contentTypeService.formatContentType(strapi.contentTypes[uid]);\n\n  await cleanup();\n\n  return (ct || {}).schema;\n}\n\nmodule.exports = {\n  // Create Content-Types\n  createContentType,\n  createContentTypes,\n  // Delete Content-Types\n  deleteContentType,\n  deleteContentTypes,\n  // Cleanup Models\n  cleanupModel,\n  cleanupModels,\n  // Create Components\n  createComponent,\n  createComponents,\n  // Delete Components\n  deleteComponent,\n  deleteComponents,\n  // Fixtures\n  createFixtures,\n  createFixturesFor,\n  deleteFixturesFor,\n  // Update Content-Types\n  modifyContentType,\n  // Misc\n  getContentTypeSchema,\n};\n",
    "test/helpers/strapi.js": "'use strict';\n\nconst path = require('path');\nconst _ = require('lodash');\nconst strapi = require('../../packages/strapi/lib');\nconst { createUtils } = require('./utils');\n\nconst superAdminCredentials = {\n  email: 'admin@strapi.io',\n  firstname: 'admin',\n  lastname: 'admin',\n  password: 'Password123',\n};\n\nconst superAdminLoginInfo = _.pick(superAdminCredentials, ['email', 'password']);\n\nconst TEST_APP_URL = path.resolve(__dirname, '../../testApp');\n\nconst createStrapiInstance = async ({ ensureSuperAdmin = true, logLevel = 'fatal' } = {}) => {\n  const options = { dir: TEST_APP_URL };\n  const instance = strapi(options);\n\n  await instance.load();\n\n  instance.log.level = logLevel;\n\n  await instance.app\n    // Populate Koa routes\n    .use(instance.router.routes())\n    // Populate Koa methods\n    .use(instance.router.allowedMethods());\n\n  const utils = createUtils(instance);\n\n  if (ensureSuperAdmin) {\n    await utils.createUserIfNotExists(superAdminCredentials);\n  }\n\n  return instance;\n};\n\nmodule.exports = {\n  createStrapiInstance,\n  superAdmin: {\n    loginInfo: superAdminLoginInfo,\n    credentials: superAdminCredentials,\n  },\n};\n",
    "test/helpers/utils.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst createUtils = strapi => {\n  const login = async userInfo => {\n    const sanitizedUserInfo = _.pick(userInfo, ['email', 'id']);\n    const user = await strapi.admin.services.user.findOne(sanitizedUserInfo);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    const token = strapi.admin.services.token.createJwtToken(user);\n\n    return { token, user };\n  };\n  const registerOrLogin = async userCredentials => {\n    await createUserIfNotExists(userCredentials);\n    return login(userCredentials);\n  };\n\n  const findUser = strapi.admin.services.user.findOne;\n  const userExists = strapi.admin.services.user.exists;\n  const createUser = async userInfo => {\n    const superAdminRole = await strapi.admin.services.role.getSuperAdminWithUsersCount();\n\n    if (superAdminRole.usersCount === 0) {\n      const userRoles = _.uniq((userInfo.roles || []).concat(superAdminRole.id));\n      Object.assign(userInfo, { roles: userRoles });\n    }\n\n    return strapi.admin.services.user.create({\n      registrationToken: null,\n      isActive: true,\n      ...userInfo,\n    });\n  };\n  const deleteUserById = strapi.admin.services.user.deleteById;\n  const deleteUsersById = strapi.admin.services.user.deleteByIds;\n  const createUserIfNotExists = async userInfo => {\n    const sanitizedUserInfo = _.pick(userInfo, ['email', 'id']);\n    const exists = await userExists(sanitizedUserInfo);\n\n    return !exists ? createUser(userInfo) : null;\n  };\n\n  const createRole = strapi.admin.services.role.create;\n  const getRole = strapi.admin.services.role.find;\n  const deleteRolesById = strapi.admin.services.role.deleteByIds;\n  const getSuperAdminRole = strapi.admin.services.role.getSuperAdmin;\n  const assignPermissionsToRole = strapi.admin.services.role.assignPermissions;\n\n  return {\n    // Auth\n    login,\n    registerOrLogin,\n    // Users\n    findUser,\n    createUser,\n    createUserIfNotExists,\n    userExists,\n    deleteUserById,\n    deleteUsersById,\n    // Roles\n    getRole,\n    getSuperAdminRole,\n    createRole,\n    deleteRolesById,\n    assignPermissionsToRole,\n  };\n};\n\nmodule.exports = { createUtils };\n"
  }
}