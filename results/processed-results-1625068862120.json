{
  "promises": {
    "0": {
      "source": "node_modules/ava/lib/runner.js:489:17:489:17",
      "startTime": "94230758611764",
      "endTime": "94230761365298",
      "elapsedTime": "2753534",
      "asyncId": 113,
      "triggerAsyncId": 15,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.start",
      "userCode": false,
      "line": "\n\t\t}\n\n\t\tawait Promise.all(this.waitForReady);\n\n\t\tif (concurrentTests.length === 0 && serialTests.length === 0) {\n\t\t\tthis.emit('finish')",
      "startLine": 489,
      "startCol": 17,
      "endLine": 489,
      "endCol": 17,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        114
      ],
      "uniqueid": 0
    },
    "1": {
      "source": "node_modules/ava/lib/runner.js:78:11:78:11",
      "startTime": "94230763144322",
      "endTime": "94231117959710",
      "elapsedTime": "354815388",
      "asyncId": 114,
      "triggerAsyncId": 113,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "triggers": [
        167,
        166,
        165,
        171
      ],
      "line": "\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\thasStarted = true;\n\t\t\t\t\tthis.start();\n\t\t\t\t});\n\t\t\t}",
      "startLine": 78,
      "startCol": 11,
      "endLine": 78,
      "endCol": 11,
      "file": "node_modules/ava/lib/runner.js",
      "uniqueid": 1
    },
    "2": {
      "source": "node_modules/ava/lib/runner.js:500:30:500:30",
      "startTime": "94231021068886",
      "endTime": "94231184827666",
      "elapsedTime": "163758780",
      "asyncId": 165,
      "triggerAsyncId": 114,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.start",
      "userCode": false,
      "line": "\n\n\t\t// Note that the hooks and tests always begin running asynchronously.\n\t\tconst beforePromise = this.runHooks(this.tasks.before, contextRef);\n\t\tconst serialPromise = beforePromise.then(beforeHooksOk => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t// Don't run tests if a `before` hook failed.\n\t\t\tif (!beforeHooksOk) ",
      "startLine": 500,
      "startCol": 30,
      "endLine": 500,
      "endCol": 30,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        170,
        172,
        170
      ],
      "uniqueid": 2
    },
    "3": {
      "source": "node_modules/ava/lib/runner.js:501:39:501:39",
      "startTime": "94231032903004",
      "endTime": "94231727760657",
      "elapsedTime": "694857653",
      "asyncId": 170,
      "triggerAsyncId": 165,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.start",
      "userCode": false,
      "triggers": [
        176,
        176,
        173
      ],
      "line": "\n\t\t// Note that the hooks and tests always begin running asynchronously.\n\t\tconst beforePromise = this.runHooks(this.tasks.before, contextRef);\n\t\tconst serialPromise = beforePromise.then(beforeHooksOk => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t// Don't run tests if a `before` hook failed.\n\t\t\tif (!beforeHooksOk) {\n\t\t\t\treturn false",
      "startLine": 501,
      "startCol": 39,
      "endLine": 501,
      "endCol": 39,
      "file": "node_modules/ava/lib/runner.js",
      "uniqueid": 3
    },
    "4": {
      "source": "node_modules/ava/lib/runner.js:523:37:523:37",
      "startTime": "94231035921394",
      "endTime": "94231731493993",
      "elapsedTime": "695572599",
      "asyncId": 171,
      "triggerAsyncId": 114,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.start",
      "userCode": false,
      "line": "\n\t\t\t}, true);\n\t\t});\n\t\tconst concurrentPromise = Promise.all([beforePromise, serialPromise]).then(async ([beforeHooksOk, serialOk]) => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t// Don't run tests if a `before` hook failed, or if `failFast` is enabled\n\t\t\t// and a previous serial test failed.\n\t\t\tif (!beforeHooksOk || (!serialOk && this.failFast)) ",
      "startLine": 523,
      "startCol": 37,
      "endLine": 523,
      "endCol": 37,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        174,
        174
      ],
      "uniqueid": 4
    },
    "5": {
      "source": "node_modules/ava/lib/runner.js:523:73:523:73",
      "startTime": "94231040291774",
      "endTime": "94235204800399",
      "elapsedTime": "4164508625",
      "asyncId": 174,
      "triggerAsyncId": 171,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.start",
      "userCode": false,
      "triggers": [
        251,
        258,
        265,
        272,
        279,
        286,
        293,
        300,
        307,
        250,
        257,
        264,
        271,
        278,
        285,
        292,
        299,
        306,
        249,
        256,
        263,
        270,
        277,
        284,
        291,
        298,
        305,
        297,
        304,
        248,
        255,
        262,
        269,
        276,
        283,
        290,
        311,
        247,
        175
      ],
      "line": "\n\t\t\t}, true);\n\t\t});\n\t\tconst concurrentPromise = Promise.all([beforePromise, serialPromise]).then(async ([beforeHooksOk, serialOk]) => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t// Don't run tests if a `before` hook failed, or if `failFast` is enabled\n\t\t\t// and a previous serial test failed.\n\t\t\tif (!beforeHooksOk || (!serialOk && this.failFast)) ",
      "startLine": 523,
      "startCol": 73,
      "endLine": 523,
      "endCol": 73,
      "file": "node_modules/ava/lib/runner.js",
      "uniqueid": 5
    },
    "6": {
      "source": "node_modules/ava/lib/runner.js:348:28:348:28",
      "startTime": "94231204347114",
      "endTime": "94231223654064",
      "elapsedTime": "19306950",
      "asyncId": 180,
      "triggerAsyncId": 178,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.runTest",
      "userCode": false,
      "line": "\n\tasync runTest(task, contextRef) {\n\t\tconst hookSuffix = ` for ${task.title}`;\n\t\tlet hooksOk = await this.runHooks(\n\t\t\tthis.tasks.beforeEach,\n\t\t\tcontextRef,\n\t\t\t",
      "startLine": 348,
      "startCol": 28,
      "endLine": 348,
      "endCol": 28,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        185
      ],
      "uniqueid": 6
    },
    "7": {
      "source": "node_modules/ava/lib/runner.js:520:17:520:17",
      "startTime": "94231213770256",
      "endTime": "94231268425118",
      "elapsedTime": "54654862",
      "asyncId": 185,
      "triggerAsyncId": 180,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "triggers": [
        192,
        191,
        190,
        189,
        200,
        200,
        188
      ],
      "line": "\n\t\t\t\t}\n\n\t\t\t\treturn this.runTest(task, contextRef.copy());\n\t\t\t}, true);\n\t\t});\n\t\tconst concurrentPromise = Promise.all([beforePromise, serialPromise]).then(async ([beforeHooksOk, serialOk]) => { // eslint-disable-line promise/prefer-await-to-the",
      "startLine": 520,
      "startCol": 17,
      "endLine": 520,
      "endCol": 17,
      "file": "node_modules/ava/lib/runner.js",
      "uniqueid": 7
    },
    "8": {
      "source": "test/lib/init/init.js:108:22:108:22",
      "startTime": "94231235174402",
      "endTime": "94231269243003",
      "elapsedTime": "34068601",
      "asyncId": 190,
      "triggerAsyncId": 185,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\tconst {init} = mock.reRequire(\"../../../lib/init/init\");\n\n\tawait t.throwsAsync(init(), {\n\t\tmessage: \"Some error from fs.readFile\"\n\t});\n})",
      "startLine": 108,
      "startCol": 22,
      "endLine": 108,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [
        195
      ],
      "uniqueid": 8
    },
    "9": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94231238048556",
      "endTime": "94231268813503",
      "elapsedTime": "30764947",
      "asyncId": 191,
      "triggerAsyncId": 185,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [
        194
      ],
      "uniqueid": 9
    },
    "10": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94231239703568",
      "endTime": "94231244755086",
      "elapsedTime": "5051518",
      "asyncId": 192,
      "triggerAsyncId": 185,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "readFile",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        193
      ],
      "uniqueid": 10
    },
    "11": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94231246365257",
      "endTime": "94231269031855",
      "elapsedTime": "22666598",
      "asyncId": 193,
      "triggerAsyncId": 192,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 11
    },
    "12": {
      "source": "test/lib/init/init.js:108:22:108:22",
      "startTime": "94231248178180",
      "endTime": "94231269424619",
      "elapsedTime": "21246439",
      "asyncId": 194,
      "triggerAsyncId": 191,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\tconst {init} = mock.reRequire(\"../../../lib/init/init\");\n\n\tawait t.throwsAsync(init(), {\n\t\tmessage: \"Some error from fs.readFile\"\n\t});\n})",
      "startLine": 108,
      "startCol": 22,
      "endLine": 108,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [],
      "uniqueid": 12
    },
    "13": {
      "source": "node_modules/ava/lib/assert.js:552:51:552:51",
      "startTime": "94231252710186",
      "endTime": "94231271915370",
      "elapsedTime": "19205184",
      "asyncId": 195,
      "triggerAsyncId": 190,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "handlePromise",
      "userCode": false,
      "line": "\n\t\t\t\tconst savedError = getErrorWithLongStackTrace();\n\t\t\t\t// Handle \"promise like\" objects by casting to a real Promise.\n\t\t\t\tconst intermediate = Promise.resolve(promise).then(value => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion: 'throwsAsync',\n\t\t\t\t\t\tmessage",
      "startLine": 552,
      "startCol": 51,
      "endLine": 552,
      "endCol": 51,
      "file": "node_modules/ava/lib/assert.js",
      "triggers": [
        196,
        198
      ],
      "uniqueid": 13
    },
    "14": {
      "source": "node_modules/ava/lib/test.js:377:5:377:5",
      "startTime": "94231255872335",
      "endTime": "94231272647227",
      "elapsedTime": "16774892",
      "asyncId": 197,
      "triggerAsyncId": 196,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.addPendingAssertion",
      "userCode": false,
      "line": "\n\t\tpromise\n\t\t\t.catch(error => this.saveFirstError(error))\n\t\t\t.then(() => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\tthis.pendingAssertionCount--;\n\t\t\t\tthis.refreshTimeout();\n\t\t\t})",
      "startLine": 377,
      "startCol": 5,
      "endLine": 377,
      "endCol": 5,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 14
    },
    "15": {
      "source": "node_modules/ava/lib/test.js:622:21:622:21",
      "startTime": "94231258513221",
      "endTime": "94231273517385",
      "elapsedTime": "15004164",
      "asyncId": 199,
      "triggerAsyncId": 198,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.callFn",
      "userCode": false,
      "line": "\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tretval: this.fn.call(null, this.createExecutionContext())\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn ",
      "startLine": 622,
      "startCol": 21,
      "endLine": 622,
      "endCol": 21,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 15
    },
    "16": {
      "source": "node_modules/ava/lib/runner.js:348:28:348:28",
      "startTime": "94231775400000",
      "endTime": "94232149135347",
      "elapsedTime": "373735347",
      "asyncId": 249,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.runTest",
      "userCode": false,
      "line": "\n\tasync runTest(task, contextRef) {\n\t\tconst hookSuffix = ` for ${task.title}`;\n\t\tlet hooksOk = await this.runHooks(\n\t\t\tthis.tasks.beforeEach,\n\t\t\tcontextRef,\n\t\t\t",
      "startLine": 348,
      "startCol": 28,
      "endLine": 348,
      "endCol": 28,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        254
      ],
      "uniqueid": 16
    },
    "17": {
      "source": "node_modules/ava/lib/runner.js:538:17:538:17",
      "startTime": "94231806142242",
      "endTime": "94232187046746",
      "elapsedTime": "380904504",
      "asyncId": 254,
      "triggerAsyncId": 249,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t\t\t// stop other concurrent tests from running.\n\t\t\tconst allOkays = await Promise.all(concurrentTests.map(task => {\n\t\t\t\treturn this.runTest(task, contextRef.copy());\n\t\t\t}));\n\t\t\treturn allOkays.every(ok => ok);\n\t\t})",
      "startLine": 538,
      "startCol": 17,
      "endLine": 538,
      "endCol": 17,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        327,
        326,
        325,
        324,
        332,
        332,
        323
      ],
      "uniqueid": 17
    },
    "18": {
      "source": "node_modules/ava/lib/runner.js:348:28:348:28",
      "startTime": "94231809551114",
      "endTime": "94232149564839",
      "elapsedTime": "340013725",
      "asyncId": 256,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.runTest",
      "userCode": false,
      "line": "\n\tasync runTest(task, contextRef) {\n\t\tconst hookSuffix = ` for ${task.title}`;\n\t\tlet hooksOk = await this.runHooks(\n\t\t\tthis.tasks.beforeEach,\n\t\t\tcontextRef,\n\t\t\t",
      "startLine": 348,
      "startCol": 28,
      "endLine": 348,
      "endCol": 28,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        261
      ],
      "uniqueid": 18
    },
    "19": {
      "source": "node_modules/ava/lib/runner.js:538:17:538:17",
      "startTime": "94231816944688",
      "endTime": "94232210985979",
      "elapsedTime": "394041291",
      "asyncId": 261,
      "triggerAsyncId": 256,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t\t\t// stop other concurrent tests from running.\n\t\t\tconst allOkays = await Promise.all(concurrentTests.map(task => {\n\t\t\t\treturn this.runTest(task, contextRef.copy());\n\t\t\t}));\n\t\t\treturn allOkays.every(ok => ok);\n\t\t})",
      "startLine": 538,
      "startCol": 17,
      "endLine": 538,
      "endCol": 17,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        341,
        340,
        339,
        338,
        346,
        346,
        337
      ],
      "uniqueid": 19
    },
    "20": {
      "source": "node_modules/ava/lib/runner.js:348:28:348:28",
      "startTime": "94231820076066",
      "endTime": "94232151260648",
      "elapsedTime": "331184582",
      "asyncId": 263,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.runTest",
      "userCode": false,
      "line": "\n\tasync runTest(task, contextRef) {\n\t\tconst hookSuffix = ` for ${task.title}`;\n\t\tlet hooksOk = await this.runHooks(\n\t\t\tthis.tasks.beforeEach,\n\t\t\tcontextRef,\n\t\t\t",
      "startLine": 348,
      "startCol": 28,
      "endLine": 348,
      "endCol": 28,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        268
      ],
      "uniqueid": 20
    },
    "21": {
      "source": "node_modules/ava/lib/runner.js:538:17:538:17",
      "startTime": "94231829110502",
      "endTime": "94232242920033",
      "elapsedTime": "413809531",
      "asyncId": 268,
      "triggerAsyncId": 263,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t\t\t// stop other concurrent tests from running.\n\t\t\tconst allOkays = await Promise.all(concurrentTests.map(task => {\n\t\t\t\treturn this.runTest(task, contextRef.copy());\n\t\t\t}));\n\t\t\treturn allOkays.every(ok => ok);\n\t\t})",
      "startLine": 538,
      "startCol": 17,
      "endLine": 538,
      "endCol": 17,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        355,
        354,
        353,
        352,
        364,
        364,
        351
      ],
      "uniqueid": 21
    },
    "22": {
      "source": "node_modules/ava/lib/runner.js:348:28:348:28",
      "startTime": "94231832178170",
      "endTime": "94232153850198",
      "elapsedTime": "321672028",
      "asyncId": 270,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.runTest",
      "userCode": false,
      "line": "\n\tasync runTest(task, contextRef) {\n\t\tconst hookSuffix = ` for ${task.title}`;\n\t\tlet hooksOk = await this.runHooks(\n\t\t\tthis.tasks.beforeEach,\n\t\t\tcontextRef,\n\t\t\t",
      "startLine": 348,
      "startCol": 28,
      "endLine": 348,
      "endCol": 28,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        275
      ],
      "uniqueid": 22
    },
    "23": {
      "source": "node_modules/ava/lib/runner.js:538:17:538:17",
      "startTime": "94231839103593",
      "endTime": "94232275015772",
      "elapsedTime": "435912179",
      "asyncId": 275,
      "triggerAsyncId": 270,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t\t\t// stop other concurrent tests from running.\n\t\t\tconst allOkays = await Promise.all(concurrentTests.map(task => {\n\t\t\t\treturn this.runTest(task, contextRef.copy());\n\t\t\t}));\n\t\t\treturn allOkays.every(ok => ok);\n\t\t})",
      "startLine": 538,
      "startCol": 17,
      "endLine": 538,
      "endCol": 17,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        373,
        372,
        371,
        370,
        382,
        382,
        369
      ],
      "uniqueid": 23
    },
    "24": {
      "source": "node_modules/ava/lib/runner.js:348:28:348:28",
      "startTime": "94231842252283",
      "endTime": "94232154503433",
      "elapsedTime": "312251150",
      "asyncId": 277,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.runTest",
      "userCode": false,
      "line": "\n\tasync runTest(task, contextRef) {\n\t\tconst hookSuffix = ` for ${task.title}`;\n\t\tlet hooksOk = await this.runHooks(\n\t\t\tthis.tasks.beforeEach,\n\t\t\tcontextRef,\n\t\t\t",
      "startLine": 348,
      "startCol": 28,
      "endLine": 348,
      "endCol": 28,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        282
      ],
      "uniqueid": 24
    },
    "25": {
      "source": "node_modules/ava/lib/runner.js:538:17:538:17",
      "startTime": "94231850431483",
      "endTime": "94232550207233",
      "elapsedTime": "699775750",
      "asyncId": 282,
      "triggerAsyncId": 277,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t\t\t// stop other concurrent tests from running.\n\t\t\tconst allOkays = await Promise.all(concurrentTests.map(task => {\n\t\t\t\treturn this.runTest(task, contextRef.copy());\n\t\t\t}));\n\t\t\treturn allOkays.every(ok => ok);\n\t\t})",
      "startLine": 538,
      "startCol": 17,
      "endLine": 538,
      "endCol": 17,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        391,
        390,
        389,
        388,
        400,
        400,
        387
      ],
      "uniqueid": 25
    },
    "26": {
      "source": "node_modules/ava/lib/runner.js:348:28:348:28",
      "startTime": "94231853105036",
      "endTime": "94232154867760",
      "elapsedTime": "301762724",
      "asyncId": 284,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.runTest",
      "userCode": false,
      "line": "\n\tasync runTest(task, contextRef) {\n\t\tconst hookSuffix = ` for ${task.title}`;\n\t\tlet hooksOk = await this.runHooks(\n\t\t\tthis.tasks.beforeEach,\n\t\t\tcontextRef,\n\t\t\t",
      "startLine": 348,
      "startCol": 28,
      "endLine": 348,
      "endCol": 28,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        289
      ],
      "uniqueid": 26
    },
    "27": {
      "source": "node_modules/ava/lib/runner.js:538:17:538:17",
      "startTime": "94231866662432",
      "endTime": "94232572193894",
      "elapsedTime": "705531462",
      "asyncId": 289,
      "triggerAsyncId": 284,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t\t\t// stop other concurrent tests from running.\n\t\t\tconst allOkays = await Promise.all(concurrentTests.map(task => {\n\t\t\t\treturn this.runTest(task, contextRef.copy());\n\t\t\t}));\n\t\t\treturn allOkays.every(ok => ok);\n\t\t})",
      "startLine": 538,
      "startCol": 17,
      "endLine": 538,
      "endCol": 17,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        409,
        408,
        407,
        406,
        418,
        418,
        405
      ],
      "uniqueid": 27
    },
    "28": {
      "source": "node_modules/ava/lib/runner.js:348:28:348:28",
      "startTime": "94231870121262",
      "endTime": "94232157301411",
      "elapsedTime": "287180149",
      "asyncId": 291,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.runTest",
      "userCode": false,
      "line": "\n\tasync runTest(task, contextRef) {\n\t\tconst hookSuffix = ` for ${task.title}`;\n\t\tlet hooksOk = await this.runHooks(\n\t\t\tthis.tasks.beforeEach,\n\t\t\tcontextRef,\n\t\t\t",
      "startLine": 348,
      "startCol": 28,
      "endLine": 348,
      "endCol": 28,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        296
      ],
      "uniqueid": 28
    },
    "29": {
      "source": "node_modules/ava/lib/runner.js:538:17:538:17",
      "startTime": "94231880260344",
      "endTime": "94232598043983",
      "elapsedTime": "717783639",
      "asyncId": 296,
      "triggerAsyncId": 291,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t\t\t// stop other concurrent tests from running.\n\t\t\tconst allOkays = await Promise.all(concurrentTests.map(task => {\n\t\t\t\treturn this.runTest(task, contextRef.copy());\n\t\t\t}));\n\t\t\treturn allOkays.every(ok => ok);\n\t\t})",
      "startLine": 538,
      "startCol": 17,
      "endLine": 538,
      "endCol": 17,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        427,
        426,
        425,
        424,
        436,
        436,
        423
      ],
      "uniqueid": 29
    },
    "30": {
      "source": "node_modules/ava/lib/runner.js:348:28:348:28",
      "startTime": "94231884344267",
      "endTime": "94232162853144",
      "elapsedTime": "278508877",
      "asyncId": 298,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.runTest",
      "userCode": false,
      "line": "\n\tasync runTest(task, contextRef) {\n\t\tconst hookSuffix = ` for ${task.title}`;\n\t\tlet hooksOk = await this.runHooks(\n\t\t\tthis.tasks.beforeEach,\n\t\t\tcontextRef,\n\t\t\t",
      "startLine": 348,
      "startCol": 28,
      "endLine": 348,
      "endCol": 28,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        303
      ],
      "uniqueid": 30
    },
    "31": {
      "source": "node_modules/ava/lib/runner.js:538:17:538:17",
      "startTime": "94231892395003",
      "endTime": "94232620560643",
      "elapsedTime": "728165640",
      "asyncId": 303,
      "triggerAsyncId": 298,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t\t\t// stop other concurrent tests from running.\n\t\t\tconst allOkays = await Promise.all(concurrentTests.map(task => {\n\t\t\t\treturn this.runTest(task, contextRef.copy());\n\t\t\t}));\n\t\t\treturn allOkays.every(ok => ok);\n\t\t})",
      "startLine": 538,
      "startCol": 17,
      "endLine": 538,
      "endCol": 17,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        445,
        444,
        443,
        442,
        454,
        454,
        441
      ],
      "uniqueid": 31
    },
    "32": {
      "source": "node_modules/ava/lib/runner.js:348:28:348:28",
      "startTime": "94231896892585",
      "endTime": "94232165163236",
      "elapsedTime": "268270651",
      "asyncId": 305,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Runner.runTest",
      "userCode": false,
      "line": "\n\tasync runTest(task, contextRef) {\n\t\tconst hookSuffix = ` for ${task.title}`;\n\t\tlet hooksOk = await this.runHooks(\n\t\t\tthis.tasks.beforeEach,\n\t\t\tcontextRef,\n\t\t\t",
      "startLine": 348,
      "startCol": 28,
      "endLine": 348,
      "endCol": 28,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        310
      ],
      "uniqueid": 32
    },
    "33": {
      "source": "node_modules/ava/lib/runner.js:538:17:538:17",
      "startTime": "94231904852567",
      "endTime": "94232641354333",
      "elapsedTime": "736501766",
      "asyncId": 310,
      "triggerAsyncId": 305,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t\t\t// stop other concurrent tests from running.\n\t\t\tconst allOkays = await Promise.all(concurrentTests.map(task => {\n\t\t\t\treturn this.runTest(task, contextRef.copy());\n\t\t\t}));\n\t\t\treturn allOkays.every(ok => ok);\n\t\t})",
      "startLine": 538,
      "startCol": 17,
      "endLine": 538,
      "endCol": 17,
      "file": "node_modules/ava/lib/runner.js",
      "triggers": [
        463,
        462,
        461,
        460,
        472,
        472,
        459
      ],
      "uniqueid": 33
    },
    "34": {
      "source": "test/lib/init/init.js:18:30:18:30",
      "startTime": "94232171881536",
      "endTime": "94233551094010",
      "elapsedTime": "1379212474",
      "asyncId": 325,
      "triggerAsyncId": 254,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for application\", async (t) => {\n\tconst projectConfig = await init({\n\t\tcwd: getFixturePath(\"application\")\n\t});",
      "startLine": 18,
      "startCol": 30,
      "endLine": 18,
      "endCol": 30,
      "file": "test/lib/init/init.js",
      "triggers": [
        331
      ],
      "uniqueid": 34
    },
    "35": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232173312204",
      "endTime": "94232901308607",
      "elapsedTime": "727996403",
      "asyncId": 326,
      "triggerAsyncId": 254,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [
        330
      ],
      "uniqueid": 35
    },
    "36": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94232174847491",
      "endTime": "94232900845559",
      "elapsedTime": "725998068",
      "asyncId": 327,
      "triggerAsyncId": 254,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "readFile",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        329
      ],
      "uniqueid": 36
    },
    "37": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232177603658",
      "endTime": "94232901570768",
      "elapsedTime": "723967110",
      "asyncId": 329,
      "triggerAsyncId": 327,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 37
    },
    "38": {
      "source": "test/lib/init/init.js:18:30:18:30",
      "startTime": "94232178584906",
      "endTime": "94233050610723",
      "elapsedTime": "872025817",
      "asyncId": 330,
      "triggerAsyncId": 326,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for application\", async (t) => {\n\tconst projectConfig = await init({\n\t\tcwd: getFixturePath(\"application\")\n\t});",
      "startLine": 18,
      "startCol": 30,
      "endLine": 18,
      "endCol": 30,
      "file": "test/lib/init/init.js",
      "triggers": [
        545,
        544,
        549,
        548,
        553,
        552,
        556,
        543
      ],
      "uniqueid": 38
    },
    "39": {
      "source": "node_modules/ava/lib/test.js:622:21:622:21",
      "startTime": "94232179863092",
      "endTime": "94233559844430",
      "elapsedTime": "1379981338",
      "asyncId": 331,
      "triggerAsyncId": 325,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.callFn",
      "userCode": false,
      "line": "\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tretval: this.fn.call(null, this.createExecutionContext())\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn ",
      "startLine": 622,
      "startCol": 21,
      "endLine": 622,
      "endCol": 21,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 39
    },
    "40": {
      "source": "test/lib/init/init.js:32:30:32:30",
      "startTime": "94232190808053",
      "endTime": "94233779483882",
      "elapsedTime": "1588675829",
      "asyncId": 339,
      "triggerAsyncId": 261,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for library\", async (t) => {\n\tconst projectConfig = await init({\n\t\tcwd: getFixturePath(\"library\")\n\t});",
      "startLine": 32,
      "startCol": 30,
      "endLine": 32,
      "endCol": 30,
      "file": "test/lib/init/init.js",
      "triggers": [
        345
      ],
      "uniqueid": 40
    },
    "41": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232192462369",
      "endTime": "94233051163567",
      "elapsedTime": "858701198",
      "asyncId": 340,
      "triggerAsyncId": 261,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [
        344
      ],
      "uniqueid": 41
    },
    "42": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94232193872448",
      "endTime": "94233050867912",
      "elapsedTime": "856995464",
      "asyncId": 341,
      "triggerAsyncId": 261,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "readFile",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        343
      ],
      "uniqueid": 42
    },
    "43": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232196223432",
      "endTime": "94233051401353",
      "elapsedTime": "855177921",
      "asyncId": 343,
      "triggerAsyncId": 341,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 43
    },
    "44": {
      "source": "test/lib/init/init.js:32:30:32:30",
      "startTime": "94232201810652",
      "endTime": "94233073059860",
      "elapsedTime": "871249208",
      "asyncId": 344,
      "triggerAsyncId": 340,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for library\", async (t) => {\n\tconst projectConfig = await init({\n\t\tcwd: getFixturePath(\"library\")\n\t});",
      "startLine": 32,
      "startCol": 30,
      "endLine": 32,
      "endCol": 30,
      "file": "test/lib/init/init.js",
      "triggers": [
        564,
        563,
        568,
        567,
        572,
        571,
        575,
        562
      ],
      "uniqueid": 44
    },
    "45": {
      "source": "node_modules/ava/lib/test.js:622:21:622:21",
      "startTime": "94232203277083",
      "endTime": "94233786221068",
      "elapsedTime": "1582943985",
      "asyncId": 345,
      "triggerAsyncId": 339,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.callFn",
      "userCode": false,
      "line": "\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tretval: this.fn.call(null, this.createExecutionContext())\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn ",
      "startLine": 622,
      "startCol": 21,
      "endLine": 622,
      "endCol": 21,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 45
    },
    "46": {
      "source": "test/lib/init/init.js:46:22:46:22",
      "startTime": "94232216588058",
      "endTime": "94234008691159",
      "elapsedTime": "1792103101",
      "asyncId": 353,
      "triggerAsyncId": 268,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (Found 'webapp', 'src' and 'test' folders)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-webapp-src-test\")\n\t}), {message:\n\t\"Could not detect project type: Found 'webapp', 'src' and 'test' folders.\\n\" ",
      "startLine": 46,
      "startCol": 22,
      "endLine": 46,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [
        359
      ],
      "uniqueid": 46
    },
    "47": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232218060695",
      "endTime": "94233073709458",
      "elapsedTime": "855648763",
      "asyncId": 354,
      "triggerAsyncId": 268,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [
        358
      ],
      "uniqueid": 47
    },
    "48": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94232219826607",
      "endTime": "94233073375396",
      "elapsedTime": "853548789",
      "asyncId": 355,
      "triggerAsyncId": 268,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "readFile",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        357
      ],
      "uniqueid": 48
    },
    "49": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232224927326",
      "endTime": "94233074189369",
      "elapsedTime": "849262043",
      "asyncId": 357,
      "triggerAsyncId": 355,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 49
    },
    "50": {
      "source": "test/lib/init/init.js:46:22:46:22",
      "startTime": "94232226519122",
      "endTime": "94233097019933",
      "elapsedTime": "870500811",
      "asyncId": 358,
      "triggerAsyncId": 354,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (Found 'webapp', 'src' and 'test' folders)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-webapp-src-test\")\n\t}), {message:\n\t\"Could not detect project type: Found 'webapp', 'src' and 'test' folders.\\n\" ",
      "startLine": 46,
      "startCol": 22,
      "endLine": 46,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [
        583,
        582,
        587,
        586,
        591,
        590,
        594,
        581
      ],
      "uniqueid": 50
    },
    "51": {
      "source": "node_modules/ava/lib/assert.js:552:51:552:51",
      "startTime": "94232227771553",
      "endTime": "94234011111212",
      "elapsedTime": "1783339659",
      "asyncId": 359,
      "triggerAsyncId": 353,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "handlePromise",
      "userCode": false,
      "line": "\n\t\t\t\tconst savedError = getErrorWithLongStackTrace();\n\t\t\t\t// Handle \"promise like\" objects by casting to a real Promise.\n\t\t\t\tconst intermediate = Promise.resolve(promise).then(value => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion: 'throwsAsync',\n\t\t\t\t\t\tmessage",
      "startLine": 552,
      "startCol": 51,
      "endLine": 552,
      "endCol": 51,
      "file": "node_modules/ava/lib/assert.js",
      "triggers": [
        360,
        362
      ],
      "uniqueid": 51
    },
    "52": {
      "source": "node_modules/ava/lib/test.js:377:5:377:5",
      "startTime": "94232230687109",
      "endTime": "94234013944202",
      "elapsedTime": "1783257093",
      "asyncId": 361,
      "triggerAsyncId": 360,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.addPendingAssertion",
      "userCode": false,
      "line": "\n\t\tpromise\n\t\t\t.catch(error => this.saveFirstError(error))\n\t\t\t.then(() => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\tthis.pendingAssertionCount--;\n\t\t\t\tthis.refreshTimeout();\n\t\t\t})",
      "startLine": 377,
      "startCol": 5,
      "endLine": 377,
      "endCol": 5,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 52
    },
    "53": {
      "source": "node_modules/ava/lib/test.js:622:21:622:21",
      "startTime": "94232234173904",
      "endTime": "94234014734158",
      "elapsedTime": "1780560254",
      "asyncId": 363,
      "triggerAsyncId": 362,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.callFn",
      "userCode": false,
      "line": "\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tretval: this.fn.call(null, this.createExecutionContext())\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn ",
      "startLine": 622,
      "startCol": 21,
      "endLine": 622,
      "endCol": 21,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 53
    },
    "54": {
      "source": "test/lib/init/init.js:55:22:55:22",
      "startTime": "94232253340958",
      "endTime": "94234226706308",
      "elapsedTime": "1973365350",
      "asyncId": 371,
      "triggerAsyncId": 275,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (Found 'webapp' and 'src' folders)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-webapp-src\")\n\t}), {message:\n\t\"Could not detect project type: Found 'webapp' and 'src' folders.\\n\" ",
      "startLine": 55,
      "startCol": 22,
      "endLine": 55,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [
        377
      ],
      "uniqueid": 54
    },
    "55": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232254561652",
      "endTime": "94233097509090",
      "elapsedTime": "842947438",
      "asyncId": 372,
      "triggerAsyncId": 275,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [
        376
      ],
      "uniqueid": 55
    },
    "56": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94232256024179",
      "endTime": "94233097250874",
      "elapsedTime": "841226695",
      "asyncId": 373,
      "triggerAsyncId": 275,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "readFile",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        375
      ],
      "uniqueid": 56
    },
    "57": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232257910923",
      "endTime": "94233097794296",
      "elapsedTime": "839883373",
      "asyncId": 375,
      "triggerAsyncId": 373,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 57
    },
    "58": {
      "source": "test/lib/init/init.js:55:22:55:22",
      "startTime": "94232259934345",
      "endTime": "94233123192798",
      "elapsedTime": "863258453",
      "asyncId": 376,
      "triggerAsyncId": 372,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (Found 'webapp' and 'src' folders)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-webapp-src\")\n\t}), {message:\n\t\"Could not detect project type: Found 'webapp' and 'src' folders.\\n\" ",
      "startLine": 55,
      "startCol": 22,
      "endLine": 55,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [
        602,
        601,
        606,
        605,
        610,
        609,
        613,
        600
      ],
      "uniqueid": 58
    },
    "59": {
      "source": "node_modules/ava/lib/assert.js:552:51:552:51",
      "startTime": "94232262172752",
      "endTime": "94234227248543",
      "elapsedTime": "1965075791",
      "asyncId": 377,
      "triggerAsyncId": 371,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "handlePromise",
      "userCode": false,
      "line": "\n\t\t\t\tconst savedError = getErrorWithLongStackTrace();\n\t\t\t\t// Handle \"promise like\" objects by casting to a real Promise.\n\t\t\t\tconst intermediate = Promise.resolve(promise).then(value => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion: 'throwsAsync',\n\t\t\t\t\t\tmessage",
      "startLine": 552,
      "startCol": 51,
      "endLine": 552,
      "endCol": 51,
      "file": "node_modules/ava/lib/assert.js",
      "triggers": [
        378,
        380
      ],
      "uniqueid": 59
    },
    "60": {
      "source": "node_modules/ava/lib/test.js:377:5:377:5",
      "startTime": "94232265428253",
      "endTime": "94234228055313",
      "elapsedTime": "1962627060",
      "asyncId": 379,
      "triggerAsyncId": 378,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.addPendingAssertion",
      "userCode": false,
      "line": "\n\t\tpromise\n\t\t\t.catch(error => this.saveFirstError(error))\n\t\t\t.then(() => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\tthis.pendingAssertionCount--;\n\t\t\t\tthis.refreshTimeout();\n\t\t\t})",
      "startLine": 377,
      "startCol": 5,
      "endLine": 377,
      "endCol": 5,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 60
    },
    "61": {
      "source": "node_modules/ava/lib/test.js:622:21:622:21",
      "startTime": "94232267610462",
      "endTime": "94234228480477",
      "elapsedTime": "1960870015",
      "asyncId": 381,
      "triggerAsyncId": 380,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.callFn",
      "userCode": false,
      "line": "\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tretval: this.fn.call(null, this.createExecutionContext())\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn ",
      "startLine": 622,
      "startCol": 21,
      "endLine": 622,
      "endCol": 21,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 61
    },
    "62": {
      "source": "test/lib/init/init.js:64:22:64:22",
      "startTime": "94232280232743",
      "endTime": "94234439359177",
      "elapsedTime": "2159126434",
      "asyncId": 389,
      "triggerAsyncId": 282,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (Found 'webapp' and 'test' folders)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-webapp-test\")\n\t}), {message:\n\t\"Could not detect project type: Found 'webapp' and 'test' folders.\\n\" ",
      "startLine": 64,
      "startCol": 22,
      "endLine": 64,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [
        395
      ],
      "uniqueid": 62
    },
    "63": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232281980313",
      "endTime": "94233123706086",
      "elapsedTime": "841725773",
      "asyncId": 390,
      "triggerAsyncId": 282,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [
        394
      ],
      "uniqueid": 63
    },
    "64": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94232283405462",
      "endTime": "94233123484180",
      "elapsedTime": "840078718",
      "asyncId": 391,
      "triggerAsyncId": 282,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "readFile",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        393
      ],
      "uniqueid": 64
    },
    "65": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232285637865",
      "endTime": "94233123945964",
      "elapsedTime": "838308099",
      "asyncId": 393,
      "triggerAsyncId": 391,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 65
    },
    "66": {
      "source": "test/lib/init/init.js:64:22:64:22",
      "startTime": "94232287151570",
      "endTime": "94233143019365",
      "elapsedTime": "855867795",
      "asyncId": 394,
      "triggerAsyncId": 390,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (Found 'webapp' and 'test' folders)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-webapp-test\")\n\t}), {message:\n\t\"Could not detect project type: Found 'webapp' and 'test' folders.\\n\" ",
      "startLine": 64,
      "startCol": 22,
      "endLine": 64,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [
        621,
        620,
        625,
        624,
        629,
        628,
        632,
        619
      ],
      "uniqueid": 66
    },
    "67": {
      "source": "node_modules/ava/lib/assert.js:552:51:552:51",
      "startTime": "94232288640013",
      "endTime": "94234440237086",
      "elapsedTime": "2151597073",
      "asyncId": 395,
      "triggerAsyncId": 389,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "handlePromise",
      "userCode": false,
      "line": "\n\t\t\t\tconst savedError = getErrorWithLongStackTrace();\n\t\t\t\t// Handle \"promise like\" objects by casting to a real Promise.\n\t\t\t\tconst intermediate = Promise.resolve(promise).then(value => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion: 'throwsAsync',\n\t\t\t\t\t\tmessage",
      "startLine": 552,
      "startCol": 51,
      "endLine": 552,
      "endCol": 51,
      "file": "node_modules/ava/lib/assert.js",
      "triggers": [
        396,
        398
      ],
      "uniqueid": 67
    },
    "68": {
      "source": "node_modules/ava/lib/test.js:377:5:377:5",
      "startTime": "94232291917710",
      "endTime": "94234441520573",
      "elapsedTime": "2149602863",
      "asyncId": 397,
      "triggerAsyncId": 396,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.addPendingAssertion",
      "userCode": false,
      "line": "\n\t\tpromise\n\t\t\t.catch(error => this.saveFirstError(error))\n\t\t\t.then(() => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\tthis.pendingAssertionCount--;\n\t\t\t\tthis.refreshTimeout();\n\t\t\t})",
      "startLine": 377,
      "startCol": 5,
      "endLine": 377,
      "endCol": 5,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 68
    },
    "69": {
      "source": "node_modules/ava/lib/test.js:622:21:622:21",
      "startTime": "94232544277172",
      "endTime": "94234442110407",
      "elapsedTime": "1897833235",
      "asyncId": 399,
      "triggerAsyncId": 398,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.callFn",
      "userCode": false,
      "line": "\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tretval: this.fn.call(null, this.createExecutionContext())\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn ",
      "startLine": 622,
      "startCol": 21,
      "endLine": 622,
      "endCol": 21,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 69
    },
    "70": {
      "source": "test/lib/init/init.js:73:22:73:22",
      "startTime": "94232555496248",
      "endTime": "94234681142420",
      "elapsedTime": "2125646172",
      "asyncId": 407,
      "triggerAsyncId": 289,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (Found 'test' folder but no 'src' folder)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-test\")\n\t}), {message:\n\t\"Could not detect project type: Found 'test' folder but no 'src' folder.\\n\" ",
      "startLine": 73,
      "startCol": 22,
      "endLine": 73,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [
        413
      ],
      "uniqueid": 70
    },
    "71": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232556496647",
      "endTime": "94233143595566",
      "elapsedTime": "587098919",
      "asyncId": 408,
      "triggerAsyncId": 289,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [
        412
      ],
      "uniqueid": 71
    },
    "72": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94232557387807",
      "endTime": "94233143366504",
      "elapsedTime": "585978697",
      "asyncId": 409,
      "triggerAsyncId": 289,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "readFile",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        411
      ],
      "uniqueid": 72
    },
    "73": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232558802315",
      "endTime": "94233143802442",
      "elapsedTime": "585000127",
      "asyncId": 411,
      "triggerAsyncId": 409,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 73
    },
    "74": {
      "source": "test/lib/init/init.js:73:22:73:22",
      "startTime": "94232559722967",
      "endTime": "94233164794809",
      "elapsedTime": "605071842",
      "asyncId": 412,
      "triggerAsyncId": 408,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (Found 'test' folder but no 'src' folder)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-test\")\n\t}), {message:\n\t\"Could not detect project type: Found 'test' folder but no 'src' folder.\\n\" ",
      "startLine": 73,
      "startCol": 22,
      "endLine": 73,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [
        640,
        639,
        644,
        643,
        648,
        647,
        651,
        638
      ],
      "uniqueid": 74
    },
    "75": {
      "source": "node_modules/ava/lib/assert.js:552:51:552:51",
      "startTime": "94232560737504",
      "endTime": "94234683373876",
      "elapsedTime": "2122636372",
      "asyncId": 413,
      "triggerAsyncId": 407,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "handlePromise",
      "userCode": false,
      "line": "\n\t\t\t\tconst savedError = getErrorWithLongStackTrace();\n\t\t\t\t// Handle \"promise like\" objects by casting to a real Promise.\n\t\t\t\tconst intermediate = Promise.resolve(promise).then(value => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion: 'throwsAsync',\n\t\t\t\t\t\tmessage",
      "startLine": 552,
      "startCol": 51,
      "endLine": 552,
      "endCol": 51,
      "file": "node_modules/ava/lib/assert.js",
      "triggers": [
        414,
        416
      ],
      "uniqueid": 75
    },
    "76": {
      "source": "node_modules/ava/lib/test.js:377:5:377:5",
      "startTime": "94232563045829",
      "endTime": "94234684502779",
      "elapsedTime": "2121456950",
      "asyncId": 415,
      "triggerAsyncId": 414,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.addPendingAssertion",
      "userCode": false,
      "line": "\n\t\tpromise\n\t\t\t.catch(error => this.saveFirstError(error))\n\t\t\t.then(() => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\tthis.pendingAssertionCount--;\n\t\t\t\tthis.refreshTimeout();\n\t\t\t})",
      "startLine": 377,
      "startCol": 5,
      "endLine": 377,
      "endCol": 5,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 76
    },
    "77": {
      "source": "node_modules/ava/lib/test.js:622:21:622:21",
      "startTime": "94232565716813",
      "endTime": "94234690165746",
      "elapsedTime": "2124448933",
      "asyncId": 417,
      "triggerAsyncId": 416,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.callFn",
      "userCode": false,
      "line": "\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tretval: this.fn.call(null, this.createExecutionContext())\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn ",
      "startLine": 622,
      "startCol": 21,
      "endLine": 622,
      "endCol": 21,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 77
    },
    "78": {
      "source": "test/lib/init/init.js:82:22:82:22",
      "startTime": "94232575680735",
      "endTime": "94235007363190",
      "elapsedTime": "2431682455",
      "asyncId": 425,
      "triggerAsyncId": 296,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (Could not find 'webapp' or 'src' / 'test' folders)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid\")\n\t}), {message:\n\t\"Could not detect project type: Could not find 'webapp' or 'src' / 'test' folders.\\n\" ",
      "startLine": 82,
      "startCol": 22,
      "endLine": 82,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [
        431
      ],
      "uniqueid": 78
    },
    "79": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232576943035",
      "endTime": "94233165636254",
      "elapsedTime": "588693219",
      "asyncId": 426,
      "triggerAsyncId": 296,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [
        430
      ],
      "uniqueid": 79
    },
    "80": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94232578959040",
      "endTime": "94233165276362",
      "elapsedTime": "586317322",
      "asyncId": 427,
      "triggerAsyncId": 296,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "readFile",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        429
      ],
      "uniqueid": 80
    },
    "81": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232580770146",
      "endTime": "94233165917771",
      "elapsedTime": "585147625",
      "asyncId": 429,
      "triggerAsyncId": 427,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 81
    },
    "82": {
      "source": "test/lib/init/init.js:82:22:82:22",
      "startTime": "94232581915132",
      "endTime": "94233361672463",
      "elapsedTime": "779757331",
      "asyncId": 430,
      "triggerAsyncId": 426,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (Could not find 'webapp' or 'src' / 'test' folders)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid\")\n\t}), {message:\n\t\"Could not detect project type: Could not find 'webapp' or 'src' / 'test' folders.\\n\" ",
      "startLine": 82,
      "startCol": 22,
      "endLine": 82,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [
        659,
        658,
        663,
        662,
        667,
        666,
        670,
        657
      ],
      "uniqueid": 82
    },
    "83": {
      "source": "node_modules/ava/lib/assert.js:552:51:552:51",
      "startTime": "94232583692006",
      "endTime": "94235008235961",
      "elapsedTime": "2424543955",
      "asyncId": 431,
      "triggerAsyncId": 425,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "handlePromise",
      "userCode": false,
      "line": "\n\t\t\t\tconst savedError = getErrorWithLongStackTrace();\n\t\t\t\t// Handle \"promise like\" objects by casting to a real Promise.\n\t\t\t\tconst intermediate = Promise.resolve(promise).then(value => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion: 'throwsAsync',\n\t\t\t\t\t\tmessage",
      "startLine": 552,
      "startCol": 51,
      "endLine": 552,
      "endCol": 51,
      "file": "node_modules/ava/lib/assert.js",
      "triggers": [
        432,
        434
      ],
      "uniqueid": 83
    },
    "84": {
      "source": "node_modules/ava/lib/test.js:377:5:377:5",
      "startTime": "94232586146446",
      "endTime": "94235009122996",
      "elapsedTime": "2422976550",
      "asyncId": 433,
      "triggerAsyncId": 432,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.addPendingAssertion",
      "userCode": false,
      "line": "\n\t\tpromise\n\t\t\t.catch(error => this.saveFirstError(error))\n\t\t\t.then(() => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\tthis.pendingAssertionCount--;\n\t\t\t\tthis.refreshTimeout();\n\t\t\t})",
      "startLine": 377,
      "startCol": 5,
      "endLine": 377,
      "endCol": 5,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 84
    },
    "85": {
      "source": "node_modules/ava/lib/test.js:622:21:622:21",
      "startTime": "94232590969522",
      "endTime": "94235010043037",
      "elapsedTime": "2419073515",
      "asyncId": 435,
      "triggerAsyncId": 434,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.callFn",
      "userCode": false,
      "line": "\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tretval: this.fn.call(null, this.createExecutionContext())\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn ",
      "startLine": 622,
      "startCol": 21,
      "endLine": 622,
      "endCol": 21,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 85
    },
    "86": {
      "source": "test/lib/init/init.js:91:22:91:22",
      "startTime": "94232601235694",
      "endTime": "94232644105062",
      "elapsedTime": "42869368",
      "asyncId": 443,
      "triggerAsyncId": 303,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (No package.json)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-no-package-json\")\n\t}), {message: \"Initialization not possible: Missing package.json file\"});\n})",
      "startLine": 91,
      "startCol": 22,
      "endLine": 91,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [
        449
      ],
      "uniqueid": 86
    },
    "87": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232602513617",
      "endTime": "94232643703907",
      "elapsedTime": "41190290",
      "asyncId": 444,
      "triggerAsyncId": 303,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [
        448
      ],
      "uniqueid": 87
    },
    "88": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94232603664647",
      "endTime": "94232643476860",
      "elapsedTime": "39812213",
      "asyncId": 445,
      "triggerAsyncId": 303,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "readFile",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        447
      ],
      "uniqueid": 88
    },
    "89": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232605370620",
      "endTime": "94232643888735",
      "elapsedTime": "38518115",
      "asyncId": 447,
      "triggerAsyncId": 445,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 89
    },
    "90": {
      "source": "test/lib/init/init.js:91:22:91:22",
      "startTime": "94232606359212",
      "endTime": "94232644292474",
      "elapsedTime": "37933262",
      "asyncId": 448,
      "triggerAsyncId": 444,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (No package.json)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-no-package-json\")\n\t}), {message: \"Initialization not possible: Missing package.json file\"});\n})",
      "startLine": 91,
      "startCol": 22,
      "endLine": 91,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [],
      "uniqueid": 90
    },
    "91": {
      "source": "node_modules/ava/lib/assert.js:552:51:552:51",
      "startTime": "94232609067373",
      "endTime": "94232644584567",
      "elapsedTime": "35517194",
      "asyncId": 449,
      "triggerAsyncId": 443,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "handlePromise",
      "userCode": false,
      "line": "\n\t\t\t\tconst savedError = getErrorWithLongStackTrace();\n\t\t\t\t// Handle \"promise like\" objects by casting to a real Promise.\n\t\t\t\tconst intermediate = Promise.resolve(promise).then(value => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion: 'throwsAsync',\n\t\t\t\t\t\tmessage",
      "startLine": 552,
      "startCol": 51,
      "endLine": 552,
      "endCol": 51,
      "file": "node_modules/ava/lib/assert.js",
      "triggers": [
        450,
        452
      ],
      "uniqueid": 91
    },
    "92": {
      "source": "node_modules/ava/lib/test.js:377:5:377:5",
      "startTime": "94232611486590",
      "endTime": "94232645385116",
      "elapsedTime": "33898526",
      "asyncId": 451,
      "triggerAsyncId": 450,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.addPendingAssertion",
      "userCode": false,
      "line": "\n\t\tpromise\n\t\t\t.catch(error => this.saveFirstError(error))\n\t\t\t.then(() => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\tthis.pendingAssertionCount--;\n\t\t\t\tthis.refreshTimeout();\n\t\t\t})",
      "startLine": 377,
      "startCol": 5,
      "endLine": 377,
      "endCol": 5,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 92
    },
    "93": {
      "source": "node_modules/ava/lib/test.js:622:21:622:21",
      "startTime": "94232614188849",
      "endTime": "94232645742995",
      "elapsedTime": "31554146",
      "asyncId": 453,
      "triggerAsyncId": 452,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.callFn",
      "userCode": false,
      "line": "\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tretval: this.fn.call(null, this.createExecutionContext())\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn ",
      "startLine": 622,
      "startCol": 21,
      "endLine": 622,
      "endCol": 21,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 93
    },
    "94": {
      "source": "test/lib/init/init.js:97:22:97:22",
      "startTime": "94232623711140",
      "endTime": "94233362997585",
      "elapsedTime": "739286445",
      "asyncId": 461,
      "triggerAsyncId": 310,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (Missing 'name' in package.json)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-missing-package-name\")\n\t}), {message: \"Initialization not possible: Missing 'name' in package.json\"});\n})",
      "startLine": 97,
      "startCol": 22,
      "endLine": 97,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [
        467
      ],
      "uniqueid": 94
    },
    "95": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232624556539",
      "endTime": "94233362186423",
      "elapsedTime": "737629884",
      "asyncId": 462,
      "triggerAsyncId": 310,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [
        466
      ],
      "uniqueid": 95
    },
    "96": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94232625846088",
      "endTime": "94233361947759",
      "elapsedTime": "736101671",
      "asyncId": 463,
      "triggerAsyncId": 310,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "readFile",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        465
      ],
      "uniqueid": 96
    },
    "97": {
      "source": "lib/init/init.js:75:15:75:15",
      "startTime": "94232627345981",
      "endTime": "94233362693081",
      "elapsedTime": "735347100",
      "asyncId": 465,
      "triggerAsyncId": 463,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\")",
      "startLine": 75,
      "startCol": 15,
      "endLine": 75,
      "endCol": 15,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 97
    },
    "98": {
      "source": "test/lib/init/init.js:97:22:97:22",
      "startTime": "94232628364363",
      "endTime": "94233363209416",
      "elapsedTime": "734845053",
      "asyncId": 466,
      "triggerAsyncId": 462,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for invalid project (Missing 'name' in package.json)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-missing-package-name\")\n\t}), {message: \"Initialization not possible: Missing 'name' in package.json\"});\n})",
      "startLine": 97,
      "startCol": 22,
      "endLine": 97,
      "endCol": 22,
      "file": "test/lib/init/init.js",
      "triggers": [],
      "uniqueid": 98
    },
    "99": {
      "source": "node_modules/ava/lib/assert.js:552:51:552:51",
      "startTime": "94232629575778",
      "endTime": "94233363681367",
      "elapsedTime": "734105589",
      "asyncId": 467,
      "triggerAsyncId": 461,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "handlePromise",
      "userCode": false,
      "line": "\n\t\t\t\tconst savedError = getErrorWithLongStackTrace();\n\t\t\t\t// Handle \"promise like\" objects by casting to a real Promise.\n\t\t\t\tconst intermediate = Promise.resolve(promise).then(value => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion: 'throwsAsync',\n\t\t\t\t\t\tmessage",
      "startLine": 552,
      "startCol": 51,
      "endLine": 552,
      "endCol": 51,
      "file": "node_modules/ava/lib/assert.js",
      "triggers": [
        468,
        470
      ],
      "uniqueid": 99
    },
    "100": {
      "source": "node_modules/ava/lib/test.js:377:5:377:5",
      "startTime": "94232631839065",
      "endTime": "94233364394260",
      "elapsedTime": "732555195",
      "asyncId": 469,
      "triggerAsyncId": 468,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.addPendingAssertion",
      "userCode": false,
      "line": "\n\t\tpromise\n\t\t\t.catch(error => this.saveFirstError(error))\n\t\t\t.then(() => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\tthis.pendingAssertionCount--;\n\t\t\t\tthis.refreshTimeout();\n\t\t\t})",
      "startLine": 377,
      "startCol": 5,
      "endLine": 377,
      "endCol": 5,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 100
    },
    "101": {
      "source": "node_modules/ava/lib/test.js:622:21:622:21",
      "startTime": "94232633724245",
      "endTime": "94233365881700",
      "elapsedTime": "732157455",
      "asyncId": 471,
      "triggerAsyncId": 470,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Test.callFn",
      "userCode": false,
      "line": "\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tretval: this.fn.call(null, this.createExecutionContext())\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn ",
      "startLine": 622,
      "startCol": 21,
      "endLine": 622,
      "endCol": 21,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 101
    },
    "102": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94232903484289",
      "endTime": "94233550566282",
      "elapsedTime": "647081993",
      "asyncId": 543,
      "triggerAsyncId": 330,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [
        561
      ],
      "uniqueid": 102
    },
    "103": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94232905702660",
      "endTime": "94233547351031",
      "elapsedTime": "641648371",
      "asyncId": 544,
      "triggerAsyncId": 330,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        557
      ],
      "uniqueid": 103
    },
    "104": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94232908199285",
      "endTime": "94233547146561",
      "elapsedTime": "638947276",
      "asyncId": 545,
      "triggerAsyncId": 330,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        547
      ],
      "uniqueid": 104
    },
    "105": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94232910502261",
      "endTime": "94233547531315",
      "elapsedTime": "637029054",
      "asyncId": 547,
      "triggerAsyncId": 545,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 105
    },
    "106": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94232913004728",
      "endTime": "94233548201098",
      "elapsedTime": "635196370",
      "asyncId": 548,
      "triggerAsyncId": 330,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        558
      ],
      "uniqueid": 106
    },
    "107": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94232914373025",
      "endTime": "94233547931909",
      "elapsedTime": "633558884",
      "asyncId": 549,
      "triggerAsyncId": 330,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        551
      ],
      "uniqueid": 107
    },
    "108": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94232916105758",
      "endTime": "94233548402959",
      "elapsedTime": "632297201",
      "asyncId": 551,
      "triggerAsyncId": 549,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 108
    },
    "109": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94232986395480",
      "endTime": "94233549262677",
      "elapsedTime": "562867197",
      "asyncId": 552,
      "triggerAsyncId": 330,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        559
      ],
      "uniqueid": 109
    },
    "110": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233021583607",
      "endTime": "94233548898871",
      "elapsedTime": "527315264",
      "asyncId": 553,
      "triggerAsyncId": 330,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        555
      ],
      "uniqueid": 110
    },
    "111": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233043353061",
      "endTime": "94233549719259",
      "elapsedTime": "506366198",
      "asyncId": 555,
      "triggerAsyncId": 553,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 111
    },
    "112": {
      "source": "lib/utils/fsHelper.js:36:23:36:23",
      "startTime": "94233044616518",
      "endTime": "94233549971800",
      "elapsedTime": "505355282",
      "asyncId": 556,
      "triggerAsyncId": 330,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Object.pathsExist",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 23,
      "endLine": 36,
      "endCol": 23,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        560
      ],
      "uniqueid": 112
    },
    "113": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94233049042925",
      "endTime": "94233550763555",
      "elapsedTime": "501720630",
      "asyncId": 560,
      "triggerAsyncId": 556,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 113
    },
    "114": {
      "source": "test/lib/init/init.js:18:24:18:24",
      "startTime": "94233050332666",
      "endTime": "94233551285327",
      "elapsedTime": "500952661",
      "asyncId": 561,
      "triggerAsyncId": 543,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for application\", async (t) => {\n\tconst projectConfig = await init({\n\t\tcwd: getFixturePath(\"application\")\n\t});",
      "startLine": 18,
      "startCol": 24,
      "endLine": 18,
      "endCol": 24,
      "file": "test/lib/init/init.js",
      "triggers": [],
      "uniqueid": 114
    },
    "115": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94233052434511",
      "endTime": "94233773966077",
      "elapsedTime": "721531566",
      "asyncId": 562,
      "triggerAsyncId": 344,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [
        580
      ],
      "uniqueid": 115
    },
    "116": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233053797302",
      "endTime": "94233738921748",
      "elapsedTime": "685124446",
      "asyncId": 563,
      "triggerAsyncId": 344,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        576
      ],
      "uniqueid": 116
    },
    "117": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233055065139",
      "endTime": "94233731929819",
      "elapsedTime": "676864680",
      "asyncId": 564,
      "triggerAsyncId": 344,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        566
      ],
      "uniqueid": 117
    },
    "118": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233056344115",
      "endTime": "94233741947943",
      "elapsedTime": "685603828",
      "asyncId": 566,
      "triggerAsyncId": 564,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 118
    },
    "119": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233057785125",
      "endTime": "94233757470070",
      "elapsedTime": "699684945",
      "asyncId": 567,
      "triggerAsyncId": 344,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        577
      ],
      "uniqueid": 119
    },
    "120": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233058788440",
      "endTime": "94233747086463",
      "elapsedTime": "688298023",
      "asyncId": 568,
      "triggerAsyncId": 344,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        570
      ],
      "uniqueid": 120
    },
    "121": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233060287716",
      "endTime": "94233762135629",
      "elapsedTime": "701847913",
      "asyncId": 570,
      "triggerAsyncId": 568,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 121
    },
    "122": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233061306889",
      "endTime": "94233764450911",
      "elapsedTime": "703144022",
      "asyncId": 571,
      "triggerAsyncId": 344,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        578
      ],
      "uniqueid": 122
    },
    "123": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233062398168",
      "endTime": "94233763275341",
      "elapsedTime": "700877173",
      "asyncId": 572,
      "triggerAsyncId": 344,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        574
      ],
      "uniqueid": 123
    },
    "124": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233064292717",
      "endTime": "94233768161917",
      "elapsedTime": "703869200",
      "asyncId": 574,
      "triggerAsyncId": 572,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 124
    },
    "125": {
      "source": "lib/utils/fsHelper.js:36:23:36:23",
      "startTime": "94233065692724",
      "endTime": "94233770554111",
      "elapsedTime": "704861387",
      "asyncId": 575,
      "triggerAsyncId": 344,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Object.pathsExist",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 23,
      "endLine": 36,
      "endCol": 23,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        579
      ],
      "uniqueid": 125
    },
    "126": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94233071505643",
      "endTime": "94233777529321",
      "elapsedTime": "706023678",
      "asyncId": 579,
      "triggerAsyncId": 575,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "init",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 126
    },
    "127": {
      "source": "test/lib/init/init.js:32:24:32:24",
      "startTime": "94233072515803",
      "endTime": "94233780188334",
      "elapsedTime": "707672531",
      "asyncId": 580,
      "triggerAsyncId": 562,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\ntest(\"Init for library\", async (t) => {\n\tconst projectConfig = await init({\n\t\tcwd: getFixturePath(\"library\")\n\t});",
      "startLine": 32,
      "startCol": 24,
      "endLine": 32,
      "endCol": 24,
      "file": "test/lib/init/init.js",
      "triggers": [],
      "uniqueid": 127
    },
    "128": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94233075244407",
      "endTime": "94234007111578",
      "elapsedTime": "931867171",
      "asyncId": 581,
      "triggerAsyncId": 358,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 128
    },
    "129": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233076308176",
      "endTime": "94233999616606",
      "elapsedTime": "923308430",
      "asyncId": 582,
      "triggerAsyncId": 358,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        595
      ],
      "uniqueid": 129
    },
    "130": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233077769267",
      "endTime": "94233998957723",
      "elapsedTime": "921188456",
      "asyncId": 583,
      "triggerAsyncId": 358,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        585
      ],
      "uniqueid": 130
    },
    "131": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233079653180",
      "endTime": "94233999954986",
      "elapsedTime": "920301806",
      "asyncId": 585,
      "triggerAsyncId": 583,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 131
    },
    "132": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233080577543",
      "endTime": "94234003685105",
      "elapsedTime": "923107562",
      "asyncId": 586,
      "triggerAsyncId": 358,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        596
      ],
      "uniqueid": 132
    },
    "133": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233082221650",
      "endTime": "94234003039706",
      "elapsedTime": "920818056",
      "asyncId": 587,
      "triggerAsyncId": 358,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        589
      ],
      "uniqueid": 133
    },
    "134": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233083437647",
      "endTime": "94234003940135",
      "elapsedTime": "920502488",
      "asyncId": 589,
      "triggerAsyncId": 587,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 134
    },
    "135": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233086485313",
      "endTime": "94234005236627",
      "elapsedTime": "918751314",
      "asyncId": 590,
      "triggerAsyncId": 358,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        597
      ],
      "uniqueid": 135
    },
    "136": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233087447269",
      "endTime": "94234004888871",
      "elapsedTime": "917441602",
      "asyncId": 591,
      "triggerAsyncId": 358,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        593
      ],
      "uniqueid": 136
    },
    "137": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233088818945",
      "endTime": "94234005813094",
      "elapsedTime": "916994149",
      "asyncId": 593,
      "triggerAsyncId": 591,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 137
    },
    "138": {
      "source": "lib/utils/fsHelper.js:36:23:36:23",
      "startTime": "94233089612557",
      "endTime": "94234006294303",
      "elapsedTime": "916681746",
      "asyncId": 594,
      "triggerAsyncId": 358,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Object.pathsExist",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 23,
      "endLine": 36,
      "endCol": 23,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        598
      ],
      "uniqueid": 138
    },
    "139": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94233095748173",
      "endTime": "94234007527932",
      "elapsedTime": "911779759",
      "asyncId": 598,
      "triggerAsyncId": 594,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 139
    },
    "140": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94233098813430",
      "endTime": "94234226087178",
      "elapsedTime": "1127273748",
      "asyncId": 600,
      "triggerAsyncId": 376,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 140
    },
    "141": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233099978747",
      "endTime": "94234222696185",
      "elapsedTime": "1122717438",
      "asyncId": 601,
      "triggerAsyncId": 376,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        614
      ],
      "uniqueid": 141
    },
    "142": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233100816040",
      "endTime": "94234222377440",
      "elapsedTime": "1121561400",
      "asyncId": 602,
      "triggerAsyncId": 376,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        604
      ],
      "uniqueid": 142
    },
    "143": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233102152942",
      "endTime": "94234223110159",
      "elapsedTime": "1120957217",
      "asyncId": 604,
      "triggerAsyncId": 602,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 143
    },
    "144": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233106287842",
      "endTime": "94234224341043",
      "elapsedTime": "1118053201",
      "asyncId": 605,
      "triggerAsyncId": 376,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        615
      ],
      "uniqueid": 144
    },
    "145": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233108099906",
      "endTime": "94234224007994",
      "elapsedTime": "1115908088",
      "asyncId": 606,
      "triggerAsyncId": 376,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        608
      ],
      "uniqueid": 145
    },
    "146": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233109461185",
      "endTime": "94234224633353",
      "elapsedTime": "1115172168",
      "asyncId": 608,
      "triggerAsyncId": 606,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 146
    },
    "147": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233112676576",
      "endTime": "94234225300213",
      "elapsedTime": "1112623637",
      "asyncId": 609,
      "triggerAsyncId": 376,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        616
      ],
      "uniqueid": 147
    },
    "148": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233114056290",
      "endTime": "94234225050789",
      "elapsedTime": "1110994499",
      "asyncId": 610,
      "triggerAsyncId": 376,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        612
      ],
      "uniqueid": 148
    },
    "149": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233116571166",
      "endTime": "94234225512646",
      "elapsedTime": "1108941480",
      "asyncId": 612,
      "triggerAsyncId": 610,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 149
    },
    "150": {
      "source": "lib/utils/fsHelper.js:36:23:36:23",
      "startTime": "94233117915055",
      "endTime": "94234225684740",
      "elapsedTime": "1107769685",
      "asyncId": 613,
      "triggerAsyncId": 376,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Object.pathsExist",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 23,
      "endLine": 36,
      "endCol": 23,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        617
      ],
      "uniqueid": 150
    },
    "151": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94233121929072",
      "endTime": "94234226449860",
      "elapsedTime": "1104520788",
      "asyncId": 617,
      "triggerAsyncId": 613,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 151
    },
    "152": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94233124607360",
      "endTime": "94234438811255",
      "elapsedTime": "1314203895",
      "asyncId": 619,
      "triggerAsyncId": 394,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 152
    },
    "153": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233125502078",
      "endTime": "94234428719808",
      "elapsedTime": "1303217730",
      "asyncId": 620,
      "triggerAsyncId": 394,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        633
      ],
      "uniqueid": 153
    },
    "154": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233127358068",
      "endTime": "94234428178071",
      "elapsedTime": "1300820003",
      "asyncId": 621,
      "triggerAsyncId": 394,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        623
      ],
      "uniqueid": 154
    },
    "155": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233128657544",
      "endTime": "94234428931658",
      "elapsedTime": "1300274114",
      "asyncId": 623,
      "triggerAsyncId": 621,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 155
    },
    "156": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233129488353",
      "endTime": "94234430751718",
      "elapsedTime": "1301263365",
      "asyncId": 624,
      "triggerAsyncId": 394,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        634
      ],
      "uniqueid": 156
    },
    "157": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233130805459",
      "endTime": "94234429767859",
      "elapsedTime": "1298962400",
      "asyncId": 625,
      "triggerAsyncId": 394,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        627
      ],
      "uniqueid": 157
    },
    "158": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233132189554",
      "endTime": "94234433922171",
      "elapsedTime": "1301732617",
      "asyncId": 627,
      "triggerAsyncId": 625,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 158
    },
    "159": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233133067612",
      "endTime": "94234437167340",
      "elapsedTime": "1304099728",
      "asyncId": 628,
      "triggerAsyncId": 394,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        635
      ],
      "uniqueid": 159
    },
    "160": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233134393414",
      "endTime": "94234436940015",
      "elapsedTime": "1302546601",
      "asyncId": 629,
      "triggerAsyncId": 394,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        631
      ],
      "uniqueid": 160
    },
    "161": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233136428011",
      "endTime": "94234437406661",
      "elapsedTime": "1300978650",
      "asyncId": 631,
      "triggerAsyncId": 629,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 161
    },
    "162": {
      "source": "lib/utils/fsHelper.js:36:23:36:23",
      "startTime": "94233137929566",
      "endTime": "94234437733384",
      "elapsedTime": "1299803818",
      "asyncId": 632,
      "triggerAsyncId": 394,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Object.pathsExist",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 23,
      "endLine": 36,
      "endCol": 23,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        636
      ],
      "uniqueid": 162
    },
    "163": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94233141654994",
      "endTime": "94234439107929",
      "elapsedTime": "1297452935",
      "asyncId": 636,
      "triggerAsyncId": 632,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 163
    },
    "164": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94233144749849",
      "endTime": "94234679678934",
      "elapsedTime": "1534929085",
      "asyncId": 638,
      "triggerAsyncId": 412,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 164
    },
    "165": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233146031947",
      "endTime": "94234542376287",
      "elapsedTime": "1396344340",
      "asyncId": 639,
      "triggerAsyncId": 412,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        652
      ],
      "uniqueid": 165
    },
    "166": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233147163231",
      "endTime": "94234542120018",
      "elapsedTime": "1394956787",
      "asyncId": 640,
      "triggerAsyncId": 412,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        642
      ],
      "uniqueid": 166
    },
    "167": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233149037920",
      "endTime": "94234561457681",
      "elapsedTime": "1412419761",
      "asyncId": 642,
      "triggerAsyncId": 640,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 167
    },
    "168": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233150025455",
      "endTime": "94234672016292",
      "elapsedTime": "1521990837",
      "asyncId": 643,
      "triggerAsyncId": 412,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        653
      ],
      "uniqueid": 168
    },
    "169": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233151153953",
      "endTime": "94234670017303",
      "elapsedTime": "1518863350",
      "asyncId": 644,
      "triggerAsyncId": 412,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        646
      ],
      "uniqueid": 169
    },
    "170": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233152899922",
      "endTime": "94234672372299",
      "elapsedTime": "1519472377",
      "asyncId": 646,
      "triggerAsyncId": 644,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 170
    },
    "171": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233154588554",
      "endTime": "94234674606375",
      "elapsedTime": "1520017821",
      "asyncId": 647,
      "triggerAsyncId": 412,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        654
      ],
      "uniqueid": 171
    },
    "172": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233156169545",
      "endTime": "94234673368762",
      "elapsedTime": "1517199217",
      "asyncId": 648,
      "triggerAsyncId": 412,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        650
      ],
      "uniqueid": 172
    },
    "173": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233157673663",
      "endTime": "94234675261711",
      "elapsedTime": "1517588048",
      "asyncId": 650,
      "triggerAsyncId": 648,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 173
    },
    "174": {
      "source": "lib/utils/fsHelper.js:36:23:36:23",
      "startTime": "94233158906274",
      "endTime": "94234677074241",
      "elapsedTime": "1518167967",
      "asyncId": 651,
      "triggerAsyncId": 412,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Object.pathsExist",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 23,
      "endLine": 36,
      "endCol": 23,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        655
      ],
      "uniqueid": 174
    },
    "175": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94233163593639",
      "endTime": "94234679933090",
      "elapsedTime": "1516339451",
      "asyncId": 655,
      "triggerAsyncId": 651,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 175
    },
    "176": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94233166605959",
      "endTime": "94235006790597",
      "elapsedTime": "1840184638",
      "asyncId": 657,
      "triggerAsyncId": 430,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 176
    },
    "177": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233167558625",
      "endTime": "94234997625744",
      "elapsedTime": "1830067119",
      "asyncId": 658,
      "triggerAsyncId": 430,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        671
      ],
      "uniqueid": 177
    },
    "178": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233254570002",
      "endTime": "94234997165963",
      "elapsedTime": "1742595961",
      "asyncId": 659,
      "triggerAsyncId": 430,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        661
      ],
      "uniqueid": 178
    },
    "179": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233293265675",
      "endTime": "94234998636560",
      "elapsedTime": "1705370885",
      "asyncId": 661,
      "triggerAsyncId": 659,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 179
    },
    "180": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233333399830",
      "endTime": "94235001117228",
      "elapsedTime": "1667717398",
      "asyncId": 662,
      "triggerAsyncId": 430,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        672
      ],
      "uniqueid": 180
    },
    "181": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233341912809",
      "endTime": "94235000870786",
      "elapsedTime": "1658957977",
      "asyncId": 663,
      "triggerAsyncId": 430,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        665
      ],
      "uniqueid": 181
    },
    "182": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233345314190",
      "endTime": "94235001795582",
      "elapsedTime": "1656481392",
      "asyncId": 665,
      "triggerAsyncId": 663,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 182
    },
    "183": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233348738598",
      "endTime": "94235005589426",
      "elapsedTime": "1656850828",
      "asyncId": 666,
      "triggerAsyncId": 430,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        673
      ],
      "uniqueid": 183
    },
    "184": {
      "source": "(/internal/util:311:12:311:12)",
      "startTime": "94233351378796",
      "endTime": "94235005023098",
      "elapsedTime": "1653644302",
      "asyncId": 667,
      "triggerAsyncId": 430,
      "io": true,
      "createdIn": 1625068862120,
      "functionName": "stat",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        669
      ],
      "uniqueid": 184
    },
    "185": {
      "source": "lib/utils/fsHelper.js:36:44:36:44",
      "startTime": "94233353651224",
      "endTime": "94235005871643",
      "elapsedTime": "1652220419",
      "asyncId": 669,
      "triggerAsyncId": 667,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 44,
      "endLine": 36,
      "endCol": 44,
      "file": "lib/utils/fsHelper.js",
      "triggers": [],
      "uniqueid": 185
    },
    "186": {
      "source": "lib/utils/fsHelper.js:36:23:36:23",
      "startTime": "94233355548945",
      "endTime": "94235006066837",
      "elapsedTime": "1650517892",
      "asyncId": 670,
      "triggerAsyncId": 430,
      "io": false,
      "createdIn": 1625068862120,
      "functionName": "Object.pathsExist",
      "userCode": false,
      "line": "\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = ",
      "startLine": 36,
      "startCol": 23,
      "endLine": 36,
      "endCol": 23,
      "file": "lib/utils/fsHelper.js",
      "triggers": [
        674
      ],
      "uniqueid": 186
    },
    "187": {
      "source": "lib/init/init.js:90:54:90:54",
      "startTime": "94233360498023",
      "endTime": "94235007087559",
      "elapsedTime": "1646589536",
      "asyncId": 674,
      "triggerAsyncId": 670,
      "io": "",
      "createdIn": 1625068862120,
      "functionName": "",
      "userCode": false,
      "line": "\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig",
      "startLine": 90,
      "startCol": 54,
      "endLine": 90,
      "endCol": 54,
      "file": "lib/init/init.js",
      "triggers": [],
      "uniqueid": 187
    }
  },
  "antipatterns": {
    "0": {
      "patternID": "pattern1",
      "file": "lib/framework/use.js",
      "startLine": "3",
      "startCol": "1",
      "endLine": "5",
      "endCol": "1"
    },
    "1": {
      "patternID": "pattern1",
      "file": "lib/utils/fsHelper.js",
      "startLine": "35",
      "startCol": "1",
      "endLine": "37",
      "endCol": "1"
    }
  },
  "files": {
    "lib/init/init.js": "const {promisify} = require(\"util\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst readFile = promisify(fs.readFile);\nconst fsHelper = require(\"../utils/fsHelper\");\n\n/**\n * Reads the package.json file and returns its content\n *\n * @private\n * @param {string} filePath Path to package.json\n * @returns {object} Package json content\n */\nasync function readPackageJson(filePath) {\n\tconst content = await readFile(filePath, \"utf8\");\n\treturn JSON.parse(content);\n}\n\n/**\n * Determines the project type from the provided parameters\n *\n * @private\n * @param {boolean} hasWebapp Webapp folder exists\n * @param {boolean} hasSrc Src folder exists\n * @param {boolean} hasTest Test folder exists\n * @returns {string} Project type\n */\nfunction getProjectType(hasWebapp, hasSrc, hasTest) {\n\tlet errorReason;\n\tif (hasWebapp) {\n\t\t// Mixed folders of application and library\n\t\tif (hasSrc && hasTest) {\n\t\t\terrorReason = \"Found 'webapp', 'src' and 'test' folders.\\n\";\n\t\t} else if (hasSrc) {\n\t\t\terrorReason = \"Found 'webapp' and 'src' folders.\\n\";\n\t\t} else if (hasTest) {\n\t\t\terrorReason = \"Found 'webapp' and 'test' folders.\\n\";\n\t\t} else {\n\t\t\treturn \"application\";\n\t\t}\n\t} else if (hasSrc) {\n\t\treturn \"library\";\n\t} else if (hasTest) {\n\t\t// Only test folder\n\t\terrorReason = \"Found 'test' folder but no 'src' folder.\\n\";\n\t} else {\n\t\t// No folders at all\n\t\terrorReason = \"Could not find 'webapp' or 'src' / 'test' folders.\\n\";\n\t}\n\n\tlet message = `Could not detect project type: ${errorReason}`;\n\tmessage += \"Applications should only have a 'webapp' folder.\\n\";\n\tmessage += \"Libraries should only have a 'src' and (optional) 'test' folder.\";\n\tthrow new Error(message);\n}\n\n/**\n * Initiates the projects <b>ui5.yaml</b> configuration file.\n *\n * Checks the package.json and tries to determine the project type. If the <b>ui5.yaml</b> file does not exist,\n * it is created with the basic project configuration.\n *\n * @module @ui5/cli/init\n * @param {string} cwd Current working directory\n * @returns {Promise} Promise resolving with the project configuration object\n */\nasync function init({cwd = \"./\"} = {}) {\n\tconst projectConfig = {\n\t\tspecVersion: \"2.4\",\n\t\tmetadata: {}\n\t};\n\tlet pkg;\n\n\ttry {\n\t\tpkg = await readPackageJson(path.join(cwd, \"package.json\"));\n\t} catch (err) {\n\t\tif (err.code === \"ENOENT\") {\n\t\t\tthrow new Error(\"Initialization not possible: Missing package.json file\");\n\t\t} else {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tif (pkg && pkg.name) {\n\t\tprojectConfig.metadata.name = pkg.name;\n\t} else {\n\t\tthrow new Error(\"Initialization not possible: Missing 'name' in package.json\");\n\t}\n\n\tconst [hasWebapp, hasSrc, hasTest] = await fsHelper.pathsExist([\"webapp\", \"src\", \"test\"], cwd);\n\tprojectConfig.type = getProjectType(hasWebapp, hasSrc, hasTest);\n\n\treturn projectConfig;\n}\n\nmodule.exports = {\n\tinit: init\n};\n",
    "node_modules/ava/lib/runner.js": "'use strict';\nconst Emittery = require('emittery');\nconst matcher = require('matcher');\nconst ContextRef = require('./context-ref');\nconst createChain = require('./create-chain');\nconst parseTestArgs = require('./parse-test-args');\nconst snapshotManager = require('./snapshot-manager');\nconst serializeError = require('./serialize-error');\nconst Runnable = require('./test');\n\nclass Runner extends Emittery {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tthis.experiments = options.experiments || {};\n\t\tthis.failFast = options.failFast === true;\n\t\tthis.failWithoutAssertions = options.failWithoutAssertions !== false;\n\t\tthis.file = options.file;\n\t\tthis.checkSelectedByLineNumbers = options.checkSelectedByLineNumbers;\n\t\tthis.match = options.match || [];\n\t\tthis.powerAssert = undefined; // Assigned later.\n\t\tthis.projectDir = options.projectDir;\n\t\tthis.recordNewSnapshots = options.recordNewSnapshots === true;\n\t\tthis.runOnlyExclusive = options.runOnlyExclusive === true;\n\t\tthis.serial = options.serial === true;\n\t\tthis.skippingTests = false;\n\t\tthis.snapshotDir = options.snapshotDir;\n\t\tthis.updateSnapshots = options.updateSnapshots;\n\n\t\tthis.activeRunnables = new Set();\n\t\tthis.boundCompareTestSnapshot = this.compareTestSnapshot.bind(this);\n\t\tthis.skippedSnapshots = false;\n\t\tthis.boundSkipSnapshot = this.skipSnapshot.bind(this);\n\t\tthis.interrupted = false;\n\t\tthis.snapshots = null;\n\t\tthis.nextTaskIndex = 0;\n\t\tthis.tasks = {\n\t\t\tafter: [],\n\t\t\tafterAlways: [],\n\t\t\tafterEach: [],\n\t\t\tafterEachAlways: [],\n\t\t\tbefore: [],\n\t\t\tbeforeEach: [],\n\t\t\tconcurrent: [],\n\t\t\tserial: [],\n\t\t\ttodo: []\n\t\t};\n\t\tthis.waitForReady = [];\n\n\t\tconst uniqueTestTitles = new Set();\n\t\tthis.registerUniqueTitle = title => {\n\t\t\tif (uniqueTestTitles.has(title)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tuniqueTestTitles.add(title);\n\t\t\treturn true;\n\t\t};\n\n\t\tlet hasStarted = false;\n\t\tlet scheduledStart = false;\n\t\tconst meta = Object.freeze({\n\t\t\tfile: options.file,\n\t\t\tget snapshotDirectory() {\n\t\t\t\tconst {file, snapshotDir: fixedLocation, projectDir} = options;\n\t\t\t\treturn snapshotManager.determineSnapshotDir({file, fixedLocation, projectDir});\n\t\t\t}\n\t\t});\n\t\tthis.chain = createChain((metadata, testArgs) => { // eslint-disable-line complexity\n\t\t\tif (hasStarted) {\n\t\t\t\tthrow new Error('All tests and hooks must be declared synchronously in your test file, and cannot be nested within other tests or hooks.');\n\t\t\t}\n\n\t\t\tif (!scheduledStart) {\n\t\t\t\tscheduledStart = true;\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\thasStarted = true;\n\t\t\t\t\tthis.start();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tmetadata.taskIndex = this.nextTaskIndex++;\n\n\t\t\tconst {args, buildTitle, implementations, rawTitle} = parseTestArgs(testArgs);\n\n\t\t\tif (this.checkSelectedByLineNumbers) {\n\t\t\t\tmetadata.selected = this.checkSelectedByLineNumbers();\n\t\t\t}\n\n\t\t\tif (metadata.todo) {\n\t\t\t\tif (implementations.length > 0) {\n\t\t\t\t\tthrow new TypeError('`todo` tests are not allowed to have an implementation. Use `test.skip()` for tests with an implementation.');\n\t\t\t\t}\n\n\t\t\t\tif (!rawTitle) { // Either undefined or a string.\n\t\t\t\t\tthrow new TypeError('`todo` tests require a title');\n\t\t\t\t}\n\n\t\t\t\tif (!this.registerUniqueTitle(rawTitle)) {\n\t\t\t\t\tthrow new Error(`Duplicate test title: ${rawTitle}`);\n\t\t\t\t}\n\n\t\t\t\tif (this.match.length > 0) {\n\t\t\t\t\t// --match selects TODO tests.\n\t\t\t\t\tif (matcher([rawTitle], this.match).length === 1) {\n\t\t\t\t\t\tmetadata.exclusive = true;\n\t\t\t\t\t\tthis.runOnlyExclusive = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.tasks.todo.push({title: rawTitle, metadata});\n\t\t\t\tthis.emit('stateChange', {\n\t\t\t\t\ttype: 'declared-test',\n\t\t\t\t\ttitle: rawTitle,\n\t\t\t\t\tknownFailing: false,\n\t\t\t\t\ttodo: true\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (implementations.length === 0) {\n\t\t\t\t\tthrow new TypeError('Expected an implementation. Use `test.todo()` for tests without an implementation.');\n\t\t\t\t}\n\n\t\t\t\tfor (const implementation of implementations) {\n\t\t\t\t\tlet {title, isSet, isValid, isEmpty} = buildTitle(implementation);\n\n\t\t\t\t\tif (isSet && !isValid) {\n\t\t\t\t\t\tthrow new TypeError('Test & hook titles must be strings');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isEmpty) {\n\t\t\t\t\t\tif (metadata.type === 'test') {\n\t\t\t\t\t\t\tthrow new TypeError('Tests must have a title');\n\t\t\t\t\t\t} else if (metadata.always) {\n\t\t\t\t\t\t\ttitle = `${metadata.type}.always hook`;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttitle = `${metadata.type} hook`;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (metadata.type === 'test' && !this.registerUniqueTitle(title)) {\n\t\t\t\t\t\tthrow new Error(`Duplicate test title: ${title}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst task = {\n\t\t\t\t\t\ttitle,\n\t\t\t\t\t\timplementation,\n\t\t\t\t\t\targs,\n\t\t\t\t\t\tmetadata: {...metadata}\n\t\t\t\t\t};\n\n\t\t\t\t\tif (metadata.type === 'test') {\n\t\t\t\t\t\tif (this.match.length > 0) {\n\t\t\t\t\t\t\t// --match overrides .only()\n\t\t\t\t\t\t\ttask.metadata.exclusive = matcher([title], this.match).length === 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (task.metadata.skipped) {\n\t\t\t\t\t\t\tthis.skippingTests = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (task.metadata.exclusive) {\n\t\t\t\t\t\t\tthis.runOnlyExclusive = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.tasks[metadata.serial ? 'serial' : 'concurrent'].push(task);\n\t\t\t\t\t\tthis.emit('stateChange', {\n\t\t\t\t\t\t\ttype: 'declared-test',\n\t\t\t\t\t\t\ttitle,\n\t\t\t\t\t\t\tknownFailing: metadata.failing,\n\t\t\t\t\t\t\ttodo: false\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (!metadata.skipped) {\n\t\t\t\t\t\tthis.tasks[metadata.type + (metadata.always ? 'Always' : '')].push(task);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tserial: false,\n\t\t\texclusive: false,\n\t\t\tskipped: false,\n\t\t\ttodo: false,\n\t\t\tfailing: false,\n\t\t\tcallback: false,\n\t\t\tinline: false, // Set for attempt metadata created by `t.try()`\n\t\t\talways: false\n\t\t}, meta);\n\t}\n\n\tcompareTestSnapshot(options) {\n\t\tif (!this.snapshots) {\n\t\t\tthis.snapshots = snapshotManager.load({\n\t\t\t\tfile: this.file,\n\t\t\t\tfixedLocation: this.snapshotDir,\n\t\t\t\tprojectDir: this.projectDir,\n\t\t\t\trecordNewSnapshots: this.recordNewSnapshots,\n\t\t\t\tupdating: this.updateSnapshots && !this.runOnlyExclusive && !this.skippingTests\n\t\t\t});\n\t\t\tthis.emit('dependency', this.snapshots.snapPath);\n\t\t}\n\n\t\treturn this.snapshots.compare(options);\n\t}\n\n\tskipSnapshot() {\n\t\tthis.skippedSnapshots = true;\n\t}\n\n\tsaveSnapshotState() {\n\t\tif (\n\t\t\tthis.updateSnapshots &&\n\t\t\t(\n\t\t\t\tthis.runOnlyExclusive ||\n\t\t\t\tthis.skippingTests ||\n\t\t\t\tthis.skippedSnapshots\n\t\t\t)\n\t\t) {\n\t\t\treturn {cannotSave: true};\n\t\t}\n\n\t\tif (this.snapshots) {\n\t\t\treturn {touchedFiles: this.snapshots.save()};\n\t\t}\n\n\t\tif (this.updateSnapshots) {\n\t\t\treturn {touchedFiles: snapshotManager.cleanSnapshots({\n\t\t\t\tfile: this.file,\n\t\t\t\tfixedLocation: this.snapshotDir,\n\t\t\t\tprojectDir: this.projectDir\n\t\t\t})};\n\t\t}\n\n\t\treturn {};\n\t}\n\n\tonRun(runnable) {\n\t\tthis.activeRunnables.add(runnable);\n\t}\n\n\tonRunComplete(runnable) {\n\t\tthis.activeRunnables.delete(runnable);\n\t}\n\n\tattributeLeakedError(err) {\n\t\tfor (const runnable of this.activeRunnables) {\n\t\t\tif (runnable.attributeLeakedError(err)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tbeforeExitHandler() {\n\t\tfor (const runnable of this.activeRunnables) {\n\t\t\trunnable.finishDueToInactivity();\n\t\t}\n\t}\n\n\tasync runMultiple(runnables) {\n\t\tlet allPassed = true;\n\t\tconst storedResults = [];\n\t\tconst runAndStoreResult = async runnable => {\n\t\t\tconst result = await this.runSingle(runnable);\n\t\t\tif (!result.passed) {\n\t\t\t\tallPassed = false;\n\t\t\t}\n\n\t\t\tstoredResults.push(result);\n\t\t};\n\n\t\tlet waitForSerial = Promise.resolve();\n\t\tawait runnables.reduce((previous, runnable) => { // eslint-disable-line unicorn/no-reduce\n\t\t\tif (runnable.metadata.serial || this.serial) {\n\t\t\t\twaitForSerial = previous.then(() => {\n\t\t\t\t\t// Serial runnables run as long as there was no previous failure, unless\n\t\t\t\t\t// the runnable should always be run.\n\t\t\t\t\treturn (allPassed || runnable.metadata.always) && runAndStoreResult(runnable);\n\t\t\t\t});\n\t\t\t\treturn waitForSerial;\n\t\t\t}\n\n\t\t\treturn Promise.all([\n\t\t\t\tprevious,\n\t\t\t\twaitForSerial.then(() => {\n\t\t\t\t\t// Concurrent runnables are kicked off after the previous serial\n\t\t\t\t\t// runnables have completed, as long as there was no previous failure\n\t\t\t\t\t// (or if the runnable should always be run). One concurrent runnable's\n\t\t\t\t\t// failure does not prevent the next runnable from running.\n\t\t\t\t\treturn (allPassed || runnable.metadata.always) && runAndStoreResult(runnable);\n\t\t\t\t})\n\t\t\t]);\n\t\t}, waitForSerial);\n\n\t\treturn {allPassed, storedResults};\n\t}\n\n\tasync runSingle(runnable) {\n\t\tthis.onRun(runnable);\n\t\tconst result = await runnable.run();\n\t\t// If run() throws or rejects then the entire test run crashes, so\n\t\t// onRunComplete() doesn't *have* to be inside a finally.\n\t\tthis.onRunComplete(runnable);\n\t\treturn result;\n\t}\n\n\tasync runHooks(tasks, contextRef, {titleSuffix, testPassed, associatedTaskIndex} = {}) {\n\t\tconst hooks = tasks.map(task => new Runnable({\n\t\t\tcontextRef,\n\t\t\texperiments: this.experiments,\n\t\t\tfailWithoutAssertions: false,\n\t\t\tfn: task.args.length === 0 ?\n\t\t\t\ttask.implementation :\n\t\t\t\tt => task.implementation.apply(null, [t].concat(task.args)),\n\t\t\tcompareTestSnapshot: this.boundCompareTestSnapshot,\n\t\t\tskipSnapshot: this.boundSkipSnapshot,\n\t\t\tupdateSnapshots: this.updateSnapshots,\n\t\t\tmetadata: {...task.metadata, associatedTaskIndex},\n\t\t\tpowerAssert: this.powerAssert,\n\t\t\ttitle: `${task.title}${titleSuffix || ''}`,\n\t\t\tisHook: true,\n\t\t\ttestPassed\n\t\t}));\n\t\tconst outcome = await this.runMultiple(hooks, this.serial);\n\t\tfor (const result of outcome.storedResults) {\n\t\t\tif (result.passed) {\n\t\t\t\tthis.emit('stateChange', {\n\t\t\t\t\ttype: 'hook-finished',\n\t\t\t\t\ttitle: result.title,\n\t\t\t\t\tduration: result.duration,\n\t\t\t\t\tlogs: result.logs\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.emit('stateChange', {\n\t\t\t\t\ttype: 'hook-failed',\n\t\t\t\t\ttitle: result.title,\n\t\t\t\t\terr: serializeError('Hook failure', true, result.error),\n\t\t\t\t\tduration: result.duration,\n\t\t\t\t\tlogs: result.logs\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn outcome.allPassed;\n\t}\n\n\tasync runTest(task, contextRef) {\n\t\tconst hookSuffix = ` for ${task.title}`;\n\t\tlet hooksOk = await this.runHooks(\n\t\t\tthis.tasks.beforeEach,\n\t\t\tcontextRef,\n\t\t\t{\n\t\t\t\ttitleSuffix: hookSuffix,\n\t\t\t\tassociatedTaskIndex: task.metadata.taskIndex\n\t\t\t}\n\t\t);\n\n\t\tlet testOk = false;\n\t\tif (hooksOk) {\n\t\t\t// Only run the test if all `beforeEach` hooks passed.\n\t\t\tconst test = new Runnable({\n\t\t\t\tcontextRef,\n\t\t\t\texperiments: this.experiments,\n\t\t\t\tfailWithoutAssertions: this.failWithoutAssertions,\n\t\t\t\tfn: task.args.length === 0 ?\n\t\t\t\t\ttask.implementation :\n\t\t\t\t\tt => task.implementation.apply(null, [t].concat(task.args)),\n\t\t\t\tcompareTestSnapshot: this.boundCompareTestSnapshot,\n\t\t\t\tskipSnapshot: this.boundSkipSnapshot,\n\t\t\t\tupdateSnapshots: this.updateSnapshots,\n\t\t\t\tmetadata: task.metadata,\n\t\t\t\tpowerAssert: this.powerAssert,\n\t\t\t\ttitle: task.title,\n\t\t\t\tregisterUniqueTitle: this.registerUniqueTitle\n\t\t\t});\n\n\t\t\tconst result = await this.runSingle(test);\n\t\t\ttestOk = result.passed;\n\n\t\t\tif (testOk) {\n\t\t\t\tthis.emit('stateChange', {\n\t\t\t\t\ttype: 'test-passed',\n\t\t\t\t\ttitle: result.title,\n\t\t\t\t\tduration: result.duration,\n\t\t\t\t\tknownFailing: result.metadata.failing,\n\t\t\t\t\tlogs: result.logs\n\t\t\t\t});\n\n\t\t\t\thooksOk = await this.runHooks(\n\t\t\t\t\tthis.tasks.afterEach,\n\t\t\t\t\tcontextRef,\n\t\t\t\t\t{\n\t\t\t\t\t\ttitleSuffix: hookSuffix,\n\t\t\t\t\t\ttestPassed: testOk,\n\t\t\t\t\t\tassociatedTaskIndex: task.metadata.taskIndex\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.emit('stateChange', {\n\t\t\t\t\ttype: 'test-failed',\n\t\t\t\t\ttitle: result.title,\n\t\t\t\t\terr: serializeError('Test failure', true, result.error, this.file),\n\t\t\t\t\tduration: result.duration,\n\t\t\t\t\tknownFailing: result.metadata.failing,\n\t\t\t\t\tlogs: result.logs\n\t\t\t\t});\n\t\t\t\t// Don't run `afterEach` hooks if the test failed.\n\t\t\t}\n\t\t}\n\n\t\tconst alwaysOk = await this.runHooks(\n\t\t\tthis.tasks.afterEachAlways,\n\t\t\tcontextRef,\n\t\t\t{\n\t\t\t\ttitleSuffix: hookSuffix,\n\t\t\t\ttestPassed: testOk,\n\t\t\t\tassociatedTaskIndex: task.metadata.taskIndex\n\t\t\t});\n\t\treturn alwaysOk && hooksOk && testOk;\n\t}\n\n\tasync start() {\n\t\tconst concurrentTests = [];\n\t\tconst serialTests = [];\n\t\tfor (const task of this.tasks.serial) {\n\t\t\tif (this.runOnlyExclusive && !task.metadata.exclusive) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (this.checkSelectedByLineNumbers && !task.metadata.selected) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.emit('stateChange', {\n\t\t\t\ttype: 'selected-test',\n\t\t\t\ttitle: task.title,\n\t\t\t\tknownFailing: task.metadata.failing,\n\t\t\t\tskip: task.metadata.skipped,\n\t\t\t\ttodo: false\n\t\t\t});\n\n\t\t\tif (!task.metadata.skipped) {\n\t\t\t\tserialTests.push(task);\n\t\t\t}\n\t\t}\n\n\t\tfor (const task of this.tasks.concurrent) {\n\t\t\tif (this.runOnlyExclusive && !task.metadata.exclusive) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (this.checkSelectedByLineNumbers && !task.metadata.selected) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.emit('stateChange', {\n\t\t\t\ttype: 'selected-test',\n\t\t\t\ttitle: task.title,\n\t\t\t\tknownFailing: task.metadata.failing,\n\t\t\t\tskip: task.metadata.skipped,\n\t\t\t\ttodo: false\n\t\t\t});\n\n\t\t\tif (!task.metadata.skipped) {\n\t\t\t\tif (this.serial) {\n\t\t\t\t\tserialTests.push(task);\n\t\t\t\t} else {\n\t\t\t\t\tconcurrentTests.push(task);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const task of this.tasks.todo) {\n\t\t\tif (this.runOnlyExclusive && !task.metadata.exclusive) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (this.checkSelectedByLineNumbers && !task.metadata.selected) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.emit('stateChange', {\n\t\t\t\ttype: 'selected-test',\n\t\t\t\ttitle: task.title,\n\t\t\t\tknownFailing: false,\n\t\t\t\tskip: false,\n\t\t\t\ttodo: true\n\t\t\t});\n\t\t}\n\n\t\tawait Promise.all(this.waitForReady);\n\n\t\tif (concurrentTests.length === 0 && serialTests.length === 0) {\n\t\t\tthis.emit('finish');\n\t\t\t// Don't run any hooks if there are no tests to run.\n\t\t\treturn;\n\t\t}\n\n\t\tconst contextRef = new ContextRef();\n\n\t\t// Note that the hooks and tests always begin running asynchronously.\n\t\tconst beforePromise = this.runHooks(this.tasks.before, contextRef);\n\t\tconst serialPromise = beforePromise.then(beforeHooksOk => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t// Don't run tests if a `before` hook failed.\n\t\t\tif (!beforeHooksOk) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn serialTests.reduce(async (previous, task) => { // eslint-disable-line unicorn/no-reduce\n\t\t\t\tconst previousOk = await previous;\n\t\t\t\t// Don't start tests after an interrupt.\n\t\t\t\tif (this.interrupted) {\n\t\t\t\t\treturn previousOk;\n\t\t\t\t}\n\n\t\t\t\t// Prevent subsequent tests from running if `failFast` is enabled and\n\t\t\t\t// the previous test failed.\n\t\t\t\tif (!previousOk && this.failFast) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn this.runTest(task, contextRef.copy());\n\t\t\t}, true);\n\t\t});\n\t\tconst concurrentPromise = Promise.all([beforePromise, serialPromise]).then(async ([beforeHooksOk, serialOk]) => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t// Don't run tests if a `before` hook failed, or if `failFast` is enabled\n\t\t\t// and a previous serial test failed.\n\t\t\tif (!beforeHooksOk || (!serialOk && this.failFast)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Don't start tests after an interrupt.\n\t\t\tif (this.interrupted) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// If a concurrent test fails, even if `failFast` is enabled it won't\n\t\t\t// stop other concurrent tests from running.\n\t\t\tconst allOkays = await Promise.all(concurrentTests.map(task => {\n\t\t\t\treturn this.runTest(task, contextRef.copy());\n\t\t\t}));\n\t\t\treturn allOkays.every(ok => ok);\n\t\t});\n\n\t\tconst beforeExitHandler = this.beforeExitHandler.bind(this);\n\t\tprocess.on('beforeExit', beforeExitHandler);\n\n\t\ttry {\n\t\t\tconst ok = await concurrentPromise;\n\t\t\t// Only run `after` hooks if all hooks and tests passed.\n\t\t\tif (ok) {\n\t\t\t\tawait this.runHooks(this.tasks.after, contextRef);\n\t\t\t}\n\n\t\t\t// Always run `after.always` hooks.\n\t\t\tawait this.runHooks(this.tasks.afterAlways, contextRef);\n\t\t\tprocess.removeListener('beforeExit', beforeExitHandler);\n\t\t\tawait this.emit('finish');\n\t\t} catch (error) {\n\t\t\tawait this.emit('error', error);\n\t\t}\n\t}\n\n\tinterrupt() {\n\t\tthis.interrupted = true;\n\t}\n}\n\nmodule.exports = Runner;\n",
    "test/lib/init/init.js": "const test = require(\"ava\");\nconst path = require(\"path\");\nconst ui5Cli = require(\"../../../\");\nconst sinon = require(\"sinon\");\nconst mock = require(\"mock-require\");\nconst init = ui5Cli.init;\n\nfunction getFixturePath(fixtureName) {\n\treturn path.join(__dirname, \"..\", \"..\", \"fixtures\", \"init\", fixtureName);\n}\n\ntest.afterEach.always(() => {\n\tsinon.restore();\n\tmock.stopAll();\n});\n\ntest(\"Init for application\", async (t) => {\n\tconst projectConfig = await init({\n\t\tcwd: getFixturePath(\"application\")\n\t});\n\n\tt.deepEqual(projectConfig, {\n\t\tspecVersion: \"2.4\",\n\t\ttype: \"application\",\n\t\tmetadata: {\n\t\t\tname: \"init-application\"\n\t\t}\n\t});\n});\n\ntest(\"Init for library\", async (t) => {\n\tconst projectConfig = await init({\n\t\tcwd: getFixturePath(\"library\")\n\t});\n\n\tt.deepEqual(projectConfig, {\n\t\tspecVersion: \"2.4\",\n\t\ttype: \"library\",\n\t\tmetadata: {\n\t\t\tname: \"init-library\"\n\t\t}\n\t});\n});\n\ntest(\"Init for invalid project (Found 'webapp', 'src' and 'test' folders)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-webapp-src-test\")\n\t}), {message:\n\t\"Could not detect project type: Found 'webapp', 'src' and 'test' folders.\\n\" +\n\t\"Applications should only have a 'webapp' folder.\\n\" +\n\t\"Libraries should only have a 'src' and (optional) 'test' folder.\"});\n});\n\ntest(\"Init for invalid project (Found 'webapp' and 'src' folders)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-webapp-src\")\n\t}), {message:\n\t\"Could not detect project type: Found 'webapp' and 'src' folders.\\n\" +\n\t\"Applications should only have a 'webapp' folder.\\n\" +\n\t\"Libraries should only have a 'src' and (optional) 'test' folder.\"});\n});\n\ntest(\"Init for invalid project (Found 'webapp' and 'test' folders)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-webapp-test\")\n\t}), {message:\n\t\"Could not detect project type: Found 'webapp' and 'test' folders.\\n\" +\n\t\"Applications should only have a 'webapp' folder.\\n\" +\n\t\"Libraries should only have a 'src' and (optional) 'test' folder.\"});\n});\n\ntest(\"Init for invalid project (Found 'test' folder but no 'src' folder)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-test\")\n\t}), {message:\n\t\"Could not detect project type: Found 'test' folder but no 'src' folder.\\n\" +\n\t\"Applications should only have a 'webapp' folder.\\n\" +\n\t\"Libraries should only have a 'src' and (optional) 'test' folder.\"});\n});\n\ntest(\"Init for invalid project (Could not find 'webapp' or 'src' / 'test' folders)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid\")\n\t}), {message:\n\t\"Could not detect project type: Could not find 'webapp' or 'src' / 'test' folders.\\n\" +\n\t\"Applications should only have a 'webapp' folder.\\n\" +\n\t\"Libraries should only have a 'src' and (optional) 'test' folder.\"});\n});\n\ntest(\"Init for invalid project (No package.json)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-no-package-json\")\n\t}), {message: \"Initialization not possible: Missing package.json file\"});\n});\n\ntest(\"Init for invalid project (Missing 'name' in package.json)\", async (t) => {\n\tawait t.throwsAsync(init({\n\t\tcwd: getFixturePath(\"invalid-missing-package-name\")\n\t}), {message: \"Initialization not possible: Missing 'name' in package.json\"});\n});\n\ntest.serial(\"Init with default arguments (throws fs.readFile error)\", async (t) => {\n\tsinon.stub(require(\"fs\"), \"readFile\")\n\t\t.withArgs(\"package.json\", \"utf8\").callsArgWith(2, new Error(\"Some error from fs.readFile\"));\n\n\tconst {init} = mock.reRequire(\"../../../lib/init/init\");\n\n\tawait t.throwsAsync(init(), {\n\t\tmessage: \"Some error from fs.readFile\"\n\t});\n});\n",
    "node_modules/ava/lib/assert.js": "'use strict';\nconst concordance = require('concordance');\nconst isError = require('is-error');\nconst isPromise = require('is-promise');\nconst concordanceOptions = require('./concordance-options').default;\nconst {CIRCULAR_SELECTOR, isLikeSelector, selectComparable} = require('./like-selector');\nconst snapshotManager = require('./snapshot-manager');\n\nfunction formatDescriptorDiff(actualDescriptor, expectedDescriptor, options) {\n\toptions = {...options, ...concordanceOptions};\n\treturn {\n\t\tlabel: 'Difference:',\n\t\tformatted: concordance.diffDescriptors(actualDescriptor, expectedDescriptor, options)\n\t};\n}\n\nfunction formatDescriptorWithLabel(label, descriptor) {\n\treturn {\n\t\tlabel,\n\t\tformatted: concordance.formatDescriptor(descriptor, concordanceOptions)\n\t};\n}\n\nfunction formatWithLabel(label, value) {\n\treturn formatDescriptorWithLabel(label, concordance.describe(value, concordanceOptions));\n}\n\nfunction formatPowerAssertValue(value) {\n\treturn concordance.format(value, concordanceOptions);\n}\n\nconst hasOwnProperty = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);\nconst noop = () => {};\nconst notImplemented = () => {\n\tthrow new Error('not implemented');\n};\n\nclass AssertionError extends Error {\n\tconstructor(options) {\n\t\tsuper(options.message || '');\n\t\tthis.name = 'AssertionError';\n\n\t\tthis.assertion = options.assertion;\n\t\tthis.fixedSource = options.fixedSource;\n\t\tthis.improperUsage = options.improperUsage || false;\n\t\tthis.actualStack = options.actualStack;\n\t\tthis.operator = options.operator;\n\t\tthis.values = options.values || [];\n\n\t\t// Raw expected and actual objects are stored for custom reporters\n\t\t// (such as wallaby.js), that manage worker processes directly and\n\t\t// use the values for custom diff views\n\t\tthis.raw = options.raw;\n\n\t\t// Reserved for power-assert statements\n\t\tthis.statements = [];\n\n\t\tif (options.savedError) {\n\t\t\tthis.savedError = options.savedError;\n\t\t} else {\n\t\t\tthis.savedError = getErrorWithLongStackTrace();\n\t\t}\n\t}\n}\nexports.AssertionError = AssertionError;\n\nfunction checkAssertionMessage(assertion, message) {\n\tif (typeof message === 'undefined' || typeof message === 'string') {\n\t\treturn true;\n\t}\n\n\treturn new AssertionError({\n\t\tassertion,\n\t\timproperUsage: true,\n\t\tmessage: 'The assertion message must be a string',\n\t\tvalues: [formatWithLabel('Called with:', message)]\n\t});\n}\n\nexports.checkAssertionMessage = checkAssertionMessage;\n\nfunction getErrorWithLongStackTrace() {\n\tconst limitBefore = Error.stackTraceLimit;\n\tError.stackTraceLimit = Infinity;\n\tconst err = new Error();\n\tError.stackTraceLimit = limitBefore;\n\treturn err;\n}\n\nfunction validateExpectations(assertion, expectations, numberArgs, experiments) { // eslint-disable-line complexity\n\tif (numberArgs === 1 || expectations === null || expectations === undefined) {\n\t\tif (experiments.disableNullExpectations && expectations === null) {\n\t\t\tthrow new AssertionError({\n\t\t\t\tassertion,\n\t\t\t\tmessage: `The second argument to \\`t.${assertion}()\\` must be an expectation object or \\`undefined\\``,\n\t\t\t\tvalues: [formatWithLabel('Called with:', expectations)]\n\t\t\t});\n\t\t}\n\n\t\texpectations = {};\n\t} else if (\n\t\ttypeof expectations === 'function' ||\n\t\ttypeof expectations === 'string' ||\n\t\texpectations instanceof RegExp ||\n\t\ttypeof expectations !== 'object' ||\n\t\tArray.isArray(expectations) ||\n\t\tObject.keys(expectations).length === 0\n\t) {\n\t\tthrow new AssertionError({\n\t\t\tassertion,\n\t\t\tmessage: `The second argument to \\`t.${assertion}()\\` must be an expectation object, \\`null\\` or \\`undefined\\``,\n\t\t\tvalues: [formatWithLabel('Called with:', expectations)]\n\t\t});\n\t} else {\n\t\tif (hasOwnProperty(expectations, 'instanceOf') && typeof expectations.instanceOf !== 'function') {\n\t\t\tthrow new AssertionError({\n\t\t\t\tassertion,\n\t\t\t\tmessage: `The \\`instanceOf\\` property of the second argument to \\`t.${assertion}()\\` must be a function`,\n\t\t\t\tvalues: [formatWithLabel('Called with:', expectations)]\n\t\t\t});\n\t\t}\n\n\t\tif (hasOwnProperty(expectations, 'message') && typeof expectations.message !== 'string' && !(expectations.message instanceof RegExp)) {\n\t\t\tthrow new AssertionError({\n\t\t\t\tassertion,\n\t\t\t\tmessage: `The \\`message\\` property of the second argument to \\`t.${assertion}()\\` must be a string or regular expression`,\n\t\t\t\tvalues: [formatWithLabel('Called with:', expectations)]\n\t\t\t});\n\t\t}\n\n\t\tif (hasOwnProperty(expectations, 'name') && typeof expectations.name !== 'string') {\n\t\t\tthrow new AssertionError({\n\t\t\t\tassertion,\n\t\t\t\tmessage: `The \\`name\\` property of the second argument to \\`t.${assertion}()\\` must be a string`,\n\t\t\t\tvalues: [formatWithLabel('Called with:', expectations)]\n\t\t\t});\n\t\t}\n\n\t\tif (hasOwnProperty(expectations, 'code') && typeof expectations.code !== 'string' && typeof expectations.code !== 'number') {\n\t\t\tthrow new AssertionError({\n\t\t\t\tassertion,\n\t\t\t\tmessage: `The \\`code\\` property of the second argument to \\`t.${assertion}()\\` must be a string or number`,\n\t\t\t\tvalues: [formatWithLabel('Called with:', expectations)]\n\t\t\t});\n\t\t}\n\n\t\tfor (const key of Object.keys(expectations)) {\n\t\t\tswitch (key) {\n\t\t\t\tcase 'instanceOf':\n\t\t\t\tcase 'is':\n\t\t\t\tcase 'message':\n\t\t\t\tcase 'name':\n\t\t\t\tcase 'code':\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion,\n\t\t\t\t\t\tmessage: `The second argument to \\`t.${assertion}()\\` contains unexpected properties`,\n\t\t\t\t\t\tvalues: [formatWithLabel('Called with:', expectations)]\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn expectations;\n}\n\n// Note: this function *must* throw exceptions, since it can be used\n// as part of a pending assertion for promises.\nfunction assertExpectations({assertion, actual, expectations, message, prefix, savedError}) {\n\tif (!isError(actual)) {\n\t\tthrow new AssertionError({\n\t\t\tassertion,\n\t\t\tmessage,\n\t\t\tsavedError,\n\t\t\tvalues: [formatWithLabel(`${prefix} exception that is not an error:`, actual)]\n\t\t});\n\t}\n\n\tconst actualStack = actual.stack;\n\n\tif (hasOwnProperty(expectations, 'is') && actual !== expectations.is) {\n\t\tthrow new AssertionError({\n\t\t\tassertion,\n\t\t\tmessage,\n\t\t\tsavedError,\n\t\t\tactualStack,\n\t\t\tvalues: [\n\t\t\t\tformatWithLabel(`${prefix} unexpected exception:`, actual),\n\t\t\t\tformatWithLabel('Expected to be strictly equal to:', expectations.is)\n\t\t\t]\n\t\t});\n\t}\n\n\tif (expectations.instanceOf && !(actual instanceof expectations.instanceOf)) {\n\t\tthrow new AssertionError({\n\t\t\tassertion,\n\t\t\tmessage,\n\t\t\tsavedError,\n\t\t\tactualStack,\n\t\t\tvalues: [\n\t\t\t\tformatWithLabel(`${prefix} unexpected exception:`, actual),\n\t\t\t\tformatWithLabel('Expected instance of:', expectations.instanceOf)\n\t\t\t]\n\t\t});\n\t}\n\n\tif (typeof expectations.name === 'string' && actual.name !== expectations.name) {\n\t\tthrow new AssertionError({\n\t\t\tassertion,\n\t\t\tmessage,\n\t\t\tsavedError,\n\t\t\tactualStack,\n\t\t\tvalues: [\n\t\t\t\tformatWithLabel(`${prefix} unexpected exception:`, actual),\n\t\t\t\tformatWithLabel('Expected name to equal:', expectations.name)\n\t\t\t]\n\t\t});\n\t}\n\n\tif (typeof expectations.message === 'string' && actual.message !== expectations.message) {\n\t\tthrow new AssertionError({\n\t\t\tassertion,\n\t\t\tmessage,\n\t\t\tsavedError,\n\t\t\tactualStack,\n\t\t\tvalues: [\n\t\t\t\tformatWithLabel(`${prefix} unexpected exception:`, actual),\n\t\t\t\tformatWithLabel('Expected message to equal:', expectations.message)\n\t\t\t]\n\t\t});\n\t}\n\n\tif (expectations.message instanceof RegExp && !expectations.message.test(actual.message)) {\n\t\tthrow new AssertionError({\n\t\t\tassertion,\n\t\t\tmessage,\n\t\t\tsavedError,\n\t\t\tactualStack,\n\t\t\tvalues: [\n\t\t\t\tformatWithLabel(`${prefix} unexpected exception:`, actual),\n\t\t\t\tformatWithLabel('Expected message to match:', expectations.message)\n\t\t\t]\n\t\t});\n\t}\n\n\tif (typeof expectations.code !== 'undefined' && actual.code !== expectations.code) {\n\t\tthrow new AssertionError({\n\t\t\tassertion,\n\t\t\tmessage,\n\t\t\tsavedError,\n\t\t\tactualStack,\n\t\t\tvalues: [\n\t\t\t\tformatWithLabel(`${prefix} unexpected exception:`, actual),\n\t\t\t\tformatWithLabel('Expected code to equal:', expectations.code)\n\t\t\t]\n\t\t});\n\t}\n}\n\nclass Assertions {\n\tconstructor({\n\t\tpass = notImplemented,\n\t\tpending = notImplemented,\n\t\tfail = notImplemented,\n\t\tskip = notImplemented,\n\t\tcompareWithSnapshot = notImplemented,\n\t\tpowerAssert,\n\t\texperiments = {},\n\t\tdisableSnapshots = false\n\t} = {}) {\n\t\tconst withSkip = assertionFn => {\n\t\t\tassertionFn.skip = skip;\n\t\t\treturn assertionFn;\n\t\t};\n\n\t\t// When adding new enhanced functions with new patterns, don't forget to\n\t\t// enable the pattern in the power-assert compilation step in @ava/babel.\n\t\tconst withPowerAssert = (pattern, assertionFn) => powerAssert.empower(assertionFn, {\n\t\t\tonError: event => {\n\t\t\t\tif (event.powerAssertContext) {\n\t\t\t\t\tevent.error.statements = powerAssert.format(event.powerAssertContext, formatPowerAssertValue);\n\t\t\t\t}\n\n\t\t\t\tfail(event.error);\n\t\t\t},\n\t\t\tonSuccess: () => {\n\t\t\t\tpass();\n\t\t\t},\n\t\t\tbindReceiver: false,\n\t\t\tpatterns: [pattern]\n\t\t});\n\n\t\tconst checkMessage = (assertion, message, powerAssert = false) => {\n\t\t\tconst result = checkAssertionMessage(assertion, message);\n\t\t\tif (result === true) {\n\t\t\t\treturn this.true;\n\t\t\t}\n\n\t\t\tif (powerAssert) {\n\t\t\t\tthrow result;\n\t\t\t}\n\n\t\t\tfail(result);\n\t\t\treturn false;\n\t\t};\n\n\t\tthis.pass = withSkip(() => {\n\t\t\tpass();\n\t\t});\n\n\t\tthis.fail = withSkip(message => {\n\t\t\tif (!checkMessage('fail', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfail(new AssertionError({\n\t\t\t\tassertion: 'fail',\n\t\t\t\tmessage: message || 'Test failed via `t.fail()`'\n\t\t\t}));\n\t\t});\n\n\t\tthis.is = withSkip((actual, expected, message) => {\n\t\t\tif (!checkMessage('is', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Object.is(actual, expected)) {\n\t\t\t\tpass();\n\t\t\t} else {\n\t\t\t\tconst result = concordance.compare(actual, expected, concordanceOptions);\n\t\t\t\tconst actualDescriptor = result.actual || concordance.describe(actual, concordanceOptions);\n\t\t\t\tconst expectedDescriptor = result.expected || concordance.describe(expected, concordanceOptions);\n\n\t\t\t\tif (result.pass) {\n\t\t\t\t\tfail(new AssertionError({\n\t\t\t\t\t\tassertion: 'is',\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\traw: {actual, expected},\n\t\t\t\t\t\tvalues: [formatDescriptorWithLabel('Values are deeply equal to each other, but they are not the same:', actualDescriptor)]\n\t\t\t\t\t}));\n\t\t\t\t} else {\n\t\t\t\t\tfail(new AssertionError({\n\t\t\t\t\t\tassertion: 'is',\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\traw: {actual, expected},\n\t\t\t\t\t\tvalues: [formatDescriptorDiff(actualDescriptor, expectedDescriptor)]\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis.not = withSkip((actual, expected, message) => {\n\t\t\tif (!checkMessage('not', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Object.is(actual, expected)) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'not',\n\t\t\t\t\tmessage,\n\t\t\t\t\traw: {actual, expected},\n\t\t\t\t\tvalues: [formatWithLabel('Value is the same as:', actual)]\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tpass();\n\t\t\t}\n\t\t});\n\n\t\tthis.deepEqual = withSkip((actual, expected, message) => {\n\t\t\tif (!checkMessage('deepEqual', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst result = concordance.compare(actual, expected, concordanceOptions);\n\t\t\tif (result.pass) {\n\t\t\t\tpass();\n\t\t\t} else {\n\t\t\t\tconst actualDescriptor = result.actual || concordance.describe(actual, concordanceOptions);\n\t\t\t\tconst expectedDescriptor = result.expected || concordance.describe(expected, concordanceOptions);\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'deepEqual',\n\t\t\t\t\tmessage,\n\t\t\t\t\traw: {actual, expected},\n\t\t\t\t\tvalues: [formatDescriptorDiff(actualDescriptor, expectedDescriptor)]\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\n\t\tthis.notDeepEqual = withSkip((actual, expected, message) => {\n\t\t\tif (!checkMessage('notDeepEqual', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst result = concordance.compare(actual, expected, concordanceOptions);\n\t\t\tif (result.pass) {\n\t\t\t\tconst actualDescriptor = result.actual || concordance.describe(actual, concordanceOptions);\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'notDeepEqual',\n\t\t\t\t\tmessage,\n\t\t\t\t\traw: {actual, expected},\n\t\t\t\t\tvalues: [formatDescriptorWithLabel('Value is deeply equal:', actualDescriptor)]\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tpass();\n\t\t\t}\n\t\t});\n\n\t\tthis.like = withSkip((actual, selector, message) => {\n\t\t\tif (!checkMessage('like', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isLikeSelector(selector)) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'like',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.like()` selector must be a non-empty object',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', selector)]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet comparable;\n\t\t\ttry {\n\t\t\t\tcomparable = selectComparable(actual, selector);\n\t\t\t} catch (error) {\n\t\t\t\tif (error === CIRCULAR_SELECTOR) {\n\t\t\t\t\tfail(new AssertionError({\n\t\t\t\t\t\tassertion: 'like',\n\t\t\t\t\t\timproperUsage: true,\n\t\t\t\t\t\tmessage: '`t.like()` selector must not contain circular references',\n\t\t\t\t\t\tvalues: [formatWithLabel('Called with:', selector)]\n\t\t\t\t\t}));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tconst result = concordance.compare(comparable, selector, concordanceOptions);\n\t\t\tif (result.pass) {\n\t\t\t\tpass();\n\t\t\t} else {\n\t\t\t\tconst actualDescriptor = result.actual || concordance.describe(comparable, concordanceOptions);\n\t\t\t\tconst expectedDescriptor = result.expected || concordance.describe(selector, concordanceOptions);\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'like',\n\t\t\t\t\tmessage,\n\t\t\t\t\tvalues: [formatDescriptorDiff(actualDescriptor, expectedDescriptor)]\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\n\t\tthis.throws = withSkip((...args) => {\n\t\t\t// Since arrow functions do not support 'arguments', we are using rest\n\t\t\t// operator, so we can determine the total number of arguments passed\n\t\t\t// to the function.\n\t\t\tlet [fn, expectations, message] = args;\n\n\t\t\tif (!checkMessage('throws', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof fn !== 'function') {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'throws',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.throws()` must be called with a function',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', fn)]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\texpectations = validateExpectations('throws', expectations, args.length, experiments);\n\t\t\t} catch (error) {\n\t\t\t\tfail(error);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet retval;\n\t\t\tlet actual = null;\n\t\t\ttry {\n\t\t\t\tretval = fn();\n\t\t\t\tif (isPromise(retval)) {\n\t\t\t\t\t// Here isPromise() checks if something is \"promise like\". Cast to an actual promise.\n\t\t\t\t\tPromise.resolve(retval).catch(noop);\n\t\t\t\t\tfail(new AssertionError({\n\t\t\t\t\t\tassertion: 'throws',\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tvalues: [formatWithLabel('Function returned a promise. Use `t.throwsAsync()` instead:', retval)]\n\t\t\t\t\t}));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tactual = error;\n\t\t\t}\n\n\t\t\tif (!actual) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'throws',\n\t\t\t\t\tmessage,\n\t\t\t\t\tvalues: [formatWithLabel('Function returned:', retval)]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tassertExpectations({\n\t\t\t\t\tassertion: 'throws',\n\t\t\t\t\tactual,\n\t\t\t\t\texpectations,\n\t\t\t\t\tmessage,\n\t\t\t\t\tprefix: 'Function threw'\n\t\t\t\t});\n\t\t\t\tpass();\n\t\t\t\treturn actual;\n\t\t\t} catch (error) {\n\t\t\t\tfail(error);\n\t\t\t}\n\t\t});\n\n\t\tthis.throwsAsync = withSkip((...args) => {\n\t\t\tlet [thrower, expectations, message] = args;\n\n\t\t\tif (!checkMessage('throwsAsync', message)) {\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\tif (typeof thrower !== 'function' && !isPromise(thrower)) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'throwsAsync',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.throwsAsync()` must be called with a function or promise',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', thrower)]\n\t\t\t\t}));\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\texpectations = validateExpectations('throwsAsync', expectations, args.length, experiments);\n\t\t\t} catch (error) {\n\t\t\t\tfail(error);\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\tconst handlePromise = (promise, wasReturned) => {\n\t\t\t\t// Create an error object to record the stack before it gets lost in the promise chain.\n\t\t\t\tconst savedError = getErrorWithLongStackTrace();\n\t\t\t\t// Handle \"promise like\" objects by casting to a real Promise.\n\t\t\t\tconst intermediate = Promise.resolve(promise).then(value => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion: 'throwsAsync',\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tsavedError,\n\t\t\t\t\t\tvalues: [formatWithLabel(`${wasReturned ? 'Returned promise' : 'Promise'} resolved with:`, value)]\n\t\t\t\t\t});\n\t\t\t\t}, error => {\n\t\t\t\t\tassertExpectations({\n\t\t\t\t\t\tassertion: 'throwsAsync',\n\t\t\t\t\t\tactual: error,\n\t\t\t\t\t\texpectations,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tprefix: `${wasReturned ? 'Returned promise' : 'Promise'} rejected with`,\n\t\t\t\t\t\tsavedError\n\t\t\t\t\t});\n\t\t\t\t\treturn error;\n\t\t\t\t});\n\n\t\t\t\tpending(intermediate);\n\t\t\t\t// Don't reject the returned promise, even if the assertion fails.\n\t\t\t\treturn intermediate.catch(noop);\n\t\t\t};\n\n\t\t\tif (isPromise(thrower)) {\n\t\t\t\treturn handlePromise(thrower, false);\n\t\t\t}\n\n\t\t\tlet retval;\n\t\t\tlet actual = null;\n\t\t\ttry {\n\t\t\t\tretval = thrower();\n\t\t\t} catch (error) {\n\t\t\t\tactual = error;\n\t\t\t}\n\n\t\t\tif (actual) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'throwsAsync',\n\t\t\t\t\tmessage,\n\t\t\t\t\tactualStack: actual.stack,\n\t\t\t\t\tvalues: [formatWithLabel('Function threw synchronously. Use `t.throws()` instead:', actual)]\n\t\t\t\t}));\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\tif (isPromise(retval)) {\n\t\t\t\treturn handlePromise(retval, true);\n\t\t\t}\n\n\t\t\tfail(new AssertionError({\n\t\t\t\tassertion: 'throwsAsync',\n\t\t\t\tmessage,\n\t\t\t\tvalues: [formatWithLabel('Function returned:', retval)]\n\t\t\t}));\n\t\t\treturn Promise.resolve();\n\t\t});\n\n\t\tthis.notThrows = withSkip((fn, message) => {\n\t\t\tif (!checkMessage('notThrows', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof fn !== 'function') {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'notThrows',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.notThrows()` must be called with a function',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', fn)]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfn();\n\t\t\t} catch (error) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'notThrows',\n\t\t\t\t\tmessage,\n\t\t\t\t\tactualStack: error.stack,\n\t\t\t\t\tvalues: [formatWithLabel('Function threw:', error)]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpass();\n\t\t});\n\n\t\tthis.notThrowsAsync = withSkip((nonThrower, message) => {\n\t\t\tif (!checkMessage('notThrowsAsync', message)) {\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\tif (typeof nonThrower !== 'function' && !isPromise(nonThrower)) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'notThrowsAsync',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.notThrowsAsync()` must be called with a function or promise',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', nonThrower)]\n\t\t\t\t}));\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\tconst handlePromise = (promise, wasReturned) => {\n\t\t\t\t// Create an error object to record the stack before it gets lost in the promise chain.\n\t\t\t\tconst savedError = getErrorWithLongStackTrace();\n\t\t\t\t// Handle \"promise like\" objects by casting to a real Promise.\n\t\t\t\tconst intermediate = Promise.resolve(promise).then(noop, error => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion: 'notThrowsAsync',\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tsavedError,\n\t\t\t\t\t\tvalues: [formatWithLabel(`${wasReturned ? 'Returned promise' : 'Promise'} rejected with:`, error)]\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tpending(intermediate);\n\t\t\t\t// Don't reject the returned promise, even if the assertion fails.\n\t\t\t\treturn intermediate.catch(noop);\n\t\t\t};\n\n\t\t\tif (isPromise(nonThrower)) {\n\t\t\t\treturn handlePromise(nonThrower, false);\n\t\t\t}\n\n\t\t\tlet retval;\n\t\t\ttry {\n\t\t\t\tretval = nonThrower();\n\t\t\t} catch (error) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'notThrowsAsync',\n\t\t\t\t\tmessage,\n\t\t\t\t\tactualStack: error.stack,\n\t\t\t\t\tvalues: [formatWithLabel('Function threw:', error)]\n\t\t\t\t}));\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\tif (!isPromise(retval)) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'notThrowsAsync',\n\t\t\t\t\tmessage,\n\t\t\t\t\tvalues: [formatWithLabel('Function did not return a promise. Use `t.notThrows()` instead:', retval)]\n\t\t\t\t}));\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\treturn handlePromise(retval, true);\n\t\t});\n\n\t\tthis.snapshot = withSkip((expected, ...rest) => {\n\t\t\tif (disableSnapshots && experiments.disableSnapshotsInHooks) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'snapshot',\n\t\t\t\t\tmessage: '`t.snapshot()` can only be used in tests',\n\t\t\t\t\timproperUsage: true\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet message;\n\t\t\tlet snapshotOptions;\n\t\t\tif (rest.length > 1) {\n\t\t\t\t[snapshotOptions, message] = rest;\n\t\t\t} else {\n\t\t\t\tconst [optionsOrMessage] = rest;\n\t\t\t\tif (typeof optionsOrMessage === 'object') {\n\t\t\t\t\tsnapshotOptions = optionsOrMessage;\n\t\t\t\t} else {\n\t\t\t\t\tmessage = optionsOrMessage;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!checkMessage('snapshot', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tresult = compareWithSnapshot({\n\t\t\t\t\texpected,\n\t\t\t\t\tid: snapshotOptions ? snapshotOptions.id : undefined,\n\t\t\t\t\tmessage\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tif (!(error instanceof snapshotManager.SnapshotError)) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\tconst improperUsage = {name: error.name, snapPath: error.snapPath};\n\t\t\t\tif (error instanceof snapshotManager.VersionMismatchError) {\n\t\t\t\t\timproperUsage.snapVersion = error.snapVersion;\n\t\t\t\t\timproperUsage.expectedVersion = error.expectedVersion;\n\t\t\t\t}\n\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'snapshot',\n\t\t\t\t\tmessage: message || 'Could not compare snapshot',\n\t\t\t\t\timproperUsage\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (result.pass) {\n\t\t\t\tpass();\n\t\t\t} else if (result.actual) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'snapshot',\n\t\t\t\t\tmessage: message || 'Did not match snapshot',\n\t\t\t\t\tvalues: [formatDescriptorDiff(result.actual, result.expected, {invert: true})]\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\t// This can only occur in CI environments.\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'snapshot',\n\t\t\t\t\tmessage: message || 'No snapshot available — new snapshots are not created in CI environments'\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\n\t\tthis.truthy = withSkip((actual, message) => {\n\t\t\tif (!checkMessage('truthy', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (actual) {\n\t\t\t\tpass();\n\t\t\t} else {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'truthy',\n\t\t\t\t\tmessage,\n\t\t\t\t\toperator: '!!',\n\t\t\t\t\tvalues: [formatWithLabel('Value is not truthy:', actual)]\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\n\t\tthis.falsy = withSkip((actual, message) => {\n\t\t\tif (!checkMessage('falsy', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (actual) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'falsy',\n\t\t\t\t\tmessage,\n\t\t\t\t\toperator: '!',\n\t\t\t\t\tvalues: [formatWithLabel('Value is not falsy:', actual)]\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tpass();\n\t\t\t}\n\t\t});\n\n\t\tthis.true = withSkip((actual, message) => {\n\t\t\tif (!checkMessage('true', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (actual === true) {\n\t\t\t\tpass();\n\t\t\t} else {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'true',\n\t\t\t\t\tmessage,\n\t\t\t\t\tvalues: [formatWithLabel('Value is not `true`:', actual)]\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\n\t\tthis.false = withSkip((actual, message) => {\n\t\t\tif (!checkMessage('false', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (actual === false) {\n\t\t\t\tpass();\n\t\t\t} else {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'false',\n\t\t\t\t\tmessage,\n\t\t\t\t\tvalues: [formatWithLabel('Value is not `false`:', actual)]\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\n\t\tthis.regex = withSkip((string, regex, message) => {\n\t\t\tif (!checkMessage('regex', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof string !== 'string') {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'regex',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.regex()` must be called with a string',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', string)]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!(regex instanceof RegExp)) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'regex',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.regex()` must be called with a regular expression',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', regex)]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!regex.test(string)) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'regex',\n\t\t\t\t\tmessage,\n\t\t\t\t\tvalues: [\n\t\t\t\t\t\tformatWithLabel('Value must match expression:', string),\n\t\t\t\t\t\tformatWithLabel('Regular expression:', regex)\n\t\t\t\t\t]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpass();\n\t\t});\n\n\t\tthis.notRegex = withSkip((string, regex, message) => {\n\t\t\tif (!checkMessage('notRegex', message)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof string !== 'string') {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'notRegex',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.notRegex()` must be called with a string',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', string)]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!(regex instanceof RegExp)) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'notRegex',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.notRegex()` must be called with a regular expression',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', regex)]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (regex.test(string)) {\n\t\t\t\tfail(new AssertionError({\n\t\t\t\t\tassertion: 'notRegex',\n\t\t\t\t\tmessage,\n\t\t\t\t\tvalues: [\n\t\t\t\t\t\tformatWithLabel('Value must not match expression:', string),\n\t\t\t\t\t\tformatWithLabel('Regular expression:', regex)\n\t\t\t\t\t]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpass();\n\t\t});\n\n\t\tif (powerAssert === undefined) {\n\t\t\tthis.assert = withSkip((actual, message) => {\n\t\t\t\tif (!checkMessage('assert', message)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!actual) {\n\t\t\t\t\tfail(new AssertionError({\n\t\t\t\t\t\tassertion: 'assert',\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\toperator: '!!',\n\t\t\t\t\t\tvalues: [formatWithLabel('Value is not truthy:', actual)]\n\t\t\t\t\t}));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tpass();\n\t\t\t});\n\t\t} else {\n\t\t\tthis.assert = withSkip(withPowerAssert(\n\t\t\t\t'assert(value, [message])',\n\t\t\t\t(actual, message) => {\n\t\t\t\t\tcheckMessage('assert', message, true);\n\n\t\t\t\t\tif (!actual) {\n\t\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\t\tassertion: 'assert',\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\toperator: '!!',\n\t\t\t\t\t\t\tvalues: [formatWithLabel('Value is not truthy:', actual)]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t}\n}\nexports.Assertions = Assertions;\n",
    "node_modules/ava/lib/test.js": "'use strict';\nconst concordance = require('concordance');\nconst isPromise = require('is-promise');\nconst plur = require('plur');\nconst assert = require('./assert');\nconst nowAndTimers = require('./now-and-timers');\nconst parseTestArgs = require('./parse-test-args');\nconst concordanceOptions = require('./concordance-options').default;\n\nfunction formatErrorValue(label, error) {\n\tconst formatted = concordance.format(error, concordanceOptions);\n\treturn {label, formatted};\n}\n\nconst captureSavedError = () => {\n\tconst limitBefore = Error.stackTraceLimit;\n\tError.stackTraceLimit = 1;\n\tconst err = new Error();\n\tError.stackTraceLimit = limitBefore;\n\treturn err;\n};\n\nconst testMap = new WeakMap();\nclass ExecutionContext extends assert.Assertions {\n\tconstructor(test) {\n\t\tsuper({\n\t\t\tpass: () => {\n\t\t\t\ttest.countPassedAssertion();\n\t\t\t},\n\t\t\tpending: promise => {\n\t\t\t\ttest.addPendingAssertion(promise);\n\t\t\t},\n\t\t\tfail: err => {\n\t\t\t\ttest.addFailedAssertion(err);\n\t\t\t},\n\t\t\tskip: () => {\n\t\t\t\ttest.countPassedAssertion();\n\t\t\t},\n\t\t\tcompareWithSnapshot: options => {\n\t\t\t\treturn test.compareWithSnapshot(options);\n\t\t\t},\n\t\t\tpowerAssert: test.powerAssert,\n\t\t\texperiments: test.experiments,\n\t\t\tdisableSnapshots: test.isHook === true\n\t\t});\n\t\ttestMap.set(this, test);\n\n\t\tthis.snapshot.skip = () => {\n\t\t\ttest.skipSnapshot();\n\t\t};\n\n\t\tthis.log = (...inputArgs) => {\n\t\t\tconst args = inputArgs.map(value => {\n\t\t\t\treturn typeof value === 'string' ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tconcordance.format(value, concordanceOptions);\n\t\t\t});\n\t\t\tif (args.length > 0) {\n\t\t\t\ttest.addLog(args.join(' '));\n\t\t\t}\n\t\t};\n\n\t\tthis.plan = count => {\n\t\t\ttest.plan(count, captureSavedError());\n\t\t};\n\n\t\tthis.plan.skip = () => {};\n\n\t\tthis.timeout = (ms, message) => {\n\t\t\ttest.timeout(ms, message);\n\t\t};\n\n\t\tthis.teardown = callback => {\n\t\t\ttest.addTeardown(callback);\n\t\t};\n\n\t\tthis.try = async (...attemptArgs) => {\n\t\t\tif (test.isHook) {\n\t\t\t\tconst error = new Error('`t.try()` can only be used in tests');\n\t\t\t\ttest.saveFirstError(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tconst {args, buildTitle, implementations, receivedImplementationArray} = parseTestArgs(attemptArgs);\n\n\t\t\tif (implementations.length === 0) {\n\t\t\t\tthrow new TypeError('Expected an implementation.');\n\t\t\t}\n\n\t\t\tconst attemptPromises = implementations.map((implementation, index) => {\n\t\t\t\tlet {title, isSet, isValid, isEmpty} = buildTitle(implementation);\n\n\t\t\t\tif (!isSet || isEmpty) {\n\t\t\t\t\ttitle = `${test.title} ─ attempt ${test.attemptCount + 1 + index}`;\n\t\t\t\t} else if (isValid) {\n\t\t\t\t\ttitle = `${test.title} ─ ${title}`;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError('`t.try()` titles must be strings'); // Throw synchronously!\n\t\t\t\t}\n\n\t\t\t\tif (!test.registerUniqueTitle(title)) {\n\t\t\t\t\tthrow new Error(`Duplicate test title: ${title}`);\n\t\t\t\t}\n\n\t\t\t\treturn {implementation, title};\n\t\t\t}).map(async ({implementation, title}) => {\n\t\t\t\tlet committed = false;\n\t\t\t\tlet discarded = false;\n\n\t\t\t\tconst {assertCount, deferredSnapshotRecordings, errors, logs, passed, snapshotCount, startingSnapshotCount} = await test.runAttempt(title, t => implementation(t, ...args));\n\n\t\t\t\treturn {\n\t\t\t\t\terrors,\n\t\t\t\t\tlogs: [...logs], // Don't allow modification of logs.\n\t\t\t\t\tpassed,\n\t\t\t\t\ttitle,\n\t\t\t\t\tcommit: ({retainLogs = true} = {}) => {\n\t\t\t\t\t\tif (committed) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (discarded) {\n\t\t\t\t\t\t\ttest.saveFirstError(new Error('Can’t commit a result that was previously discarded'));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcommitted = true;\n\t\t\t\t\t\ttest.finishAttempt({\n\t\t\t\t\t\t\tassertCount,\n\t\t\t\t\t\t\tcommit: true,\n\t\t\t\t\t\t\tdeferredSnapshotRecordings,\n\t\t\t\t\t\t\terrors,\n\t\t\t\t\t\t\tlogs,\n\t\t\t\t\t\t\tpassed,\n\t\t\t\t\t\t\tretainLogs,\n\t\t\t\t\t\t\tsnapshotCount,\n\t\t\t\t\t\t\tstartingSnapshotCount\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tdiscard: ({retainLogs = false} = {}) => {\n\t\t\t\t\t\tif (committed) {\n\t\t\t\t\t\t\ttest.saveFirstError(new Error('Can’t discard a result that was previously committed'));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (discarded) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdiscarded = true;\n\t\t\t\t\t\ttest.finishAttempt({\n\t\t\t\t\t\t\tassertCount: 0,\n\t\t\t\t\t\t\tcommit: false,\n\t\t\t\t\t\t\tdeferredSnapshotRecordings,\n\t\t\t\t\t\t\terrors,\n\t\t\t\t\t\t\tlogs,\n\t\t\t\t\t\t\tpassed,\n\t\t\t\t\t\t\tretainLogs,\n\t\t\t\t\t\t\tsnapshotCount,\n\t\t\t\t\t\t\tstartingSnapshotCount\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tconst results = await Promise.all(attemptPromises);\n\t\t\treturn receivedImplementationArray ? results : results[0];\n\t\t};\n\t}\n\n\tget end() {\n\t\tconst end = testMap.get(this).bindEndCallback();\n\t\tconst endFn = error => end(error, captureSavedError());\n\t\treturn endFn;\n\t}\n\n\tget title() {\n\t\treturn testMap.get(this).title;\n\t}\n\n\tget context() {\n\t\treturn testMap.get(this).contextRef.get();\n\t}\n\n\tset context(context) {\n\t\ttestMap.get(this).contextRef.set(context);\n\t}\n\n\tget passed() {\n\t\tconst test = testMap.get(this);\n\t\treturn test.isHook ? test.testPassed : !test.assertError;\n\t}\n\n\t_throwsArgStart(assertion, file, line) {\n\t\ttestMap.get(this).trackThrows({assertion, file, line});\n\t}\n\n\t_throwsArgEnd() {\n\t\ttestMap.get(this).trackThrows(null);\n\t}\n}\n\nclass Test {\n\tconstructor(options) {\n\t\tthis.contextRef = options.contextRef;\n\t\tthis.experiments = options.experiments || {};\n\t\tthis.failWithoutAssertions = options.failWithoutAssertions;\n\t\tthis.fn = options.fn;\n\t\tthis.isHook = options.isHook === true;\n\t\tthis.metadata = options.metadata;\n\t\tthis.powerAssert = options.powerAssert;\n\t\tthis.title = options.title;\n\t\tthis.testPassed = options.testPassed;\n\t\tthis.registerUniqueTitle = options.registerUniqueTitle;\n\t\tthis.logs = [];\n\t\tthis.teardowns = [];\n\n\t\tconst {snapshotBelongsTo = this.title, nextSnapshotIndex = 0} = options;\n\t\tthis.snapshotBelongsTo = snapshotBelongsTo;\n\t\tthis.nextSnapshotIndex = nextSnapshotIndex;\n\t\tthis.snapshotCount = 0;\n\n\t\tconst deferRecording = this.metadata.inline;\n\t\tthis.deferredSnapshotRecordings = [];\n\t\tthis.compareWithSnapshot = ({expected, id, message}) => {\n\t\t\tthis.snapshotCount++;\n\n\t\t\t// TODO: In a breaking change, reject non-undefined, falsy IDs and messages.\n\t\t\tconst belongsTo = id || snapshotBelongsTo;\n\t\t\tconst index = id ? 0 : this.nextSnapshotIndex++;\n\t\t\tconst label = id ? '' : message || `Snapshot ${index + 1}`; // Human-readable labels start counting at 1.\n\n\t\t\tconst {taskIndex, associatedTaskIndex} = this.metadata;\n\t\t\tconst {record, ...result} = options.compareTestSnapshot({\n\t\t\t\tbelongsTo,\n\t\t\t\tdeferRecording,\n\t\t\t\texpected,\n\t\t\t\tindex,\n\t\t\t\tlabel,\n\t\t\t\ttaskIndex,\n\t\t\t\tsnapIndex: this.snapshotCount,\n\t\t\t\tassociatedTaskIndex\n\t\t\t});\n\t\t\tif (record) {\n\t\t\t\tthis.deferredSnapshotRecordings.push(record);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\tthis.skipSnapshot = () => {\n\t\t\tif (typeof options.skipSnapshot === 'function') {\n\t\t\t\toptions.skipSnapshot();\n\t\t\t}\n\n\t\t\tif (options.updateSnapshots) {\n\t\t\t\tthis.addFailedAssertion(new Error('Snapshot assertions cannot be skipped when updating snapshots'));\n\t\t\t} else {\n\t\t\t\tthis.nextSnapshotIndex++;\n\t\t\t\tthis.snapshotCount++;\n\t\t\t\tthis.countPassedAssertion();\n\t\t\t}\n\t\t};\n\n\t\tthis.runAttempt = async (title, fn) => {\n\t\t\tif (this.finishing) {\n\t\t\t\tthis.saveFirstError(new Error('Running a `t.try()`, but the test has already finished'));\n\t\t\t}\n\n\t\t\tthis.attemptCount++;\n\t\t\tthis.pendingAttemptCount++;\n\n\t\t\tconst {contextRef, snapshotBelongsTo, nextSnapshotIndex, snapshotCount: startingSnapshotCount} = this;\n\t\t\tconst attempt = new Test({\n\t\t\t\t...options,\n\t\t\t\tfn,\n\t\t\t\tmetadata: {...options.metadata, callback: false, failing: false, inline: true},\n\t\t\t\tcontextRef: contextRef.copy(),\n\t\t\t\tsnapshotBelongsTo,\n\t\t\t\tnextSnapshotIndex,\n\t\t\t\ttitle\n\t\t\t});\n\n\t\t\tconst {deferredSnapshotRecordings, error, logs, passed, assertCount, snapshotCount} = await attempt.run();\n\t\t\tconst errors = error ? [error] : [];\n\t\t\treturn {assertCount, deferredSnapshotRecordings, errors, logs, passed, snapshotCount, startingSnapshotCount};\n\t\t};\n\n\t\tthis.assertCount = 0;\n\t\tthis.assertError = undefined;\n\t\tthis.attemptCount = 0;\n\t\tthis.calledEnd = false;\n\t\tthis.duration = null;\n\t\tthis.endCallbackFinisher = null;\n\t\tthis.finishDueToAttributedError = null;\n\t\tthis.finishDueToInactivity = null;\n\t\tthis.finishDueToTimeout = null;\n\t\tthis.finishing = false;\n\t\tthis.pendingAssertionCount = 0;\n\t\tthis.pendingAttemptCount = 0;\n\t\tthis.pendingThrowsAssertion = null;\n\t\tthis.planCount = null;\n\t\tthis.startedAt = 0;\n\t\tthis.timeoutMs = 0;\n\t\tthis.timeoutTimer = null;\n\t}\n\n\tbindEndCallback() {\n\t\tif (this.metadata.callback) {\n\t\t\treturn (error, savedError) => {\n\t\t\t\tthis.endCallback(error, savedError);\n\t\t\t};\n\t\t}\n\n\t\tconst error_ = this.metadata.inline ? new Error('`t.end()` is not supported inside `t.try()`') : new Error('`t.end()` is not supported in this context. To use `t.end()` as a callback, you must use \"callback mode\" via `test.cb(testName, fn)`');\n\t\tthrow error_;\n\t}\n\n\tendCallback(error, savedError) {\n\t\tif (this.calledEnd) {\n\t\t\tthis.saveFirstError(new Error('`t.end()` called more than once'));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.calledEnd = true;\n\n\t\tif (error) {\n\t\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\t\tactual: error,\n\t\t\t\tmessage: 'Callback called with an error',\n\t\t\t\tsavedError,\n\t\t\t\tvalues: [formatErrorValue('Callback called with an error:', error)]\n\t\t\t}));\n\t\t}\n\n\t\tif (this.endCallbackFinisher) {\n\t\t\tthis.endCallbackFinisher();\n\t\t}\n\t}\n\n\tcreateExecutionContext() {\n\t\treturn new ExecutionContext(this);\n\t}\n\n\tcountPassedAssertion() {\n\t\tif (this.finishing) {\n\t\t\tthis.saveFirstError(new Error('Assertion passed, but test has already finished'));\n\t\t}\n\n\t\tif (this.pendingAttemptCount > 0) {\n\t\t\tthis.saveFirstError(new Error('Assertion passed, but an attempt is pending. Use the attempt’s assertions instead'));\n\t\t}\n\n\t\tthis.assertCount++;\n\t\tthis.refreshTimeout();\n\t}\n\n\taddLog(text) {\n\t\tthis.logs.push(text);\n\t}\n\n\taddPendingAssertion(promise) {\n\t\tif (this.finishing) {\n\t\t\tthis.saveFirstError(new Error('Assertion started, but test has already finished'));\n\t\t}\n\n\t\tif (this.pendingAttemptCount > 0) {\n\t\t\tthis.saveFirstError(new Error('Assertion started, but an attempt is pending. Use the attempt’s assertions instead'));\n\t\t}\n\n\t\tthis.assertCount++;\n\t\tthis.pendingAssertionCount++;\n\t\tthis.refreshTimeout();\n\n\t\tpromise\n\t\t\t.catch(error => this.saveFirstError(error))\n\t\t\t.then(() => { // eslint-disable-line promise/prefer-await-to-then\n\t\t\t\tthis.pendingAssertionCount--;\n\t\t\t\tthis.refreshTimeout();\n\t\t\t});\n\t}\n\n\taddFailedAssertion(error) {\n\t\tif (this.finishing) {\n\t\t\tthis.saveFirstError(new Error('Assertion failed, but test has already finished'));\n\t\t}\n\n\t\tif (this.pendingAttemptCount > 0) {\n\t\t\tthis.saveFirstError(new Error('Assertion failed, but an attempt is pending. Use the attempt’s assertions instead'));\n\t\t}\n\n\t\tthis.assertCount++;\n\t\tthis.refreshTimeout();\n\t\tthis.saveFirstError(error);\n\t}\n\n\tfinishAttempt({commit, deferredSnapshotRecordings, errors, logs, passed, retainLogs, snapshotCount, startingSnapshotCount}) {\n\t\tif (this.finishing) {\n\t\t\tif (commit) {\n\t\t\t\tthis.saveFirstError(new Error('`t.try()` result was committed, but the test has already finished'));\n\t\t\t} else {\n\t\t\t\tthis.saveFirstError(new Error('`t.try()` result was discarded, but the test has already finished'));\n\t\t\t}\n\t\t}\n\n\t\tif (commit) {\n\t\t\tthis.assertCount++;\n\n\t\t\tif (startingSnapshotCount === this.snapshotCount) {\n\t\t\t\tthis.snapshotCount += snapshotCount;\n\t\t\t\tthis.nextSnapshotIndex += snapshotCount;\n\t\t\t\tfor (const record of deferredSnapshotRecordings) {\n\t\t\t\t\trecord();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.saveFirstError(new Error('Cannot commit `t.try()` result. Do not run concurrent snapshot assertions when using `t.try()`'));\n\t\t\t}\n\t\t}\n\n\t\tthis.pendingAttemptCount--;\n\n\t\tif (commit && !passed) {\n\t\t\tthis.saveFirstError(errors[0]);\n\t\t}\n\n\t\tif (retainLogs) {\n\t\t\tfor (const log of logs) {\n\t\t\t\tthis.addLog(log);\n\t\t\t}\n\t\t}\n\n\t\tthis.refreshTimeout();\n\t}\n\n\tsaveFirstError(error) {\n\t\tif (!this.assertError) {\n\t\t\tthis.assertError = error;\n\t\t}\n\t}\n\n\tplan(count, planError) {\n\t\tif (typeof count !== 'number') {\n\t\t\tthrow new TypeError('Expected a number');\n\t\t}\n\n\t\tthis.planCount = count;\n\n\t\t// In case the `planCount` doesn't match `assertCount, we need the stack of\n\t\t// this function to throw with a useful stack.\n\t\tthis.planError = planError;\n\t}\n\n\ttimeout(ms, message) {\n\t\tconst result = assert.checkAssertionMessage('timeout', message);\n\t\tif (result !== true) {\n\t\t\tthis.saveFirstError(result);\n\t\t\t// Allow the timeout to be set even when the message is invalid.\n\t\t\tmessage = '';\n\t\t}\n\n\t\tif (this.finishing) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.clearTimeout();\n\t\tthis.timeoutMs = ms;\n\t\tthis.timeoutTimer = nowAndTimers.setTimeout(() => {\n\t\t\tthis.saveFirstError(new Error(message || 'Test timeout exceeded'));\n\n\t\t\tif (this.finishDueToTimeout) {\n\t\t\t\tthis.finishDueToTimeout();\n\t\t\t}\n\t\t}, ms);\n\t}\n\n\trefreshTimeout() {\n\t\tif (!this.timeoutTimer) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.timeoutTimer.refresh) {\n\t\t\tthis.timeoutTimer.refresh();\n\t\t} else {\n\t\t\tthis.timeout(this.timeoutMs);\n\t\t}\n\t}\n\n\tclearTimeout() {\n\t\tnowAndTimers.clearTimeout(this.timeoutTimer);\n\t\tthis.timeoutTimer = null;\n\t}\n\n\taddTeardown(callback) {\n\t\tif (this.isHook) {\n\t\t\tthis.saveFirstError(new Error('`t.teardown()` is not allowed in hooks'));\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.finishing) {\n\t\t\tthis.saveFirstError(new Error('`t.teardown()` cannot be used during teardown'));\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof callback !== 'function') {\n\t\t\tthrow new TypeError('Expected a function');\n\t\t}\n\n\t\tthis.teardowns.push(callback);\n\t}\n\n\tasync runTeardowns() {\n\t\tconst teardowns = [...this.teardowns];\n\n\t\tif (this.experiments.reverseTeardowns) {\n\t\t\tteardowns.reverse();\n\t\t}\n\n\t\tfor (const teardown of teardowns) {\n\t\t\ttry {\n\t\t\t\tawait teardown(); // eslint-disable-line no-await-in-loop\n\t\t\t} catch (error) {\n\t\t\t\tthis.saveFirstError(error);\n\t\t\t}\n\t\t}\n\t}\n\n\tverifyPlan() {\n\t\tif (!this.assertError && this.planCount !== null && this.planCount !== this.assertCount) {\n\t\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\t\tassertion: 'plan',\n\t\t\t\tmessage: `Planned for ${this.planCount} ${plur('assertion', this.planCount)}, but got ${this.assertCount}.`,\n\t\t\t\toperator: '===',\n\t\t\t\tsavedError: this.planError\n\t\t\t}));\n\t\t}\n\t}\n\n\tverifyAssertions() {\n\t\tif (this.assertError) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.pendingAttemptCount > 0) {\n\t\t\tthis.saveFirstError(new Error('Test finished, but not all attempts were committed or discarded'));\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.pendingAssertionCount > 0) {\n\t\t\tthis.saveFirstError(new Error('Test finished, but an assertion is still pending'));\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.failWithoutAssertions) {\n\t\t\tif (this.planCount !== null) {\n\t\t\t\treturn; // `verifyPlan()` will report an error already.\n\t\t\t}\n\n\t\t\tif (this.assertCount === 0 && !this.calledEnd) {\n\t\t\t\tthis.saveFirstError(new Error('Test finished without running any assertions'));\n\t\t\t}\n\t\t}\n\t}\n\n\ttrackThrows(pending) {\n\t\tthis.pendingThrowsAssertion = pending;\n\t}\n\n\tdetectImproperThrows(error) {\n\t\tif (!this.pendingThrowsAssertion) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst pending = this.pendingThrowsAssertion;\n\t\tthis.pendingThrowsAssertion = null;\n\n\t\tconst values = [];\n\t\tif (error) {\n\t\t\tvalues.push(formatErrorValue(`The following error was thrown, possibly before \\`t.${pending.assertion}()\\` could be called:`, error));\n\t\t}\n\n\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\tassertion: pending.assertion,\n\t\t\tfixedSource: {file: pending.file, line: pending.line},\n\t\t\timproperUsage: true,\n\t\t\tmessage: `Improper usage of \\`t.${pending.assertion}()\\` detected`,\n\t\t\tsavedError: error instanceof Error && error,\n\t\t\tvalues\n\t\t}));\n\t\treturn true;\n\t}\n\n\twaitForPendingThrowsAssertion() {\n\t\treturn new Promise(resolve => {\n\t\t\tthis.finishDueToAttributedError = () => {\n\t\t\t\tresolve(this.finish());\n\t\t\t};\n\n\t\t\tthis.finishDueToInactivity = () => {\n\t\t\t\tthis.detectImproperThrows();\n\t\t\t\tresolve(this.finish());\n\t\t\t};\n\n\t\t\t// Wait up to a second to see if an error can be attributed to the\n\t\t\t// pending assertion.\n\t\t\tnowAndTimers.setTimeout(() => this.finishDueToInactivity(), 1000).unref();\n\t\t});\n\t}\n\n\tattributeLeakedError(error) {\n\t\tif (!this.detectImproperThrows(error)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.finishDueToAttributedError();\n\t\treturn true;\n\t}\n\n\tcallFn() {\n\t\ttry {\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tretval: this.fn.call(null, this.createExecutionContext())\n\t\t\t};\n\t\t} catch (error) {\n\t\t\treturn {\n\t\t\t\tok: false,\n\t\t\t\terror\n\t\t\t};\n\t\t}\n\t}\n\n\trun() {\n\t\tthis.startedAt = nowAndTimers.now();\n\n\t\tconst result = this.callFn();\n\t\tif (!result.ok) {\n\t\t\tif (!this.detectImproperThrows(result.error)) {\n\t\t\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\t\t\tmessage: 'Error thrown in test',\n\t\t\t\t\tsavedError: result.error instanceof Error && result.error,\n\t\t\t\t\tvalues: [formatErrorValue('Error thrown in test:', result.error)]\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\treturn this.finish();\n\t\t}\n\n\t\tconst returnedObservable = result.retval !== null && typeof result.retval === 'object' && typeof result.retval.subscribe === 'function';\n\t\tconst returnedPromise = isPromise(result.retval);\n\n\t\tlet promise;\n\t\tif (returnedObservable) {\n\t\t\tpromise = new Promise((resolve, reject) => {\n\t\t\t\tresult.retval.subscribe({\n\t\t\t\t\terror: reject,\n\t\t\t\t\tcomplete: () => resolve()\n\t\t\t\t});\n\t\t\t});\n\t\t} else if (returnedPromise) {\n\t\t\t// `retval` can be any thenable, so convert to a proper promise.\n\t\t\tpromise = Promise.resolve(result.retval);\n\t\t}\n\n\t\tif (this.metadata.callback) {\n\t\t\tif (returnedObservable || returnedPromise) {\n\t\t\t\tconst asyncType = returnedObservable ? 'observables' : 'promises';\n\t\t\t\tthis.saveFirstError(new Error(`Do not return ${asyncType} from tests declared via \\`test.cb(…)\\`. Use \\`test.cb(…)\\` for legacy callback APIs. When using promises, observables or async functions, use \\`test(…)\\`.`));\n\t\t\t\treturn this.finish();\n\t\t\t}\n\n\t\t\tif (this.calledEnd) {\n\t\t\t\treturn this.finish();\n\t\t\t}\n\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tthis.endCallbackFinisher = () => {\n\t\t\t\t\tresolve(this.finish());\n\t\t\t\t};\n\n\t\t\t\tthis.finishDueToAttributedError = () => {\n\t\t\t\t\tresolve(this.finish());\n\t\t\t\t};\n\n\t\t\t\tthis.finishDueToTimeout = () => {\n\t\t\t\t\tresolve(this.finish());\n\t\t\t\t};\n\n\t\t\t\tthis.finishDueToInactivity = () => {\n\t\t\t\t\tthis.saveFirstError(new Error('`t.end()` was never called'));\n\t\t\t\t\tresolve(this.finish());\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\tif (promise) {\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tthis.finishDueToAttributedError = () => {\n\t\t\t\t\tresolve(this.finish());\n\t\t\t\t};\n\n\t\t\t\tthis.finishDueToTimeout = () => {\n\t\t\t\t\tresolve(this.finish());\n\t\t\t\t};\n\n\t\t\t\tthis.finishDueToInactivity = () => {\n\t\t\t\t\tconst error = returnedObservable ?\n\t\t\t\t\t\tnew Error('Observable returned by test never completed') :\n\t\t\t\t\t\tnew Error('Promise returned by test never resolved');\n\t\t\t\t\tthis.saveFirstError(error);\n\t\t\t\t\tresolve(this.finish());\n\t\t\t\t};\n\n\t\t\t\tpromise\n\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\tif (!this.detectImproperThrows(error)) {\n\t\t\t\t\t\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\t\t\t\t\t\tmessage: 'Rejected promise returned by test',\n\t\t\t\t\t\t\t\tsavedError: error instanceof Error && error,\n\t\t\t\t\t\t\t\tvalues: [formatErrorValue('Rejected promise returned by test. Reason:', error)]\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => resolve(this.finish())); // eslint-disable-line promise/prefer-await-to-then\n\t\t\t});\n\t\t}\n\n\t\treturn this.finish();\n\t}\n\n\tasync finish() {\n\t\tthis.finishing = true;\n\n\t\tif (!this.assertError && this.pendingThrowsAssertion) {\n\t\t\treturn this.waitForPendingThrowsAssertion();\n\t\t}\n\n\t\tthis.clearTimeout();\n\t\tthis.verifyPlan();\n\t\tthis.verifyAssertions();\n\t\tawait this.runTeardowns();\n\n\t\tthis.duration = nowAndTimers.now() - this.startedAt;\n\n\t\tlet error = this.assertError;\n\t\tlet passed = !error;\n\n\t\tif (this.metadata.failing) {\n\t\t\tpassed = !passed;\n\n\t\t\terror = passed ? null : new Error('Test was expected to fail, but succeeded, you should stop marking the test as failing');\n\t\t}\n\n\t\treturn {\n\t\t\tdeferredSnapshotRecordings: this.deferredSnapshotRecordings,\n\t\t\tduration: this.duration,\n\t\t\terror,\n\t\t\tlogs: this.logs,\n\t\t\tmetadata: this.metadata,\n\t\t\tpassed,\n\t\t\tsnapshotCount: this.snapshotCount,\n\t\t\tassertCount: this.assertCount,\n\t\t\ttitle: this.title\n\t\t};\n\t}\n}\n\nmodule.exports = Test;\n",
    "lib/utils/fsHelper.js": "const {promisify} = require(\"util\");\nconst fs = require(\"fs\");\nconst stat = promisify(fs.stat);\nconst path = require(\"path\");\n\n/**\n * Checks if a file or path exists\n *\n * @private\n * @param {string} filePath Path to check\n * @returns {Promise} Promise resolving with true if the file or path exists\n */\nasync function exists(filePath) {\n\ttry {\n\t\tawait stat(filePath);\n\t\treturn true;\n\t} catch (err) {\n\t\t// \"File or directory does not exist\"\n\t\tif (err.code === \"ENOENT\") {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\n/**\n * Checks if a list of paths exists\n *\n * @private\n * @param {Array} paths List of paths to check\n * @param {string} cwd Current working directory\n * @returns {Promise} Resolving with an array of booleans for each path\n */\nasync function pathsExist(paths, cwd) {\n\treturn await Promise.all(paths.map((p) => exists(path.join(cwd, p))));\n}\n\nmodule.exports = {\n\texists,\n\tpathsExist\n};\n\n"
  }
}