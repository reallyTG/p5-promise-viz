{
  "promises": {
    "0": {
      "source": "bin/c8.js:49:1:49:1",
      "startTime": "23377000095438",
      "endTime": "23377026614188",
      "elapsedTime": "26518750",
      "asyncId": 5,
      "triggerAsyncId": 1,
      "io": "",
      "userCode": false,
      "line": "\n}\n\nrun().catch((err) => {\n  console.error(err.stack)\n  process.exitCode = 1\n}",
      "startLine": 49,
      "startCol": 1,
      "endLine": 49,
      "endCol": 1,
      "file": "bin/c8.js",
      "triggers": [
        9
      ],
      "uniqueid": 0
    },
    "1": {
      "source": "(internal/util.js:296:12:296:12)",
      "startTime": "23377001010461",
      "endTime": "23377017324416",
      "elapsedTime": "16313955",
      "asyncId": 6,
      "triggerAsyncId": 1,
      "io": false,
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        8
      ],
      "uniqueid": 1
    },
    "2": {
      "source": "bin/c8.js:49:1:49:1",
      "startTime": "23377003624071",
      "endTime": "23377019496530",
      "elapsedTime": "15872459",
      "asyncId": 8,
      "triggerAsyncId": 6,
      "io": "",
      "userCode": false,
      "line": "\n}\n\nrun().catch((err) => {\n  console.error(err.stack)\n  process.exitCode = 1\n}",
      "startLine": 49,
      "startCol": 1,
      "endLine": 49,
      "endCol": 1,
      "file": "bin/c8.js",
      "triggers": [
        93,
        94
      ],
      "uniqueid": 2
    },
    "3": {
      "source": "bin/c8.js:49:12:49:12",
      "startTime": "23377003986097",
      "endTime": "23377026903296",
      "elapsedTime": "22917199",
      "asyncId": 9,
      "triggerAsyncId": 5,
      "io": "",
      "userCode": false,
      "line": "\n}\n\nrun().catch((err) => {\n  console.error(err.stack)\n  process.exitCode = 1\n}",
      "startLine": 49,
      "startCol": 12,
      "endLine": 49,
      "endCol": 12,
      "file": "bin/c8.js",
      "triggers": [],
      "uniqueid": 3
    },
    "4": {
      "source": "bin/c8.js:35:20:35:20",
      "startTime": "23377017767861",
      "endTime": "23377020278050",
      "elapsedTime": "2510189",
      "asyncId": 93,
      "triggerAsyncId": 8,
      "io": false,
      "userCode": false,
      "line": "\n    }\n\n    await promises.mkdir(argv.tempDirectory, { recursive: true })\n    process.env.NODE_V8_COVERAGE = argv.tempDirectory\n    foreground(hideInstrumenterArgs(argv), async (done) => {\n      try ",
      "startLine": 35,
      "startCol": 20,
      "endLine": 35,
      "endCol": 20,
      "file": "bin/c8.js",
      "triggers": [],
      "uniqueid": 4
    },
    "5": {
      "source": "bin/c8.js:35:20:35:20",
      "startTime": "23377018003731",
      "endTime": "23377020063290",
      "elapsedTime": "2059559",
      "asyncId": 94,
      "triggerAsyncId": 8,
      "io": false,
      "userCode": false,
      "line": "\n    }\n\n    await promises.mkdir(argv.tempDirectory, { recursive: true })\n    process.env.NODE_V8_COVERAGE = argv.tempDirectory\n    foreground(hideInstrumenterArgs(argv), async (done) => {\n      try ",
      "startLine": 35,
      "startCol": 20,
      "endLine": 35,
      "endCol": 20,
      "file": "bin/c8.js",
      "triggers": [],
      "uniqueid": 5
    },
    "6": {
      "source": "bin/c8.js:39:15:39:15",
      "startTime": "23399263798942",
      "endTime": "23405468789815",
      "elapsedTime": "6204990873",
      "asyncId": 114,
      "triggerAsyncId": 98,
      "io": "",
      "userCode": false,
      "line": "\n    foreground(hideInstrumenterArgs(argv), async (done) => {\n      try {\n        await outputReport(argv)\n      } catch (err) {\n        console.error(err.stack)\n        process.exitCode = ",
      "startLine": 39,
      "startCol": 15,
      "endLine": 39,
      "endCol": 15,
      "file": "bin/c8.js",
      "triggers": [],
      "uniqueid": 6
    },
    "7": {
      "source": "lib/commands/report.js:27:16:27:16",
      "startTime": "23399265893532",
      "endTime": "23405468452972",
      "elapsedTime": "6202559440",
      "asyncId": 115,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n    src: argv.src\n  })\n  await report.run()\n  if (argv.checkCoverage) await checkCoverages(argv, report)\n}",
      "startLine": 27,
      "startCol": 16,
      "endLine": 27,
      "endCol": 16,
      "file": "lib/commands/report.js",
      "triggers": [
        211
      ],
      "uniqueid": 7
    },
    "8": {
      "source": "lib/report.js:61:31:61:31",
      "startTime": "23399266666166",
      "endTime": "23405429107646",
      "elapsedTime": "6162441480",
      "asyncId": 116,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n      dir: this.reportsDirectory,\n      watermarks: this.watermarks,\n      coverageMap: await this.getCoverageMapFromAllCoverageFiles()\n    })\n\n    this.reporter.forEach(function (_reporter) ",
      "startLine": 61,
      "startCol": 31,
      "endLine": 61,
      "endCol": 31,
      "file": "lib/report.js",
      "triggers": [
        210
      ],
      "uniqueid": 8
    },
    "9": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405304547542",
      "endTime": "23405406661721",
      "elapsedTime": "102114179",
      "asyncId": 118,
      "triggerAsyncId": 98,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [
        128
      ],
      "uniqueid": 9
    },
    "10": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405305849787",
      "endTime": "23405404656749",
      "elapsedTime": "98806962",
      "asyncId": 119,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [
        127
      ],
      "uniqueid": 10
    },
    "11": {
      "source": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js:43:52:43:52",
      "startTime": "23405306586205",
      "endTime": "23405402465526",
      "elapsedTime": "95879321",
      "asyncId": 120,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n\n  async load () {\n    const rawSource = this.sources.source || await readFile(this.path, 'utf8')\n    this.rawSourceMap = this.sources.sourceMap ||\n      // if we find a source-map (either inline, or a .map file) we load\n      // both the transpiled and original source, both of which are used durin",
      "startLine": 43,
      "startCol": 52,
      "endLine": 43,
      "endCol": 52,
      "file": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js",
      "triggers": [
        126
      ],
      "uniqueid": 11
    },
    "12": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405308533552",
      "endTime": "23405404819897",
      "elapsedTime": "96286345",
      "asyncId": 126,
      "triggerAsyncId": 120,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 12
    },
    "13": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405308832152",
      "endTime": "23405406895747",
      "elapsedTime": "98063595",
      "asyncId": 127,
      "triggerAsyncId": 119,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 13
    },
    "14": {
      "source": "(:0:0:0:0)",
      "startTime": "23405309115207",
      "endTime": "23405407222742",
      "elapsedTime": "98107535",
      "asyncId": 128,
      "triggerAsyncId": 118,
      "io": "",
      "userCode": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 14
    },
    "15": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405309669458",
      "endTime": "23405410284260",
      "elapsedTime": "100614802",
      "asyncId": 130,
      "triggerAsyncId": 98,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [
        140
      ],
      "uniqueid": 15
    },
    "16": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405309996754",
      "endTime": "23405409274833",
      "elapsedTime": "99278079",
      "asyncId": 131,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [
        139
      ],
      "uniqueid": 16
    },
    "17": {
      "source": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js:43:52:43:52",
      "startTime": "23405310584289",
      "endTime": "23405408683617",
      "elapsedTime": "98099328",
      "asyncId": 132,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n\n  async load () {\n    const rawSource = this.sources.source || await readFile(this.path, 'utf8')\n    this.rawSourceMap = this.sources.sourceMap ||\n      // if we find a source-map (either inline, or a .map file) we load\n      // both the transpiled and original source, both of which are used durin",
      "startLine": 43,
      "startCol": 52,
      "endLine": 43,
      "endCol": 52,
      "file": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js",
      "triggers": [
        138
      ],
      "uniqueid": 17
    },
    "18": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405312537163",
      "endTime": "23405409705872",
      "elapsedTime": "97168709",
      "asyncId": 138,
      "triggerAsyncId": 132,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 18
    },
    "19": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405312836451",
      "endTime": "23405410471918",
      "elapsedTime": "97635467",
      "asyncId": 139,
      "triggerAsyncId": 131,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 19
    },
    "20": {
      "source": "(:0:0:0:0)",
      "startTime": "23405313228392",
      "endTime": "23405410820507",
      "elapsedTime": "97592115",
      "asyncId": 140,
      "triggerAsyncId": 130,
      "io": "",
      "userCode": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 20
    },
    "21": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405313863251",
      "endTime": "23405413231894",
      "elapsedTime": "99368643",
      "asyncId": 142,
      "triggerAsyncId": 98,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [
        152
      ],
      "uniqueid": 21
    },
    "22": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405314246482",
      "endTime": "23405412681766",
      "elapsedTime": "98435284",
      "asyncId": 143,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [
        151
      ],
      "uniqueid": 22
    },
    "23": {
      "source": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js:43:52:43:52",
      "startTime": "23405314590793",
      "endTime": "23405412093977",
      "elapsedTime": "97503184",
      "asyncId": 144,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n\n  async load () {\n    const rawSource = this.sources.source || await readFile(this.path, 'utf8')\n    this.rawSourceMap = this.sources.sourceMap ||\n      // if we find a source-map (either inline, or a .map file) we load\n      // both the transpiled and original source, both of which are used durin",
      "startLine": 43,
      "startCol": 52,
      "endLine": 43,
      "endCol": 52,
      "file": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js",
      "triggers": [
        150
      ],
      "uniqueid": 23
    },
    "24": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405318088695",
      "endTime": "23405412877828",
      "elapsedTime": "94789133",
      "asyncId": 150,
      "triggerAsyncId": 144,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 24
    },
    "25": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405318642366",
      "endTime": "23405413454930",
      "elapsedTime": "94812564",
      "asyncId": 151,
      "triggerAsyncId": 143,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 25
    },
    "26": {
      "source": "(:0:0:0:0)",
      "startTime": "23405319010920",
      "endTime": "23405413803474",
      "elapsedTime": "94792554",
      "asyncId": 152,
      "triggerAsyncId": 142,
      "io": "",
      "userCode": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 26
    },
    "27": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405319737851",
      "endTime": "23405416243482",
      "elapsedTime": "96505631",
      "asyncId": 154,
      "triggerAsyncId": 98,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [
        164
      ],
      "uniqueid": 27
    },
    "28": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405320096236",
      "endTime": "23405415712410",
      "elapsedTime": "95616174",
      "asyncId": 155,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [
        163
      ],
      "uniqueid": 28
    },
    "29": {
      "source": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js:43:52:43:52",
      "startTime": "23405320424008",
      "endTime": "23405415075491",
      "elapsedTime": "94651483",
      "asyncId": 156,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n\n  async load () {\n    const rawSource = this.sources.source || await readFile(this.path, 'utf8')\n    this.rawSourceMap = this.sources.sourceMap ||\n      // if we find a source-map (either inline, or a .map file) we load\n      // both the transpiled and original source, both of which are used durin",
      "startLine": 43,
      "startCol": 52,
      "endLine": 43,
      "endCol": 52,
      "file": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js",
      "triggers": [
        162
      ],
      "uniqueid": 29
    },
    "30": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405322329096",
      "endTime": "23405415921803",
      "elapsedTime": "93592707",
      "asyncId": 162,
      "triggerAsyncId": 156,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 30
    },
    "31": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405322637966",
      "endTime": "23405416484236",
      "elapsedTime": "93846270",
      "asyncId": 163,
      "triggerAsyncId": 155,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 31
    },
    "32": {
      "source": "(:0:0:0:0)",
      "startTime": "23405322890158",
      "endTime": "23405416831812",
      "elapsedTime": "93941654",
      "asyncId": 164,
      "triggerAsyncId": 154,
      "io": "",
      "userCode": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 32
    },
    "33": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405323481045",
      "endTime": "23405420084188",
      "elapsedTime": "96603143",
      "asyncId": 166,
      "triggerAsyncId": 98,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [
        176
      ],
      "uniqueid": 33
    },
    "34": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405323813487",
      "endTime": "23405418839294",
      "elapsedTime": "95025807",
      "asyncId": 167,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [
        175
      ],
      "uniqueid": 34
    },
    "35": {
      "source": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js:43:52:43:52",
      "startTime": "23405324120812",
      "endTime": "23405418061827",
      "elapsedTime": "93941015",
      "asyncId": 168,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n\n  async load () {\n    const rawSource = this.sources.source || await readFile(this.path, 'utf8')\n    this.rawSourceMap = this.sources.sourceMap ||\n      // if we find a source-map (either inline, or a .map file) we load\n      // both the transpiled and original source, both of which are used durin",
      "startLine": 43,
      "startCol": 52,
      "endLine": 43,
      "endCol": 52,
      "file": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js",
      "triggers": [
        174
      ],
      "uniqueid": 35
    },
    "36": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405325779660",
      "endTime": "23405419377009",
      "elapsedTime": "93597349",
      "asyncId": 174,
      "triggerAsyncId": 168,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 36
    },
    "37": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405326067710",
      "endTime": "23405420285499",
      "elapsedTime": "94217789",
      "asyncId": 175,
      "triggerAsyncId": 167,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 37
    },
    "38": {
      "source": "(:0:0:0:0)",
      "startTime": "23405326303413",
      "endTime": "23405420672925",
      "elapsedTime": "94369512",
      "asyncId": 176,
      "triggerAsyncId": 166,
      "io": "",
      "userCode": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 38
    },
    "39": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405326878568",
      "endTime": "23405424736580",
      "elapsedTime": "97858012",
      "asyncId": 178,
      "triggerAsyncId": 98,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [
        188
      ],
      "uniqueid": 39
    },
    "40": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405327191440",
      "endTime": "23405422697335",
      "elapsedTime": "95505895",
      "asyncId": 179,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [
        187
      ],
      "uniqueid": 40
    },
    "41": {
      "source": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js:43:52:43:52",
      "startTime": "23405327490671",
      "endTime": "23405421705018",
      "elapsedTime": "94214347",
      "asyncId": 180,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n\n  async load () {\n    const rawSource = this.sources.source || await readFile(this.path, 'utf8')\n    this.rawSourceMap = this.sources.sourceMap ||\n      // if we find a source-map (either inline, or a .map file) we load\n      // both the transpiled and original source, both of which are used durin",
      "startLine": 43,
      "startCol": 52,
      "endLine": 43,
      "endCol": 52,
      "file": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js",
      "triggers": [
        186
      ],
      "uniqueid": 41
    },
    "42": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405329060125",
      "endTime": "23405422896215",
      "elapsedTime": "93836090",
      "asyncId": 186,
      "triggerAsyncId": 180,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 42
    },
    "43": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405329352071",
      "endTime": "23405424933666",
      "elapsedTime": "95581595",
      "asyncId": 187,
      "triggerAsyncId": 179,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 43
    },
    "44": {
      "source": "(:0:0:0:0)",
      "startTime": "23405329634748",
      "endTime": "23405425327432",
      "elapsedTime": "95692684",
      "asyncId": 188,
      "triggerAsyncId": 178,
      "io": "",
      "userCode": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 44
    },
    "45": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405330221395",
      "endTime": "23405427968656",
      "elapsedTime": "97747261",
      "asyncId": 190,
      "triggerAsyncId": 98,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [
        200
      ],
      "uniqueid": 45
    },
    "46": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405330551815",
      "endTime": "23405427369062",
      "elapsedTime": "96817247",
      "asyncId": 191,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [
        199
      ],
      "uniqueid": 46
    },
    "47": {
      "source": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js:43:52:43:52",
      "startTime": "23405330855362",
      "endTime": "23405426970571",
      "elapsedTime": "96115209",
      "asyncId": 192,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n\n  async load () {\n    const rawSource = this.sources.source || await readFile(this.path, 'utf8')\n    this.rawSourceMap = this.sources.sourceMap ||\n      // if we find a source-map (either inline, or a .map file) we load\n      // both the transpiled and original source, both of which are used durin",
      "startLine": 43,
      "startCol": 52,
      "endLine": 43,
      "endCol": 52,
      "file": "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js",
      "triggers": [
        198
      ],
      "uniqueid": 47
    },
    "48": {
      "source": "lib/report.js:104:25:104:25",
      "startTime": "23405332405484",
      "endTime": "23405427576666",
      "elapsedTime": "95171182",
      "asyncId": 198,
      "triggerAsyncId": 192,
      "io": false,
      "userCode": false,
      "line": "\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1",
      "startLine": 104,
      "startCol": 25,
      "endLine": 104,
      "endCol": 25,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 48
    },
    "49": {
      "source": "lib/report.js:127:17:127:17",
      "startTime": "23405332692330",
      "endTime": "23405428172842",
      "elapsedTime": "95480512",
      "asyncId": 199,
      "triggerAsyncId": 191,
      "io": "",
      "userCode": false,
      "line": "\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /",
      "startLine": 127,
      "startCol": 17,
      "endLine": 127,
      "endCol": 17,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 49
    },
    "50": {
      "source": "(:0:0:0:0)",
      "startTime": "23405332977991",
      "endTime": "23405428589725",
      "elapsedTime": "95611734",
      "asyncId": 200,
      "triggerAsyncId": 190,
      "io": "",
      "userCode": "",
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 50
    },
    "51": {
      "source": "lib/report.js:126:19:126:19",
      "startTime": "23405333277659",
      "endTime": "23405428746103",
      "elapsedTime": "95468444",
      "asyncId": 201,
      "triggerAsyncId": 98,
      "io": false,
      "userCode": false,
      "line": "\n    }\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n  ",
      "startLine": 126,
      "startCol": 19,
      "endLine": 126,
      "endCol": 19,
      "file": "lib/report.js",
      "triggers": [
        209
      ],
      "uniqueid": 51
    },
    "52": {
      "source": "lib/report.js:61:31:61:31",
      "startTime": "23405335923085",
      "endTime": "23405429345494",
      "elapsedTime": "93422409",
      "asyncId": 209,
      "triggerAsyncId": 201,
      "io": false,
      "userCode": false,
      "line": "\n      dir: this.reportsDirectory,\n      watermarks: this.watermarks,\n      coverageMap: await this.getCoverageMapFromAllCoverageFiles()\n    })\n\n    this.reporter.forEach(function (_reporter) ",
      "startLine": 61,
      "startCol": 31,
      "endLine": 61,
      "endCol": 31,
      "file": "lib/report.js",
      "triggers": [],
      "uniqueid": 52
    },
    "53": {
      "source": "lib/commands/report.js:27:16:27:16",
      "startTime": "23405336138857",
      "endTime": "23405468634668",
      "elapsedTime": "132495811",
      "asyncId": 210,
      "triggerAsyncId": 116,
      "io": false,
      "userCode": false,
      "line": "\n    src: argv.src\n  })\n  await report.run()\n  if (argv.checkCoverage) await checkCoverages(argv, report)\n}",
      "startLine": 27,
      "startCol": 16,
      "endLine": 27,
      "endCol": 16,
      "file": "lib/commands/report.js",
      "triggers": [],
      "uniqueid": 53
    },
    "54": {
      "source": "bin/c8.js:39:15:39:15",
      "startTime": "23405336402479",
      "endTime": "23405469645655",
      "elapsedTime": "133243176",
      "asyncId": 211,
      "triggerAsyncId": 115,
      "io": "",
      "userCode": false,
      "line": "\n    foreground(hideInstrumenterArgs(argv), async (done) => {\n      try {\n        await outputReport(argv)\n      } catch (err) {\n        console.error(err.stack)\n        process.exitCode = ",
      "startLine": 39,
      "startCol": 15,
      "endLine": 39,
      "endCol": 15,
      "file": "bin/c8.js",
      "triggers": [],
      "uniqueid": 54
    }
  },
  "files": {
    "bin/c8.js": "#!/usr/bin/env node\n'use strict'\n\nconst foreground = require('foreground-child')\nconst { outputReport } = require('../lib/commands/report')\nconst { promises } = require('fs')\nconst { promisify } = require('util')\nconst rimraf = require('rimraf')\nconst {\n  buildYargs,\n  hideInstrumenteeArgs,\n  hideInstrumenterArgs\n} = require('../lib/parse-args')\n\nconst instrumenterArgs = hideInstrumenteeArgs()\nlet argv = buildYargs().parse(instrumenterArgs)\n\nasync function run () {\n  if ([\n    'check-coverage', 'report'\n  ].indexOf(argv._[0]) !== -1) {\n    argv = buildYargs(true).parse(process.argv.slice(2))\n  } else {\n    // fs.promises was not added until Node.js v10.0.0, if it doesn't\n    // exist, assume we're Node.js v8.x and skip coverage.\n    if (!promises) {\n      foreground(hideInstrumenterArgs(argv))\n      return\n    }\n\n    if (argv.clean) {\n      await promisify(rimraf)(argv.tempDirectory)\n    }\n\n    await promises.mkdir(argv.tempDirectory, { recursive: true })\n    process.env.NODE_V8_COVERAGE = argv.tempDirectory\n    foreground(hideInstrumenterArgs(argv), async (done) => {\n      try {\n        await outputReport(argv)\n      } catch (err) {\n        console.error(err.stack)\n        process.exitCode = 1\n      }\n      done()\n    })\n  }\n}\n\nrun().catch((err) => {\n  console.error(err.stack)\n  process.exitCode = 1\n})\n",
    "lib/commands/report.js": "const { checkCoverages } = require('./check-coverage')\nconst Report = require('../report')\n\nexports.command = 'report'\n\nexports.describe = 'read V8 coverage data from temp and output report'\n\nexports.handler = async function (argv) {\n  await exports.outputReport(argv)\n}\n\nexports.outputReport = async function (argv) {\n  const report = Report({\n    include: argv.include,\n    exclude: argv.exclude,\n    reporter: Array.isArray(argv.reporter) ? argv.reporter : [argv.reporter],\n    reportsDirectory: argv['reports-dir'],\n    tempDirectory: argv.tempDirectory,\n    watermarks: argv.watermarks,\n    resolve: argv.resolve,\n    omitRelative: argv.omitRelative,\n    wrapperLength: argv.wrapperLength,\n    all: argv.all,\n    allowExternal: argv.allowExternal,\n    src: argv.src\n  })\n  await report.run()\n  if (argv.checkCoverage) await checkCoverages(argv, report)\n}\n",
    "lib/report.js": "const Exclude = require('test-exclude')\nconst furi = require('furi')\nconst libCoverage = require('istanbul-lib-coverage')\nconst libReport = require('istanbul-lib-report')\nconst reports = require('istanbul-reports')\nconst { readdirSync, readFileSync, statSync } = require('fs')\nconst { isAbsolute, resolve, extname } = require('path')\nconst getSourceMapFromFile = require('./source-map-from-file')\n// TODO: switch back to @c88/v8-coverage once patch is landed.\nconst v8toIstanbul = require('v8-to-istanbul')\nconst isCjsEsmBridgeCov = require('./is-cjs-esm-bridge')\nconst util = require('util')\nconst debuglog = util.debuglog('c8')\n\nclass Report {\n  constructor ({\n    exclude,\n    include,\n    reporter,\n    reportsDirectory,\n    tempDirectory,\n    watermarks,\n    omitRelative,\n    wrapperLength,\n    resolve: resolvePaths,\n    all,\n    src,\n    allowExternal = false\n  }) {\n    this.reporter = reporter\n    this.reportsDirectory = reportsDirectory\n    this.tempDirectory = tempDirectory\n    this.watermarks = watermarks\n    this.resolve = resolvePaths\n    this.exclude = new Exclude({\n      exclude: exclude,\n      include: include,\n      relativePath: !allowExternal\n    })\n    this.omitRelative = omitRelative\n    this.sourceMapCache = {}\n    this.wrapperLength = wrapperLength\n    this.all = all\n    this.src = this._getSrc(src)\n  }\n\n  _getSrc (src) {\n    if (typeof src === 'string') {\n      return [src]\n    } else if (Array.isArray(src)) {\n      return src\n    } else {\n      return [process.cwd()]\n    }\n  }\n\n  async run () {\n    const context = libReport.createContext({\n      dir: this.reportsDirectory,\n      watermarks: this.watermarks,\n      coverageMap: await this.getCoverageMapFromAllCoverageFiles()\n    })\n\n    this.reporter.forEach(function (_reporter) {\n      reports.create(_reporter, {\n        skipEmpty: false,\n        skipFull: false,\n        maxCols: 100\n      }).execute(context)\n    })\n  }\n\n  async getCoverageMapFromAllCoverageFiles () {\n    // the merge process can be very expensive, and it's often the case that\n    // check-coverage is called immediately after a report. We memoize the\n    // result from getCoverageMapFromAllCoverageFiles() to address this\n    // use-case.\n    if (this._allCoverageFiles) return this._allCoverageFiles\n\n    const map = libCoverage.createCoverageMap()\n    const v8ProcessCov = this._getMergedProcessCov()\n    const resultCountPerPath = new Map()\n    const possibleCjsEsmBridges = new Map()\n\n    /*\n    \n    OG Runtime:\n    Executed in   28.81 secs   fish           external \n       usr time   31.46 secs  138.00 micros   31.46 secs \n       sys time    3.39 secs  582.00 micros    3.39 secs \n\n    Runtime with change:\n    Executed in   28.00 secs   fish           external \n       usr time   30.63 secs  126.00 micros   30.63 secs \n       sys time    3.17 secs  580.00 micros    3.17 secs \n\n    */\n\n    async function tmp (v8ScriptCov) {\n      try {\n        const sources = this._getSourceMap(v8ScriptCov)\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1)\n        } else {\n          resultCountPerPath.set(path, 0)\n        }\n\n        if (isCjsEsmBridgeCov(v8ScriptCov)) {\n          possibleCjsEsmBridges.set(converter, {\n            path,\n            functions: v8ScriptCov.functions\n          })\n        } else {\n          converter.applyCoverage(v8ScriptCov.functions)\n          map.merge(converter.toIstanbul())\n        }\n      } catch (err) {\n        debuglog(`file: ${v8ScriptCov.url} error: ${err.stack}`)\n      }\n    }\n\n    await Promise.all(v8ProcessCov.result.map(async (e) => { \n      await tmp.apply(this, [e]);\n    }));\n   \n    /*\n    for (const v8ScriptCov of v8ProcessCov.result) {\n      try {\n        const sources = this._getSourceMap(v8ScriptCov)\n        const path = resolve(this.resolve, v8ScriptCov.url)\n        const converter = v8toIstanbul(path, this.wrapperLength, sources)\n        await converter.load()\n\n        if (resultCountPerPath.has(path)) {\n          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1)\n        } else {\n          resultCountPerPath.set(path, 0)\n        }\n\n        if (isCjsEsmBridgeCov(v8ScriptCov)) {\n          possibleCjsEsmBridges.set(converter, {\n            path,\n            functions: v8ScriptCov.functions\n          })\n        } else {\n          converter.applyCoverage(v8ScriptCov.functions)\n          map.merge(converter.toIstanbul())\n        }\n      } catch (err) {\n        debuglog(`file: ${v8ScriptCov.url} error: ${err.stack}`)\n      }\n    }\n    */\n\n    for (const [converter, { path, functions }] of possibleCjsEsmBridges) {\n      if (resultCountPerPath.get(path) <= 1) {\n        converter.applyCoverage(functions)\n        map.merge(converter.toIstanbul())\n      }\n    }\n    this._allCoverageFiles = map\n    return this._allCoverageFiles\n  }\n\n  /**\n   * Returns source-map and fake source file, if cached during Node.js'\n   * execution. This is used to support tools like ts-node, which transpile\n   * using runtime hooks.\n   *\n   * Note: requires Node.js 13+\n   *\n   * @return {Object} sourceMap and fake source file (created from line #s).\n   * @private\n   */\n  _getSourceMap (v8ScriptCov) {\n    const sources = {}\n    if (this.sourceMapCache[`file://${v8ScriptCov.url}`]) {\n      const sourceMapAndLineLengths = this.sourceMapCache[`file://${v8ScriptCov.url}`]\n      // See: https://github.com/nodejs/node/pull/34305\n      if (!sourceMapAndLineLengths.data) return\n      sources.sourceMap = {\n        sourcemap: sourceMapAndLineLengths.data\n      }\n      if (sourceMapAndLineLengths.lineLengths) {\n        let source = ''\n        sourceMapAndLineLengths.lineLengths.forEach(length => {\n          source += `${''.padEnd(length, '.')}\\n`\n        })\n        sources.source = source\n      }\n    }\n    return sources\n  }\n\n  /**\n   * Returns the merged V8 process coverage.\n   *\n   * The result is computed from the individual process coverages generated\n   * by Node. It represents the sum of their counts.\n   *\n   * @return {ProcessCov} Merged V8 process coverage.\n   * @private\n   */\n  _getMergedProcessCov () {\n    const { mergeProcessCovs } = require('@bcoe/v8-coverage')\n    const v8ProcessCovs = []\n    const fileIndex = new Set() // Set<string>\n    for (const v8ProcessCov of this._loadReports()) {\n      if (this._isCoverageObject(v8ProcessCov)) {\n        if (v8ProcessCov['source-map-cache']) {\n          Object.assign(this.sourceMapCache, v8ProcessCov['source-map-cache'])\n        }\n        v8ProcessCovs.push(this._normalizeProcessCov(v8ProcessCov, fileIndex))\n      }\n    }\n\n    if (this.all) {\n      const emptyReports = []\n      v8ProcessCovs.unshift({\n        result: emptyReports\n      })\n      const workingDirs = this.src\n      for (const workingDir of workingDirs) {\n        this.exclude.globSync(workingDir).forEach((f) => {\n          const fullPath = resolve(workingDir, f)\n          if (!fileIndex.has(fullPath)) {\n            const ext = extname(fullPath)\n            if (ext === '.js' || ext === '.ts' || ext === '.mjs') {\n              const stat = statSync(fullPath)\n              const sourceMap = getSourceMapFromFile(fullPath)\n              if (sourceMap !== undefined) {\n                this.sourceMapCache[`file://${fullPath}`] = { data: JSON.parse(readFileSync(sourceMap).toString()) }\n              }\n              emptyReports.push({\n                scriptId: 0,\n                url: resolve(fullPath),\n                functions: [{\n                  functionName: '(empty-report)',\n                  ranges: [{\n                    startOffset: 0,\n                    endOffset: stat.size,\n                    count: 0\n                  }],\n                  isBlockCoverage: true\n                }]\n              })\n            }\n          }\n        })\n      }\n    }\n\n    return mergeProcessCovs(v8ProcessCovs)\n  }\n\n  /**\n   * Make sure v8ProcessCov actually contains coverage information.\n   *\n   * @return {boolean} does it look like v8ProcessCov?\n   * @private\n   */\n  _isCoverageObject (maybeV8ProcessCov) {\n    return maybeV8ProcessCov && Array.isArray(maybeV8ProcessCov.result)\n  }\n\n  /**\n   * Returns the list of V8 process coverages generated by Node.\n   *\n   * @return {ProcessCov[]} Process coverages generated by Node.\n   * @private\n   */\n  _loadReports () {\n    const reports = []\n    for (const file of readdirSync(this.tempDirectory)) {\n      try {\n        reports.push(JSON.parse(readFileSync(\n          resolve(this.tempDirectory, file),\n          'utf8'\n        )))\n      } catch (err) {\n        debuglog(`${err.stack}`)\n      }\n    }\n    return reports\n  }\n\n  /**\n   * Normalizes a process coverage.\n   *\n   * This function replaces file URLs (`url` property) by their corresponding\n   * system-dependent path and applies the current inclusion rules to filter out\n   * the excluded script coverages.\n   *\n   * The result is a copy of the input, with script coverages filtered based\n   * on their `url` and the current inclusion rules.\n   * There is no deep cloning.\n   *\n   * @param v8ProcessCov V8 process coverage to normalize.\n   * @param fileIndex a Set<string> of paths discovered in coverage\n   * @return {v8ProcessCov} Normalized V8 process coverage.\n   * @private\n   */\n  _normalizeProcessCov (v8ProcessCov, fileIndex) {\n    const result = []\n    for (const v8ScriptCov of v8ProcessCov.result) {\n      // https://github.com/nodejs/node/pull/35498 updates Node.js'\n      // builtin module filenames:\n      if (/^node:/.test(v8ScriptCov.url)) {\n        v8ScriptCov.url = `${v8ScriptCov.url.replace(/^node:/, '')}.js`\n      }\n      if (/^file:\\/\\//.test(v8ScriptCov.url)) {\n        try {\n          v8ScriptCov.url = furi.toSysPath(v8ScriptCov.url)\n          fileIndex.add(v8ScriptCov.url)\n        } catch (err) {\n          debuglog(`${err.stack}`)\n          continue\n        }\n      }\n      if (this.exclude.shouldInstrument(v8ScriptCov.url) &&\n        (!this.omitRelative || isAbsolute(v8ScriptCov.url))) {\n        result.push(v8ScriptCov)\n      }\n    }\n    return { result }\n  }\n}\n\nmodule.exports = function (opts) {\n  return new Report(opts)\n}\n",
    "node_modules/v8-to-istanbul/lib/v8-to-istanbul.js": "const assert = require('assert')\nconst convertSourceMap = require('convert-source-map')\nconst { dirname, isAbsolute, join, resolve } = require('path')\nconst CovBranch = require('./branch')\nconst CovFunction = require('./function')\nconst CovSource = require('./source')\nconst compatError = Error(`requires Node.js ${require('../package.json').engines.node}`)\nlet readFile = () => { throw compatError }\ntry {\n  readFile = require('fs').promises.readFile\n} catch (_err) {\n  // most likely we're on an older version of Node.js.\n}\nconst { SourceMapConsumer } = require('source-map')\nconst isOlderNode10 = /^v10\\.(([0-9]\\.)|(1[0-5]\\.))/u.test(process.version)\nconst isNode8 = /^v8\\./.test(process.version)\n\n// Injected when Node.js is loading script into isolate pre Node 10.16.x.\n// see: https://github.com/nodejs/node/pull/21573.\nconst cjsWrapperLength = isOlderNode10 ? require('module').wrapper[0].length : 0\n\nmodule.exports = class V8ToIstanbul {\n  constructor (scriptPath, wrapperLength, sources, excludePath) {\n    assert(typeof scriptPath === 'string', 'scriptPath must be a string')\n    assert(!isNode8, 'This module does not support node 8 or lower, please upgrade to node 10')\n    this.path = parsePath(scriptPath)\n    this.wrapperLength = wrapperLength === undefined ? cjsWrapperLength : wrapperLength\n    this.excludePath = excludePath || (() => false)\n    this.sources = sources || {}\n    this.generatedLines = []\n    this.branches = {}\n    this.functions = {}\n    this.covSources = []\n    this.rawSourceMap = undefined\n    this.sourceMap = undefined\n    this.sourceTranspiled = undefined\n    // Indicate that this report was generated with placeholder data from\n    // running --all:\n    this.all = false\n  }\n\n  async load () {\n    const rawSource = this.sources.source || await readFile(this.path, 'utf8')\n    this.rawSourceMap = this.sources.sourceMap ||\n      // if we find a source-map (either inline, or a .map file) we load\n      // both the transpiled and original source, both of which are used during\n      // the backflips we perform to remap absolute to relative positions.\n      convertSourceMap.fromSource(rawSource) || convertSourceMap.fromMapFileSource(rawSource, dirname(this.path))\n\n    if (this.rawSourceMap) {\n      if (this.rawSourceMap.sourcemap.sources.length > 1) {\n        this.sourceMap = await new SourceMapConsumer(this.rawSourceMap.sourcemap)\n        this.covSources = this.sourceMap.sourcesContent.map((rawSource, i) => ({ source: new CovSource(rawSource, this.wrapperLength), path: this.sourceMap.sources[i] }))\n        this.sourceTranspiled = new CovSource(rawSource, this.wrapperLength)\n      } else {\n        const candidatePath = this.rawSourceMap.sourcemap.sources.length >= 1 ? this.rawSourceMap.sourcemap.sources[0] : this.rawSourceMap.sourcemap.file\n        this.path = this._resolveSource(this.rawSourceMap, candidatePath)\n        this.sourceMap = await new SourceMapConsumer(this.rawSourceMap.sourcemap)\n\n        let originalRawSource\n        if (this.sources.sourceMap && this.sources.sourceMap.sourcemap && this.sources.sourceMap.sourcemap.sourcesContent && this.sources.sourceMap.sourcemap.sourcesContent.length === 1) {\n          // If the sourcesContent field has been provided, return it rather than attempting\n          // to load the original source from disk.\n          // TODO: investigate whether there's ever a case where we hit this logic with 1:many sources.\n          originalRawSource = this.sources.sourceMap.sourcemap.sourcesContent[0]\n        } else if (this.sources.originalSource) {\n          // Original source may be populated on the sources object.\n          originalRawSource = this.sources.originalSource\n        } else if (this.sourceMap.sourcesContent && this.sourceMap.sourcesContent[0]) {\n          // perhaps we loaded sourcesContent was populated by an inline source map, or .map file?\n          // TODO: investigate whether there's ever a case where we hit this logic with 1:many sources.\n          originalRawSource = this.sourceMap.sourcesContent[0]\n        } else {\n          // We fallback to reading the original source from disk.\n          originalRawSource = await readFile(this.path, 'utf8')\n        }\n        this.covSources = [{ source: new CovSource(originalRawSource, this.wrapperLength), path: this.path }]\n        this.sourceTranspiled = new CovSource(rawSource, this.wrapperLength)\n      }\n    } else {\n      this.covSources = [{ source: new CovSource(rawSource, this.wrapperLength), path: this.path }]\n    }\n  }\n\n  _resolveSource (rawSourceMap, sourcePath) {\n    sourcePath = sourcePath.replace(/(^file:\\/\\/)|(^webpack:\\/\\/)/, '')\n    const sourceRoot = rawSourceMap.sourcemap.sourceRoot ? rawSourceMap.sourcemap.sourceRoot.replace('file://', '') : ''\n    const candidatePath = join(sourceRoot, sourcePath)\n\n    if (isAbsolute(candidatePath)) {\n      return candidatePath\n    } else {\n      return resolve(dirname(this.path), candidatePath)\n    }\n  }\n\n  applyCoverage (blocks) {\n    blocks.forEach(block => {\n      block.ranges.forEach((range, i) => {\n        const { startCol, endCol, path, covSource } = this._maybeRemapStartColEndCol(range)\n        if (this.excludePath(path)) {\n          return\n        }\n        const lines = covSource.lines.filter(line => {\n          // Upstream tooling can provide a block with the functionName\n          // (empty-report), this will result in a report that has all\n          // lines zeroed out.\n          if (block.functionName === '(empty-report)') {\n            line.count = 0\n            this.all = true\n            return true\n          }\n\n          return startCol < line.endCol && endCol >= line.startCol\n        })\n        const startLineInstance = lines[0]\n        const endLineInstance = lines[lines.length - 1]\n\n        if (block.isBlockCoverage && lines.length) {\n          this.branches[path] = this.branches[path] || []\n          // record branches.\n          this.branches[path].push(new CovBranch(\n            startLineInstance.line,\n            startCol - startLineInstance.startCol,\n            endLineInstance.line,\n            endCol - endLineInstance.startCol,\n            range.count\n          ))\n\n          // if block-level granularity is enabled, we we still create a single\n          // CovFunction tracking object for each set of ranges.\n          if (block.functionName && i === 0) {\n            this.functions[path] = this.functions[path] || []\n            this.functions[path].push(new CovFunction(\n              block.functionName,\n              startLineInstance.line,\n              startCol - startLineInstance.startCol,\n              endLineInstance.line,\n              endCol - endLineInstance.startCol,\n              range.count\n            ))\n          }\n        } else if (block.functionName && lines.length) {\n          this.functions[path] = this.functions[path] || []\n          // record functions.\n          this.functions[path].push(new CovFunction(\n            block.functionName,\n            startLineInstance.line,\n            startCol - startLineInstance.startCol,\n            endLineInstance.line,\n            endCol - endLineInstance.startCol,\n            range.count\n          ))\n        }\n\n        // record the lines (we record these as statements, such that we're\n        // compatible with Istanbul 2.0).\n        lines.forEach(line => {\n          // make sure branch spans entire line; don't record 'goodbye'\n          // branch in `const foo = true ? 'hello' : 'goodbye'` as a\n          // 0 for line coverage.\n          //\n          // All lines start out with coverage of 1, and are later set to 0\n          // if they are not invoked; line.ignore prevents a line from being\n          // set to 0, and is set if the special comment /* c8 ignore next */\n          // is used.\n\n          if (startCol <= line.startCol && endCol >= line.endCol && !line.ignore) {\n            line.count = range.count\n          }\n        })\n      })\n    })\n  }\n\n  _maybeRemapStartColEndCol (range) {\n    let covSource = this.covSources[0].source\n    let startCol = Math.max(0, range.startOffset - covSource.wrapperLength)\n    let endCol = Math.min(covSource.eof, range.endOffset - covSource.wrapperLength)\n    let path = this.path\n\n    if (this.sourceMap) {\n      startCol = Math.max(0, range.startOffset - this.sourceTranspiled.wrapperLength)\n      endCol = Math.min(this.sourceTranspiled.eof, range.endOffset - this.sourceTranspiled.wrapperLength)\n\n      const { startLine, relStartCol, endLine, relEndCol, source } = this.sourceTranspiled.offsetToOriginalRelative(\n        this.sourceMap,\n        startCol,\n        endCol\n      )\n\n      const matchingSource = this.covSources.find(covSource => covSource.path === source)\n      covSource = matchingSource ? matchingSource.source : this.covSources[0].source\n      path = matchingSource ? matchingSource.path : this.covSources[0].path\n\n      // next we convert these relative positions back to absolute positions\n      // in the original source (which is the format expected in the next step).\n      startCol = covSource.relativeToOffset(startLine, relStartCol)\n      endCol = covSource.relativeToOffset(endLine, relEndCol)\n    }\n\n    return {\n      path,\n      covSource,\n      startCol,\n      endCol\n    }\n  }\n\n  getInnerIstanbul (source, path) {\n    // We apply the \"Resolving Sources\" logic (as defined in\n    // sourcemaps.info/spec.html) as a final step for 1:many source maps.\n    // for 1:1 source maps, the resolve logic is applied while loading.\n    //\n    // TODO: could we move the resolving logic for 1:1 source maps to the final\n    // step as well? currently this breaks some tests in c8.\n    let resolvedPath = path\n    if (this.rawSourceMap && this.rawSourceMap.sourcemap.sources.length > 1) {\n      resolvedPath = this._resolveSource(this.rawSourceMap, path)\n    }\n\n    if (this.excludePath(resolvedPath)) {\n      return\n    }\n\n    return {\n      [resolvedPath]: {\n        path: resolvedPath,\n        all: this.all,\n        ...this._statementsToIstanbul(source, path),\n        ...this._branchesToIstanbul(source, path),\n        ...this._functionsToIstanbul(source, path)\n      }\n    }\n  }\n\n  toIstanbul () {\n    return this.covSources.reduce((istanbulOuter, { source, path }) => Object.assign(istanbulOuter, this.getInnerIstanbul(source, path)), {})\n  }\n\n  _statementsToIstanbul (source, path) {\n    const statements = {\n      statementMap: {},\n      s: {}\n    }\n    source.lines.forEach((line, index) => {\n      statements.statementMap[`${index}`] = line.toIstanbul()\n      statements.s[`${index}`] = line.count\n    })\n    return statements\n  }\n\n  _branchesToIstanbul (source, path) {\n    const branches = {\n      branchMap: {},\n      b: {}\n    }\n    this.branches[path] = this.branches[path] || []\n    this.branches[path].forEach((branch, index) => {\n      const ignore = source.lines[branch.startLine - 1].ignore\n      branches.branchMap[`${index}`] = branch.toIstanbul()\n      branches.b[`${index}`] = [ignore ? 1 : branch.count]\n    })\n    return branches\n  }\n\n  _functionsToIstanbul (source, path) {\n    const functions = {\n      fnMap: {},\n      f: {}\n    }\n    this.functions[path] = this.functions[path] || []\n    this.functions[path].forEach((fn, index) => {\n      const ignore = source.lines[fn.startLine - 1].ignore\n      functions.fnMap[`${index}`] = fn.toIstanbul()\n      functions.f[`${index}`] = ignore ? 1 : fn.count\n    })\n    return functions\n  }\n}\n\nfunction parsePath (scriptPath) {\n  return scriptPath.replace('file://', '')\n}\n"
  }
}