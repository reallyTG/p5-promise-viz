{
  "promises": {
    "0": {
      "source": "tests/dataApi/deleteSnippet-test.js:22:18:22:18",
      "startTime": "2736093626656745",
      "endTime": "2736093626693484",
      "elapsedTime": "36739",
      "asyncId": 13,
      "triggerAsyncId": 12,
      "io": false,
      "createdIn": 1628012378385,
      "functionName": " Test.fn",
      "userCode": false,
      "line": "\n\ntest.serial('Delete a snippet', t => {\n  return Promise.resolve()\n    .then(function doTest() {\n      return Promise.all([deleteSnippet(newSnippet, snippetFile)])\n    }",
      "startLine": 22,
      "startCol": 18,
      "endLine": 22,
      "endCol": 18,
      "file": "tests/dataApi/deleteSnippet-test.js",
      "triggers": [
        14,
        14
      ],
      "uniqueid": 0
    },
    "1": {
      "source": "tests/dataApi/deleteSnippet-test.js:23:6:23:6",
      "startTime": "2736093627196988",
      "endTime": "2736093636894588",
      "elapsedTime": "9697600",
      "asyncId": 14,
      "triggerAsyncId": 13,
      "io": false,
      "createdIn": 1628012378385,
      "functionName": " Test.fn",
      "userCode": false,
      "triggers": [
        27,
        26,
        30,
        15
      ],
      "line": "\ntest.serial('Delete a snippet', t => {\n  return Promise.resolve()\n    .then(function doTest() {\n      return Promise.all([deleteSnippet(newSnippet, snippetFile)])\n    })\n    .then(function assert(data) ",
      "startLine": 23,
      "startCol": 6,
      "endLine": 23,
      "endCol": 6,
      "file": "tests/dataApi/deleteSnippet-test.js",
      "uniqueid": 1
    },
    "2": {
      "source": "tests/dataApi/deleteSnippet-test.js:26:6:26:6",
      "startTime": "2736093627629348",
      "endTime": "2736093637161217",
      "elapsedTime": "9531869",
      "asyncId": 15,
      "triggerAsyncId": 14,
      "io": false,
      "createdIn": 1628012378385,
      "functionName": " Test.fn",
      "userCode": false,
      "line": "\n      return Promise.all([deleteSnippet(newSnippet, snippetFile)])\n    })\n    .then(function assert(data) {\n      data = data[0]\n      const snippets = JSON.parse(sander.readFileSync(snippetFile))\n      t.is(snippets.length, 0",
      "startLine": 26,
      "startCol": 6,
      "endLine": 26,
      "endCol": 6,
      "file": "tests/dataApi/deleteSnippet-test.js",
      "triggers": [
        17
      ],
      "uniqueid": 2
    },
    "3": {
      "source": "node_modules/ava/lib/test.js:393:7:393:7",
      "startTime": "2736093628956055",
      "endTime": "2736093637631269",
      "elapsedTime": "8675214",
      "asyncId": 18,
      "triggerAsyncId": 17,
      "io": "",
      "createdIn": 1628012378385,
      "functionName": "",
      "userCode": false,
      "triggers": [
        39
      ],
      "line": "\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => resolve(this.finishPromised()));\n\t\t\t});\n\t\t}",
      "startLine": 393,
      "startCol": 7,
      "endLine": 393,
      "endCol": 7,
      "file": "node_modules/ava/lib/test.js",
      "uniqueid": 3
    },
    "4": {
      "source": "browser/main/lib/dataApi/deleteSnippet.js:19:10:19:10",
      "startTime": "2736093633616212",
      "endTime": "2736093636709922",
      "elapsedTime": "3093710",
      "asyncId": 26,
      "triggerAsyncId": 14,
      "io": false,
      "createdIn": 1628012378385,
      "functionName": " deleteSnippet",
      "userCode": false,
      "line": "\n          resolve(snippet)\n        }\n      )\n    })\n  })\n}",
      "startLine": 19,
      "startCol": 10,
      "endLine": 19,
      "endCol": 10,
      "file": "browser/main/lib/dataApi/deleteSnippet.js",
      "triggers": [
        31
      ],
      "uniqueid": 4
    },
    "5": {
      "source": "browser/main/lib/dataApi/fetchSnippet.js:14:10:14:10",
      "startTime": "2736093634035027",
      "endTime": "2736093635917636",
      "elapsedTime": "1882609",
      "asyncId": 27,
      "triggerAsyncId": 14,
      "io": false,
      "createdIn": 1628012378385,
      "functionName": " fetchSnippet",
      "userCode": false,
      "line": "\n        const snippet = snippets.find(snippet => {\n          return snippet.id === id\n        })\n        resolve(snippet)\n      }\n      resolve(snippets",
      "startLine": 14,
      "startCol": 10,
      "endLine": 14,
      "endCol": 10,
      "file": "browser/main/lib/dataApi/fetchSnippet.js",
      "triggers": [
        29
      ],
      "uniqueid": 5
    },
    "6": {
      "source": "browser/main/lib/dataApi/deleteSnippet.js:20:52:20:52",
      "startTime": "2736093634622789",
      "endTime": "2736093636156865",
      "elapsedTime": "1534076",
      "asyncId": 29,
      "triggerAsyncId": 27,
      "io": "",
      "createdIn": 1628012378385,
      "functionName": "",
      "userCode": false,
      "line": "",
      "startLine": 20,
      "startCol": 52,
      "endLine": 20,
      "endCol": 52,
      "file": "browser/main/lib/dataApi/deleteSnippet.js",
      "triggers": [],
      "uniqueid": 6
    },
    "7": {
      "source": "tests/dataApi/deleteSnippet-test.js:24:22:24:22",
      "startTime": "2736093634838634",
      "endTime": "2736093636777719",
      "elapsedTime": "1939085",
      "asyncId": 30,
      "triggerAsyncId": 14,
      "io": false,
      "createdIn": 1628012378385,
      "functionName": " doTest",
      "userCode": false,
      "line": "\n  return Promise.resolve()\n    .then(function doTest() {\n      return Promise.all([deleteSnippet(newSnippet, snippetFile)])\n    })\n    .then(function assert(data) {\n      data = data[0",
      "startLine": 24,
      "startCol": 22,
      "endLine": 24,
      "endCol": 22,
      "file": "tests/dataApi/deleteSnippet-test.js",
      "triggers": [
        32
      ],
      "uniqueid": 7
    },
    "8": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "2736093635272417",
      "endTime": "2736093636937037",
      "elapsedTime": "1664620",
      "asyncId": 32,
      "triggerAsyncId": 30,
      "io": "",
      "createdIn": 1628012378385,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 8
    },
    "9": {
      "source": "node_modules/ava/lib/test.js:435:10:435:10",
      "startTime": "2736093637461691",
      "endTime": "2736093637546991",
      "elapsedTime": "85300",
      "asyncId": 39,
      "triggerAsyncId": 18,
      "io": false,
      "createdIn": 1628012378385,
      "functionName": " Test.finishPromised",
      "userCode": false,
      "line": "\n\n\tfinishPromised() {\n\t\treturn new Promise(resolve => {\n\t\t\tresolve(this.finish());\n\t\t});\n\t",
      "startLine": 435,
      "startCol": 10,
      "endLine": 435,
      "endCol": 10,
      "file": "node_modules/ava/lib/test.js",
      "triggers": [],
      "uniqueid": 9
    }
  },
  "antipatterns": {
    "0": {
      "patternID": "pattern2",
      "file": "browser/main/Main.js",
      "startLine": "137",
      "startCol": "16",
      "endLine": "138",
      "endCol": "36"
    },
    "1": {
      "patternID": "pattern2",
      "file": "browser/main/lib/dataApi/addStorage.js",
      "startLine": "44",
      "startCol": "10",
      "endLine": "45",
      "endCol": "29"
    },
    "2": {
      "patternID": "pattern2",
      "file": "browser/main/lib/dataApi/init.js",
      "startLine": "88",
      "startCol": "10",
      "endLine": "94",
      "endCol": "6"
    },
    "3": {
      "patternID": "pattern2",
      "file": "browser/main/lib/dataApi/migrateFromV6Storage.js",
      "startLine": "9",
      "startCol": "10",
      "endLine": "14",
      "endCol": "6"
    },
    "4": {
      "patternID": "pattern2",
      "file": "browser/main/lib/dataApi/moveNote.js",
      "startLine": "31",
      "startCol": "12",
      "endLine": "60",
      "endCol": "8"
    },
    "5": {
      "patternID": "pattern2",
      "file": "tests/dataApi/addStorage.js",
      "startLine": "37",
      "startCol": "10",
      "endLine": "40",
      "endCol": "6"
    },
    "6": {
      "patternID": "pattern2",
      "file": "tests/dataApi/createFolder.test.js",
      "startLine": "34",
      "startCol": "10",
      "endLine": "37",
      "endCol": "6"
    },
    "7": {
      "patternID": "pattern2",
      "file": "tests/dataApi/createNote.test.js",
      "startLine": "61",
      "startCol": "10",
      "endLine": "67",
      "endCol": "6"
    },
    "8": {
      "patternID": "pattern2",
      "file": "tests/dataApi/createSnippet.test.js",
      "startLine": "14",
      "startCol": "10",
      "endLine": "15",
      "endCol": "58"
    },
    "9": {
      "patternID": "pattern2",
      "file": "tests/dataApi/deleteFolder.test.js",
      "startLine": "52",
      "startCol": "10",
      "endLine": "71",
      "endCol": "6"
    },
    "10": {
      "patternID": "pattern2",
      "file": "tests/dataApi/deleteNote-test.js",
      "startLine": "49",
      "startCol": "10",
      "endLine": "68",
      "endCol": "6"
    },
    "11": {
      "patternID": "pattern2",
      "file": "tests/dataApi/deleteSnippet-test.js",
      "startLine": "22",
      "startCol": "10",
      "endLine": "25",
      "endCol": "6"
    },
    "12": {
      "patternID": "pattern2",
      "file": "tests/dataApi/init.js",
      "startLine": "55",
      "startCol": "10",
      "endLine": "58",
      "endCol": "6"
    },
    "13": {
      "patternID": "pattern2",
      "file": "tests/dataApi/migrateFromV6Storage-test.js",
      "startLine": "31",
      "startCol": "10",
      "endLine": "34",
      "endCol": "6"
    },
    "14": {
      "patternID": "pattern2",
      "file": "tests/dataApi/moveNote-test.js",
      "startLine": "39",
      "startCol": "10",
      "endLine": "45",
      "endCol": "6"
    },
    "15": {
      "patternID": "pattern2",
      "file": "tests/dataApi/removeStorage-test.js",
      "startLine": "27",
      "startCol": "10",
      "endLine": "30",
      "endCol": "6"
    },
    "16": {
      "patternID": "pattern2",
      "file": "tests/dataApi/renameStorage-test.js",
      "startLine": "28",
      "startCol": "10",
      "endLine": "31",
      "endCol": "6"
    },
    "17": {
      "patternID": "pattern2",
      "file": "tests/dataApi/reorderFolder-test.js",
      "startLine": "32",
      "startCol": "10",
      "endLine": "35",
      "endCol": "6"
    },
    "18": {
      "patternID": "pattern2",
      "file": "tests/dataApi/toggleStorage-test.js",
      "startLine": "28",
      "startCol": "10",
      "endLine": "31",
      "endCol": "6"
    },
    "19": {
      "patternID": "pattern2",
      "file": "tests/dataApi/updateFolder-test.js",
      "startLine": "34",
      "startCol": "10",
      "endLine": "37",
      "endCol": "6"
    },
    "20": {
      "patternID": "pattern2",
      "file": "tests/dataApi/updateNote-test.js",
      "startLine": "87",
      "startCol": "10",
      "endLine": "100",
      "endCol": "6"
    },
    "21": {
      "patternID": "pattern2",
      "file": "tests/dataApi/updateSnippet-test.js",
      "startLine": "29",
      "startCol": "10",
      "endLine": "32",
      "endCol": "6"
    },
    "22": {
      "patternID": "pattern9",
      "file": "browser/main/lib/dataApi/createNoteFromUrl.js",
      "startLine": "36",
      "startCol": "10",
      "endLine": "99",
      "endCol": "4"
    },
    "23": {
      "patternID": "pattern9",
      "file": "browser/main/lib/dataApi/createSnippet.js",
      "startLine": "7",
      "startCol": "10",
      "endLine": "30",
      "endCol": "4"
    },
    "24": {
      "patternID": "pattern9",
      "file": "browser/main/lib/dataApi/deleteSnippet.js",
      "startLine": "6",
      "startCol": "10",
      "endLine": "20",
      "endCol": "4"
    },
    "25": {
      "patternID": "pattern8",
      "file": "browser/main/lib/dataApi/attachmentManagement.js",
      "startLine": "25",
      "startCol": "12",
      "endLine": "29",
      "endCol": "6"
    },
    "26": {
      "patternID": "pattern8",
      "file": "browser/main/lib/dataApi/attachmentManagement.js",
      "startLine": "31",
      "startCol": "12",
      "endLine": "39",
      "endCol": "6"
    },
    "27": {
      "patternID": "pattern8",
      "file": "browser/main/lib/dataApi/attachmentManagement.js",
      "startLine": "99",
      "startCol": "10",
      "endLine": "103",
      "endCol": "4"
    },
    "28": {
      "patternID": "pattern8",
      "file": "browser/main/lib/dataApi/attachmentManagement.js",
      "startLine": "617",
      "startCol": "10",
      "endLine": "662",
      "endCol": "4"
    },
    "29": {
      "patternID": "pattern8",
      "file": "browser/main/lib/dataApi/copyFile.js",
      "startLine": "16",
      "startCol": "10",
      "endLine": "30",
      "endCol": "4"
    },
    "30": {
      "patternID": "pattern8",
      "file": "browser/main/modals/PreferencesModal/StoragesTab.js",
      "startLine": "19",
      "startCol": "10",
      "endLine": "31",
      "endCol": "4"
    },
    "31": {
      "patternID": "pattern10",
      "file": "lib/main-menu.js",
      "startLine": "492",
      "startCol": "14",
      "endLine": "494",
      "endCol": "7"
    },
    "32": {
      "patternID": "pattern4",
      "file": "browser/main/lib/dataApi/copyFile.js",
      "startLine": "11",
      "startCol": "1",
      "endLine": "31",
      "endCol": "1"
    },
    "33": {
      "patternID": "pattern5",
      "file": "browser/components/CodeEditor.js",
      "startLine": "1227",
      "startCol": "47",
      "endLine": "1245",
      "endCol": "5"
    },
    "34": {
      "patternID": "pattern5",
      "file": "browser/components/CodeEditor.js",
      "startLine": "1275",
      "startCol": "19",
      "endLine": "1286",
      "endCol": "3"
    },
    "35": {
      "patternID": "pattern5",
      "file": "browser/components/CodeEditor.js",
      "startLine": "1293",
      "startCol": "40",
      "endLine": "1305",
      "endCol": "5"
    },
    "36": {
      "patternID": "pattern5",
      "file": "browser/main/lib/dataApi/attachmentManagement.js",
      "startLine": "23",
      "startCol": "1",
      "endLine": "41",
      "endCol": "1"
    },
    "37": {
      "patternID": "pattern5",
      "file": "browser/main/lib/dataApi/attachmentManagement.js",
      "startLine": "59",
      "startCol": "1",
      "endLine": "104",
      "endCol": "1"
    },
    "38": {
      "patternID": "pattern5",
      "file": "browser/main/lib/dataApi/attachmentManagement.js",
      "startLine": "166",
      "startCol": "1",
      "endLine": "236",
      "endCol": "1"
    },
    "39": {
      "patternID": "pattern5",
      "file": "browser/main/lib/dataApi/attachmentManagement.js",
      "startLine": "616",
      "startCol": "1",
      "endLine": "663",
      "endCol": "1"
    },
    "40": {
      "patternID": "pattern5",
      "file": "browser/main/lib/dataApi/attachmentManagement.js",
      "startLine": "841",
      "startCol": "1",
      "endLine": "908",
      "endCol": "1"
    },
    "41": {
      "patternID": "pattern5",
      "file": "browser/main/lib/dataApi/createNoteFromUrl.js",
      "startLine": "29",
      "startCol": "1",
      "endLine": "100",
      "endCol": "1"
    },
    "42": {
      "patternID": "pattern5",
      "file": "browser/main/lib/dataApi/createSnippet.js",
      "startLine": "6",
      "startCol": "1",
      "endLine": "31",
      "endCol": "1"
    },
    "43": {
      "patternID": "pattern5",
      "file": "browser/main/lib/dataApi/deleteSnippet.js",
      "startLine": "5",
      "startCol": "1",
      "endLine": "21",
      "endCol": "1"
    },
    "44": {
      "patternID": "pattern5",
      "file": "browser/main/lib/dataApi/exportNote.js",
      "startLine": "63",
      "startCol": "1",
      "endLine": "71",
      "endCol": "1"
    },
    "45": {
      "patternID": "pattern5",
      "file": "browser/main/lib/dataApi/fetchSnippet.js",
      "startLine": "4",
      "startCol": "1",
      "endLine": "20",
      "endCol": "1"
    },
    "46": {
      "patternID": "pattern5",
      "file": "browser/main/lib/dataApi/formatPDF.js",
      "startLine": "5",
      "startCol": "10",
      "endLine": "25",
      "endCol": "3"
    },
    "47": {
      "patternID": "pattern5",
      "file": "browser/main/lib/dataApi/updateSnippet.js",
      "startLine": "4",
      "startCol": "1",
      "endLine": "39",
      "endCol": "1"
    },
    "48": {
      "patternID": "pattern5",
      "file": "browser/main/modals/PreferencesModal/StoragesTab.js",
      "startLine": "15",
      "startCol": "1",
      "endLine": "32",
      "endCol": "1"
    },
    "49": {
      "patternID": "pattern5",
      "file": "dev-scripts/dev.js",
      "startLine": "18",
      "startCol": "1",
      "endLine": "49",
      "endCol": "1"
    },
    "50": {
      "patternID": "pattern11",
      "file": "browser/components/CodeEditor.js",
      "startLine": "1227",
      "startCol": "12",
      "endLine": "1245",
      "endCol": "6"
    },
    "51": {
      "patternID": "pattern11",
      "file": "browser/components/CodeEditor.js",
      "startLine": "1293",
      "startCol": "12",
      "endLine": "1305",
      "endCol": "6"
    },
    "52": {
      "patternID": "pattern11",
      "file": "browser/main/Main.js",
      "startLine": "60",
      "startCol": "5",
      "endLine": "140",
      "endCol": "8"
    },
    "53": {
      "patternID": "pattern11",
      "file": "browser/main/Main.js",
      "startLine": "60",
      "startCol": "5",
      "endLine": "84",
      "endCol": "8"
    },
    "54": {
      "patternID": "pattern11",
      "file": "browser/main/NoteList/index.js",
      "startLine": "1006",
      "startCol": "5",
      "endLine": "1025",
      "endCol": "8"
    },
    "55": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/addStorage.js",
      "startLine": "44",
      "startCol": "10",
      "endLine": "80",
      "endCol": "6"
    },
    "56": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/attachmentManagement.js",
      "startLine": "358",
      "startCol": "20",
      "endLine": "376",
      "endCol": "16"
    },
    "57": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/attachmentManagement.js",
      "startLine": "1033",
      "startCol": "9",
      "endLine": "1077",
      "endCol": "10"
    },
    "58": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/attachmentManagement.js",
      "startLine": "1052",
      "startCol": "18",
      "endLine": "1076",
      "endCol": "12"
    },
    "59": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/deleteFolder.js",
      "startLine": "29",
      "startCol": "10",
      "endLine": "54",
      "endCol": "6"
    },
    "60": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/deleteFolder.js",
      "startLine": "29",
      "startCol": "10",
      "endLine": "37",
      "endCol": "6"
    },
    "61": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/exportFolder.js",
      "startLine": "36",
      "startCol": "10",
      "endLine": "68",
      "endCol": "6"
    },
    "62": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/exportFolder.js",
      "startLine": "36",
      "startCol": "10",
      "endLine": "47",
      "endCol": "6"
    },
    "63": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/exportStorage.js",
      "startLine": "35",
      "startCol": "10",
      "endLine": "82",
      "endCol": "6"
    },
    "64": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/exportStorage.js",
      "startLine": "35",
      "startCol": "10",
      "endLine": "43",
      "endCol": "6"
    },
    "65": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/migrateFromV6Storage.js",
      "startLine": "9",
      "startCol": "10",
      "endLine": "87",
      "endCol": "6"
    },
    "66": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/migrateFromV6Storage.js",
      "startLine": "9",
      "startCol": "10",
      "endLine": "29",
      "endCol": "6"
    },
    "67": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/moveNote.js",
      "startLine": "20",
      "startCol": "10",
      "endLine": "107",
      "endCol": "4"
    },
    "68": {
      "patternID": "pattern11",
      "file": "browser/main/lib/dataApi/moveNote.js",
      "startLine": "31",
      "startCol": "12",
      "endLine": "60",
      "endCol": "8"
    },
    "69": {
      "patternID": "pattern11",
      "file": "browser/main/modals/PreferencesModal/InfoTab.js",
      "startLine": "54",
      "startCol": "5",
      "endLine": "74",
      "endCol": "8"
    },
    "70": {
      "patternID": "pattern11",
      "file": "tests/dataApi/deleteFolder.test.js",
      "startLine": "52",
      "startCol": "10",
      "endLine": "71",
      "endCol": "6"
    },
    "71": {
      "patternID": "pattern11",
      "file": "tests/dataApi/deleteNote-test.js",
      "startLine": "49",
      "startCol": "10",
      "endLine": "68",
      "endCol": "6"
    },
    "72": {
      "patternID": "pattern11",
      "file": "tests/dataApi/updateNote-test.js",
      "startLine": "87",
      "startCol": "10",
      "endLine": "100",
      "endCol": "6"
    }
  },
  "files": {
    "tests/dataApi/deleteSnippet-test.js": "const test = require('ava')\nconst deleteSnippet = require('browser/main/lib/dataApi/deleteSnippet')\nconst sander = require('sander')\nconst os = require('os')\nconst path = require('path')\nconst crypto = require('crypto')\n\nconst snippetFilePath = path.join(os.tmpdir(), 'test', 'delete-snippet')\nconst snippetFile = path.join(snippetFilePath, 'snippets.json')\nconst newSnippet = {\n  id: crypto.randomBytes(16).toString('hex'),\n  name: 'Unnamed snippet',\n  prefix: [],\n  content: ''\n}\n\ntest.beforeEach(t => {\n  sander.writeFileSync(snippetFile, JSON.stringify([newSnippet]))\n})\n\ntest.serial('Delete a snippet', t => {\n  return Promise.resolve()\n    .then(function doTest() {\n      return Promise.all([deleteSnippet(newSnippet, snippetFile)])\n    })\n    .then(function assert(data) {\n      data = data[0]\n      const snippets = JSON.parse(sander.readFileSync(snippetFile))\n      t.is(snippets.length, 0)\n    })\n})\n\ntest.after.always(() => {\n  sander.rimrafSync(snippetFilePath)\n})\n",
    "browser/main/lib/dataApi/deleteSnippet.js": "import fs from 'fs'\nimport consts from 'browser/lib/consts'\nimport fetchSnippet from 'browser/main/lib/dataApi/fetchSnippet'\n\nfunction deleteSnippet(snippet, snippetFile) {\n  console.log('Code Executed');\n  return new Promise((resolve, reject) => {\n    fetchSnippet(null, snippetFile).then(snippets => {\n      snippets = snippets.filter(\n        currentSnippet => currentSnippet.id !== snippet.id\n      )\n      fs.writeFile(\n        snippetFile || consts.SNIPPET_FILE,\n        JSON.stringify(snippets, null, 4),\n        err => {\n          if (err) reject(err)\n          resolve(snippet)\n        }\n      )\n    })\n  })\n}\n\nmodule.exports = deleteSnippet\n",
    "browser/main/lib/dataApi/fetchSnippet.js": "import fs from 'fs'\nimport consts from 'browser/lib/consts'\n\nfunction fetchSnippet(id, snippetFile) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(snippetFile || consts.SNIPPET_FILE, 'utf8', (err, data) => {\n      if (err) {\n        reject(err)\n      }\n      const snippets = JSON.parse(data)\n      if (id) {\n        const snippet = snippets.find(snippet => {\n          return snippet.id === id\n        })\n        resolve(snippet)\n      }\n      resolve(snippets)\n    })\n  })\n}\n\nmodule.exports = fetchSnippet\n",
    "node_modules/ava/lib/test.js": "'use strict';\nconst isGeneratorFn = require('is-generator-fn');\nconst co = require('co-with-promise');\nconst concordance = require('concordance');\nconst observableToPromise = require('observable-to-promise');\nconst isPromise = require('is-promise');\nconst isObservable = require('is-observable');\nconst plur = require('plur');\nconst assert = require('./assert');\nconst globals = require('./globals');\nconst concordanceOptions = require('./concordance-options').default;\n\nfunction formatErrorValue(label, error) {\n\tconst formatted = concordance.format(error, concordanceOptions);\n\treturn {label, formatted};\n}\n\nclass SkipApi {\n\tconstructor(test) {\n\t\tthis._test = test;\n\t}\n}\n\nconst captureStack = start => {\n\tconst limitBefore = Error.stackTraceLimit;\n\tError.stackTraceLimit = 1;\n\tconst obj = {};\n\tError.captureStackTrace(obj, start);\n\tError.stackTraceLimit = limitBefore;\n\treturn obj.stack;\n};\n\nclass ExecutionContext {\n\tconstructor(test) {\n\t\tObject.defineProperties(this, {\n\t\t\t_test: {value: test},\n\t\t\tskip: {value: new SkipApi(test)}\n\t\t});\n\t}\n\n\tplan(ct) {\n\t\tthis._test.plan(ct, captureStack(this.plan));\n\t}\n\n\tget end() {\n\t\tconst end = this._test.bindEndCallback();\n\t\tconst endFn = err => end(err, captureStack(endFn));\n\t\treturn endFn;\n\t}\n\n\tget title() {\n\t\treturn this._test.title;\n\t}\n\n\tget context() {\n\t\tconst contextRef = this._test.contextRef;\n\t\treturn contextRef && contextRef.context;\n\t}\n\n\tset context(context) {\n\t\tconst contextRef = this._test.contextRef;\n\n\t\tif (!contextRef) {\n\t\t\tthis._test.saveFirstError(new Error(`\\`t.context\\` is not available in ${this._test.metadata.type} tests`));\n\t\t\treturn;\n\t\t}\n\n\t\tcontextRef.context = context;\n\t}\n\n\t_throwsArgStart(assertion, file, line) {\n\t\tthis._test.trackThrows({assertion, file, line});\n\t}\n\n\t_throwsArgEnd() {\n\t\tthis._test.trackThrows(null);\n\t}\n}\n\n{\n\tconst assertions = assert.wrapAssertions({\n\t\tlog(executionContext, text) {\n\t\t\texecutionContext._test.addLog(text);\n\t\t},\n\n\t\tpass(executionContext) {\n\t\t\texecutionContext._test.countPassedAssertion();\n\t\t},\n\n\t\tpending(executionContext, promise) {\n\t\t\texecutionContext._test.addPendingAssertion(promise);\n\t\t},\n\n\t\tfail(executionContext, error) {\n\t\t\texecutionContext._test.addFailedAssertion(error);\n\t\t}\n\t});\n\tObject.assign(ExecutionContext.prototype, assertions);\n\n\tfunction skipFn() {\n\t\tthis._test.countPassedAssertion();\n\t}\n\tObject.keys(assertions).forEach(el => {\n\t\tSkipApi.prototype[el] = skipFn;\n\t});\n}\n\nclass Test {\n\tconstructor(options) {\n\t\tthis.contextRef = options.contextRef;\n\t\tthis.failWithoutAssertions = options.failWithoutAssertions;\n\t\tthis.fn = isGeneratorFn(options.fn) ? co.wrap(options.fn) : options.fn;\n\t\tthis.metadata = options.metadata;\n\t\tthis.onResult = options.onResult;\n\t\tthis.title = options.title;\n\t\tthis.logs = [];\n\n\t\tthis.snapshotInvocationCount = 0;\n\t\tthis.compareWithSnapshot = assertionOptions => {\n\t\t\tconst belongsTo = assertionOptions.id || this.title;\n\t\t\tconst expected = assertionOptions.expected;\n\t\t\tconst index = assertionOptions.id ? 0 : this.snapshotInvocationCount++;\n\t\t\tconst label = assertionOptions.id ? '' : assertionOptions.message || `Snapshot ${this.snapshotInvocationCount}`;\n\t\t\treturn options.compareTestSnapshot({belongsTo, expected, index, label});\n\t\t};\n\n\t\tthis.assertCount = 0;\n\t\tthis.assertError = undefined;\n\t\tthis.calledEnd = false;\n\t\tthis.duration = null;\n\t\tthis.endCallbackFinisher = null;\n\t\tthis.finishDueToAttributedError = null;\n\t\tthis.finishDueToInactivity = null;\n\t\tthis.finishing = false;\n\t\tthis.pendingAssertionCount = 0;\n\t\tthis.pendingThrowsAssertion = null;\n\t\tthis.planCount = null;\n\t\tthis.startedAt = 0;\n\t}\n\n\tbindEndCallback() {\n\t\tif (this.metadata.callback) {\n\t\t\treturn (err, stack) => {\n\t\t\t\tthis.endCallback(err, stack);\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error('`t.end()`` is not supported in this context. To use `t.end()` as a callback, you must use \"callback mode\" via `test.cb(testName, fn)`');\n\t}\n\n\tendCallback(err, stack) {\n\t\tif (this.calledEnd) {\n\t\t\tthis.saveFirstError(new Error('`t.end()` called more than once'));\n\t\t\treturn;\n\t\t}\n\t\tthis.calledEnd = true;\n\n\t\tif (err) {\n\t\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\t\tactual: err,\n\t\t\t\tmessage: 'Callback called with an error',\n\t\t\t\tstack,\n\t\t\t\tvalues: [formatErrorValue('Callback called with an error:', err)]\n\t\t\t}));\n\t\t}\n\n\t\tif (this.endCallbackFinisher) {\n\t\t\tthis.endCallbackFinisher();\n\t\t}\n\t}\n\n\tcreateExecutionContext() {\n\t\treturn new ExecutionContext(this);\n\t}\n\n\tcountPassedAssertion() {\n\t\tif (this.finishing) {\n\t\t\tthis.saveFirstError(new Error('Assertion passed, but test has already finished'));\n\t\t}\n\n\t\tthis.assertCount++;\n\t}\n\n\taddLog(text) {\n\t\tthis.logs.push(text);\n\t}\n\n\taddPendingAssertion(promise) {\n\t\tif (this.finishing) {\n\t\t\tthis.saveFirstError(new Error('Assertion passed, but test has already finished'));\n\t\t}\n\n\t\tthis.assertCount++;\n\t\tthis.pendingAssertionCount++;\n\t\tpromise\n\t\t\t.catch(err => this.saveFirstError(err))\n\t\t\t.then(() => this.pendingAssertionCount--);\n\t}\n\n\taddFailedAssertion(error) {\n\t\tif (this.finishing) {\n\t\t\tthis.saveFirstError(new Error('Assertion failed, but test has already finished'));\n\t\t}\n\n\t\tthis.assertCount++;\n\t\tthis.saveFirstError(error);\n\t}\n\n\tsaveFirstError(err) {\n\t\tif (!this.assertError) {\n\t\t\tthis.assertError = err;\n\t\t}\n\t}\n\n\tplan(count, planStack) {\n\t\tif (typeof count !== 'number') {\n\t\t\tthrow new TypeError('Expected a number');\n\t\t}\n\n\t\tthis.planCount = count;\n\n\t\t// In case the `planCount` doesn't match `assertCount, we need the stack of\n\t\t// this function to throw with a useful stack.\n\t\tthis.planStack = planStack;\n\t}\n\n\tverifyPlan() {\n\t\tif (!this.assertError && this.planCount !== null && this.planCount !== this.assertCount) {\n\t\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\t\tassertion: 'plan',\n\t\t\t\tmessage: `Planned for ${this.planCount} ${plur('assertion', this.planCount)}, but got ${this.assertCount}.`,\n\t\t\t\toperator: '===',\n\t\t\t\tstack: this.planStack\n\t\t\t}));\n\t\t}\n\t}\n\n\tverifyAssertions() {\n\t\tif (!this.assertError) {\n\t\t\tif (this.failWithoutAssertions && !this.calledEnd && this.planCount === null && this.assertCount === 0) {\n\t\t\t\tthis.saveFirstError(new Error('Test finished without running any assertions'));\n\t\t\t} else if (this.pendingAssertionCount > 0) {\n\t\t\t\tthis.saveFirstError(new Error('Test finished, but an assertion is still pending'));\n\t\t\t}\n\t\t}\n\t}\n\n\ttrackThrows(pending) {\n\t\tthis.pendingThrowsAssertion = pending;\n\t}\n\n\tdetectImproperThrows(err) {\n\t\tif (!this.pendingThrowsAssertion) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst pending = this.pendingThrowsAssertion;\n\t\tthis.pendingThrowsAssertion = null;\n\n\t\tconst values = [];\n\t\tif (err) {\n\t\t\tvalues.push(formatErrorValue(`The following error was thrown, possibly before \\`t.${pending.assertion}()\\` could be called:`, err));\n\t\t}\n\n\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\tassertion: pending.assertion,\n\t\t\tfixedSource: {file: pending.file, line: pending.line},\n\t\t\timproperUsage: true,\n\t\t\tmessage: `Improper usage of \\`t.${pending.assertion}()\\` detected`,\n\t\t\tstack: err instanceof Error && err.stack,\n\t\t\tvalues\n\t\t}));\n\t\treturn true;\n\t}\n\n\twaitForPendingThrowsAssertion() {\n\t\treturn new Promise(resolve => {\n\t\t\tthis.finishDueToAttributedError = () => {\n\t\t\t\tresolve(this.finishPromised());\n\t\t\t};\n\n\t\t\tthis.finishDueToInactivity = () => {\n\t\t\t\tthis.detectImproperThrows();\n\t\t\t\tresolve(this.finishPromised());\n\t\t\t};\n\n\t\t\t// Wait up to a second to see if an error can be attributed to the\n\t\t\t// pending assertion.\n\t\t\tglobals.setTimeout(() => this.finishDueToInactivity(), 1000).unref();\n\t\t});\n\t}\n\n\tattributeLeakedError(err) {\n\t\tif (!this.detectImproperThrows(err)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.finishDueToAttributedError();\n\t\treturn true;\n\t}\n\n\tcallFn() {\n\t\ttry {\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tretval: this.fn(this.createExecutionContext())\n\t\t\t};\n\t\t} catch (err) {\n\t\t\treturn {\n\t\t\t\tok: false,\n\t\t\t\terror: err\n\t\t\t};\n\t\t}\n\t}\n\n\trun() {\n\t\tthis.startedAt = globals.now();\n\n\t\tconst result = this.callFn();\n\t\tif (!result.ok) {\n\t\t\tif (!this.detectImproperThrows(result.error)) {\n\t\t\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\t\t\tmessage: 'Error thrown in test',\n\t\t\t\t\tstack: result.error instanceof Error && result.error.stack,\n\t\t\t\t\tvalues: [formatErrorValue('Error thrown in test:', result.error)]\n\t\t\t\t}));\n\t\t\t}\n\t\t\treturn this.finish();\n\t\t}\n\n\t\tconst returnedObservable = isObservable(result.retval);\n\t\tconst returnedPromise = isPromise(result.retval);\n\n\t\tlet promise;\n\t\tif (returnedObservable) {\n\t\t\tpromise = observableToPromise(result.retval);\n\t\t} else if (returnedPromise) {\n\t\t\t// `retval` can be any thenable, so convert to a proper promise.\n\t\t\tpromise = Promise.resolve(result.retval);\n\t\t}\n\n\t\tif (this.metadata.callback) {\n\t\t\tif (returnedObservable || returnedPromise) {\n\t\t\t\tconst asyncType = returnedObservable ? 'observables' : 'promises';\n\t\t\t\tthis.saveFirstError(new Error(`Do not return ${asyncType} from tests declared via \\`test.cb(...)\\`, if you want to return a promise simply declare the test via \\`test(...)\\``));\n\t\t\t\treturn this.finish();\n\t\t\t}\n\n\t\t\tif (this.calledEnd) {\n\t\t\t\treturn this.finish();\n\t\t\t}\n\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tthis.endCallbackFinisher = () => {\n\t\t\t\t\tresolve(this.finishPromised());\n\t\t\t\t};\n\n\t\t\t\tthis.finishDueToAttributedError = () => {\n\t\t\t\t\tresolve(this.finishPromised());\n\t\t\t\t};\n\n\t\t\t\tthis.finishDueToInactivity = () => {\n\t\t\t\t\tthis.saveFirstError(new Error('`t.end()` was never called'));\n\t\t\t\t\tresolve(this.finishPromised());\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\tif (promise) {\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tthis.finishDueToAttributedError = () => {\n\t\t\t\t\tresolve(this.finishPromised());\n\t\t\t\t};\n\n\t\t\t\tthis.finishDueToInactivity = () => {\n\t\t\t\t\tconst err = returnedObservable ?\n\t\t\t\t\t\tnew Error('Observable returned by test never completed') :\n\t\t\t\t\t\tnew Error('Promise returned by test never resolved');\n\t\t\t\t\tthis.saveFirstError(err);\n\t\t\t\t\tresolve(this.finishPromised());\n\t\t\t\t};\n\n\t\t\t\tpromise\n\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\tif (!this.detectImproperThrows(err)) {\n\t\t\t\t\t\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\t\t\t\t\t\tmessage: 'Rejected promise returned by test',\n\t\t\t\t\t\t\t\tstack: err instanceof Error && err.stack,\n\t\t\t\t\t\t\t\tvalues: [formatErrorValue('Rejected promise returned by test. Reason:', err)]\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => resolve(this.finishPromised()));\n\t\t\t});\n\t\t}\n\n\t\treturn this.finish();\n\t}\n\n\tfinish() {\n\t\tthis.finishing = true;\n\n\t\tif (!this.assertError && this.pendingThrowsAssertion) {\n\t\t\treturn this.waitForPendingThrowsAssertion();\n\t\t}\n\n\t\tthis.verifyPlan();\n\t\tthis.verifyAssertions();\n\n\t\tthis.duration = globals.now() - this.startedAt;\n\n\t\tlet reason = this.assertError;\n\t\tlet passed = !reason;\n\n\t\tif (this.metadata.failing) {\n\t\t\tpassed = !passed;\n\n\t\t\tif (passed) {\n\t\t\t\treason = undefined;\n\t\t\t} else {\n\t\t\t\treason = new Error('Test was expected to fail, but succeeded, you should stop marking the test as failing');\n\t\t\t}\n\t\t}\n\n\t\tthis.onResult({\n\t\t\tpassed,\n\t\t\tresult: this,\n\t\t\treason\n\t\t});\n\n\t\treturn passed;\n\t}\n\n\tfinishPromised() {\n\t\treturn new Promise(resolve => {\n\t\t\tresolve(this.finish());\n\t\t});\n\t}\n}\n\nmodule.exports = Test;\n",
    "browser/main/Main.js": "import PropTypes from 'prop-types'\nimport React from 'react'\nimport CSSModules from 'browser/lib/CSSModules'\nimport styles from './Main.styl'\nimport { connect } from 'react-redux'\nimport SideNav from './SideNav'\nimport TopBar from './TopBar'\nimport NoteList from './NoteList'\nimport Detail from './Detail'\nimport dataApi from 'browser/main/lib/dataApi'\nimport _ from 'lodash'\nimport ConfigManager from 'browser/main/lib/ConfigManager'\nimport mobileAnalytics from 'browser/main/lib/AwsMobileAnalyticsConfig'\nimport eventEmitter from 'browser/main/lib/eventEmitter'\nimport { store } from 'browser/main/store'\nimport i18n from 'browser/lib/i18n'\nimport { getLocales } from 'browser/lib/Languages'\nimport applyShortcuts from 'browser/main/lib/shortcutManager'\nimport { chooseTheme, applyTheme } from 'browser/main/lib/ThemeManager'\nimport { push } from 'connected-react-router'\nimport { ipcRenderer } from 'electron'\n\nconst path = require('path')\nconst electron = require('electron')\nconst { remote } = electron\n\nclass Main extends React.Component {\n  constructor(props) {\n    super(props)\n\n    if (process.env.NODE_ENV === 'production') {\n      mobileAnalytics.initAwsMobileAnalytics()\n    }\n\n    const { config } = props\n\n    this.state = {\n      isRightSliderFocused: false,\n      listWidth: config.listWidth,\n      navWidth: config.navWidth,\n      isLeftSliderFocused: false,\n      fullScreen: false,\n      noteDetailWidth: 0,\n      mainBodyWidth: 0\n    }\n\n    this.toggleFullScreen = () => this.handleFullScreenButton()\n  }\n\n  getChildContext() {\n    const { status, config } = this.props\n\n    return {\n      status,\n      config\n    }\n  }\n\n  init() {\n    dataApi\n      .addStorage({\n        name: 'My Storage Location',\n        path: path.join(remote.app.getPath('home'), 'Boostnote')\n      })\n      .then(data => {\n        return data\n      })\n      .then(data => {\n        if (data.storage.folders[0] != null) {\n          return data\n        } else {\n          return dataApi\n            .createFolder(data.storage.key, {\n              color: '#1278BD',\n              name: 'Default'\n            })\n            .then(_data => {\n              return {\n                storage: _data.storage,\n                notes: data.notes\n              }\n            })\n        }\n      })\n      .then(data => {\n        store.dispatch({\n          type: 'ADD_STORAGE',\n          storage: data.storage,\n          notes: data.notes\n        })\n\n        const defaultSnippetNote = dataApi\n          .createNote(data.storage.key, {\n            type: 'SNIPPET_NOTE',\n            folder: data.storage.folders[0].key,\n            title: 'Snippet note example',\n            description:\n              'Snippet note example\\nYou can store a series of snippets as a single note, like Gist.',\n            snippets: [\n              {\n                name: 'example.html',\n                mode: 'html',\n                content:\n                  \"<html>\\n<body>\\n<h1 id='hello'>Enjoy Boostnote!</h1>\\n</body>\\n</html>\",\n                linesHighlighted: []\n              },\n              {\n                name: 'example.js',\n                mode: 'javascript',\n                content:\n                  \"var boostnote = document.getElementById('hello').innerHTML\\n\\nconsole.log(boostnote)\",\n                linesHighlighted: []\n              }\n            ]\n          })\n          .then(note => {\n            store.dispatch({\n              type: 'UPDATE_NOTE',\n              note: note\n            })\n          })\n        const defaultMarkdownNote = dataApi\n          .createNote(data.storage.key, {\n            type: 'MARKDOWN_NOTE',\n            folder: data.storage.folders[0].key,\n            title: 'Welcome to Boostnote!',\n            content:\n              '# Welcome to Boostnote!\\n## Click here to edit markdown :wave:\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/L0qNPLsvmyM\" frameborder=\"0\" allowfullscreen></iframe>\\n\\n## Docs :memo:\\n- [Boostnote | Boost your happiness, productivity and creativity.](https://hackernoon.com/boostnote-boost-your-happiness-productivity-and-creativity-315034efeebe)\\n- [Cloud Syncing & Backups](https://github.com/BoostIO/Boostnote/wiki/Cloud-Syncing-and-Backup)\\n- [How to sync your data across Desktop and Mobile apps](https://github.com/BoostIO/Boostnote/wiki/Sync-Data-Across-Desktop-and-Mobile-apps)\\n- [Convert data from **Evernote** to Boostnote.](https://github.com/BoostIO/Boostnote/wiki/Evernote)\\n- [Keyboard Shortcuts](https://github.com/BoostIO/Boostnote/wiki/Keyboard-Shortcuts)\\n- [Keymaps in Editor mode](https://github.com/BoostIO/Boostnote/wiki/Keymaps-in-Editor-mode)\\n- [How to set syntax highlight in Snippet note](https://github.com/BoostIO/Boostnote/wiki/Syntax-Highlighting)\\n\\n---\\n\\n## Article Archive :books:\\n- [Reddit English](http://bit.ly/2mOJPu7)\\n- [Reddit Spanish](https://www.reddit.com/r/boostnote_es/)\\n- [Reddit Chinese](https://www.reddit.com/r/boostnote_cn/)\\n- [Reddit Japanese](https://www.reddit.com/r/boostnote_jp/)\\n\\n---\\n\\n## Community :beers:\\n- [GitHub](http://bit.ly/2AWWzkD)\\n- [Twitter](http://bit.ly/2z8BUJZ)\\n- [Facebook Group](http://bit.ly/2jcca8t)'\n          })\n          .then(note => {\n            store.dispatch({\n              type: 'UPDATE_NOTE',\n              note: note\n            })\n          })\n\n        return Promise.resolve(defaultSnippetNote)\n          .then(defaultMarkdownNote)\n          .then(() => data.storage)\n      })\n      .then(storage => {\n        store.dispatch(push('/storages/' + storage.key))\n      })\n      .catch(err => {\n        throw err\n      })\n  }\n\n  componentDidMount() {\n    const { dispatch, config } = this.props\n\n    this.refreshTheme = setInterval(() => {\n      const conf = ConfigManager.get()\n      chooseTheme(conf)\n    }, 5 * 1000)\n\n    chooseTheme(config)\n    applyTheme(config.ui.theme)\n\n    if (getLocales().indexOf(config.ui.language) !== -1) {\n      i18n.setLocale(config.ui.language)\n    } else {\n      i18n.setLocale('en')\n    }\n    applyShortcuts()\n    // Reload all data\n    dataApi.init().then(data => {\n      dispatch({\n        type: 'INIT_ALL',\n        storages: data.storages,\n        notes: data.notes\n      })\n\n      if (data.storages.length < 1) {\n        this.init()\n      }\n    })\n\n    // eslint-disable-next-line no-undef\n    delete CodeMirror.keyMap.emacs['Ctrl-V']\n\n    eventEmitter.on('editor:fullscreen', this.toggleFullScreen)\n    eventEmitter.on(\n      'menubar:togglemenubar',\n      this.toggleMenuBarVisible.bind(this)\n    )\n    eventEmitter.on('dispatch:push', this.changeRoutePush.bind(this))\n    eventEmitter.on('update', () => ipcRenderer.send('update-check', 'manual'))\n  }\n\n  componentWillUnmount() {\n    eventEmitter.off('editor:fullscreen', this.toggleFullScreen)\n    eventEmitter.off(\n      'menubar:togglemenubar',\n      this.toggleMenuBarVisible.bind(this)\n    )\n    eventEmitter.off('dispatch:push', this.changeRoutePush.bind(this))\n    clearInterval(this.refreshTheme)\n  }\n\n  changeRoutePush(event, destination) {\n    const { dispatch } = this.props\n    dispatch(push(destination))\n  }\n\n  toggleMenuBarVisible() {\n    const { config } = this.props\n    const { ui } = config\n\n    const newUI = Object.assign(ui, { showMenuBar: !ui.showMenuBar })\n    const newConfig = Object.assign(config, newUI)\n    ConfigManager.set(newConfig)\n  }\n\n  handleLeftSlideMouseDown(e) {\n    e.preventDefault()\n    this.setState({\n      isLeftSliderFocused: true\n    })\n  }\n\n  handleRightSlideMouseDown(e) {\n    e.preventDefault()\n    this.setState({\n      isRightSliderFocused: true\n    })\n  }\n\n  handleMouseUp(e) {\n    // Change width of NoteList component.\n    if (this.state.isRightSliderFocused) {\n      this.setState(\n        {\n          isRightSliderFocused: false\n        },\n        () => {\n          const { dispatch } = this.props\n          const newListWidth = this.state.listWidth\n          // TODO: ConfigManager should dispatch itself.\n          ConfigManager.set({ listWidth: newListWidth })\n          dispatch({\n            type: 'SET_LIST_WIDTH',\n            listWidth: newListWidth\n          })\n        }\n      )\n    }\n\n    // Change width of SideNav component.\n    if (this.state.isLeftSliderFocused) {\n      this.setState(\n        {\n          isLeftSliderFocused: false\n        },\n        () => {\n          const { dispatch } = this.props\n          const navWidth = this.state.navWidth\n          // TODO: ConfigManager should dispatch itself.\n          ConfigManager.set({ navWidth })\n          dispatch({\n            type: 'SET_NAV_WIDTH',\n            navWidth\n          })\n        }\n      )\n    }\n  }\n\n  handleMouseMove(e) {\n    if (this.state.isRightSliderFocused) {\n      const offset = this.refs.body.getBoundingClientRect().left\n      let newListWidth = e.pageX - offset\n      if (newListWidth < 180) {\n        newListWidth = 180\n      } else if (newListWidth > 600) {\n        newListWidth = 600\n      }\n      this.setState({\n        listWidth: newListWidth\n      })\n    }\n    if (this.state.isLeftSliderFocused) {\n      let navWidth = e.pageX\n      if (navWidth < 80) {\n        navWidth = 80\n      } else if (navWidth > 600) {\n        navWidth = 600\n      }\n      this.setState({\n        navWidth: navWidth\n      })\n    }\n  }\n\n  handleFullScreenButton(e) {\n    this.setState({ fullScreen: !this.state.fullScreen }, () => {\n      const noteDetail = document.querySelector('.NoteDetail')\n      const noteList = document.querySelector('.NoteList')\n      const mainBody = document.querySelector('#main-body')\n\n      if (this.state.fullScreen) {\n        this.hideLeftLists(noteDetail, noteList, mainBody)\n      } else {\n        this.showLeftLists(noteDetail, noteList, mainBody)\n      }\n    })\n  }\n\n  hideLeftLists(noteDetail, noteList, mainBody) {\n    this.setState({ noteDetailWidth: noteDetail.style.left })\n    this.setState({ mainBodyWidth: mainBody.style.left })\n    noteDetail.style.left = '0px'\n    mainBody.style.left = '0px'\n    noteList.style.display = 'none'\n  }\n\n  showLeftLists(noteDetail, noteList, mainBody) {\n    noteDetail.style.left = this.state.noteDetailWidth\n    mainBody.style.left = this.state.mainBodyWidth\n    noteList.style.display = 'inline'\n  }\n\n  render() {\n    const { config } = this.props\n\n    // the width of the navigation bar when it is folded/collapsed\n    const foldedNavigationWidth = 44\n\n    return (\n      <div\n        className='Main'\n        styleName='root'\n        onMouseMove={e => this.handleMouseMove(e)}\n        onMouseUp={e => this.handleMouseUp(e)}\n      >\n        <SideNav\n          {..._.pick(this.props, [\n            'dispatch',\n            'data',\n            'config',\n            'match',\n            'location'\n          ])}\n          width={this.state.navWidth}\n        />\n        {!config.isSideNavFolded && (\n          <div\n            styleName={\n              this.state.isLeftSliderFocused ? 'slider--active' : 'slider'\n            }\n            style={{ left: this.state.navWidth }}\n            onMouseDown={e => this.handleLeftSlideMouseDown(e)}\n            draggable='false'\n          >\n            <div styleName='slider-hitbox' />\n          </div>\n        )}\n        <div\n          styleName={config.isSideNavFolded ? 'body--expanded' : 'body'}\n          id='main-body'\n          ref='body'\n          style={{\n            left: config.isSideNavFolded\n              ? foldedNavigationWidth\n              : this.state.navWidth\n          }}\n        >\n          <TopBar\n            style={{ width: this.state.listWidth }}\n            {..._.pick(this.props, [\n              'dispatch',\n              'config',\n              'data',\n              'match',\n              'location'\n            ])}\n          />\n          <NoteList\n            style={{ width: this.state.listWidth }}\n            {..._.pick(this.props, [\n              'dispatch',\n              'data',\n              'config',\n              'match',\n              'location'\n            ])}\n          />\n          <div\n            styleName={\n              this.state.isRightSliderFocused\n                ? 'slider-right--active'\n                : 'slider-right'\n            }\n            style={{ left: this.state.listWidth - 1 }}\n            onMouseDown={e => this.handleRightSlideMouseDown(e)}\n            draggable='false'\n          >\n            <div styleName='slider-hitbox' />\n          </div>\n          <Detail\n            style={{ left: this.state.listWidth }}\n            {..._.pick(this.props, [\n              'dispatch',\n              'data',\n              'config',\n              'match',\n              'location'\n            ])}\n            ignorePreviewPointerEvents={this.state.isRightSliderFocused}\n          />\n        </div>\n      </div>\n    )\n  }\n}\n\nMain.childContextTypes = {\n  status: PropTypes.shape({\n    updateReady: PropTypes.bool.isRequired\n  }).isRequired,\n  config: PropTypes.shape({}).isRequired\n}\n\nMain.propTypes = {\n  dispatch: PropTypes.func,\n  data: PropTypes.shape({}).isRequired\n}\n\nexport default connect(x => x)(CSSModules(Main, styles))\n",
    "browser/main/lib/dataApi/addStorage.js": "const _ = require('lodash')\nconst keygen = require('browser/lib/keygen')\nconst resolveStorageData = require('./resolveStorageData')\nconst resolveStorageNotes = require('./resolveStorageNotes')\nconst consts = require('browser/lib/consts')\nconst path = require('path')\nconst CSON = require('@rokt33r/season')\n/**\n * @param {Object}\n * name, path, type\n *\n * 1. check if BoostnoteJSON can be created\n *   if the file doesn't exist or isn't valid, try to rewrite it.\n *   if the rewriting failed, throw Error\n * 2. save metadata to localStorage\n * 3. fetch notes & folders\n * 4. return `{storage: {...} folders: [folder]}`\n */\nfunction addStorage(input) {\n  if (!_.isString(input.path)) {\n    return Promise.reject(new Error('Path must be a string.'))\n  }\n  let rawStorages\n  try {\n    rawStorages = JSON.parse(localStorage.getItem('storages'))\n    if (!_.isArray(rawStorages)) throw new Error('invalid storages')\n  } catch (e) {\n    console.warn(e)\n    rawStorages = []\n  }\n  let key = keygen()\n  while (rawStorages.some(storage => storage.key === key)) {\n    key = keygen()\n  }\n\n  let newStorage = {\n    key,\n    name: input.name,\n    type: input.type,\n    path: input.path,\n    isOpen: false\n  }\n\n  return Promise.resolve(newStorage)\n    .then(resolveStorageData)\n    .then(function saveMetadataToLocalStorage(resolvedStorage) {\n      newStorage = resolvedStorage\n      rawStorages.push({\n        key: newStorage.key,\n        type: newStorage.type,\n        name: newStorage.name,\n        path: newStorage.path,\n        isOpen: false\n      })\n\n      localStorage.setItem('storages', JSON.stringify(rawStorages))\n      return newStorage\n    })\n    .then(function(storage) {\n      return resolveStorageNotes(storage).then(notes => {\n        let unknownCount = 0\n        notes.forEach(note => {\n          if (!storage.folders.some(folder => note.folder === folder.key)) {\n            unknownCount++\n            storage.folders.push({\n              key: note.folder,\n              color: consts.FOLDER_COLORS[(unknownCount - 1) % 7],\n              name: 'Unknown ' + unknownCount\n            })\n          }\n        })\n        if (unknownCount > 0) {\n          CSON.writeFileSync(\n            path.join(storage.path, 'boostnote.json'),\n            _.pick(storage, ['folders', 'version'])\n          )\n        }\n        return notes\n      })\n    })\n    .then(function returnValue(notes) {\n      return {\n        storage: newStorage,\n        notes\n      }\n    })\n}\n\nmodule.exports = addStorage\n",
    "browser/main/lib/dataApi/init.js": "'use strict'\nconst _ = require('lodash')\nconst resolveStorageData = require('./resolveStorageData')\nconst resolveStorageNotes = require('./resolveStorageNotes')\nconst consts = require('browser/lib/consts')\nconst path = require('path')\nconst fs = require('fs')\nconst CSON = require('@rokt33r/season')\n/**\n * @return {Object} all storages and notes\n * ```\n * {\n *   storages: [...],\n *   notes: [...]\n * }\n * ```\n *\n * This method deals with 3 patterns.\n * 1. v1\n * 2. legacy\n * 3. empty directory\n */\n\nfunction init() {\n  const fetchStorages = function() {\n    let rawStorages\n    try {\n      rawStorages = JSON.parse(window.localStorage.getItem('storages'))\n      // Remove storages who's location is inaccesible.\n      rawStorages = rawStorages.filter(storage => fs.existsSync(storage.path))\n      if (!_.isArray(rawStorages)) throw new Error('Cached data is not valid.')\n    } catch (e) {\n      console.warn('Failed to parse cached data from localStorage', e)\n      rawStorages = []\n      window.localStorage.setItem('storages', JSON.stringify(rawStorages))\n    }\n    return Promise.all(rawStorages.map(resolveStorageData))\n  }\n\n  const fetchNotes = function(storages) {\n    const findNotesFromEachStorage = storages\n      .filter(storage => fs.existsSync(storage.path))\n      .map(storage => {\n        return resolveStorageNotes(storage).then(notes => {\n          let unknownCount = 0\n          notes.forEach(note => {\n            if (\n              note &&\n              !storage.folders.some(folder => note.folder === folder.key)\n            ) {\n              unknownCount++\n              storage.folders.push({\n                key: note.folder,\n                color: consts.FOLDER_COLORS[(unknownCount - 1) % 7],\n                name: 'Unknown ' + unknownCount\n              })\n            }\n          })\n          if (unknownCount > 0) {\n            try {\n              CSON.writeFileSync(\n                path.join(storage.path, 'boostnote.json'),\n                _.pick(storage, ['folders', 'version'])\n              )\n            } catch (e) {\n              console.log(\n                'Error writting boostnote.json: ' + e + ' from init.js'\n              )\n            }\n          }\n          return notes\n        })\n      })\n    return Promise.all(findNotesFromEachStorage)\n      .then(function concatNoteGroup(noteGroups) {\n        return noteGroups.reduce(function(sum, group) {\n          return sum.concat(group)\n        }, [])\n      })\n      .then(function returnData(notes) {\n        return {\n          storages,\n          notes\n        }\n      })\n  }\n\n  return Promise.resolve(fetchStorages())\n    .then(storages => {\n      return storages.filter(storage => {\n        if (!_.isObject(storage)) return false\n        return true\n      })\n    })\n    .then(fetchNotes)\n}\nmodule.exports = init\n",
    "browser/main/lib/dataApi/migrateFromV6Storage.js": "const path = require('path')\nconst sander = require('sander')\nconst keygen = require('browser/lib/keygen')\nconst _ = require('lodash')\nconst CSON = require('@rokt33r/season')\n\nfunction migrateFromV5Storage(storagePath) {\n  var boostnoteJSONPath = path.join(storagePath, 'boostnote.json')\n  return Promise.resolve()\n    .then(function readBoostnoteJSON() {\n      return sander.readFile(boostnoteJSONPath, {\n        encoding: 'utf-8'\n      })\n    })\n    .then(function verifyVersion(rawData) {\n      var boostnoteJSONData = JSON.parse(rawData)\n      if (boostnoteJSONData.version === '1.0')\n        throw new Error('Target storage seems to be transformed already.')\n      if (!_.isArray(boostnoteJSONData.folders))\n        throw new Error('the value of folders is not an array.')\n\n      return boostnoteJSONData\n    })\n    .then(function setVersion(boostnoteJSONData) {\n      boostnoteJSONData.version = '1.0'\n      return sander\n        .writeFile(boostnoteJSONPath, JSON.stringify(boostnoteJSONData))\n        .then(() => boostnoteJSONData)\n    })\n    .then(function fetchNotes(boostnoteJSONData) {\n      var fetchNotesFromEachFolder = boostnoteJSONData.folders.map(function(\n        folder\n      ) {\n        const folderDataJSONPath = path.join(\n          storagePath,\n          folder.key,\n          'data.json'\n        )\n        return sander\n          .readFile(folderDataJSONPath, {\n            encoding: 'utf-8'\n          })\n          .then(function(rawData) {\n            var data = JSON.parse(rawData)\n            if (!_.isArray(data.notes))\n              throw new Error('value of notes is not an array.')\n            return data.notes.map(function setFolderToNote(note) {\n              note.folder = folder.key\n              return note\n            })\n          })\n          .catch(function failedToReadDataJSON(err) {\n            console.warn('Failed to fetch notes from ', folderDataJSONPath, err)\n            return []\n          })\n      })\n\n      return Promise.all(fetchNotesFromEachFolder)\n        .then(function flatten(folderNotes) {\n          return folderNotes.reduce(function concatNotes(sum, notes) {\n            return sum.concat(notes)\n          }, [])\n        })\n        .then(function saveNotes(notes) {\n          notes.forEach(function renewKey(note) {\n            var newKey = keygen()\n            while (notes.some(_note => _note.key === newKey)) {\n              newKey = keygen()\n            }\n            note.key = newKey\n          })\n\n          const noteDirPath = path.join(storagePath, 'notes')\n          notes.map(function saveNote(note) {\n            CSON.writeFileSync(path.join(noteDirPath, note.key) + '.cson', note)\n          })\n          return true\n        })\n        .then(function deleteFolderDir(check) {\n          if (check) {\n            boostnoteJSONData.folders.forEach(folder => {\n              sander.rimrafSync(path.join(storagePath, folder.key))\n            })\n          }\n          return check\n        })\n    })\n    .catch(function handleError(err) {\n      console.warn(err)\n      return false\n    })\n}\n\nmodule.exports = migrateFromV5Storage\n",
    "browser/main/lib/dataApi/moveNote.js": "const resolveStorageData = require('./resolveStorageData')\nconst _ = require('lodash')\nconst path = require('path')\nconst CSON = require('@rokt33r/season')\nconst keygen = require('browser/lib/keygen')\nconst sander = require('sander')\nconst { findStorage } = require('browser/lib/findStorage')\nconst attachmentManagement = require('./attachmentManagement')\n\nfunction moveNote(storageKey, noteKey, newStorageKey, newFolderKey) {\n  let oldStorage, newStorage\n  try {\n    oldStorage = findStorage(storageKey)\n    newStorage = findStorage(newStorageKey)\n    if (newStorage == null) throw new Error(\"Target storage doesn't exist.\")\n  } catch (e) {\n    return Promise.reject(e)\n  }\n\n  return resolveStorageData(oldStorage).then(function saveNote(_oldStorage) {\n    oldStorage = _oldStorage\n    let noteData\n    const notePath = path.join(oldStorage.path, 'notes', noteKey + '.cson')\n    try {\n      noteData = CSON.readFileSync(notePath)\n    } catch (err) {\n      console.warn('Failed to find note cson', err)\n      throw err\n    }\n    let newNoteKey\n    return Promise.resolve()\n      .then(function resolveNewStorage() {\n        if (storageKey === newStorageKey) {\n          newNoteKey = noteKey\n          return oldStorage\n        }\n        return resolveStorageData(newStorage).then(function findNewNoteKey(\n          _newStorage\n        ) {\n          newStorage = _newStorage\n          newNoteKey = keygen(true)\n          let isUnique = false\n          while (!isUnique) {\n            try {\n              sander.statSync(\n                path.join(newStorage.path, 'notes', newNoteKey + '.cson')\n              )\n              newNoteKey = keygen(true)\n            } catch (err) {\n              if (err.code === 'ENOENT') {\n                isUnique = true\n              } else {\n                throw err\n              }\n            }\n          }\n\n          return newStorage\n        })\n      })\n      .then(function checkFolderExistsAndPrepareNoteData(newStorage) {\n        if (_.find(newStorage.folders, { key: newFolderKey }) == null)\n          throw new Error(\"Target folder doesn't exist.\")\n\n        noteData.folder = newFolderKey\n        noteData.key = newNoteKey\n        noteData.storage = newStorageKey\n        noteData.updatedAt = new Date()\n        noteData.oldContent = noteData.content\n\n        return noteData\n      })\n      .then(function moveAttachments(noteData) {\n        if (oldStorage.path === newStorage.path) {\n          return noteData\n        }\n\n        noteData.content = attachmentManagement.moveAttachments(\n          oldStorage.path,\n          newStorage.path,\n          noteKey,\n          newNoteKey,\n          noteData.content\n        )\n        return noteData\n      })\n      .then(function writeAndReturn(noteData) {\n        CSON.writeFileSync(\n          path.join(newStorage.path, 'notes', noteData.key + '.cson'),\n          _.omit(noteData, ['key', 'storage', 'oldContent'])\n        )\n        return noteData\n      })\n      .then(function deleteOldNote(data) {\n        if (storageKey !== newStorageKey) {\n          try {\n            sander.unlinkSync(\n              path.join(oldStorage.path, 'notes', noteKey + '.cson')\n            )\n          } catch (err) {\n            console.warn(err)\n          }\n        }\n\n        return data\n      })\n  })\n}\n\nmodule.exports = moveNote\n",
    "tests/dataApi/addStorage.js": "const test = require('ava')\nconst addStorage = require('browser/main/lib/dataApi/addStorage')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst TestDummy = require('../fixtures/TestDummy')\nconst sander = require('sander')\nconst _ = require('lodash')\nconst os = require('os')\nconst CSON = require('@rokt33r/season')\n\nconst v1StoragePath = path.join(os.tmpdir(), 'test/addStorage-v1-storage')\n// const legacyStoragePath = path.join(os.tmpdir(), 'test/addStorage-legacy-storage')\n// const emptyDirPath = path.join(os.tmpdir(), 'test/addStorage-empty-storage')\n\ntest.beforeEach(t => {\n  t.context.v1StorageData = TestDummy.dummyStorage(v1StoragePath)\n  // t.context.legacyStorageData = TestDummy.dummyLegacyStorage(legacyStoragePath)\n\n  localStorage.setItem('storages', JSON.stringify([]))\n})\n\ntest.serial('Add Storage', t => {\n  const input = {\n    type: 'FILESYSTEM',\n    name: 'add-storage1',\n    path: v1StoragePath\n  }\n  return Promise.resolve()\n    .then(function doTest() {\n      return addStorage(input)\n    })\n    .then(function validateResult(data) {\n      const { storage, notes } = data\n\n      // Check data.storage\n      t.true(_.isString(storage.key))\n      t.is(storage.name, input.name)\n      t.is(storage.type, input.type)\n      t.is(storage.path, input.path)\n      t.is(storage.version, '1.0')\n      t.is(storage.folders.length, t.context.v1StorageData.json.folders.length)\n\n      // Check data.notes\n      t.is(notes.length, t.context.v1StorageData.notes.length)\n      notes.forEach(function validateNote(note) {\n        t.is(note.storage, storage.key)\n      })\n\n      // Check localStorage\n      const cacheData = _.find(JSON.parse(localStorage.getItem('storages')), {\n        key: data.storage.key\n      })\n      t.is(cacheData.name, input.name)\n      t.is(cacheData.type, input.type)\n      t.is(cacheData.path, input.path)\n\n      // Check boostnote.json\n      const jsonData = CSON.readFileSync(\n        path.join(storage.path, 'boostnote.json')\n      )\n      t.true(_.isArray(jsonData.folders))\n      t.is(jsonData.version, '1.0')\n      t.is(jsonData.folders.length, t.context.v1StorageData.json.folders.length)\n    })\n})\n\ntest.after.always(() => {\n  localStorage.clear()\n  sander.rimrafSync(v1StoragePath)\n})\n",
    "tests/dataApi/createFolder.test.js": "const createFolder = require('browser/main/lib/dataApi/createFolder')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst _ = require('lodash')\nconst TestDummy = require('../fixtures/TestDummy')\nconst sander = require('sander')\nconst os = require('os')\nconst CSON = require('@rokt33r/season')\n\nconst storagePath = path.join(os.tmpdir(), 'test/create-folder')\n\nlet storageContext\n\nbeforeAll(() => {\n  storageContext = TestDummy.dummyStorage(storagePath)\n  localStorage.setItem('storages', JSON.stringify([storageContext.cache]))\n})\n\nit('Create a folder', done => {\n  const storageKey = storageContext.cache.key\n  const input = {\n    name: 'created',\n    color: '#ff5555'\n  }\n  return Promise.resolve()\n    .then(() => {\n      return createFolder(storageKey, input)\n    })\n    .then(data => {\n      expect(_.find(data.storage.folders, input)).not.toBeNull()\n      const jsonData = CSON.readFileSync(\n        path.join(data.storage.path, 'boostnote.json')\n      )\n      expect(_.find(jsonData.folders, input)).not.toBeNull()\n      done()\n    })\n})\n\nafterAll(() => {\n  localStorage.clear()\n  sander.rimrafSync(storagePath)\n})\n",
    "tests/dataApi/createNote.test.js": "const createNote = require('browser/main/lib/dataApi/createNote')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst TestDummy = require('../fixtures/TestDummy')\nconst sander = require('sander')\nconst os = require('os')\nconst CSON = require('@rokt33r/season')\nconst faker = require('faker')\n\nconst storagePath = path.join(os.tmpdir(), 'test/create-note')\n\nlet storageContext\n\nbeforeEach(() => {\n  storageContext = TestDummy.dummyStorage(storagePath)\n  localStorage.setItem('storages', JSON.stringify([storageContext.cache]))\n})\n\nit('Create a note', done => {\n  const storageKey = storageContext.cache.key\n  const folderKey = storageContext.json.folders[0].key\n\n  const randLinesHighlightedArray = new Array(10)\n    .fill()\n    .map(() => Math.round(Math.random() * 10))\n\n  const input1 = {\n    type: 'SNIPPET_NOTE',\n    description: faker.lorem.lines(),\n    snippets: [\n      {\n        name: faker.system.fileName(),\n        mode: 'text',\n        content: faker.lorem.lines(),\n        linesHighlighted: randLinesHighlightedArray\n      }\n    ],\n    tags: faker.lorem.words().split(' '),\n    folder: folderKey\n  }\n  input1.title = input1.description.split('\\n').shift()\n\n  const input2 = {\n    type: 'MARKDOWN_NOTE',\n    content: faker.lorem.lines(),\n    tags: faker.lorem.words().split(' '),\n    folder: folderKey,\n    linesHighlighted: randLinesHighlightedArray\n  }\n  input2.title = input2.content.split('\\n').shift()\n\n  return Promise.resolve()\n    .then(() => {\n      return Promise.all([\n        createNote(storageKey, input1),\n        createNote(storageKey, input2)\n      ])\n    })\n    .then(data => {\n      const data1 = data[0]\n      const data2 = data[1]\n\n      expect(storageKey).toEqual(data1.storage)\n      const jsonData1 = CSON.readFileSync(\n        path.join(storagePath, 'notes', data1.key + '.cson')\n      )\n\n      expect(input1.title).toEqual(data1.title)\n      expect(input1.title).toEqual(jsonData1.title)\n      expect(input1.description).toEqual(data1.description)\n      expect(input1.description).toEqual(jsonData1.description)\n      expect(input1.tags.length).toEqual(data1.tags.length)\n      expect(input1.tags.length).toEqual(jsonData1.tags.length)\n      expect(input1.snippets.length).toEqual(data1.snippets.length)\n      expect(input1.snippets.length).toEqual(jsonData1.snippets.length)\n      expect(input1.snippets[0].content).toEqual(data1.snippets[0].content)\n      expect(input1.snippets[0].content).toEqual(jsonData1.snippets[0].content)\n      expect(input1.snippets[0].name).toEqual(data1.snippets[0].name)\n      expect(input1.snippets[0].name).toEqual(jsonData1.snippets[0].name)\n      expect(input1.snippets[0].linesHighlighted).toEqual(\n        data1.snippets[0].linesHighlighted\n      )\n      expect(input1.snippets[0].linesHighlighted).toEqual(\n        jsonData1.snippets[0].linesHighlighted\n      )\n\n      expect(storageKey).toEqual(data2.storage)\n      const jsonData2 = CSON.readFileSync(\n        path.join(storagePath, 'notes', data2.key + '.cson')\n      )\n      expect(input2.title).toEqual(data2.title)\n      expect(input2.title).toEqual(jsonData2.title)\n      expect(input2.content).toEqual(data2.content)\n      expect(input2.content).toEqual(jsonData2.content)\n      expect(input2.tags.length).toEqual(data2.tags.length)\n      expect(input2.tags.length).toEqual(jsonData2.tags.length)\n      expect(input2.linesHighlighted).toEqual(data2.linesHighlighted)\n      expect(input2.linesHighlighted).toEqual(jsonData2.linesHighlighted)\n\n      done()\n    })\n})\n\nafterAll(function after() {\n  localStorage.clear()\n  sander.rimrafSync(storagePath)\n})\n",
    "tests/dataApi/createSnippet.test.js": "const createSnippet = require('browser/main/lib/dataApi/createSnippet')\nconst sander = require('sander')\nconst os = require('os')\nconst path = require('path')\n\nconst snippetFilePath = path.join(os.tmpdir(), 'test', 'create-snippet')\nconst snippetFile = path.join(snippetFilePath, 'snippets.json')\n\nbeforeEach(() => {\n  sander.writeFileSync(snippetFile, '[]')\n})\n\nit('Create a snippet', () => {\n  return Promise.resolve()\n    .then(() => Promise.all([createSnippet(snippetFile)]))\n    .then(function assert(data) {\n      data = data[0]\n      const snippets = JSON.parse(sander.readFileSync(snippetFile))\n      const snippet = snippets.find(\n        currentSnippet => currentSnippet.id === data.id\n      )\n      expect(snippet).not.toBeUndefined()\n      expect(snippet.name).toEqual(data.name)\n      expect(snippet.prefix).toEqual(data.prefix)\n      expect(snippet.content).toEqual(data.content)\n      expect(snippet.linesHighlighted).toEqual(data.linesHighlighted)\n    })\n})\n\nafterAll(() => {\n  sander.rimrafSync(snippetFilePath)\n})\n",
    "tests/dataApi/deleteFolder.test.js": "const deleteFolder = require('browser/main/lib/dataApi/deleteFolder')\nconst attachmentManagement = require('browser/main/lib/dataApi/attachmentManagement')\nconst createNote = require('browser/main/lib/dataApi/createNote')\nconst fs = require('fs')\nconst faker = require('faker')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst _ = require('lodash')\nconst TestDummy = require('../fixtures/TestDummy')\nconst sander = require('sander')\nconst os = require('os')\nconst CSON = require('@rokt33r/season')\n\nconst storagePath = path.join(os.tmpdir(), 'test/delete-folder')\n\nlet storageContext\n\nbeforeEach(() => {\n  storageContext = TestDummy.dummyStorage(storagePath)\n  localStorage.setItem('storages', JSON.stringify([storageContext.cache]))\n})\n\nit('Delete a folder', () => {\n  const storageKey = storageContext.cache.key\n  const folderKey = storageContext.json.folders[0].key\n  let noteKey\n\n  const input1 = {\n    type: 'SNIPPET_NOTE',\n    description: faker.lorem.lines(),\n    snippets: [\n      {\n        name: faker.system.fileName(),\n        mode: 'text',\n        content: faker.lorem.lines()\n      }\n    ],\n    tags: faker.lorem.words().split(' '),\n    folder: folderKey\n  }\n  input1.title = input1.description.split('\\n').shift()\n\n  return Promise.resolve()\n    .then(function prepare() {\n      return createNote(storageKey, input1).then(\n        function createAttachmentFolder(data) {\n          fs.mkdirSync(\n            path.join(storagePath, attachmentManagement.DESTINATION_FOLDER)\n          )\n          fs.mkdirSync(\n            path.join(\n              storagePath,\n              attachmentManagement.DESTINATION_FOLDER,\n              data.key\n            )\n          )\n          noteKey = data.key\n\n          return data\n        }\n      )\n    })\n    .then(function doTest() {\n      return deleteFolder(storageKey, folderKey)\n    })\n    .then(function assert(data) {\n      expect(_.find(data.storage.folders, { key: folderKey })).toBeUndefined()\n      const jsonData = CSON.readFileSync(\n        path.join(data.storage.path, 'boostnote.json')\n      )\n\n      expect(_.find(jsonData.folders, { key: folderKey })).toBeUndefined()\n      const notePaths = sander.readdirSync(data.storage.path, 'notes')\n      expect(notePaths.length).toBe(\n        storageContext.notes.filter(note => note.folder !== folderKey).length\n      )\n\n      const attachmentFolderPath = path.join(\n        storagePath,\n        attachmentManagement.DESTINATION_FOLDER,\n        noteKey\n      )\n      expect(fs.existsSync(attachmentFolderPath)).toBe(false)\n    })\n})\n\nafterAll(() => {\n  localStorage.clear()\n  sander.rimrafSync(storagePath)\n})\n",
    "tests/dataApi/deleteNote-test.js": "const test = require('ava')\nconst createNote = require('browser/main/lib/dataApi/createNote')\nconst deleteNote = require('browser/main/lib/dataApi/deleteNote')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst TestDummy = require('../fixtures/TestDummy')\nconst sander = require('sander')\nconst os = require('os')\nconst CSON = require('@rokt33r/season')\nconst faker = require('faker')\nconst fs = require('fs')\nconst attachmentManagement = require('browser/main/lib/dataApi/attachmentManagement')\n\nconst storagePath = path.join(os.tmpdir(), 'test/delete-note')\n\ntest.beforeEach(t => {\n  t.context.storage = TestDummy.dummyStorage(storagePath)\n  localStorage.setItem('storages', JSON.stringify([t.context.storage.cache]))\n})\n\ntest.serial('Delete a note', t => {\n  const storageKey = t.context.storage.cache.key\n  const folderKey = t.context.storage.json.folders[0].key\n\n  const input1 = {\n    type: 'SNIPPET_NOTE',\n    description: faker.lorem.lines(),\n    snippets: [\n      {\n        name: faker.system.fileName(),\n        mode: 'text',\n        content: faker.lorem.lines()\n      }\n    ],\n    tags: faker.lorem.words().split(' '),\n    folder: folderKey\n  }\n  input1.title = input1.description.split('\\n').shift()\n\n  return Promise.resolve()\n    .then(function doTest() {\n      return createNote(storageKey, input1)\n        .then(function createAttachmentFolder(data) {\n          fs.mkdirSync(\n            path.join(storagePath, attachmentManagement.DESTINATION_FOLDER)\n          )\n          fs.mkdirSync(\n            path.join(\n              storagePath,\n              attachmentManagement.DESTINATION_FOLDER,\n              data.key\n            )\n          )\n          return data\n        })\n        .then(function(data) {\n          return deleteNote(storageKey, data.key)\n        })\n    })\n    .then(function assert(data) {\n      try {\n        CSON.readFileSync(\n          path.join(storagePath, 'notes', data.noteKey + '.cson')\n        )\n        t.fail('note cson must be deleted.')\n      } catch (err) {\n        t.is(err.code, 'ENOENT')\n        return data\n      }\n    })\n    .then(function assertAttachmentFolderDeleted(data) {\n      const attachmentFolderPath = path.join(\n        storagePath,\n        attachmentManagement.DESTINATION_FOLDER,\n        data.noteKey\n      )\n      t.is(fs.existsSync(attachmentFolderPath), false)\n    })\n})\n\ntest.after(function after() {\n  localStorage.clear()\n  sander.rimrafSync(storagePath)\n})\n",
    "tests/dataApi/init.js": "const test = require('ava')\nconst init = require('browser/main/lib/dataApi/init')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst TestDummy = require('../fixtures/TestDummy')\nconst keygen = require('browser/lib/keygen')\nconst sander = require('sander')\nconst _ = require('lodash')\nconst os = require('os')\n\nconst v1StoragePath = path.join(os.tmpdir(), 'test/init-v1-storage')\nconst legacyStoragePath = path.join(os.tmpdir(), 'test/init-legacy-storage')\nconst emptyDirPath = path.join(os.tmpdir(), 'test/init-empty-storage')\n\ntest.beforeEach(t => {\n  localStorage.clear()\n  // Prepare 3 types of dir\n  t.context.v1StorageData = TestDummy.dummyStorage(v1StoragePath, {\n    cache: { name: 'v1' }\n  })\n  t.context.legacyStorageData = TestDummy.dummyLegacyStorage(\n    legacyStoragePath,\n    { cache: { name: 'legacy' } }\n  )\n  t.context.emptyStorageData = {\n    cache: {\n      type: 'FILESYSTEM',\n      name: 'empty',\n      key: keygen(),\n      path: emptyDirPath\n    }\n  }\n\n  localStorage.setItem(\n    'storages',\n    JSON.stringify([\n      t.context.v1StorageData.cache,\n      t.context.legacyStorageData.cache,\n      t.context.emptyStorageData.cache\n    ])\n  )\n})\n\ntest.serial('Initialize All Storages', t => {\n  const { v1StorageData, legacyStorageData } = t.context\n  return Promise.resolve()\n    .then(function test() {\n      return init()\n    })\n    .then(function assert(data) {\n      t.true(Array.isArray(data.storages))\n      t.is(\n        data.notes.length,\n        v1StorageData.notes.length + legacyStorageData.notes.length\n      )\n      t.is(data.storages.length, 3)\n      data.storages.forEach(function assertStorage(storage) {\n        t.true(_.isString(storage.key))\n        t.true(_.isString(storage.name))\n        t.true(storage.type === 'FILESYSTEM')\n        t.true(_.isString(storage.path))\n      })\n    })\n    .then(function after() {\n      localStorage.clear()\n    })\n})\n\ntest.after.always(() => {\n  localStorage.clear()\n  sander.rimrafSync(v1StoragePath)\n  sander.rimrafSync(legacyStoragePath)\n  sander.rimrafSync(emptyDirPath)\n})\n",
    "tests/dataApi/migrateFromV6Storage-test.js": "const test = require('ava')\nconst migrateFromV6Storage = require('browser/main/lib/dataApi/migrateFromV6Storage')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst TestDummy = require('../fixtures/TestDummy')\nconst sander = require('sander')\nconst CSON = require('@rokt33r/season')\nconst _ = require('lodash')\nconst os = require('os')\n\nconst dummyStoragePath = path.join(os.tmpdir(), 'test/migrate-test-storage')\n\ntest.beforeEach(t => {\n  const dummyData = (t.context.dummyData = TestDummy.dummyLegacyStorage(\n    dummyStoragePath\n  ))\n  console.log('init count', dummyData.notes.length)\n  localStorage.setItem('storages', JSON.stringify([dummyData.cache]))\n})\n\ntest.serial('Migrate legacy storage into v1 storage', t => {\n  return Promise.resolve()\n    .then(function test() {\n      return migrateFromV6Storage(dummyStoragePath)\n    })\n    .then(function assert(data) {\n      // Check the result. It must be true if succeed.\n      t.true(data)\n\n      // Check all notes migrated.\n      const dummyData = t.context.dummyData\n      const noteDirPath = path.join(dummyStoragePath, 'notes')\n      const fileList = sander.readdirSync(noteDirPath)\n      t.is(dummyData.notes.length, fileList.length)\n      const noteMap = fileList.map(filePath => {\n        return CSON.readFileSync(path.join(noteDirPath, filePath))\n      })\n      dummyData.notes.forEach(function(targetNote) {\n        t.true(\n          _.find(noteMap, {\n            title: targetNote.title,\n            folder: targetNote.folder\n          }) != null\n        )\n      })\n\n      // Check legacy folder directory is removed\n      dummyData.json.folders.forEach(function(folder) {\n        try {\n          sander.statSync(dummyStoragePath, folder.key)\n          t.fail('Folder still remains. ENOENT error must be occured.')\n        } catch (err) {\n          t.is(err.code, 'ENOENT')\n        }\n      })\n    })\n})\n\ntest.after.always(function() {\n  localStorage.clear()\n  sander.rimrafSync(dummyStoragePath)\n})\n",
    "tests/dataApi/moveNote-test.js": "const test = require('ava')\nconst moveNote = require('browser/main/lib/dataApi/moveNote')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst TestDummy = require('../fixtures/TestDummy')\nconst sander = require('sander')\nconst os = require('os')\nconst CSON = require('@rokt33r/season')\n\nconst storagePath = path.join(os.tmpdir(), 'test/move-note')\nconst storagePath2 = path.join(os.tmpdir(), 'test/move-note2')\n\ntest.beforeEach(t => {\n  t.context.storage1 = TestDummy.dummyStorage(storagePath)\n  t.context.storage2 = TestDummy.dummyStorage(storagePath2)\n  localStorage.setItem(\n    'storages',\n    JSON.stringify([t.context.storage1.cache, t.context.storage2.cache])\n  )\n})\n\ntest.serial('Move a note', t => {\n  const storageKey1 = t.context.storage1.cache.key\n  const folderKey1 = t.context.storage1.json.folders[0].key\n  const note1 = t.context.storage1.notes[0]\n  const note2 = t.context.storage1.notes[1]\n  const storageKey2 = t.context.storage2.cache.key\n  const folderKey2 = t.context.storage2.json.folders[0].key\n\n  return Promise.resolve()\n    .then(function doTest() {\n      return Promise.all([\n        moveNote(storageKey1, note1.key, storageKey1, folderKey1),\n        moveNote(storageKey1, note2.key, storageKey2, folderKey2)\n      ])\n    })\n    .then(function assert(data) {\n      const data1 = data[0]\n      const data2 = data[1]\n\n      const jsonData1 = CSON.readFileSync(\n        path.join(storagePath, 'notes', data1.key + '.cson')\n      )\n\n      t.is(jsonData1.folder, folderKey1)\n      t.is(jsonData1.title, note1.title)\n\n      const jsonData2 = CSON.readFileSync(\n        path.join(storagePath2, 'notes', data2.key + '.cson')\n      )\n      t.is(jsonData2.folder, folderKey2)\n      t.is(jsonData2.title, note2.title)\n      try {\n        CSON.readFileSync(path.join(storagePath, 'notes', note2.key + '.cson'))\n        t.fail('The old note should be deleted.')\n      } catch (err) {\n        t.is(err.code, 'ENOENT')\n      }\n    })\n})\n\ntest.after(function after() {\n  localStorage.clear()\n  sander.rimrafSync(storagePath)\n  sander.rimrafSync(storagePath2)\n})\n",
    "tests/dataApi/removeStorage-test.js": "const test = require('ava')\nconst removeStorage = require('browser/main/lib/dataApi/removeStorage')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst TestDummy = require('../fixtures/TestDummy')\nconst sander = require('sander')\nconst os = require('os')\n\nconst storagePath = path.join(os.tmpdir(), 'test/remove-storage')\n\ntest.beforeEach(t => {\n  t.context.storage = TestDummy.dummyStorage(storagePath)\n  localStorage.setItem('storages', JSON.stringify([t.context.storage.cache]))\n})\n\ntest('Remove a storage', t => {\n  const storageKey = t.context.storage.cache.key\n  return Promise.resolve()\n    .then(function doTest() {\n      return removeStorage(storageKey)\n    })\n    .then(function assert(data) {\n      t.is(JSON.parse(localStorage.getItem('storages')).length, 0)\n    })\n})\n\ntest.after(function after() {\n  localStorage.clear()\n  sander.rimrafSync(storagePath)\n})\n",
    "tests/dataApi/renameStorage-test.js": "const test = require('ava')\nconst renameStorage = require('browser/main/lib/dataApi/renameStorage')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst _ = require('lodash')\nconst TestDummy = require('../fixtures/TestDummy')\nconst sander = require('sander')\nconst os = require('os')\n\nconst storagePath = path.join(os.tmpdir(), 'test/rename-storage')\n\ntest.beforeEach(t => {\n  t.context.storage = TestDummy.dummyStorage(storagePath)\n  localStorage.setItem('storages', JSON.stringify([t.context.storage.cache]))\n})\n\ntest.serial('Rename a storage', t => {\n  const storageKey = t.context.storage.cache.key\n  return Promise.resolve()\n    .then(function doTest() {\n      return renameStorage(storageKey, 'changed')\n    })\n    .then(function assert(data) {\n      const cachedStorageList = JSON.parse(localStorage.getItem('storages'))\n      t.true(_.find(cachedStorageList, { key: storageKey }).name === 'changed')\n    })\n})\n\ntest.after(function after() {\n  localStorage.clear()\n  sander.rimrafSync(storagePath)\n})\n",
    "tests/dataApi/reorderFolder-test.js": "const test = require('ava')\nconst reorderFolder = require('browser/main/lib/dataApi/reorderFolder')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst _ = require('lodash')\nconst TestDummy = require('../fixtures/TestDummy')\nconst sander = require('sander')\nconst os = require('os')\nconst CSON = require('@rokt33r/season')\n\nconst storagePath = path.join(os.tmpdir(), 'test/reorder-folder')\n\ntest.beforeEach(t => {\n  t.context.storage = TestDummy.dummyStorage(storagePath)\n  localStorage.setItem('storages', JSON.stringify([t.context.storage.cache]))\n})\n\ntest.serial('Reorder a folder', t => {\n  const storageKey = t.context.storage.cache.key\n  const firstFolderKey = t.context.storage.json.folders[0].key\n  const secondFolderKey = t.context.storage.json.folders[1].key\n\n  return Promise.resolve()\n    .then(function doTest() {\n      return reorderFolder(storageKey, 0, 1)\n    })\n    .then(function assert(data) {\n      t.true(_.nth(data.storage.folders, 0).key === secondFolderKey)\n      t.true(_.nth(data.storage.folders, 1).key === firstFolderKey)\n\n      const jsonData = CSON.readFileSync(\n        path.join(data.storage.path, 'boostnote.json')\n      )\n\n      t.true(_.nth(jsonData.folders, 0).key === secondFolderKey)\n      t.true(_.nth(jsonData.folders, 1).key === firstFolderKey)\n    })\n})\n\ntest.after(function after() {\n  localStorage.clear()\n  sander.rimrafSync(storagePath)\n})\n",
    "tests/dataApi/toggleStorage-test.js": "const test = require('ava')\nconst toggleStorage = require('browser/main/lib/dataApi/toggleStorage')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst _ = require('lodash')\nconst TestDummy = require('../fixtures/TestDummy')\nconst sander = require('sander')\nconst os = require('os')\n\nconst storagePath = path.join(os.tmpdir(), 'test/toggle-storage')\n\ntest.beforeEach(t => {\n  t.context.storage = TestDummy.dummyStorage(storagePath)\n  localStorage.setItem('storages', JSON.stringify([t.context.storage.cache]))\n})\n\ntest.serial('Toggle a storage location', t => {\n  const storageKey = t.context.storage.cache.key\n  return Promise.resolve()\n    .then(function doTest() {\n      return toggleStorage(storageKey, true)\n    })\n    .then(function assert(data) {\n      const cachedStorageList = JSON.parse(localStorage.getItem('storages'))\n      t.true(_.find(cachedStorageList, { key: storageKey }).isOpen === true)\n    })\n})\n\ntest.after(function after() {\n  localStorage.clear()\n  sander.rimrafSync(storagePath)\n})\n",
    "tests/dataApi/updateFolder-test.js": "const test = require('ava')\nconst updateFolder = require('browser/main/lib/dataApi/updateFolder')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst _ = require('lodash')\nconst TestDummy = require('../fixtures/TestDummy')\nconst sander = require('sander')\nconst os = require('os')\nconst CSON = require('@rokt33r/season')\n\nconst storagePath = path.join(os.tmpdir(), 'test/update-folder')\n\ntest.beforeEach(t => {\n  t.context.storage = TestDummy.dummyStorage(storagePath)\n  localStorage.setItem('storages', JSON.stringify([t.context.storage.cache]))\n})\n\ntest.serial('Update a folder', t => {\n  const storageKey = t.context.storage.cache.key\n  const folderKey = t.context.storage.json.folders[0].key\n  const input = {\n    name: 'changed',\n    color: '#FF0000'\n  }\n  return Promise.resolve()\n    .then(function doTest() {\n      return updateFolder(storageKey, folderKey, input)\n    })\n    .then(function assert(data) {\n      t.true(_.find(data.storage.folders, input) != null)\n      const jsonData = CSON.readFileSync(\n        path.join(data.storage.path, 'boostnote.json')\n      )\n      console.log(path.join(data.storage.path, 'boostnote.json'))\n      t.true(_.find(jsonData.folders, input) != null)\n    })\n})\n\ntest.after(function after() {\n  localStorage.clear()\n  sander.rimrafSync(storagePath)\n})\n",
    "tests/dataApi/updateNote-test.js": "const test = require('ava')\nconst createNote = require('browser/main/lib/dataApi/createNote')\nconst updateNote = require('browser/main/lib/dataApi/updateNote')\n\nglobal.document = require('jsdom').jsdom('<body></body>')\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\n\nconst Storage = require('dom-storage')\nconst localStorage = (window.localStorage = global.localStorage = new Storage(\n  null,\n  { strict: true }\n))\nconst path = require('path')\nconst TestDummy = require('../fixtures/TestDummy')\nconst sander = require('sander')\nconst os = require('os')\nconst CSON = require('@rokt33r/season')\nconst faker = require('faker')\n\nconst storagePath = path.join(os.tmpdir(), 'test/update-note')\n\ntest.beforeEach(t => {\n  t.context.storage = TestDummy.dummyStorage(storagePath)\n  localStorage.setItem('storages', JSON.stringify([t.context.storage.cache]))\n})\n\ntest.serial('Update a note', t => {\n  const storageKey = t.context.storage.cache.key\n  const folderKey = t.context.storage.json.folders[0].key\n\n  const randLinesHighlightedArray = new Array(10)\n    .fill()\n    .map(() => Math.round(Math.random() * 10))\n  const randLinesHighlightedArray2 = new Array(15)\n    .fill()\n    .map(() => Math.round(Math.random() * 15))\n\n  const input1 = {\n    type: 'SNIPPET_NOTE',\n    description: faker.lorem.lines(),\n    snippets: [\n      {\n        name: faker.system.fileName(),\n        mode: 'text',\n        content: faker.lorem.lines(),\n        linesHighlighted: randLinesHighlightedArray\n      }\n    ],\n    tags: faker.lorem.words().split(' '),\n    folder: folderKey\n  }\n  input1.title = input1.description.split('\\n').shift()\n\n  const input2 = {\n    type: 'MARKDOWN_NOTE',\n    content: faker.lorem.lines(),\n    tags: faker.lorem.words().split(' '),\n    folder: folderKey,\n    linesHighlighted: randLinesHighlightedArray\n  }\n  input2.title = input2.content.split('\\n').shift()\n\n  const input3 = {\n    type: 'SNIPPET_NOTE',\n    description: faker.lorem.lines(),\n    snippets: [\n      {\n        name: faker.system.fileName(),\n        mode: 'text',\n        content: faker.lorem.lines(),\n        linesHighlighted: randLinesHighlightedArray2\n      }\n    ],\n    tags: faker.lorem.words().split(' ')\n  }\n  input3.title = input3.description.split('\\n').shift()\n\n  const input4 = {\n    type: 'MARKDOWN_NOTE',\n    content: faker.lorem.lines(),\n    tags: faker.lorem.words().split(' '),\n    linesHighlighted: randLinesHighlightedArray2\n  }\n  input4.title = input4.content.split('\\n').shift()\n\n  return Promise.resolve()\n    .then(function doTest() {\n      return Promise.all([\n        createNote(storageKey, input1),\n        createNote(storageKey, input2)\n      ]).then(function updateNotes(data) {\n        const data1 = data[0]\n        const data2 = data[1]\n        return Promise.all([\n          updateNote(data1.storage, data1.key, input3),\n          updateNote(data1.storage, data2.key, input4)\n        ])\n      })\n    })\n    .then(function assert(data) {\n      const data1 = data[0]\n      const data2 = data[1]\n\n      const jsonData1 = CSON.readFileSync(\n        path.join(storagePath, 'notes', data1.key + '.cson')\n      )\n      t.is(input3.title, data1.title)\n      t.is(input3.title, jsonData1.title)\n      t.is(input3.description, data1.description)\n      t.is(input3.description, jsonData1.description)\n      t.is(input3.tags.length, data1.tags.length)\n      t.is(input3.tags.length, jsonData1.tags.length)\n      t.is(input3.snippets.length, data1.snippets.length)\n      t.is(input3.snippets.length, jsonData1.snippets.length)\n      t.is(input3.snippets[0].content, data1.snippets[0].content)\n      t.is(input3.snippets[0].content, jsonData1.snippets[0].content)\n      t.is(input3.snippets[0].name, data1.snippets[0].name)\n      t.is(input3.snippets[0].name, jsonData1.snippets[0].name)\n      t.deepEqual(\n        input3.snippets[0].linesHighlighted,\n        data1.snippets[0].linesHighlighted\n      )\n      t.deepEqual(\n        input3.snippets[0].linesHighlighted,\n        jsonData1.snippets[0].linesHighlighted\n      )\n\n      const jsonData2 = CSON.readFileSync(\n        path.join(storagePath, 'notes', data2.key + '.cson')\n      )\n      t.is(input4.title, data2.title)\n      t.is(input4.title, jsonData2.title)\n      t.is(input4.content, data2.content)\n      t.is(input4.content, jsonData2.content)\n      t.is(input4.tags.length, data2.tags.length)\n      t.is(input4.tags.length, jsonData2.tags.length)\n      t.deepEqual(input4.linesHighlighted, data2.linesHighlighted)\n      t.deepEqual(input4.linesHighlighted, jsonData2.linesHighlighted)\n    })\n})\n\ntest.after(function after() {\n  localStorage.clear()\n  sander.rimrafSync(storagePath)\n})\n",
    "tests/dataApi/updateSnippet-test.js": "const test = require('ava')\nconst updateSnippet = require('browser/main/lib/dataApi/updateSnippet')\nconst sander = require('sander')\nconst os = require('os')\nconst path = require('path')\nconst crypto = require('crypto')\n\nconst snippetFilePath = path.join(os.tmpdir(), 'test', 'update-snippet')\nconst snippetFile = path.join(snippetFilePath, 'snippets.json')\nconst oldSnippet = {\n  id: crypto.randomBytes(16).toString('hex'),\n  name: 'Initial snippet',\n  prefix: [],\n  content: ''\n}\n\nconst newSnippet = {\n  id: oldSnippet.id,\n  name: 'new name',\n  prefix: ['prefix'],\n  content: 'new content'\n}\n\ntest.beforeEach(t => {\n  sander.writeFileSync(snippetFile, JSON.stringify([oldSnippet]))\n})\n\ntest.serial('Update a snippet', t => {\n  return Promise.resolve()\n    .then(function doTest() {\n      return Promise.all([updateSnippet(newSnippet, snippetFile)])\n    })\n    .then(function assert() {\n      const snippets = JSON.parse(sander.readFileSync(snippetFile))\n      const snippet = snippets.find(\n        currentSnippet => currentSnippet.id === newSnippet.id\n      )\n      t.not(snippet, undefined)\n      t.is(snippet.name, newSnippet.name)\n      t.deepEqual(snippet.prefix, newSnippet.prefix)\n      t.is(snippet.content, newSnippet.content)\n    })\n})\n\ntest.after.always(() => {\n  sander.rimrafSync(snippetFilePath)\n})\n",
    "browser/main/lib/dataApi/createNoteFromUrl.js": "const http = require('http')\nconst https = require('https')\nconst { createTurndownService } = require('../../../lib/turndown')\nconst createNote = require('./createNote')\n\nimport { push } from 'connected-react-router'\nimport ee from 'browser/main/lib/eventEmitter'\n\nfunction validateUrl(str) {\n  if (\n    /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})).?)(?::\\d{2,5})?(?:[/?#]\\S*)?$/i.test(\n      str\n    )\n  ) {\n    return true\n  } else {\n    return false\n  }\n}\n\nconst ERROR_MESSAGES = {\n  ENOTFOUND:\n    'URL not found. Please check the URL, or your internet connection and try again.',\n  VALIDATION_ERROR:\n    'Please check if the URL follows this format: https://www.google.com',\n  UNEXPECTED: 'Unexpected error! Please check console for details!'\n}\n\nfunction createNoteFromUrl(\n  url,\n  storage,\n  folder,\n  dispatch = null,\n  location = null\n) {\n  return new Promise((resolve, reject) => {\n    const td = createTurndownService()\n\n    if (!validateUrl(url)) {\n      reject({ result: false, error: ERROR_MESSAGES.VALIDATION_ERROR })\n    }\n\n    const request = url.startsWith('https') ? https : http\n\n    const req = request.request(url, res => {\n      let data = ''\n\n      res.on('data', chunk => {\n        data += chunk\n      })\n\n      res.on('end', () => {\n        const markdownHTML = td.turndown(data)\n\n        if (dispatch !== null) {\n          createNote(storage, {\n            type: 'MARKDOWN_NOTE',\n            folder: folder,\n            title: '',\n            content: markdownHTML\n          }).then(note => {\n            const noteHash = note.key\n            dispatch({\n              type: 'UPDATE_NOTE',\n              note: note\n            })\n            dispatch(\n              push({\n                pathname: location.pathname,\n                query: { key: noteHash }\n              })\n            )\n            ee.emit('list:jump', noteHash)\n            ee.emit('detail:focus')\n            resolve({ result: true, error: null })\n          })\n        } else {\n          createNote(storage, {\n            type: 'MARKDOWN_NOTE',\n            folder: folder,\n            title: '',\n            content: markdownHTML\n          }).then(note => {\n            resolve({ result: true, note, error: null })\n          })\n        }\n      })\n    })\n\n    req.on('error', e => {\n      console.error('error in parsing URL', e)\n      reject({\n        result: false,\n        error: ERROR_MESSAGES[e.code] || ERROR_MESSAGES.UNEXPECTED\n      })\n    })\n\n    req.end()\n  })\n}\n\nmodule.exports = createNoteFromUrl\n",
    "browser/main/lib/dataApi/createSnippet.js": "import fs from 'fs'\nimport crypto from 'crypto'\nimport consts from 'browser/lib/consts'\nimport fetchSnippet from 'browser/main/lib/dataApi/fetchSnippet'\n\nfunction createSnippet(snippetFile) {\n  return new Promise((resolve, reject) => {\n    const newSnippet = {\n      id: crypto.randomBytes(16).toString('hex'),\n      name: 'Unnamed snippet',\n      prefix: [],\n      content: '',\n      linesHighlighted: []\n    }\n    fetchSnippet(null, snippetFile)\n      .then(snippets => {\n        snippets.push(newSnippet)\n        fs.writeFile(\n          snippetFile || consts.SNIPPET_FILE,\n          JSON.stringify(snippets, null, 4),\n          err => {\n            if (err) reject(err)\n            resolve(newSnippet)\n          }\n        )\n      })\n      .catch(err => {\n        reject(err)\n      })\n  })\n}\n\nmodule.exports = createSnippet\n",
    "browser/main/lib/dataApi/attachmentManagement.js": "const uniqueSlug = require('unique-slug')\nconst fs = require('fs')\nconst path = require('path')\nconst findStorage = require('browser/lib/findStorage')\nconst mdurl = require('mdurl')\nconst fse = require('fs-extra')\nconst escapeStringRegexp = require('escape-string-regexp')\nconst sander = require('sander')\nconst url = require('url')\nimport i18n from 'browser/lib/i18n'\nimport { isString } from 'lodash'\n\nconst STORAGE_FOLDER_PLACEHOLDER = ':storage'\nconst DESTINATION_FOLDER = 'attachments'\nconst PATH_SEPARATORS =\n  escapeStringRegexp(path.posix.sep) + escapeStringRegexp(path.win32.sep)\n/**\n * @description\n * Create a Image element to get the real size of image.\n * @param {File} file the File object dropped.\n * @returns {Promise<Image>} Image element created\n */\nfunction getImage(file) {\n  if (isString(file)) {\n    return new Promise(resolve => {\n      const img = new Image()\n      img.onload = () => resolve(img)\n      img.src = file\n    })\n  } else {\n    return new Promise(resolve => {\n      const reader = new FileReader()\n      const img = new Image()\n      img.onload = () => resolve(img)\n      reader.onload = e => {\n        img.src = e.target.result\n      }\n      reader.readAsDataURL(file)\n    })\n  }\n}\n\n/**\n * @description\n * Get the orientation info from iamges's EXIF data.\n * case 1: The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.\n * case 2: The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.\n * case 3: The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.\n * case 4: The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side.\n * case 5: The 0th row is the visual left-hand side of the image, and the 0th column is the visual top.\n * case 6: The 0th row is the visual right-hand side of the image, and the 0th column is the visual top.\n * case 7: The 0th row is the visual right-hand side of the image, and the 0th column is the visual bottom.\n * case 8: The 0th row is the visual left-hand side of the image, and the 0th column is the visual bottom.\n * Other: reserved\n * ref: http://sylvana.net/jpegcrop/exif_orientation.html\n * @param {File} file the File object dropped.\n * @returns {Promise<Number>} Orientation info\n */\nfunction getOrientation(file) {\n  const getData = arrayBuffer => {\n    const view = new DataView(arrayBuffer)\n\n    // Not start with SOI(Start of image) Marker return fail value\n    if (view.getUint16(0, false) !== 0xffd8) return -2\n    const length = view.byteLength\n    let offset = 2\n    while (offset < length) {\n      const marker = view.getUint16(offset, false)\n      offset += 2\n      // Loop and seed for APP1 Marker\n      if (marker === 0xffe1) {\n        // return fail value if it isn't EXIF data\n        if (view.getUint32((offset += 2), false) !== 0x45786966) {\n          return -1\n        }\n        // Read TIFF header,\n        // First 2bytes defines byte align of TIFF data.\n        // If it is 0x4949=\"II\", it means \"Intel\" type byte align.\n        // If it is 0x4d4d=\"MM\", it means \"Motorola\" type byte align\n        const little = view.getUint16((offset += 6), false) === 0x4949\n        offset += view.getUint32(offset + 4, little)\n        const tags = view.getUint16(offset, little) // Get TAG number\n        offset += 2\n        for (let i = 0; i < tags; i++) {\n          // Loop to find Orientation TAG and return the value\n          if (view.getUint16(offset + i * 12, little) === 0x0112) {\n            return view.getUint16(offset + i * 12 + 8, little)\n          }\n        }\n      } else if ((marker & 0xff00) !== 0xff00) {\n        // If not start with 0xFF, not a Marker.\n        break\n      } else {\n        offset += view.getUint16(offset, false)\n      }\n    }\n    return -1\n  }\n  return new Promise(resolve => {\n    const reader = new FileReader()\n    reader.onload = event => resolve(getData(event.target.result))\n    reader.readAsArrayBuffer(file.slice(0, 64 * 1024))\n  })\n}\n/**\n * @description\n * Rotate image file to correct direction.\n * Create a canvas and draw the image with correct direction, then export to base64 format.\n * @param {*} file the File object dropped.\n * @return {String} Base64 encoded image.\n */\nfunction fixRotate(file) {\n  return Promise.all([getImage(file), getOrientation(file)]).then(\n    ([img, orientation]) => {\n      const canvas = document.createElement('canvas')\n      const ctx = canvas.getContext('2d')\n      if (orientation > 4 && orientation < 9) {\n        canvas.width = img.height\n        canvas.height = img.width\n      } else {\n        canvas.width = img.width\n        canvas.height = img.height\n      }\n      switch (orientation) {\n        case 2:\n          ctx.transform(-1, 0, 0, 1, img.width, 0)\n          break\n        case 3:\n          ctx.transform(-1, 0, 0, -1, img.width, img.height)\n          break\n        case 4:\n          ctx.transform(1, 0, 0, -1, 0, img.height)\n          break\n        case 5:\n          ctx.transform(0, 1, 1, 0, 0, 0)\n          break\n        case 6:\n          ctx.transform(0, 1, -1, 0, img.height, 0)\n          break\n        case 7:\n          ctx.transform(0, -1, -1, 0, img.height, img.width)\n          break\n        case 8:\n          ctx.transform(0, -1, 1, 0, 0, img.width)\n          break\n        default:\n          break\n      }\n      ctx.drawImage(img, 0, 0)\n      return canvas.toDataURL()\n    }\n  )\n}\n\n/**\n * @description\n * Copies a copy of an attachment to the storage folder specified by the given key and return the generated attachment name.\n * Renames the file to match a unique file name.\n *\n * @param {String} sourceFilePath The source path of the attachment to be copied\n * @param {String} storageKey Storage key of the destination storage\n * @param {String} noteKey Key of the current note. Will be used as subfolder in :storage\n * @param {boolean} useRandomName determines whether a random filename for the new file is used. If false the source file name is used\n * @return {Promise<String>} name (inclusive extension) of the generated file\n */\nfunction copyAttachment(\n  sourceFilePath,\n  storageKey,\n  noteKey,\n  useRandomName = true\n) {\n  return new Promise((resolve, reject) => {\n    if (!sourceFilePath) {\n      reject('sourceFilePath has to be given')\n    }\n\n    if (!storageKey) {\n      reject('storageKey has to be given')\n    }\n\n    if (!noteKey) {\n      reject('noteKey has to be given')\n    }\n\n    try {\n      const isBase64 =\n        typeof sourceFilePath === 'object' && sourceFilePath.type === 'base64'\n      if (!isBase64 && !fs.existsSync(sourceFilePath)) {\n        return reject('source file does not exist')\n      }\n\n      const sourcePath = sourceFilePath.sourceFilePath || sourceFilePath\n      const sourceURL = url.parse(\n        /^\\w+:\\/\\//.test(sourcePath) ? sourcePath : 'file:///' + sourcePath\n      )\n\n      let destinationName\n      if (useRandomName) {\n        destinationName = `${uniqueSlug()}${path.extname(sourceURL.pathname) ||\n          '.png'}`\n      } else {\n        destinationName = path.basename(sourceURL.pathname)\n      }\n\n      const targetStorage = findStorage.findStorage(storageKey)\n      const destinationDir = path.join(\n        targetStorage.path,\n        DESTINATION_FOLDER,\n        noteKey\n      )\n      createAttachmentDestinationFolder(targetStorage.path, noteKey)\n      const outputFile = fs.createWriteStream(\n        path.join(destinationDir, destinationName)\n      )\n\n      if (isBase64) {\n        const base64Data = sourceFilePath.data.replace(\n          /^data:image\\/\\w+;base64,/,\n          ''\n        )\n        const dataBuffer = Buffer.from(base64Data, 'base64')\n        outputFile.write(dataBuffer, () => {\n          resolve(destinationName)\n        })\n      } else {\n        const inputFileStream = fs.createReadStream(sourceFilePath)\n        inputFileStream.pipe(outputFile)\n        inputFileStream.on('end', () => {\n          resolve(destinationName)\n        })\n      }\n    } catch (e) {\n      return reject(e)\n    }\n  })\n}\n\nfunction createAttachmentDestinationFolder(destinationStoragePath, noteKey) {\n  let destinationDir = path.join(destinationStoragePath, DESTINATION_FOLDER)\n  if (!fs.existsSync(destinationDir)) {\n    fs.mkdirSync(destinationDir)\n  }\n  destinationDir = path.join(\n    destinationStoragePath,\n    DESTINATION_FOLDER,\n    noteKey\n  )\n  if (!fs.existsSync(destinationDir)) {\n    fs.mkdirSync(destinationDir)\n  }\n}\n\n/**\n * @description Moves attachments from the old location ('/images') to the new one ('/attachments/noteKey)\n * @param markdownContent of the current note\n * @param storagePath Storage path of the current note\n * @param noteKey Key of the current note\n */\nfunction migrateAttachments(markdownContent, storagePath, noteKey) {\n  if (\n    noteKey !== undefined &&\n    sander.existsSync(path.join(storagePath, 'images'))\n  ) {\n    const attachments = getAttachmentsInMarkdownContent(markdownContent) || []\n    if (attachments.length) {\n      createAttachmentDestinationFolder(storagePath, noteKey)\n    }\n    for (const attachment of attachments) {\n      const attachmentBaseName = path.basename(attachment)\n      const possibleLegacyPath = path.join(\n        storagePath,\n        'images',\n        attachmentBaseName\n      )\n      if (sander.existsSync(possibleLegacyPath)) {\n        const destinationPath = path.join(\n          storagePath,\n          DESTINATION_FOLDER,\n          attachmentBaseName\n        )\n        if (!sander.existsSync(destinationPath)) {\n          sander.copyFileSync(possibleLegacyPath).to(destinationPath)\n        }\n      }\n    }\n  }\n}\n\n/**\n * @description Fixes the URLs embedded in the generated HTML so that they again refer actual local files.\n * @param {String} renderedHTML HTML in that the links should be fixed\n * @param {String} storagePath Path of the current storage\n * @returns {String} postprocessed HTML in which all :storage references are mapped to the actual paths.\n */\nfunction fixLocalURLS(renderedHTML, storagePath) {\n  const encodedWin32SeparatorRegex = /%5C/g\n  const storageRegex = new RegExp('/?' + STORAGE_FOLDER_PLACEHOLDER, 'g')\n  const storageUrl =\n    'file:///' + path.join(storagePath, DESTINATION_FOLDER).replace(/\\\\/g, '/')\n\n  /*\n    A :storage reference is like `:storage/3b6f8bd6-4edd-4b15-96e0-eadc4475b564/f939b2c3.jpg`.\n\n    - `STORAGE_FOLDER_PLACEHOLDER` will match `:storage`\n    - `(?:(?:\\\\\\/|%5C)[-.\\\\w]+)+` will match `/3b6f8bd6-4edd-4b15-96e0-eadc4475b564/f939b2c3.jpg`\n    - `(?:\\\\\\/|%5C)[-.\\\\w]+` will either match `/3b6f8bd6-4edd-4b15-96e0-eadc4475b564` or `/f939b2c3.jpg`\n    - `(?:\\\\\\/|%5C)` match the path seperator. `\\\\\\/` for posix systems and `%5C` for windows.\n  */\n  return renderedHTML.replace(\n    new RegExp(\n      '/?' + STORAGE_FOLDER_PLACEHOLDER + '(?:(?:\\\\/|%5C)[-.\\\\w]+)+',\n      'g'\n    ),\n    function(match) {\n      return match\n        .replace(encodedWin32SeparatorRegex, '/')\n        .replace(storageRegex, storageUrl)\n    }\n  )\n}\n\n/**\n * @description Generates the markdown code for a given attachment\n * @param {String} fileName Name of the attachment\n * @param {String} path Path of the attachment\n * @param {Boolean} showPreview Indicator whether the generated markdown should show a preview of the image. Note that at the moment only previews for images are supported\n * @returns {String} Generated markdown code\n */\nfunction generateAttachmentMarkdown(fileName, path, showPreview) {\n  return `${showPreview ? '!' : ''}[${fileName}](${path})`\n}\n\n/**\n * @description Handles the drop-event of a file. Includes the necessary markdown code and copies the file to the corresponding storage folder.\n * The method calls {CodeEditor#insertAttachmentMd()} to include the generated markdown at the needed place!\n * @param {CodeEditor} codeEditor Markdown editor. Its insertAttachmentMd() method will be called to include the markdown code\n * @param {String} storageKey Key of the current storage\n * @param {String} noteKey Key of the current note\n * @param {Event} dropEvent DropEvent\n */\nfunction handleAttachmentDrop(codeEditor, storageKey, noteKey, dropEvent) {\n  let promise\n  if (dropEvent.dataTransfer.files.length > 0) {\n    promise = Promise.all(\n      Array.from(dropEvent.dataTransfer.files).map(file => {\n        const filePath = file.path\n        const fileType = file.type // EX) 'image/gif' or 'text/html'\n        if (fileType.startsWith('image')) {\n          if (fileType === 'image/gif' || fileType === 'image/svg+xml') {\n            return copyAttachment(filePath, storageKey, noteKey).then(\n              fileName => ({\n                fileName,\n                title: path.basename(filePath),\n                isImage: true\n              })\n            )\n          } else {\n            return getOrientation(file)\n              .then(orientation => {\n                if (orientation === -1) {\n                  // The image rotation is correct and does not need adjustment\n                  return copyAttachment(filePath, storageKey, noteKey)\n                } else {\n                  return fixRotate(file).then(data =>\n                    copyAttachment(\n                      {\n                        type: 'base64',\n                        data: data,\n                        sourceFilePath: filePath\n                      },\n                      storageKey,\n                      noteKey\n                    )\n                  )\n                }\n              })\n              .then(fileName => ({\n                fileName,\n                title: path.basename(filePath),\n                isImage: true\n              }))\n          }\n        } else {\n          return copyAttachment(filePath, storageKey, noteKey).then(\n            fileName => ({\n              fileName,\n              title: path.basename(filePath),\n              isImage: false\n            })\n          )\n        }\n      })\n    )\n  } else {\n    let imageURL = dropEvent.dataTransfer.getData('text/plain')\n\n    if (!imageURL) {\n      const match = /<img[^>]*[\\s\"']src=\"([^\"]+)\"/.exec(\n        dropEvent.dataTransfer.getData('text/html')\n      )\n      if (match) {\n        imageURL = match[1]\n      }\n    }\n\n    if (!imageURL) {\n      return\n    }\n\n    promise = Promise.all([\n      getImage(imageURL)\n        .then(image => {\n          const canvas = document.createElement('canvas')\n          const context = canvas.getContext('2d')\n          canvas.width = image.width\n          canvas.height = image.height\n          context.drawImage(image, 0, 0)\n\n          return copyAttachment(\n            {\n              type: 'base64',\n              data: canvas.toDataURL(),\n              sourceFilePath: imageURL\n            },\n            storageKey,\n            noteKey\n          )\n        })\n        .then(fileName => ({\n          fileName,\n          title: imageURL,\n          isImage: true\n        }))\n    ])\n  }\n\n  promise.then(files => {\n    const attachments = files\n      .filter(file => !!file)\n      .map(file =>\n        generateAttachmentMarkdown(\n          file.title,\n          path.join(STORAGE_FOLDER_PLACEHOLDER, noteKey, file.fileName),\n          file.isImage\n        )\n      )\n\n    codeEditor.insertAttachmentMd(attachments.join('\\n'))\n  })\n}\n\n/**\n * @description Creates a new file in the storage folder belonging to the current note and inserts the correct markdown code\n * @param {CodeEditor} codeEditor Markdown editor. Its insertAttachmentMd() method will be called to include the markdown code\n * @param {String} storageKey Key of the current storage\n * @param {String} noteKey Key of the current note\n * @param {DataTransferItem} dataTransferItem Part of the past-event\n */\nfunction handlePasteImageEvent(\n  codeEditor,\n  storageKey,\n  noteKey,\n  dataTransferItem\n) {\n  if (!codeEditor) {\n    throw new Error('codeEditor has to be given')\n  }\n  if (!storageKey) {\n    throw new Error('storageKey has to be given')\n  }\n\n  if (!noteKey) {\n    throw new Error('noteKey has to be given')\n  }\n  if (!dataTransferItem) {\n    throw new Error('dataTransferItem has to be given')\n  }\n\n  const blob = dataTransferItem.getAsFile()\n  const reader = new FileReader()\n  let base64data\n  const targetStorage = findStorage.findStorage(storageKey)\n  const destinationDir = path.join(\n    targetStorage.path,\n    DESTINATION_FOLDER,\n    noteKey\n  )\n  createAttachmentDestinationFolder(targetStorage.path, noteKey)\n\n  const imageName = `${uniqueSlug()}.png`\n  const imagePath = path.join(destinationDir, imageName)\n\n  reader.onloadend = function() {\n    base64data = reader.result.replace(/^data:image\\/png;base64,/, '')\n    base64data += base64data.replace('+', ' ')\n    const binaryData = new Buffer(base64data, 'base64').toString('binary')\n    fs.writeFileSync(imagePath, binaryData, 'binary')\n    const imageReferencePath = path.join(\n      STORAGE_FOLDER_PLACEHOLDER,\n      noteKey,\n      imageName\n    )\n    const imageMd = generateAttachmentMarkdown(\n      imageName,\n      imageReferencePath,\n      true\n    )\n    codeEditor.insertAttachmentMd(imageMd)\n  }\n  reader.readAsDataURL(blob)\n}\n\n/**\n * @description Creates a new file in the storage folder belonging to the current note and inserts the correct markdown code\n * @param {CodeEditor} codeEditor Markdown editor. Its insertAttachmentMd() method will be called to include the markdown code\n * @param {String} storageKey Key of the current storage\n * @param {String} noteKey Key of the current note\n * @param {NativeImage} image The native image\n */\nfunction handlePasteNativeImage(codeEditor, storageKey, noteKey, image) {\n  if (!codeEditor) {\n    throw new Error('codeEditor has to be given')\n  }\n  if (!storageKey) {\n    throw new Error('storageKey has to be given')\n  }\n\n  if (!noteKey) {\n    throw new Error('noteKey has to be given')\n  }\n  if (!image) {\n    throw new Error('image has to be given')\n  }\n\n  const targetStorage = findStorage.findStorage(storageKey)\n  const destinationDir = path.join(\n    targetStorage.path,\n    DESTINATION_FOLDER,\n    noteKey\n  )\n\n  createAttachmentDestinationFolder(targetStorage.path, noteKey)\n\n  const imageName = `${uniqueSlug()}.png`\n  const imagePath = path.join(destinationDir, imageName)\n\n  const binaryData = image.toPNG()\n  fs.writeFileSync(imagePath, binaryData, 'binary')\n\n  const imageReferencePath = path.join(\n    STORAGE_FOLDER_PLACEHOLDER,\n    noteKey,\n    imageName\n  )\n  const imageMd = generateAttachmentMarkdown(\n    imageName,\n    imageReferencePath,\n    true\n  )\n  codeEditor.insertAttachmentMd(imageMd)\n}\n\n/**\n * @description Returns all attachment paths of the given markdown\n * @param {String} markdownContent content in which the attachment paths should be found\n * @returns {String[]} Array of the relative paths (starting with :storage) of the attachments of the given markdown\n */\nfunction getAttachmentsInMarkdownContent(markdownContent) {\n  const preparedInput = markdownContent.replace(\n    new RegExp('[' + PATH_SEPARATORS + ']', 'g'),\n    path.sep\n  )\n  const regexp = new RegExp(\n    '/?' +\n      STORAGE_FOLDER_PLACEHOLDER +\n      '(' +\n      escapeStringRegexp(path.sep) +\n      ')' +\n      '?([a-zA-Z0-9]|-)*' +\n      '(' +\n      escapeStringRegexp(path.sep) +\n      ')' +\n      '([a-zA-Z0-9]|\\\\.)+(\\\\.[a-zA-Z0-9]+)?',\n    'g'\n  )\n  return preparedInput.match(regexp)\n}\n\n/**\n * @description Returns an array of the absolute paths of the attachments referenced in the given markdown code\n * @param {String} markdownContent content in which the attachment paths should be found\n * @param {String} storagePath path of the current storage\n * @returns {String[]} Absolute paths of the referenced attachments\n */\nfunction getAbsolutePathsOfAttachmentsInContent(markdownContent, storagePath) {\n  const temp = getAttachmentsInMarkdownContent(markdownContent) || []\n  const result = []\n  for (const relativePath of temp) {\n    result.push(\n      relativePath.replace(\n        new RegExp(STORAGE_FOLDER_PLACEHOLDER, 'g'),\n        path.join(storagePath, DESTINATION_FOLDER)\n      )\n    )\n  }\n  return result\n}\n\n/**\n * @description Copies the attachments to the storage folder and returns the mardown content it should be replaced with\n * @param {String} markDownContent content in which the attachment paths should be found\n * @param {String} filepath The path of the file with attachments to import\n * @param {String} storageKey Storage key of the destination storage\n * @param {String} noteKey Key of the current note. Will be used as subfolder in :storage\n */\nfunction importAttachments(markDownContent, filepath, storageKey, noteKey) {\n  return new Promise((resolve, reject) => {\n    const nameRegex = /(!\\[.*?]\\()(.+?\\..+?)(\\))/g\n    let attachPath = nameRegex.exec(markDownContent)\n    const promiseArray = []\n    const attachmentPaths = []\n    const groupIndex = 2\n\n    while (attachPath) {\n      let attachmentPath = attachPath[groupIndex]\n      attachmentPaths.push(attachmentPath)\n      attachmentPath = path.isAbsolute(attachmentPath)\n        ? attachmentPath\n        : path.join(path.dirname(filepath), attachmentPath)\n      promiseArray.push(\n        this.copyAttachment(attachmentPath, storageKey, noteKey)\n      )\n      attachPath = nameRegex.exec(markDownContent)\n    }\n\n    let numResolvedPromises = 0\n\n    if (promiseArray.length === 0) {\n      resolve(markDownContent)\n    }\n\n    for (let j = 0; j < promiseArray.length; j++) {\n      promiseArray[j]\n        .then(fileName => {\n          const newPath = path.join(\n            STORAGE_FOLDER_PLACEHOLDER,\n            noteKey,\n            fileName\n          )\n          markDownContent = markDownContent.replace(attachmentPaths[j], newPath)\n        })\n        .catch(e => {\n          console.error('File does not exist in path: ' + attachmentPaths[j])\n        })\n        .finally(() => {\n          numResolvedPromises++\n          if (numResolvedPromises === promiseArray.length) {\n            resolve(markDownContent)\n          }\n        })\n    }\n  })\n}\n\n/**\n * @description Moves the attachments of the current note to the new location.\n * Returns a modified version of the given content so that the links to the attachments point to the new note key.\n * @param {String} oldPath Source of the note to be moved\n * @param {String} newPath Destination of the note to be moved\n * @param {String} noteKey Old note key\n * @param {String} newNoteKey New note key\n * @param {String} noteContent Content of the note to be moved\n * @returns {String} Modified version of noteContent in which the paths of the attachments are fixed\n */\nfunction moveAttachments(oldPath, newPath, noteKey, newNoteKey, noteContent) {\n  const src = path.join(oldPath, DESTINATION_FOLDER, noteKey)\n  const dest = path.join(newPath, DESTINATION_FOLDER, newNoteKey)\n  if (fse.existsSync(src)) {\n    fse.moveSync(src, dest)\n  }\n  return replaceNoteKeyWithNewNoteKey(noteContent, noteKey, newNoteKey)\n}\n\n/**\n * Modifies the given content so that in all attachment references the oldNoteKey is replaced by the new one\n * @param noteContent content that should be modified\n * @param oldNoteKey note key to be replaced\n * @param newNoteKey note key serving as a replacement\n * @returns {String} modified note content\n */\nfunction replaceNoteKeyWithNewNoteKey(noteContent, oldNoteKey, newNoteKey) {\n  if (noteContent) {\n    const preparedInput = noteContent.replace(\n      new RegExp('[' + PATH_SEPARATORS + ']', 'g'),\n      path.sep\n    )\n    return preparedInput.replace(\n      new RegExp(\n        STORAGE_FOLDER_PLACEHOLDER + escapeStringRegexp(path.sep) + oldNoteKey,\n        'g'\n      ),\n      path.join(STORAGE_FOLDER_PLACEHOLDER, newNoteKey)\n    )\n  }\n  return noteContent\n}\n\n/**\n * @description replace all :storage references with given destination folder.\n * @param input Input in which the references should be replaced\n * @param noteKey Key of the current note\n * @param destinationFolder Destination folder of the attachements\n * @returns {String} Input without the references\n */\nfunction replaceStorageReferences(input, noteKey, destinationFolder) {\n  return input.replace(\n    new RegExp('/?' + STORAGE_FOLDER_PLACEHOLDER + '[^\"\\\\)<\\\\s]+', 'g'),\n    function(match) {\n      return match\n        .replace(new RegExp(mdurl.encode(path.win32.sep), 'g'), path.posix.sep)\n        .replace(new RegExp(mdurl.encode(path.posix.sep), 'g'), path.posix.sep)\n        .replace(\n          new RegExp(escapeStringRegexp(path.win32.sep), 'g'),\n          path.posix.sep\n        )\n        .replace(\n          new RegExp(escapeStringRegexp(path.posix.sep), 'g'),\n          path.posix.sep\n        )\n        .replace(\n          new RegExp(\n            STORAGE_FOLDER_PLACEHOLDER +\n              '(' +\n              escapeStringRegexp(path.sep) +\n              noteKey +\n              ')?',\n            'g'\n          ),\n          destinationFolder\n        )\n    }\n  )\n}\n\n/**\n * @description Deletes the attachment folder specified by the given storageKey and noteKey\n * @param storageKey Key of the storage of the note to be deleted\n * @param noteKey Key of the note to be deleted\n */\nfunction deleteAttachmentFolder(storageKey, noteKey) {\n  const storagePath = findStorage.findStorage(storageKey)\n  const noteAttachmentPath = path.join(\n    storagePath.path,\n    DESTINATION_FOLDER,\n    noteKey\n  )\n  sander.rimrafSync(noteAttachmentPath)\n}\n\n/**\n * @description Deletes all attachments stored in the attachment folder of the give not that are not referenced in the markdownContent\n * @param markdownContent Content of the note. All unreferenced notes will be deleted\n * @param storageKey StorageKey of the current note. Is used to determine the belonging attachment folder.\n * @param noteKey NoteKey of the current note. Is used to determine the belonging attachment folder.\n */\nfunction deleteAttachmentsNotPresentInNote(\n  markdownContent,\n  storageKey,\n  noteKey\n) {\n  if (storageKey == null || noteKey == null || markdownContent == null) {\n    return\n  }\n  const targetStorage = findStorage.findStorage(storageKey)\n  const attachmentFolder = path.join(\n    targetStorage.path,\n    DESTINATION_FOLDER,\n    noteKey\n  )\n  const attachmentsInNote = getAttachmentsInMarkdownContent(markdownContent)\n  const attachmentsInNoteOnlyFileNames = []\n  if (attachmentsInNote) {\n    for (let i = 0; i < attachmentsInNote.length; i++) {\n      attachmentsInNoteOnlyFileNames.push(\n        attachmentsInNote[i].replace(\n          new RegExp(\n            STORAGE_FOLDER_PLACEHOLDER +\n              escapeStringRegexp(path.sep) +\n              noteKey +\n              escapeStringRegexp(path.sep),\n            'g'\n          ),\n          ''\n        )\n      )\n    }\n  }\n  if (fs.existsSync(attachmentFolder)) {\n    fs.readdir(attachmentFolder, (err, files) => {\n      if (err) {\n        console.error(\n          'Error reading directory \"' + attachmentFolder + '\". Error:'\n        )\n        console.error(err)\n        return\n      }\n      files.forEach(file => {\n        if (!attachmentsInNoteOnlyFileNames.includes(file)) {\n          const absolutePathOfFile = path.join(\n            targetStorage.path,\n            DESTINATION_FOLDER,\n            noteKey,\n            file\n          )\n          fs.unlink(absolutePathOfFile, err => {\n            if (err) {\n              console.error('Could not delete \"%s\"', absolutePathOfFile)\n              console.error(err)\n              return\n            }\n            console.info(\n              'File \"' +\n                absolutePathOfFile +\n                '\" deleted because it was not included in the content of the note'\n            )\n          })\n        }\n      })\n    })\n  }\n}\n\n/**\n * @description Get all existing attachments related to a specific note\n including their status (in use or not) and their path. Return null if there're no attachment related to note or specified parametters are invalid\n * @param markdownContent markdownContent of the current note\n * @param storageKey StorageKey of the current note\n * @param noteKey NoteKey of the currentNote\n * @return {Promise<Array<{path: String, isInUse: bool}>>} Promise returning the\n list of attachments with their properties */\nfunction getAttachmentsPathAndStatus(markdownContent, storageKey, noteKey) {\n  if (storageKey == null || noteKey == null || markdownContent == null) {\n    return null\n  }\n  let targetStorage = null\n  try {\n    targetStorage = findStorage.findStorage(storageKey)\n  } catch (error) {\n    console.warn(`No stroage found for: ${storageKey}`)\n  }\n  if (!targetStorage) {\n    return null\n  }\n  const attachmentFolder = path.join(\n    targetStorage.path,\n    DESTINATION_FOLDER,\n    noteKey\n  )\n  const attachmentsInNote = getAttachmentsInMarkdownContent(markdownContent)\n  const attachmentsInNoteOnlyFileNames = []\n  if (attachmentsInNote) {\n    for (let i = 0; i < attachmentsInNote.length; i++) {\n      attachmentsInNoteOnlyFileNames.push(\n        attachmentsInNote[i].replace(\n          new RegExp(\n            STORAGE_FOLDER_PLACEHOLDER +\n              escapeStringRegexp(path.sep) +\n              noteKey +\n              escapeStringRegexp(path.sep),\n            'g'\n          ),\n          ''\n        )\n      )\n    }\n  }\n  if (fs.existsSync(attachmentFolder)) {\n    return new Promise((resolve, reject) => {\n      fs.readdir(attachmentFolder, (err, files) => {\n        if (err) {\n          console.error(\n            'Error reading directory \"' + attachmentFolder + '\". Error:'\n          )\n          console.error(err)\n          reject(err)\n          return\n        }\n        const attachments = []\n        for (const file of files) {\n          const absolutePathOfFile = path.join(\n            targetStorage.path,\n            DESTINATION_FOLDER,\n            noteKey,\n            file\n          )\n          if (!attachmentsInNoteOnlyFileNames.includes(file)) {\n            attachments.push({ path: absolutePathOfFile, isInUse: false })\n          } else {\n            attachments.push({ path: absolutePathOfFile, isInUse: true })\n          }\n        }\n        resolve(attachments)\n      })\n    })\n  } else {\n    return null\n  }\n}\n\n/**\n * @description Remove all specified attachment paths\n * @param attachments attachment paths\n * @return {Promise} Promise after all attachments are removed */\nfunction removeAttachmentsByPaths(attachments) {\n  const promises = []\n  for (const attachment of attachments) {\n    const promise = new Promise((resolve, reject) => {\n      fs.unlink(attachment, err => {\n        if (err) {\n          console.error('Could not delete \"%s\"', attachment)\n          console.error(err)\n          reject(err)\n          return\n        }\n        resolve()\n      })\n    })\n    promises.push(promise)\n  }\n  return Promise.all(promises)\n}\n\n/**\n * Clones the attachments of a given note.\n * Copies the attachments to their new destination and updates the content of the new note so that the attachment-links again point to the correct destination.\n * @param oldNote Note that is being cloned\n * @param newNote Clone of the note\n */\nfunction cloneAttachments(oldNote, newNote) {\n  if (newNote.type === 'MARKDOWN_NOTE') {\n    const oldStorage = findStorage.findStorage(oldNote.storage)\n    const newStorage = findStorage.findStorage(newNote.storage)\n    const attachmentsPaths =\n      getAbsolutePathsOfAttachmentsInContent(\n        oldNote.content,\n        oldStorage.path\n      ) || []\n\n    const destinationFolder = path.join(\n      newStorage.path,\n      DESTINATION_FOLDER,\n      newNote.key\n    )\n    if (!sander.existsSync(destinationFolder)) {\n      sander.mkdirSync(destinationFolder)\n    }\n\n    for (const attachment of attachmentsPaths) {\n      const destination = path.join(\n        newStorage.path,\n        DESTINATION_FOLDER,\n        newNote.key,\n        path.basename(attachment)\n      )\n      sander.copyFileSync(attachment).to(destination)\n    }\n    newNote.content = replaceNoteKeyWithNewNoteKey(\n      newNote.content,\n      oldNote.key,\n      newNote.key\n    )\n  } else {\n    console.debug(\n      'Cloning of the attachment was skipped since it only works for MARKDOWN_NOTEs'\n    )\n  }\n}\n\nfunction generateFileNotFoundMarkdown() {\n  return (\n    '**' +\n    i18n.__(\n      '⚠ You have pasted a link referring an attachment that could not be found in the storage location of this note. Pasting links referring attachments is only supported if the source and destination location is the same storage. Please Drag&Drop the attachment instead! ⚠'\n    ) +\n    '**'\n  )\n}\n\n/**\n * Determines whether a given text is a link to an boostnote attachment\n * @param text Text that might contain a attachment link\n * @return {Boolean} Result of the test\n */\nfunction isAttachmentLink(text) {\n  if (text) {\n    return (\n      text.match(\n        new RegExp(\n          '.*\\\\[.*\\\\]\\\\( *' +\n            escapeStringRegexp(STORAGE_FOLDER_PLACEHOLDER) +\n            '[' +\n            PATH_SEPARATORS +\n            ']' +\n            '.*\\\\).*',\n          'gi'\n        )\n      ) != null\n    )\n  }\n  return false\n}\n\n/**\n * @description Handles the paste of an attachment link. Copies the referenced attachment to the location belonging to the new note.\n *  Returns a modified version of the pasted text so that it matches the copied attachment (resp. the new location)\n * @param storageKey StorageKey of the current note\n * @param noteKey NoteKey of the currentNote\n * @param linkText Text that was pasted\n * @return {Promise<String>} Promise returning the modified text\n */\nfunction handleAttachmentLinkPaste(storageKey, noteKey, linkText) {\n  if (storageKey != null && noteKey != null && linkText != null) {\n    const storagePath = findStorage.findStorage(storageKey).path\n    const attachments = getAttachmentsInMarkdownContent(linkText) || []\n    const replaceInstructions = []\n    const copies = []\n    for (const attachment of attachments) {\n      const absPathOfAttachment = attachment.replace(\n        new RegExp(STORAGE_FOLDER_PLACEHOLDER, 'g'),\n        path.join(storagePath, DESTINATION_FOLDER)\n      )\n      copies.push(\n        sander.exists(absPathOfAttachment).then(fileExists => {\n          if (!fileExists) {\n            const fileNotFoundRegexp = new RegExp(\n              '!?' +\n                escapeStringRegexp('[') +\n                '[\\\\w|\\\\d|\\\\s|\\\\.]*\\\\]\\\\(\\\\s*' +\n                STORAGE_FOLDER_PLACEHOLDER +\n                '[\\\\w|\\\\d|\\\\-|' +\n                PATH_SEPARATORS +\n                ']*' +\n                escapeStringRegexp(path.basename(absPathOfAttachment)) +\n                escapeStringRegexp(')')\n            )\n            replaceInstructions.push({\n              regexp: fileNotFoundRegexp,\n              replacement: this.generateFileNotFoundMarkdown()\n            })\n            return Promise.resolve()\n          }\n          return this.copyAttachment(\n            absPathOfAttachment,\n            storageKey,\n            noteKey\n          ).then(fileName => {\n            const replaceLinkRegExp = new RegExp(\n              escapeStringRegexp('(') +\n                ' *' +\n                STORAGE_FOLDER_PLACEHOLDER +\n                '[\\\\w|\\\\d|\\\\-|' +\n                PATH_SEPARATORS +\n                ']*' +\n                escapeStringRegexp(path.basename(absPathOfAttachment)) +\n                ' *' +\n                escapeStringRegexp(')')\n            )\n            replaceInstructions.push({\n              regexp: replaceLinkRegExp,\n              replacement:\n                '(' +\n                path.join(STORAGE_FOLDER_PLACEHOLDER, noteKey, fileName) +\n                ')'\n            })\n            return Promise.resolve()\n          })\n        })\n      )\n    }\n    return Promise.all(copies).then(() => {\n      let modifiedLinkText = linkText\n      for (const replaceInstruction of replaceInstructions) {\n        modifiedLinkText = modifiedLinkText.replace(\n          replaceInstruction.regexp,\n          replaceInstruction.replacement\n        )\n      }\n      return modifiedLinkText\n    })\n  } else {\n    return Promise.resolve(linkText)\n  }\n}\n\nmodule.exports = {\n  copyAttachment,\n  fixLocalURLS,\n  generateAttachmentMarkdown,\n  handleAttachmentDrop,\n  handlePasteImageEvent,\n  handlePasteNativeImage,\n  getAttachmentsInMarkdownContent,\n  getAbsolutePathsOfAttachmentsInContent,\n  importAttachments,\n  removeAttachmentsByPaths,\n  replaceStorageReferences,\n  deleteAttachmentFolder,\n  deleteAttachmentsNotPresentInNote,\n  getAttachmentsPathAndStatus,\n  moveAttachments,\n  cloneAttachments,\n  isAttachmentLink,\n  handleAttachmentLinkPaste,\n  generateFileNotFoundMarkdown,\n  migrateAttachments,\n  STORAGE_FOLDER_PLACEHOLDER,\n  DESTINATION_FOLDER\n}\n",
    "browser/main/lib/dataApi/copyFile.js": "import fs from 'fs'\nimport fx from 'fs-extra'\nimport path from 'path'\n\n/**\n * @description Copy a file from source to destination\n * @param {String} srcPath\n * @param {String} dstPath\n * @return {Promise} an image path\n */\nfunction copyFile(srcPath, dstPath) {\n  if (!path.extname(dstPath)) {\n    dstPath = path.join(dstPath, path.basename(srcPath))\n  }\n\n  return new Promise((resolve, reject) => {\n    const dstFolder = path.dirname(dstPath)\n\n    fx.ensureDirSync(dstFolder)\n\n    const input = fs.createReadStream(decodeURI(srcPath))\n    const output = fs.createWriteStream(dstPath)\n\n    output.on('error', reject)\n    input.on('error', reject)\n    input.on('end', () => {\n      resolve(dstPath)\n    })\n    input.pipe(output)\n  })\n}\n\nmodule.exports = copyFile\n",
    "browser/main/modals/PreferencesModal/StoragesTab.js": "import PropTypes from 'prop-types'\nimport React from 'react'\nimport CSSModules from 'browser/lib/CSSModules'\nimport styles from './StoragesTab.styl'\nimport dataApi from 'browser/main/lib/dataApi'\nimport attachmentManagement from 'browser/main/lib/dataApi/attachmentManagement'\nimport StorageItem from './StorageItem'\nimport i18n from 'browser/lib/i18n'\nimport { humanFileSize } from 'browser/lib/utils'\nimport fs from 'fs'\n\nconst electron = require('electron')\nconst { shell, remote } = electron\n\nfunction browseFolder() {\n  const dialog = remote.dialog\n\n  const defaultPath = remote.app.getPath('home')\n  return new Promise((resolve, reject) => {\n    dialog.showOpenDialog(\n      {\n        title: i18n.__('Select Directory'),\n        defaultPath,\n        properties: ['openDirectory', 'createDirectory']\n      },\n      function(targetPaths) {\n        if (targetPaths == null) return resolve('')\n        resolve(targetPaths[0])\n      }\n    )\n  })\n}\n\nclass StoragesTab extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      page: 'LIST',\n      newStorage: {\n        name: 'Unnamed',\n        type: 'FILESYSTEM',\n        path: ''\n      },\n      attachments: []\n    }\n    this.loadAttachmentStorage()\n  }\n\n  loadAttachmentStorage() {\n    const promises = []\n    this.props.data.noteMap.map(note => {\n      const promise = attachmentManagement.getAttachmentsPathAndStatus(\n        note.content,\n        note.storage,\n        note.key\n      )\n      if (promise) promises.push(promise)\n    })\n\n    Promise.all(promises)\n      .then(data => {\n        const result = data.reduce((acc, curr) => acc.concat(curr), [])\n        this.setState({ attachments: result })\n      })\n      .catch(console.error)\n  }\n\n  handleAddStorageButton(e) {\n    this.setState(\n      {\n        page: 'ADD_STORAGE',\n        newStorage: {\n          name: 'Unnamed',\n          type: 'FILESYSTEM',\n          path: ''\n        }\n      },\n      () => {\n        this.refs.addStorageName.select()\n      }\n    )\n  }\n\n  handleLinkClick(e) {\n    shell.openExternal(e.currentTarget.href)\n    e.preventDefault()\n  }\n\n  handleRemoveUnusedAttachments(attachments) {\n    attachmentManagement\n      .removeAttachmentsByPaths(attachments)\n      .then(() => this.loadAttachmentStorage())\n      .catch(console.error)\n  }\n\n  renderList() {\n    const { data, boundingBox } = this.props\n    const { attachments } = this.state\n\n    const unusedAttachments = attachments.filter(\n      attachment => !attachment.isInUse\n    )\n    const inUseAttachments = attachments.filter(\n      attachment => attachment.isInUse\n    )\n\n    const totalUnusedAttachments = unusedAttachments.length\n    const totalInuseAttachments = inUseAttachments.length\n    const totalAttachments = totalUnusedAttachments + totalInuseAttachments\n\n    const totalUnusedAttachmentsSize = unusedAttachments.reduce((acc, curr) => {\n      const stats = fs.statSync(curr.path)\n      const fileSizeInBytes = stats.size\n      return acc + fileSizeInBytes\n    }, 0)\n    const totalInuseAttachmentsSize = inUseAttachments.reduce((acc, curr) => {\n      const stats = fs.statSync(curr.path)\n      const fileSizeInBytes = stats.size\n      return acc + fileSizeInBytes\n    }, 0)\n    const totalAttachmentsSize =\n      totalUnusedAttachmentsSize + totalInuseAttachmentsSize\n\n    const unusedAttachmentPaths = unusedAttachments.reduce(\n      (acc, curr) => acc.concat(curr.path),\n      []\n    )\n\n    if (!boundingBox) {\n      return null\n    }\n    const storageList = data.storageMap.map(storage => {\n      return (\n        <StorageItem\n          key={storage.key}\n          storage={storage}\n          hostBoundingBox={boundingBox}\n        />\n      )\n    })\n    return (\n      <div styleName='list'>\n        <div styleName='header'>{i18n.__('Storage Locations')}</div>\n        {storageList.length > 0 ? (\n          storageList\n        ) : (\n          <div styleName='list-empty'>{i18n.__('No storage found.')}</div>\n        )}\n        <div styleName='list-control'>\n          <button\n            styleName='list-control-addStorageButton'\n            onClick={e => this.handleAddStorageButton(e)}\n          >\n            <i className='fa fa-plus' /> {i18n.__('Add Storage Location')}\n          </button>\n        </div>\n        <div styleName='header'>{i18n.__('Attachment storage')}</div>\n        <p styleName='list-attachment-label'>\n          Unused attachments size: {humanFileSize(totalUnusedAttachmentsSize)} (\n          {totalUnusedAttachments} items)\n        </p>\n        <p styleName='list-attachment-label'>\n          In use attachments size: {humanFileSize(totalInuseAttachmentsSize)} (\n          {totalInuseAttachments} items)\n        </p>\n        <p styleName='list-attachment-label'>\n          Total attachments size: {humanFileSize(totalAttachmentsSize)} (\n          {totalAttachments} items)\n        </p>\n        <button\n          styleName='list-attachement-clear-button'\n          onClick={() =>\n            this.handleRemoveUnusedAttachments(unusedAttachmentPaths)\n          }\n        >\n          {i18n.__('Clear unused attachments')}\n        </button>\n      </div>\n    )\n  }\n\n  handleAddStorageBrowseButtonClick(e) {\n    browseFolder()\n      .then(targetPath => {\n        if (targetPath.length > 0) {\n          const { newStorage } = this.state\n          newStorage.path = targetPath\n          this.setState({\n            newStorage\n          })\n        }\n      })\n      .catch(err => {\n        console.error('BrowseFAILED')\n        console.error(err)\n      })\n  }\n\n  handleAddStorageChange(e) {\n    const { newStorage } = this.state\n    newStorage.name = this.refs.addStorageName.value\n    newStorage.path = this.refs.addStoragePath.value\n    this.setState({\n      newStorage\n    })\n  }\n\n  handleAddStorageCreateButton(e) {\n    dataApi\n      .addStorage({\n        name: this.state.newStorage.name,\n        path: this.state.newStorage.path\n      })\n      .then(data => {\n        const { dispatch } = this.props\n        dispatch({\n          type: 'ADD_STORAGE',\n          storage: data.storage,\n          notes: data.notes\n        })\n        this.setState({\n          page: 'LIST'\n        })\n      })\n  }\n\n  handleAddStorageCancelButton(e) {\n    this.setState({\n      page: 'LIST'\n    })\n  }\n\n  renderAddStorage() {\n    return (\n      <div styleName='addStorage'>\n        <div styleName='addStorage-header'>{i18n.__('Add Storage')}</div>\n\n        <div styleName='addStorage-body'>\n          <div styleName='addStorage-body-section'>\n            <div styleName='addStorage-body-section-label'>\n              {i18n.__('Name')}\n            </div>\n            <div styleName='addStorage-body-section-name'>\n              <input\n                styleName='addStorage-body-section-name-input'\n                ref='addStorageName'\n                value={this.state.newStorage.name}\n                onChange={e => this.handleAddStorageChange(e)}\n              />\n            </div>\n          </div>\n\n          <div styleName='addStorage-body-section'>\n            <div styleName='addStorage-body-section-label'>\n              {i18n.__('Type')}\n            </div>\n            <div styleName='addStorage-body-section-type'>\n              <select\n                styleName='addStorage-body-section-type-select'\n                value={this.state.newStorage.type}\n                readOnly\n              >\n                <option value='FILESYSTEM'>{i18n.__('File System')}</option>\n              </select>\n              <div styleName='addStorage-body-section-type-description'>\n                {i18n.__('Setting up 3rd-party cloud storage integration:')}{' '}\n                <a\n                  href='https://github.com/BoostIO/Boostnote/wiki/Cloud-Syncing-and-Backup'\n                  onClick={e => this.handleLinkClick(e)}\n                >\n                  {i18n.__('Cloud-Syncing-and-Backup')}\n                </a>\n              </div>\n            </div>\n          </div>\n\n          <div styleName='addStorage-body-section'>\n            <div styleName='addStorage-body-section-label'>\n              {i18n.__('Location')}\n            </div>\n            <div styleName='addStorage-body-section-path'>\n              <input\n                styleName='addStorage-body-section-path-input'\n                ref='addStoragePath'\n                placeholder={i18n.__('Select Folder')}\n                value={this.state.newStorage.path}\n                onChange={e => this.handleAddStorageChange(e)}\n              />\n              <button\n                styleName='addStorage-body-section-path-button'\n                onClick={e => this.handleAddStorageBrowseButtonClick(e)}\n              >\n                ...\n              </button>\n            </div>\n          </div>\n\n          <div styleName='addStorage-body-control'>\n            <button\n              styleName='addStorage-body-control-createButton'\n              onClick={e => this.handleAddStorageCreateButton(e)}\n            >\n              {i18n.__('Add')}\n            </button>\n            <button\n              styleName='addStorage-body-control-cancelButton'\n              onClick={e => this.handleAddStorageCancelButton(e)}\n            >\n              {i18n.__('Cancel')}\n            </button>\n          </div>\n        </div>\n      </div>\n    )\n  }\n\n  renderContent() {\n    switch (this.state.page) {\n      case 'ADD_STORAGE':\n      case 'ADD_FOLDER':\n        return this.renderAddStorage()\n      case 'LIST':\n      default:\n        return this.renderList()\n    }\n  }\n\n  render() {\n    return <div styleName='root'>{this.renderContent()}</div>\n  }\n}\n\nStoragesTab.propTypes = {\n  boundingBox: PropTypes.shape({\n    bottom: PropTypes.number,\n    height: PropTypes.number,\n    left: PropTypes.number,\n    right: PropTypes.number,\n    top: PropTypes.number,\n    width: PropTypes.number\n  }),\n  dispatch: PropTypes.func\n}\n\nexport default CSSModules(StoragesTab, styles)\n",
    "lib/main-menu.js": "const electron = require('electron')\nconst BrowserWindow = electron.BrowserWindow\nconst shell = electron.shell\nconst ipc = electron.ipcMain\nconst mainWindow = require('./main-window')\nconst os = require('os')\n\nconst macOS = process.platform === 'darwin'\n// const WIN = process.platform === 'win32'\nconst LINUX = process.platform === 'linux'\n\nconst boost = macOS\n  ? {\n      label: 'Boostnote',\n      submenu: [\n        {\n          label: 'About Boostnote',\n          selector: 'orderFrontStandardAboutPanel:'\n        },\n        {\n          type: 'separator'\n        },\n        {\n          label: 'Preferences',\n          accelerator: 'Command+,',\n          click() {\n            mainWindow.webContents.send('side:preferences')\n          }\n        },\n        {\n          type: 'separator'\n        },\n        {\n          label: 'Hide Boostnote',\n          accelerator: 'Command+H',\n          selector: 'hide:'\n        },\n        {\n          label: 'Hide Others',\n          accelerator: 'Command+Shift+H',\n          selector: 'hideOtherApplications:'\n        },\n        {\n          label: 'Show All',\n          selector: 'unhideAllApplications:'\n        },\n        {\n          type: 'separator'\n        },\n        {\n          label: 'Quit Boostnote',\n          role: 'quit',\n          accelerator: 'CommandOrControl+Q'\n        }\n      ]\n    }\n  : {\n      label: 'Boostnote',\n      submenu: [\n        {\n          label: 'Preferences',\n          accelerator: 'Control+,',\n          click() {\n            mainWindow.webContents.send('side:preferences')\n          }\n        },\n        {\n          type: 'separator'\n        },\n        {\n          role: 'quit',\n          accelerator: 'Control+Q'\n        }\n      ]\n    }\n\nconst file = {\n  label: 'File',\n  submenu: [\n    {\n      label: 'New Note',\n      accelerator: 'CommandOrControl+N',\n      click() {\n        mainWindow.webContents.send('top:new-note')\n      }\n    },\n    {\n      label: 'Focus Note',\n      accelerator: 'CommandOrControl+E',\n      click() {\n        mainWindow.webContents.send('detail:focus')\n      }\n    },\n    {\n      label: 'Delete Note',\n      accelerator: 'CommandOrControl+Shift+Backspace',\n      click() {\n        mainWindow.webContents.send('detail:delete')\n      }\n    },\n    {\n      label: 'Clone Note',\n      accelerator: 'CommandOrControl+D',\n      click() {\n        mainWindow.webContents.send('list:clone')\n      }\n    },\n    {\n      type: 'separator'\n    },\n    {\n      label: 'Import from',\n      submenu: [\n        {\n          label: 'Plain Text, MarkDown (.txt, .md)',\n          click() {\n            mainWindow.webContents.send('import:file')\n          }\n        }\n      ]\n    },\n    {\n      label: 'Export as',\n      submenu: [\n        {\n          label: 'Plain Text (.txt)',\n          click() {\n            mainWindow.webContents.send('list:isMarkdownNote', 'export-txt')\n            mainWindow.webContents.send('export:save-text')\n          }\n        },\n        {\n          label: 'MarkDown (.md)',\n          click() {\n            mainWindow.webContents.send('list:isMarkdownNote', 'export-md')\n            mainWindow.webContents.send('export:save-md')\n          }\n        },\n        {\n          label: 'HTML (.html)',\n          click() {\n            mainWindow.webContents.send('list:isMarkdownNote', 'export-html')\n            mainWindow.webContents.send('export:save-html')\n          }\n        },\n        {\n          label: 'PDF (.pdf)',\n          click() {\n            mainWindow.webContents.send('list:isMarkdownNote', 'export-pdf')\n            mainWindow.webContents.send('export:save-pdf')\n          }\n        }\n      ]\n    },\n    {\n      type: 'separator'\n    },\n    {\n      label: 'Generate/Update Markdown TOC',\n      accelerator: 'Shift+Ctrl+T',\n      click() {\n        mainWindow.webContents.send('code:generate-toc')\n      }\n    },\n    {\n      label: 'Format Table',\n      click() {\n        mainWindow.webContents.send('code:format-table')\n      }\n    },\n    {\n      type: 'separator'\n    },\n    {\n      label: 'Print',\n      accelerator: 'CommandOrControl+P',\n      click() {\n        mainWindow.webContents.send('list:isMarkdownNote', 'print')\n        mainWindow.webContents.send('print')\n      }\n    },\n    {\n      type: 'separator'\n    },\n    {\n      label: 'Update',\n      click() {\n        mainWindow.webContents.send('update')\n      }\n    },\n    {\n      type: 'separator'\n    }\n  ]\n}\n\nif (LINUX) {\n  file.submenu.push(\n    {\n      type: 'separator'\n    },\n    {\n      label: 'Preferences',\n      accelerator: 'Control+,',\n      click() {\n        mainWindow.webContents.send('side:preferences')\n      }\n    },\n    {\n      type: 'separator'\n    },\n    {\n      role: 'quit',\n      accelerator: 'Control+Q'\n    }\n  )\n}\n\nconst edit = {\n  label: 'Edit',\n  submenu: [\n    {\n      label: 'Undo',\n      accelerator: 'Command+Z',\n      selector: 'undo:'\n    },\n    {\n      label: 'Redo',\n      accelerator: 'Shift+Command+Z',\n      selector: 'redo:'\n    },\n    {\n      type: 'separator'\n    },\n    {\n      label: 'Cut',\n      accelerator: 'Command+X',\n      selector: 'cut:'\n    },\n    {\n      label: 'Copy',\n      accelerator: 'Command+C',\n      selector: 'copy:'\n    },\n    {\n      label: 'Paste',\n      accelerator: 'Command+V',\n      selector: 'paste:'\n    },\n    {\n      label: 'Select All',\n      accelerator: 'Command+A',\n      selector: 'selectAll:'\n    },\n    {\n      type: 'separator'\n    },\n    {\n      label: 'Add Tag',\n      accelerator: 'CommandOrControl+Shift+T',\n      click() {\n        mainWindow.webContents.send('editor:add-tag')\n      }\n    }\n  ]\n}\n\nconst view = {\n  label: 'View',\n  submenu: [\n    {\n      label: 'Reload',\n      accelerator: 'CommandOrControl+R',\n      click() {\n        BrowserWindow.getFocusedWindow().reload()\n      }\n    },\n    {\n      label: 'Toggle Developer Tools',\n      accelerator: 'CommandOrControl+Alt+I',\n      click() {\n        BrowserWindow.getFocusedWindow().toggleDevTools()\n      }\n    },\n    {\n      type: 'separator'\n    },\n    {\n      label: 'Next Note',\n      accelerator: 'CommandOrControl+]',\n      click() {\n        mainWindow.webContents.send('list:next')\n      }\n    },\n    {\n      label: 'Previous Note',\n      accelerator: 'CommandOrControl+[',\n      click() {\n        mainWindow.webContents.send('list:prior')\n      }\n    },\n    {\n      type: 'separator'\n    },\n    {\n      label: 'Focus Search',\n      accelerator: 'CommandOrControl+Shift+L',\n      click() {\n        mainWindow.webContents.send('top:focus-search')\n      }\n    },\n    {\n      type: 'separator'\n    },\n    {\n      label: 'Toggle Full Screen',\n      accelerator: macOS ? 'Command+Control+F' : 'F11',\n      click() {\n        mainWindow.setFullScreen(!mainWindow.isFullScreen())\n      }\n    },\n    {\n      label: 'Toggle Side Bar',\n      accelerator: 'CommandOrControl+B',\n      click() {\n        mainWindow.webContents.send('editor:fullscreen')\n      }\n    },\n    {\n      label: 'Toggle Editor Orientation',\n      click() {\n        mainWindow.webContents.send('editor:orientation')\n      }\n    },\n    {\n      type: 'separator'\n    },\n    {\n      label: 'Actual Size',\n      accelerator: 'CommandOrControl+0',\n      click() {\n        mainWindow.webContents.send('status:zoomreset')\n      }\n    },\n    {\n      label: 'Zoom In',\n      accelerator: 'CommandOrControl+=',\n      click() {\n        mainWindow.webContents.send('status:zoomin')\n      }\n    },\n    {\n      label: 'Zoom Out',\n      accelerator: 'CommandOrControl+-',\n      click() {\n        mainWindow.webContents.send('status:zoomout')\n      }\n    }\n  ]\n}\n\nlet editorFocused\n\n// Define extra shortcut keys\nmainWindow.webContents.on('before-input-event', (event, input) => {\n  // Synonyms for Search (Find)\n  if (input.control && input.key === 'l' && input.type === 'keyDown') {\n    if (!editorFocused) {\n      mainWindow.webContents.send('top:focus-search')\n      event.preventDefault()\n    }\n  }\n})\n\nipc.on('editor:focused', (event, isFocused) => {\n  editorFocused = isFocused\n})\n\nconst window = {\n  label: 'Window',\n  submenu: [\n    {\n      label: 'Minimize',\n      accelerator: 'Command+M',\n      selector: 'performMiniaturize:'\n    },\n    {\n      label: 'Close',\n      accelerator: 'Command+W',\n      selector: 'performClose:'\n    },\n    {\n      type: 'separator'\n    },\n    {\n      label: 'Bring All to Front',\n      selector: 'arrangeInFront:'\n    }\n  ]\n}\n\nconst help = {\n  label: 'Help',\n  role: 'help',\n  submenu: [\n    {\n      label: 'Boostnote official site',\n      click() {\n        shell.openExternal('https://boostnote.io/')\n      }\n    },\n    {\n      label: 'Wiki',\n      click() {\n        shell.openExternal('https://github.com/BoostIO/Boostnote/wiki')\n      }\n    },\n    {\n      label: 'Issue Tracker',\n      click() {\n        shell.openExternal('https://github.com/BoostIO/Boostnote/issues')\n      }\n    },\n    {\n      label: 'Changelog',\n      click() {\n        shell.openExternal('https://github.com/BoostIO/boost-releases')\n      }\n    },\n    {\n      label: 'Cheatsheets',\n      submenu: [\n        {\n          label: 'Markdown',\n          click() {\n            shell.openExternal(\n              'https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet'\n            )\n          }\n        },\n        {\n          label: 'Latex',\n          click() {\n            shell.openExternal('https://katex.org/docs/supported.html')\n          }\n        },\n        {\n          label: 'HTML',\n          click() {\n            shell.openExternal('https://htmlcheatsheet.com/')\n          }\n        },\n        {\n          label: 'Boostnote',\n          click() {\n            shell.openExternal(\n              'https://github.com/TobseF/boostnote-markdown-cheatsheet/blob/master/BOOSTNOTE_MARKDOWN_CHEAT_SHEET.md'\n            )\n          }\n        }\n      ]\n    },\n    {\n      type: 'separator'\n    },\n    {\n      label: 'About',\n      click() {\n        const version = electron.app.getVersion()\n        const electronVersion = process.versions.electron\n        const chromeVersion = process.versions.chrome\n        const nodeVersion = process.versions.node\n        const v8Version = process.versions.v8\n        const OSInfo = `${os.type()} ${os.arch()} ${os.release()}`\n        const detail = `Version: ${version}\\nElectron: ${electronVersion}\\nChrome: ${chromeVersion}\\nNode.js: ${nodeVersion}\\nV8: ${v8Version}\\nOS: ${OSInfo}`\n        electron.dialog.showMessageBox(BrowserWindow.getFocusedWindow(), {\n          title: 'BoostNote',\n          message: 'BoostNote',\n          type: 'info',\n          detail: `\\n${detail}`\n        })\n      }\n    }\n  ]\n}\n\nconst team = {\n  label: 'For Team',\n  submenu: [\n    {\n      label: 'BoostHub',\n      click: async () => {\n        shell.openExternal('https://boosthub.io/')\n      }\n    }\n  ]\n}\n\nmodule.exports =\n  process.platform === 'darwin'\n    ? [boost, file, edit, view, window, team, help]\n    : process.platform === 'win32'\n    ? [boost, file, view, team, help]\n    : [file, view, team, help]\n",
    "browser/components/CodeEditor.js": "import PropTypes from 'prop-types'\nimport React from 'react'\nimport _ from 'lodash'\nimport CodeMirror from 'codemirror'\nimport hljs from 'highlight.js'\nimport 'codemirror-mode-elixir'\nimport attachmentManagement from 'browser/main/lib/dataApi/attachmentManagement'\nimport convertModeName from 'browser/lib/convertModeName'\nimport { options, TableEditor, Alignment } from '@susisu/mte-kernel'\nimport TextEditorInterface from 'browser/lib/TextEditorInterface'\nimport eventEmitter from 'browser/main/lib/eventEmitter'\nimport iconv from 'iconv-lite'\n\nimport { isMarkdownTitleURL } from 'browser/lib/utils'\nimport styles from '../components/CodeEditor.styl'\nconst { ipcRenderer, remote, clipboard } = require('electron')\nimport normalizeEditorFontFamily from 'browser/lib/normalizeEditorFontFamily'\nconst spellcheck = require('browser/lib/spellcheck')\nconst buildEditorContextMenu = require('browser/lib/contextMenuBuilder')\n  .buildEditorContextMenu\nimport { createTurndownService } from '../lib/turndown'\nimport { languageMaps } from '../lib/CMLanguageList'\nimport snippetManager from '../lib/SnippetManager'\nimport { findStorage } from 'browser/lib/findStorage'\nimport { sendWakatimeHeartBeat } from 'browser/lib/wakatime-plugin'\nimport {\n  generateInEditor,\n  tocExistsInEditor\n} from 'browser/lib/markdown-toc-generator'\nimport markdownlint from 'markdownlint'\nimport Jsonlint from 'jsonlint-mod'\nimport { DEFAULT_CONFIG } from '../main/lib/ConfigManager'\nimport prettier from 'prettier'\n\nCodeMirror.modeURL = '../node_modules/codemirror/mode/%N/%N.js'\n\nconst buildCMRulers = (rulers, enableRulers) =>\n  enableRulers\n    ? rulers.map(ruler => ({\n        column: ruler\n      }))\n    : []\n\nfunction translateHotkey(hotkey) {\n  return hotkey\n    .replace(/\\s*\\+\\s*/g, '-')\n    .replace(/Command/g, 'Cmd')\n    .replace(/Control/g, 'Ctrl')\n}\n\nexport default class CodeEditor extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.scrollHandler = _.debounce(this.handleScroll.bind(this), 100, {\n      leading: false,\n      trailing: true\n    })\n    this.changeHandler = (editor, changeObject) =>\n      this.handleChange(editor, changeObject)\n    this.highlightHandler = (editor, changeObject) =>\n      this.handleHighlight(editor, changeObject)\n    this.focusHandler = () => {\n      ipcRenderer.send('editor:focused', true)\n    }\n    this.debouncedDeletionOfAttachments = _.debounce(\n      attachmentManagement.deleteAttachmentsNotPresentInNote,\n      30000\n    )\n    this.blurHandler = (editor, e) => {\n      ipcRenderer.send('editor:focused', false)\n      if (e == null) return null\n      let el = e.relatedTarget\n      while (el != null) {\n        if (el === this.refs.root) {\n          return\n        }\n        el = el.parentNode\n      }\n      this.props.onBlur != null && this.props.onBlur(e)\n      const { storageKey, noteKey } = this.props\n      if (this.props.deleteUnusedAttachments === true) {\n        this.debouncedDeletionOfAttachments(\n          this.editor.getValue(),\n          storageKey,\n          noteKey\n        )\n      }\n    }\n    this.pasteHandler = (editor, e) => {\n      e.preventDefault()\n\n      this.handlePaste(editor, false)\n    }\n    this.loadStyleHandler = e => {\n      this.editor.refresh()\n    }\n    this.searchHandler = (e, msg) => this.handleSearch(msg)\n    this.searchState = null\n    this.scrollToLineHandeler = this.scrollToLine.bind(this)\n    this.getCodeEditorLintConfig = this.getCodeEditorLintConfig.bind(this)\n    this.validatorOfMarkdown = this.validatorOfMarkdown.bind(this)\n\n    this.formatTable = () => this.handleFormatTable()\n\n    if (props.switchPreview !== 'RIGHTCLICK') {\n      this.contextMenuHandler = function(editor, event) {\n        const menu = buildEditorContextMenu(editor, event)\n        if (menu != null) {\n          setTimeout(() => menu.popup(remote.getCurrentWindow()), 30)\n        }\n      }\n    }\n\n    this.editorActivityHandler = () => this.handleEditorActivity()\n\n    this.turndownService = createTurndownService()\n\n    // wakatime\n    const { storageKey, noteKey } = this.props\n    const storage = findStorage(storageKey)\n    if (storage)\n      sendWakatimeHeartBeat(storage.path, noteKey, storage.name, {\n        isWrite: false,\n        hasFileChanges: false,\n        isFileChange: true\n      })\n  }\n\n  handleSearch(msg) {\n    const cm = this.editor\n    const component = this\n\n    if (component.searchState) cm.removeOverlay(component.searchState)\n    if (msg.length < 1) return\n\n    cm.operation(function() {\n      component.searchState = makeOverlay(msg, 'searching')\n      cm.addOverlay(component.searchState)\n\n      function makeOverlay(query, style) {\n        query = new RegExp(\n          query.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&'),\n          'gi'\n        )\n        return {\n          token: function(stream) {\n            query.lastIndex = stream.pos\n            var match = query.exec(stream.string)\n            if (match && match.index === stream.pos) {\n              stream.pos += match[0].length || 1\n              return style\n            } else if (match) {\n              stream.pos = match.index\n            } else {\n              stream.skipToEnd()\n            }\n          }\n        }\n      }\n    })\n  }\n\n  handleFormatTable() {\n    this.tableEditor.formatAll(\n      options({\n        textWidthOptions: {}\n      })\n    )\n  }\n\n  handleEditorActivity() {\n    if (this.props.onCursorActivity) {\n      this.props.onCursorActivity(this.editor)\n    }\n\n    if (!this.textEditorInterface.transaction) {\n      this.updateTableEditorState()\n    }\n  }\n\n  updateDefaultKeyMap() {\n    const { hotkey } = this.props\n    const self = this\n    const expandSnippet = snippetManager.expandSnippet\n\n    this.defaultKeyMap = CodeMirror.normalizeKeyMap({\n      Tab: function(cm) {\n        const cursor = cm.getCursor()\n        const line = cm.getLine(cursor.line)\n        const cursorPosition = cursor.ch\n        const charBeforeCursor = line.substr(cursorPosition - 1, 1)\n        if (cm.somethingSelected()) cm.indentSelection('add')\n        else {\n          const tabs = cm.getOption('indentWithTabs')\n          if (line.trimLeft().match(/^(-|\\*|\\+) (\\[( |x)] )?$/)) {\n            cm.execCommand('goLineStart')\n            if (tabs) {\n              cm.execCommand('insertTab')\n            } else {\n              cm.execCommand('insertSoftTab')\n            }\n            cm.execCommand('goLineEnd')\n          } else if (\n            !charBeforeCursor.match(/\\t|\\s|\\r|\\n|\\$/) &&\n            cursor.ch > 1\n          ) {\n            // text expansion on tab key if the char before is alphabet\n            const wordBeforeCursor = self.getWordBeforeCursor(\n              line,\n              cursor.line,\n              cursor.ch\n            )\n            if (expandSnippet(wordBeforeCursor, cursor, cm) === false) {\n              if (tabs) {\n                cm.execCommand('insertTab')\n              } else {\n                cm.execCommand('insertSoftTab')\n              }\n            }\n          } else {\n            if (tabs) {\n              cm.execCommand('insertTab')\n            } else {\n              cm.execCommand('insertSoftTab')\n            }\n          }\n        }\n      },\n      'Cmd-Left': function(cm) {\n        cm.execCommand('goLineLeft')\n      },\n      'Cmd-T': function(cm) {\n        // Do nothing\n      },\n      [translateHotkey(hotkey.insertDate)]: function(cm) {\n        const dateNow = new Date()\n        if (self.props.dateFormatISO8601) {\n          cm.replaceSelection(dateNow.toISOString().split('T')[0])\n        } else {\n          cm.replaceSelection(dateNow.toLocaleDateString())\n        }\n      },\n      [translateHotkey(hotkey.insertDateTime)]: function(cm) {\n        const dateNow = new Date()\n        if (self.props.dateFormatISO8601) {\n          cm.replaceSelection(dateNow.toISOString())\n        } else {\n          cm.replaceSelection(dateNow.toLocaleString())\n        }\n      },\n      Enter: 'boostNewLineAndIndentContinueMarkdownList',\n      'Ctrl-C': cm => {\n        if (cm.getOption('keyMap').substr(0, 3) === 'vim') {\n          document.execCommand('copy')\n        }\n        return CodeMirror.Pass\n      },\n      [translateHotkey(hotkey.prettifyMarkdown)]: cm => {\n        // Default / User configured prettier options\n        const currentConfig = JSON.parse(self.props.prettierConfig)\n\n        // Parser type will always need to be markdown so we override the option before use\n        currentConfig.parser = 'markdown'\n\n        // Get current cursor position\n        const cursorPos = cm.getCursor()\n        currentConfig.cursorOffset = cm.doc.indexFromPos(cursorPos)\n\n        // Prettify contents of editor\n        const formattedTextDetails = prettier.formatWithCursor(\n          cm.doc.getValue(),\n          currentConfig\n        )\n\n        const formattedText = formattedTextDetails.formatted\n        const formattedCursorPos = formattedTextDetails.cursorOffset\n        cm.doc.setValue(formattedText)\n\n        // Reset Cursor position to be at the same markdown as was before prettifying\n        const newCursorPos = cm.doc.posFromIndex(formattedCursorPos)\n        cm.doc.setCursor(newCursorPos)\n      },\n      [translateHotkey(hotkey.sortLines)]: cm => {\n        const selection = cm.doc.getSelection()\n        const appendLineBreak = /\\n$/.test(selection)\n\n        const sorted = _.split(selection.trim(), '\\n').sort()\n        const sortedString =\n          _.join(sorted, '\\n') + (appendLineBreak ? '\\n' : '')\n\n        cm.doc.replaceSelection(sortedString)\n      },\n      [translateHotkey(hotkey.pasteSmartly)]: cm => {\n        this.handlePaste(cm, true)\n      }\n    })\n  }\n\n  updateTableEditorState() {\n    const active = this.tableEditor.cursorIsInTable(this.tableEditorOptions)\n    if (active) {\n      if (this.extraKeysMode !== 'editor') {\n        this.extraKeysMode = 'editor'\n        this.editor.setOption('extraKeys', this.editorKeyMap)\n      }\n    } else {\n      if (this.extraKeysMode !== 'default') {\n        this.extraKeysMode = 'default'\n        this.editor.setOption('extraKeys', this.defaultKeyMap)\n        this.tableEditor.resetSmartCursor()\n      }\n    }\n  }\n\n  componentDidMount() {\n    const { rulers, enableRulers, enableMarkdownLint, RTL } = this.props\n    eventEmitter.on('line:jump', this.scrollToLineHandeler)\n\n    snippetManager.init()\n    this.updateDefaultKeyMap()\n\n    this.value = this.props.value\n    this.editor = CodeMirror(this.refs.root, {\n      rulers: buildCMRulers(rulers, enableRulers),\n      value: this.props.value,\n      linesHighlighted: this.props.linesHighlighted,\n      lineNumbers: this.props.displayLineNumbers,\n      lineWrapping: this.props.lineWrapping,\n      theme: this.props.theme,\n      indentUnit: this.props.indentSize,\n      tabSize: this.props.indentSize,\n      indentWithTabs: this.props.indentType !== 'space',\n      keyMap: this.props.keyMap,\n      scrollPastEnd: this.props.scrollPastEnd,\n      inputStyle: 'textarea',\n      dragDrop: false,\n      direction: RTL ? 'rtl' : 'ltr',\n      rtlMoveVisually: RTL,\n      foldGutter: true,\n      lint: enableMarkdownLint ? this.getCodeEditorLintConfig() : false,\n      gutters: [\n        'CodeMirror-linenumbers',\n        'CodeMirror-foldgutter',\n        'CodeMirror-lint-markers'\n      ],\n      autoCloseBrackets: {\n        codeBlock: {\n          pairs: this.props.codeBlockMatchingPairs,\n          closeBefore: this.props.codeBlockMatchingCloseBefore,\n          triples: this.props.codeBlockMatchingTriples,\n          explode: this.props.codeBlockExplodingPairs\n        },\n        markdown: {\n          pairs: this.props.matchingPairs,\n          closeBefore: this.props.matchingCloseBefore,\n          triples: this.props.matchingTriples,\n          explode: this.props.explodingPairs\n        }\n      },\n      extraKeys: this.defaultKeyMap,\n      prettierConfig: this.props.prettierConfig\n    })\n\n    document.querySelector(\n      '.CodeMirror-lint-markers'\n    ).style.display = enableMarkdownLint ? 'inline-block' : 'none'\n\n    if (!this.props.mode && this.props.value && this.props.autoDetect) {\n      this.autoDetectLanguage(this.props.value)\n    } else {\n      this.setMode(this.props.mode)\n    }\n\n    this.editor.on('focus', this.focusHandler)\n    this.editor.on('blur', this.blurHandler)\n    this.editor.on('change', this.changeHandler)\n    this.editor.on('gutterClick', this.highlightHandler)\n    this.editor.on('paste', this.pasteHandler)\n    if (this.props.switchPreview !== 'RIGHTCLICK') {\n      this.editor.on('contextmenu', this.contextMenuHandler)\n    }\n    eventEmitter.on('top:search', this.searchHandler)\n\n    eventEmitter.emit('code:init')\n    this.editor.on('scroll', this.scrollHandler)\n    this.editor.on('cursorActivity', this.editorActivityHandler)\n\n    const editorTheme = document.getElementById('editorTheme')\n    editorTheme.addEventListener('load', this.loadStyleHandler)\n\n    CodeMirror.Vim.defineEx('quit', 'q', this.quitEditor)\n    CodeMirror.Vim.defineEx('q!', 'q!', this.quitEditor)\n    CodeMirror.Vim.defineEx('wq', 'wq', this.quitEditor)\n    CodeMirror.Vim.defineEx('qw', 'qw', this.quitEditor)\n    CodeMirror.Vim.map('ZZ', ':q', 'normal')\n\n    this.textEditorInterface = new TextEditorInterface(this.editor)\n    this.tableEditor = new TableEditor(this.textEditorInterface)\n    if (this.props.spellCheck) {\n      this.editor.addPanel(this.createSpellCheckPanel(), { position: 'bottom' })\n    }\n\n    eventEmitter.on('code:format-table', this.formatTable)\n\n    this.tableEditorOptions = options({\n      smartCursor: true\n    })\n\n    this.editorKeyMap = CodeMirror.normalizeKeyMap({\n      Tab: () => {\n        this.tableEditor.nextCell(this.tableEditorOptions)\n      },\n      'Shift-Tab': () => {\n        this.tableEditor.previousCell(this.tableEditorOptions)\n      },\n      Enter: () => {\n        this.tableEditor.nextRow(this.tableEditorOptions)\n      },\n      'Ctrl-Enter': () => {\n        this.tableEditor.escape(this.tableEditorOptions)\n      },\n      'Cmd-Enter': () => {\n        this.tableEditor.escape(this.tableEditorOptions)\n      },\n      'Shift-Ctrl-Left': () => {\n        this.tableEditor.alignColumn(Alignment.LEFT, this.tableEditorOptions)\n      },\n      'Shift-Cmd-Left': () => {\n        this.tableEditor.alignColumn(Alignment.LEFT, this.tableEditorOptions)\n      },\n      'Shift-Ctrl-Right': () => {\n        this.tableEditor.alignColumn(Alignment.RIGHT, this.tableEditorOptions)\n      },\n      'Shift-Cmd-Right': () => {\n        this.tableEditor.alignColumn(Alignment.RIGHT, this.tableEditorOptions)\n      },\n      'Shift-Ctrl-Up': () => {\n        this.tableEditor.alignColumn(Alignment.CENTER, this.tableEditorOptions)\n      },\n      'Shift-Cmd-Up': () => {\n        this.tableEditor.alignColumn(Alignment.CENTER, this.tableEditorOptions)\n      },\n      'Shift-Ctrl-Down': () => {\n        this.tableEditor.alignColumn(Alignment.NONE, this.tableEditorOptions)\n      },\n      'Shift-Cmd-Down': () => {\n        this.tableEditor.alignColumn(Alignment.NONE, this.tableEditorOptions)\n      },\n      'Ctrl-Left': () => {\n        this.tableEditor.moveFocus(0, -1, this.tableEditorOptions)\n      },\n      'Cmd-Left': () => {\n        this.tableEditor.moveFocus(0, -1, this.tableEditorOptions)\n      },\n      'Ctrl-Right': () => {\n        this.tableEditor.moveFocus(0, 1, this.tableEditorOptions)\n      },\n      'Cmd-Right': () => {\n        this.tableEditor.moveFocus(0, 1, this.tableEditorOptions)\n      },\n      'Ctrl-Up': () => {\n        this.tableEditor.moveFocus(-1, 0, this.tableEditorOptions)\n      },\n      'Cmd-Up': () => {\n        this.tableEditor.moveFocus(-1, 0, this.tableEditorOptions)\n      },\n      'Ctrl-Down': () => {\n        this.tableEditor.moveFocus(1, 0, this.tableEditorOptions)\n      },\n      'Cmd-Down': () => {\n        this.tableEditor.moveFocus(1, 0, this.tableEditorOptions)\n      },\n      'Ctrl-K Ctrl-I': () => {\n        this.tableEditor.insertRow(this.tableEditorOptions)\n      },\n      'Cmd-K Cmd-I': () => {\n        this.tableEditor.insertRow(this.tableEditorOptions)\n      },\n      'Ctrl-L Ctrl-I': () => {\n        this.tableEditor.deleteRow(this.tableEditorOptions)\n      },\n      'Cmd-L Cmd-I': () => {\n        this.tableEditor.deleteRow(this.tableEditorOptions)\n      },\n      'Ctrl-K Ctrl-J': () => {\n        this.tableEditor.insertColumn(this.tableEditorOptions)\n      },\n      'Cmd-K Cmd-J': () => {\n        this.tableEditor.insertColumn(this.tableEditorOptions)\n      },\n      'Ctrl-L Ctrl-J': () => {\n        this.tableEditor.deleteColumn(this.tableEditorOptions)\n      },\n      'Cmd-L Cmd-J': () => {\n        this.tableEditor.deleteColumn(this.tableEditorOptions)\n      },\n      'Alt-Shift-Ctrl-Left': () => {\n        this.tableEditor.moveColumn(-1, this.tableEditorOptions)\n      },\n      'Alt-Shift-Cmd-Left': () => {\n        this.tableEditor.moveColumn(-1, this.tableEditorOptions)\n      },\n      'Alt-Shift-Ctrl-Right': () => {\n        this.tableEditor.moveColumn(1, this.tableEditorOptions)\n      },\n      'Alt-Shift-Cmd-Right': () => {\n        this.tableEditor.moveColumn(1, this.tableEditorOptions)\n      },\n      'Alt-Shift-Ctrl-Up': () => {\n        this.tableEditor.moveRow(-1, this.tableEditorOptions)\n      },\n      'Alt-Shift-Cmd-Up': () => {\n        this.tableEditor.moveRow(-1, this.tableEditorOptions)\n      },\n      'Alt-Shift-Ctrl-Down': () => {\n        this.tableEditor.moveRow(1, this.tableEditorOptions)\n      },\n      'Alt-Shift-Cmd-Down': () => {\n        this.tableEditor.moveRow(1, this.tableEditorOptions)\n      }\n    })\n\n    if (this.props.enableTableEditor) {\n      this.editor.on('changes', this.editorActivityHandler)\n    }\n\n    this.setState({\n      clientWidth: this.refs.root.clientWidth\n    })\n\n    this.initialHighlighting()\n  }\n\n  getWordBeforeCursor(line, lineNumber, cursorPosition) {\n    let wordBeforeCursor = ''\n    const originCursorPosition = cursorPosition\n    const emptyChars = /\\t|\\s|\\r|\\n|\\$/\n\n    // to prevent the word is long that will crash the whole app\n    // the safeStop is there to stop user to expand words that longer than 20 chars\n    const safeStop = 20\n\n    while (cursorPosition > 0) {\n      const currentChar = line.substr(cursorPosition - 1, 1)\n      // if char is not an empty char\n      if (!emptyChars.test(currentChar)) {\n        wordBeforeCursor = currentChar + wordBeforeCursor\n      } else if (wordBeforeCursor.length >= safeStop) {\n        throw new Error('Stopped after 20 loops for safety reason !')\n      } else {\n        break\n      }\n      cursorPosition--\n    }\n\n    return {\n      text: wordBeforeCursor,\n      range: {\n        from: {\n          line: lineNumber,\n          ch: originCursorPosition\n        },\n        to: {\n          line: lineNumber,\n          ch: cursorPosition\n        }\n      }\n    }\n  }\n\n  quitEditor() {\n    document.querySelector('textarea').blur()\n  }\n\n  componentWillUnmount() {\n    this.editor.off('focus', this.focusHandler)\n    this.editor.off('blur', this.blurHandler)\n    this.editor.off('change', this.changeHandler)\n    this.editor.off('paste', this.pasteHandler)\n    eventEmitter.off('top:search', this.searchHandler)\n    this.editor.off('scroll', this.scrollHandler)\n    this.editor.off('cursorActivity', this.editorActivityHandler)\n    this.editor.off('contextmenu', this.contextMenuHandler)\n\n    const editorTheme = document.getElementById('editorTheme')\n    editorTheme.removeEventListener('load', this.loadStyleHandler)\n\n    spellcheck.setLanguage(null, spellcheck.SPELLCHECK_DISABLED)\n    eventEmitter.off('code:format-table', this.formatTable)\n\n    if (this.props.enableTableEditor) {\n      this.editor.off('changes', this.editorActivityHandler)\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    let needRefresh = false\n    const {\n      rulers,\n      enableRulers,\n      enableMarkdownLint,\n      customMarkdownLintConfig\n    } = this.props\n    if (prevProps.mode !== this.props.mode) {\n      this.setMode(this.props.mode)\n    }\n    if (prevProps.theme !== this.props.theme) {\n      this.editor.setOption('theme', this.props.theme)\n      // editor should be refreshed after css loaded\n    }\n    if (prevProps.fontSize !== this.props.fontSize) {\n      needRefresh = true\n    }\n    if (prevProps.fontFamily !== this.props.fontFamily) {\n      needRefresh = true\n    }\n    if (prevProps.keyMap !== this.props.keyMap) {\n      needRefresh = true\n    }\n    if (prevProps.RTL !== this.props.RTL) {\n      this.editor.setOption('direction', this.props.RTL ? 'rtl' : 'ltr')\n      this.editor.setOption('rtlMoveVisually', this.props.RTL)\n    }\n    if (\n      prevProps.enableMarkdownLint !== enableMarkdownLint ||\n      prevProps.customMarkdownLintConfig !== customMarkdownLintConfig\n    ) {\n      if (!enableMarkdownLint) {\n        this.editor.setOption('lint', { default: false })\n        document.querySelector('.CodeMirror-lint-markers').style.display =\n          'none'\n      } else {\n        this.editor.setOption('lint', this.getCodeEditorLintConfig())\n        document.querySelector('.CodeMirror-lint-markers').style.display =\n          'inline-block'\n      }\n      needRefresh = true\n    }\n\n    if (\n      prevProps.enableRulers !== enableRulers ||\n      prevProps.rulers !== rulers\n    ) {\n      this.editor.setOption('rulers', buildCMRulers(rulers, enableRulers))\n    }\n\n    if (prevProps.indentSize !== this.props.indentSize) {\n      this.editor.setOption('indentUnit', this.props.indentSize)\n      this.editor.setOption('tabSize', this.props.indentSize)\n    }\n    if (prevProps.indentType !== this.props.indentType) {\n      this.editor.setOption('indentWithTabs', this.props.indentType !== 'space')\n    }\n\n    if (prevProps.displayLineNumbers !== this.props.displayLineNumbers) {\n      this.editor.setOption('lineNumbers', this.props.displayLineNumbers)\n    }\n\n    if (prevProps.lineWrapping !== this.props.lineWrapping) {\n      this.editor.setOption('lineWrapping', this.props.lineWrapping)\n    }\n\n    if (prevProps.scrollPastEnd !== this.props.scrollPastEnd) {\n      this.editor.setOption('scrollPastEnd', this.props.scrollPastEnd)\n    }\n\n    if (\n      prevProps.matchingPairs !== this.props.matchingPairs ||\n      prevProps.matchingCloseBefore !== this.props.matchingCloseBefore ||\n      prevProps.matchingTriples !== this.props.matchingTriples ||\n      prevProps.explodingPairs !== this.props.explodingPairs ||\n      prevProps.codeBlockMatchingPairs !== this.props.codeBlockMatchingPairs ||\n      prevProps.codeBlockMatchingCloseBefore !==\n        this.props.codeBlockMatchingCloseBefore ||\n      prevProps.codeBlockMatchingTriples !==\n        this.props.codeBlockMatchingTriples ||\n      prevProps.codeBlockExplodingPairs !== this.props.codeBlockExplodingPairs\n    ) {\n      const autoCloseBrackets = {\n        codeBlock: {\n          pairs: this.props.codeBlockMatchingPairs,\n          closeBefore: this.props.codeBlockMatchingCloseBefore,\n          triples: this.props.codeBlockMatchingTriples,\n          explode: this.props.codeBlockExplodingPairs\n        },\n        markdown: {\n          pairs: this.props.matchingPairs,\n          closeBefore: this.props.matchingCloseBefore,\n          triples: this.props.matchingTriples,\n          explode: this.props.explodingPairs\n        }\n      }\n\n      this.editor.setOption('autoCloseBrackets', autoCloseBrackets)\n    }\n\n    if (prevProps.enableTableEditor !== this.props.enableTableEditor) {\n      if (this.props.enableTableEditor) {\n        this.editor.on('cursorActivity', this.editorActivityHandler)\n        this.editor.on('changes', this.editorActivityHandler)\n      } else {\n        this.editor.off('cursorActivity', this.editorActivityHandler)\n        this.editor.off('changes', this.editorActivityHandler)\n      }\n\n      this.extraKeysMode = 'default'\n      this.editor.setOption('extraKeys', this.defaultKeyMap)\n    }\n\n    if (prevProps.hotkey !== this.props.hotkey) {\n      this.updateDefaultKeyMap()\n\n      if (this.extraKeysMode === 'default') {\n        this.editor.setOption('extraKeys', this.defaultKeyMap)\n      }\n    }\n\n    if (this.state.clientWidth !== this.refs.root.clientWidth) {\n      this.setState({\n        clientWidth: this.refs.root.clientWidth\n      })\n\n      needRefresh = true\n    }\n\n    if (prevProps.spellCheck !== this.props.spellCheck) {\n      if (this.props.spellCheck === false) {\n        spellcheck.setLanguage(this.editor, spellcheck.SPELLCHECK_DISABLED)\n        const elem = document.getElementById('editor-bottom-panel')\n        elem.parentNode.removeChild(elem)\n      } else {\n        this.editor.addPanel(this.createSpellCheckPanel(), {\n          position: 'bottom'\n        })\n      }\n    }\n    if (\n      prevProps.deleteUnusedAttachments !== this.props.deleteUnusedAttachments\n    ) {\n      this.editor.setOption(\n        'deleteUnusedAttachments',\n        this.props.deleteUnusedAttachments\n      )\n    }\n\n    if (needRefresh) {\n      this.editor.refresh()\n    }\n  }\n\n  getCodeEditorLintConfig() {\n    const { mode } = this.props\n    const checkMarkdownNoteIsOpen = mode === 'Boost Flavored Markdown'\n\n    return checkMarkdownNoteIsOpen\n      ? {\n          getAnnotations: this.validatorOfMarkdown,\n          async: true\n        }\n      : false\n  }\n\n  validatorOfMarkdown(text, updateLinting) {\n    const { customMarkdownLintConfig } = this.props\n    let lintConfigJson\n    try {\n      Jsonlint.parse(customMarkdownLintConfig)\n      lintConfigJson = JSON.parse(customMarkdownLintConfig)\n    } catch (err) {\n      eventEmitter.emit('APP_SETTING_ERROR')\n      return\n    }\n    const lintOptions = {\n      strings: {\n        content: text\n      },\n      config: lintConfigJson\n    }\n\n    return markdownlint(lintOptions, (err, result) => {\n      if (!err) {\n        const foundIssues = []\n        const splitText = text.split('\\n')\n        result.content.map(item => {\n          let ruleNames = ''\n          item.ruleNames.map((ruleName, index) => {\n            ruleNames += ruleName\n            ruleNames += index === item.ruleNames.length - 1 ? ': ' : '/'\n          })\n          const lineNumber = item.lineNumber - 1\n          foundIssues.push({\n            from: CodeMirror.Pos(lineNumber, 0),\n            to: CodeMirror.Pos(lineNumber, splitText[lineNumber].length),\n            message: ruleNames + item.ruleDescription,\n            severity: 'warning'\n          })\n        })\n        updateLinting(foundIssues)\n      }\n    })\n  }\n\n  setMode(mode) {\n    let syntax = CodeMirror.findModeByName(convertModeName(mode || 'text'))\n    if (syntax == null) syntax = CodeMirror.findModeByName('Plain Text')\n\n    this.editor.setOption('mode', syntax.mime)\n    CodeMirror.autoLoadMode(this.editor, syntax.mode)\n  }\n\n  handleChange(editor, changeObject) {\n    this.debouncedDeletionOfAttachments.cancel()\n\n    spellcheck.handleChange(editor, changeObject)\n\n    // The current note contains an toc. We'll check for changes on headlines.\n    // origin is undefined when markdownTocGenerator replace the old tod\n    if (tocExistsInEditor(editor) && changeObject.origin !== undefined) {\n      let requireTocUpdate\n\n      // Check if one of the changed lines contains a headline\n      for (let line = 0; line < changeObject.text.length; line++) {\n        if (\n          this.linePossibleContainsHeadline(\n            editor.getLine(changeObject.from.line + line)\n          )\n        ) {\n          requireTocUpdate = true\n          break\n        }\n      }\n\n      if (!requireTocUpdate) {\n        // Check if one of the removed lines contains a headline\n        for (let line = 0; line < changeObject.removed.length; line++) {\n          if (this.linePossibleContainsHeadline(changeObject.removed[line])) {\n            requireTocUpdate = true\n            break\n          }\n        }\n      }\n\n      if (requireTocUpdate) {\n        generateInEditor(editor)\n      }\n    }\n\n    this.updateHighlight(editor, changeObject)\n\n    this.value = editor.getValue()\n\n    const { storageKey, noteKey } = this.props\n    const storage = findStorage(storageKey)\n    if (this.props.onChange) {\n      this.props.onChange(editor)\n    }\n\n    const isWrite = !!this.props.onChange\n    const hasFileChanges = isWrite\n\n    if (storage) {\n      sendWakatimeHeartBeat(storage.path, noteKey, storage.name, {\n        isWrite,\n        hasFileChanges,\n        isFileChange: false\n      })\n    }\n  }\n\n  linePossibleContainsHeadline(currentLine) {\n    // We can't check if the line start with # because when some write text before\n    // the # we also need to update the toc\n    return currentLine.includes('# ')\n  }\n\n  incrementLines(start, linesAdded, linesRemoved, editor) {\n    const highlightedLines = editor.options.linesHighlighted\n\n    const totalHighlightedLines = highlightedLines.length\n\n    const offset = linesAdded - linesRemoved\n\n    // Store new items to be added as we're changing the lines\n    const newLines = []\n\n    let i = totalHighlightedLines\n\n    while (i--) {\n      const lineNumber = highlightedLines[i]\n\n      // Interval that will need to be updated\n      // Between start and (start + offset) remove highlight\n      if (lineNumber >= start) {\n        highlightedLines.splice(highlightedLines.indexOf(lineNumber), 1)\n\n        // Lines that need to be relocated\n        if (lineNumber >= start + linesRemoved) {\n          newLines.push(lineNumber + offset)\n        }\n      }\n    }\n\n    // Adding relocated lines\n    highlightedLines.push(...newLines)\n\n    if (this.props.onChange) {\n      this.props.onChange(editor)\n    }\n  }\n\n  handleHighlight(editor, changeObject) {\n    const lines = editor.options.linesHighlighted\n\n    if (!lines.includes(changeObject)) {\n      lines.push(changeObject)\n      editor.addLineClass(\n        changeObject,\n        'text',\n        'CodeMirror-activeline-background'\n      )\n    } else {\n      lines.splice(lines.indexOf(changeObject), 1)\n      editor.removeLineClass(\n        changeObject,\n        'text',\n        'CodeMirror-activeline-background'\n      )\n    }\n    if (this.props.onChange) {\n      this.props.onChange(editor)\n    }\n  }\n\n  updateHighlight(editor, changeObject) {\n    const linesAdded = changeObject.text.length - 1\n    const linesRemoved = changeObject.removed.length - 1\n\n    // If no lines added or removed return\n    if (linesAdded === 0 && linesRemoved === 0) {\n      return\n    }\n\n    let start = changeObject.from.line\n\n    switch (changeObject.origin) {\n      case '+insert\", \"undo':\n        start += 1\n        break\n\n      case 'paste':\n      case '+delete':\n      case '+input':\n        if (changeObject.to.ch !== 0 || changeObject.from.ch !== 0) {\n          start += 1\n        }\n        break\n\n      default:\n        return\n    }\n\n    this.incrementLines(start, linesAdded, linesRemoved, editor)\n  }\n\n  moveCursorTo(row, col) {}\n\n  scrollToLine(event, num) {\n    const cursor = {\n      line: num,\n      ch: 1\n    }\n    this.editor.setCursor(cursor)\n    const top = this.editor.charCoords({ line: num, ch: 0 }, 'local').top\n    const middleHeight = this.editor.getScrollerElement().offsetHeight / 2\n    this.editor.scrollTo(null, top - middleHeight - 5)\n  }\n\n  focus() {\n    this.editor.focus()\n  }\n\n  blur() {\n    this.editor.blur()\n  }\n\n  reload() {\n    // Change event shouldn't be fired when switch note\n    this.editor.off('change', this.changeHandler)\n    this.value = this.props.value\n    this.editor.setValue(this.props.value)\n    this.editor.clearHistory()\n    this.restartHighlighting()\n    this.editor.on('change', this.changeHandler)\n    this.editor.refresh()\n\n    // wakatime\n    const { storageKey, noteKey } = this.props\n    const storage = findStorage(storageKey)\n    if (storage)\n      sendWakatimeHeartBeat(storage.path, noteKey, storage.name, {\n        isWrite: false,\n        hasFileChanges: false,\n        isFileChange: true\n      })\n  }\n\n  setValue(value) {\n    const cursor = this.editor.getCursor()\n    this.editor.setValue(value)\n    this.editor.setCursor(cursor)\n  }\n\n  /**\n   * Update content of one line\n   * @param {Number} lineNumber\n   * @param {String} content\n   */\n  setLineContent(lineNumber, content) {\n    const prevContent = this.editor.getLine(lineNumber)\n    const prevContentLength = prevContent ? prevContent.length : 0\n    this.editor.replaceRange(\n      content,\n      { line: lineNumber, ch: 0 },\n      { line: lineNumber, ch: prevContentLength }\n    )\n  }\n\n  handleDropImage(dropEvent) {\n    dropEvent.preventDefault()\n    const { storageKey, noteKey } = this.props\n    attachmentManagement.handleAttachmentDrop(\n      this,\n      storageKey,\n      noteKey,\n      dropEvent\n    )\n  }\n\n  insertAttachmentMd(imageMd) {\n    this.editor.replaceSelection(imageMd)\n  }\n\n  autoDetectLanguage(content) {\n    const res = hljs.highlightAuto(content, Object.keys(languageMaps))\n    this.setMode(languageMaps[res.language])\n  }\n\n  handlePaste(editor, forceSmartPaste) {\n    const { storageKey, noteKey, fetchUrlTitle, enableSmartPaste } = this.props\n\n    const isURL = str =>\n      /(?:^\\w+:|^)\\/\\/(?:[^\\s\\.]+\\.\\S{2}|localhost[\\:?\\d]*)/.test(str)\n\n    const isInLinkTag = editor => {\n      const startCursor = editor.getCursor('start')\n      const prevChar = editor.getRange(\n        {\n          line: startCursor.line,\n          ch: startCursor.ch - 2\n        },\n        {\n          line: startCursor.line,\n          ch: startCursor.ch\n        }\n      )\n      const endCursor = editor.getCursor('end')\n      const nextChar = editor.getRange(\n        {\n          line: endCursor.line,\n          ch: endCursor.ch\n        },\n        {\n          line: endCursor.line,\n          ch: endCursor.ch + 1\n        }\n      )\n      return prevChar === '](' && nextChar === ')'\n    }\n\n    const isInFencedCodeBlock = editor => {\n      const cursor = editor.getCursor()\n\n      let token = editor.getTokenAt(cursor)\n      if (token.state.fencedState) {\n        return true\n      }\n\n      let line = (line = cursor.line - 1)\n      while (line >= 0) {\n        token = editor.getTokenAt({\n          ch: 3,\n          line\n        })\n\n        if (token.start === token.end) {\n          --line\n        } else if (token.type === 'comment') {\n          if (line > 0) {\n            token = editor.getTokenAt({\n              ch: 3,\n              line: line - 1\n            })\n\n            return token.type !== 'comment'\n          } else {\n            return true\n          }\n        } else {\n          return false\n        }\n      }\n\n      return false\n    }\n\n    const pastedTxt = clipboard.readText()\n\n    if (isInFencedCodeBlock(editor)) {\n      this.handlePasteText(editor, pastedTxt)\n    } else if (\n      fetchUrlTitle &&\n      isMarkdownTitleURL(pastedTxt) &&\n      !isInLinkTag(editor)\n    ) {\n      this.handlePasteUrl(editor, pastedTxt)\n    } else if (fetchUrlTitle && isURL(pastedTxt) && !isInLinkTag(editor)) {\n      this.handlePasteUrl(editor, pastedTxt)\n    } else if (attachmentManagement.isAttachmentLink(pastedTxt)) {\n      attachmentManagement\n        .handleAttachmentLinkPaste(storageKey, noteKey, pastedTxt)\n        .then(modifiedText => {\n          this.editor.replaceSelection(modifiedText)\n        })\n    } else {\n      const image = clipboard.readImage()\n      if (!image.isEmpty()) {\n        attachmentManagement.handlePasteNativeImage(\n          this,\n          storageKey,\n          noteKey,\n          image\n        )\n      } else if (enableSmartPaste || forceSmartPaste) {\n        const pastedHtml = clipboard.readHTML()\n        if (pastedHtml.length > 0) {\n          this.handlePasteHtml(editor, pastedHtml)\n        } else {\n          this.handlePasteText(editor, pastedTxt)\n        }\n      } else {\n        this.handlePasteText(editor, pastedTxt)\n      }\n    }\n\n    if (!this.props.mode && this.props.autoDetect) {\n      this.autoDetectLanguage(editor.doc.getValue())\n    }\n  }\n\n  handleScroll(e) {\n    if (this.props.onScroll) {\n      this.props.onScroll(e)\n    }\n  }\n\n  handlePasteUrl(editor, pastedTxt) {\n    let taggedUrl = `<${pastedTxt}>`\n    let urlToFetch = pastedTxt\n    let titleMark = ''\n\n    if (isMarkdownTitleURL(pastedTxt)) {\n      const pastedTxtSplitted = pastedTxt.split(' ')\n      titleMark = `${pastedTxtSplitted[0]} `\n      urlToFetch = pastedTxtSplitted[1]\n      taggedUrl = `<${urlToFetch}>`\n    }\n\n    editor.replaceSelection(taggedUrl)\n\n    const isImageReponse = response => {\n      return (\n        response.headers.has('content-type') &&\n        response.headers.get('content-type').match(/^image\\/.+$/)\n      )\n    }\n    const replaceTaggedUrl = replacement => {\n      const value = editor.getValue()\n      const cursor = editor.getCursor()\n      const newValue = value.replace(taggedUrl, titleMark + replacement)\n      const newCursor = Object.assign({}, cursor, {\n        ch: cursor.ch + newValue.length - (value.length - titleMark.length)\n      })\n\n      editor.setValue(newValue)\n      editor.setCursor(newCursor)\n    }\n\n    fetch(urlToFetch, {\n      method: 'get'\n    })\n      .then(response => {\n        if (isImageReponse(response)) {\n          return this.mapImageResponse(response, urlToFetch)\n        } else {\n          return this.mapNormalResponse(response, urlToFetch)\n        }\n      })\n      .then(replacement => {\n        replaceTaggedUrl(replacement)\n      })\n      .catch(e => {\n        replaceTaggedUrl(pastedTxt)\n      })\n  }\n\n  handlePasteHtml(editor, pastedHtml) {\n    const markdown = this.turndownService.turndown(pastedHtml)\n    editor.replaceSelection(markdown)\n  }\n\n  handlePasteText(editor, pastedTxt) {\n    editor.replaceSelection(pastedTxt)\n  }\n\n  mapNormalResponse(response, pastedTxt) {\n    return this.decodeResponse(response).then(body => {\n      return new Promise((resolve, reject) => {\n        try {\n          const parsedBody = new window.DOMParser().parseFromString(\n            body,\n            'text/html'\n          )\n          const escapePipe = str => {\n            return str.replace('|', '\\\\|')\n          }\n          const linkWithTitle = `[${escapePipe(\n            parsedBody.title\n          )}](${pastedTxt})`\n          resolve(linkWithTitle)\n        } catch (e) {\n          reject(e)\n        }\n      })\n    })\n  }\n\n  initialHighlighting() {\n    if (this.editor.options.linesHighlighted == null) {\n      return\n    }\n\n    const totalHighlightedLines = this.editor.options.linesHighlighted.length\n    const totalAvailableLines = this.editor.lineCount()\n\n    for (let i = 0; i < totalHighlightedLines; i++) {\n      const lineNumber = this.editor.options.linesHighlighted[i]\n      if (lineNumber > totalAvailableLines) {\n        // make sure that we skip the invalid lines althrough this case should not be happened.\n        continue\n      }\n      this.editor.addLineClass(\n        lineNumber,\n        'text',\n        'CodeMirror-activeline-background'\n      )\n    }\n  }\n\n  restartHighlighting() {\n    this.editor.options.linesHighlighted = this.props.linesHighlighted\n    this.initialHighlighting()\n  }\n\n  mapImageResponse(response, pastedTxt) {\n    return new Promise((resolve, reject) => {\n      try {\n        const url = response.url\n        const name = url.substring(url.lastIndexOf('/') + 1)\n        const imageLinkWithName = `![${name}](${pastedTxt})`\n        resolve(imageLinkWithName)\n      } catch (e) {\n        reject(e)\n      }\n    })\n  }\n\n  decodeResponse(response) {\n    const headers = response.headers\n    const _charset = headers.has('content-type')\n      ? this.extractContentTypeCharset(headers.get('content-type'))\n      : undefined\n    return response.arrayBuffer().then(buff => {\n      return new Promise((resolve, reject) => {\n        try {\n          const charset =\n            _charset !== undefined && iconv.encodingExists(_charset)\n              ? _charset\n              : 'utf-8'\n          resolve(iconv.decode(Buffer.from(buff), charset).toString())\n        } catch (e) {\n          reject(e)\n        }\n      })\n    })\n  }\n\n  extractContentTypeCharset(contentType) {\n    return contentType\n      .split(';')\n      .filter(str => {\n        return str\n          .trim()\n          .toLowerCase()\n          .startsWith('charset')\n      })\n      .map(str => {\n        return str.replace(/['\"]/g, '').split('=')[1]\n      })[0]\n  }\n\n  render() {\n    const { className, fontSize, fontFamily, width, height } = this.props\n    const normalisedFontFamily = normalizeEditorFontFamily(fontFamily)\n\n    return (\n      <div\n        className={className == null ? 'CodeEditor' : `CodeEditor ${className}`}\n        ref='root'\n        tabIndex='-1'\n        style={{\n          fontFamily: normalisedFontFamily,\n          fontSize,\n          width,\n          height\n        }}\n        onDrop={e => this.handleDropImage(e)}\n      />\n    )\n  }\n\n  createSpellCheckPanel() {\n    const panel = document.createElement('div')\n    panel.className = 'panel bottom'\n    panel.id = 'editor-bottom-panel'\n    const dropdown = document.createElement('select')\n    dropdown.title = 'Spellcheck'\n    dropdown.className = styles['spellcheck-select']\n    dropdown.addEventListener('change', e =>\n      spellcheck.setLanguage(this.editor, dropdown.value)\n    )\n    const options = spellcheck.getAvailableDictionaries()\n    for (const op of options) {\n      const option = document.createElement('option')\n      option.value = op.value\n      option.innerHTML = op.label\n      dropdown.appendChild(option)\n    }\n    panel.appendChild(dropdown)\n    return panel\n  }\n}\n\nCodeEditor.propTypes = {\n  value: PropTypes.string,\n  enableRulers: PropTypes.bool,\n  rulers: PropTypes.arrayOf(Number),\n  mode: PropTypes.string,\n  className: PropTypes.string,\n  onBlur: PropTypes.func,\n  onChange: PropTypes.func,\n  readOnly: PropTypes.bool,\n  autoDetect: PropTypes.bool,\n  spellCheck: PropTypes.bool,\n  enableMarkdownLint: PropTypes.bool,\n  customMarkdownLintConfig: PropTypes.string,\n  deleteUnusedAttachments: PropTypes.bool,\n  RTL: PropTypes.bool\n}\n\nCodeEditor.defaultProps = {\n  readOnly: false,\n  theme: 'xcode',\n  keyMap: 'sublime',\n  fontSize: 14,\n  fontFamily: 'Monaco, Consolas',\n  indentSize: 4,\n  indentType: 'space',\n  autoDetect: false,\n  spellCheck: false,\n  enableMarkdownLint: DEFAULT_CONFIG.editor.enableMarkdownLint,\n  customMarkdownLintConfig: DEFAULT_CONFIG.editor.customMarkdownLintConfig,\n  prettierConfig: DEFAULT_CONFIG.editor.prettierConfig,\n  deleteUnusedAttachments: DEFAULT_CONFIG.editor.deleteUnusedAttachments,\n  RTL: false\n}\n",
    "browser/main/lib/dataApi/exportNote.js": "import copyFile from 'browser/main/lib/dataApi/copyFile'\nimport { findStorage } from 'browser/lib/findStorage'\n\nconst fs = require('fs')\nconst path = require('path')\n\n/**\n * Export note together with attachments\n *\n * If attachments are stored in the storage, creates 'attachments' subfolder in target directory\n * and copies attachments to it. Changes links to images in the content of the note\n *\n * @param {String} storageKey or storage path\n * @param {Object} note Note to export\n * @param {String} targetPath Path to exported file\n * @param {function} outputFormatter\n * @return {Promise.<*[]>}\n */\nfunction exportNote(storageKey, note, targetPath, outputFormatter) {\n  const storagePath = path.isAbsolute(storageKey)\n    ? storageKey\n    : findStorage(storageKey).path\n\n  const exportTasks = []\n\n  if (!storagePath) {\n    throw new Error('Storage path is not found')\n  }\n\n  const exportedData = Promise.resolve(\n    outputFormatter\n      ? outputFormatter(note, targetPath, exportTasks)\n      : note.content\n  )\n\n  const tasks = prepareTasks(exportTasks, storagePath, path.dirname(targetPath))\n\n  return Promise.all(tasks.map(task => copyFile(task.src, task.dst)))\n    .then(() => exportedData)\n    .then(data => {\n      return saveToFile(data, targetPath)\n    })\n    .catch(error => {\n      rollbackExport(tasks)\n      throw error\n    })\n}\n\nfunction prepareTasks(tasks, storagePath, targetPath) {\n  return tasks.map(task => {\n    if (!path.isAbsolute(task.src)) {\n      task.src = path.join(storagePath, task.src)\n    }\n\n    if (!path.isAbsolute(task.dst)) {\n      task.dst = path.join(targetPath, task.dst)\n    }\n\n    return task\n  })\n}\n\nfunction saveToFile(data, filename) {\n  return new Promise((resolve, reject) => {\n    fs.writeFile(filename, data, err => {\n      if (err) return reject(err)\n\n      resolve(filename)\n    })\n  })\n}\n\n/**\n * Remove exported files\n * @param tasks Array of copy task objects. Object consists of two mandatory fields – `src` and `dst`\n */\nfunction rollbackExport(tasks) {\n  const folders = new Set()\n  tasks.forEach(task => {\n    let fullpath = task.dst\n\n    if (!path.extname(task.dst)) {\n      fullpath = path.join(task.dst, path.basename(task.src))\n    }\n\n    if (fs.existsSync(fullpath)) {\n      fs.unlinkSync(fullpath)\n      folders.add(path.dirname(fullpath))\n    }\n  })\n\n  folders.forEach(folder => {\n    if (fs.readdirSync(folder).length === 0) {\n      fs.rmdirSync(folder)\n    }\n  })\n}\n\nexport default exportNote\n",
    "browser/main/lib/dataApi/formatPDF.js": "import formatHTML from './formatHTML'\nimport { remote } from 'electron'\n\nexport default function formatPDF(props) {\n  return function(note, targetPath, exportTasks) {\n    const printout = new remote.BrowserWindow({\n      show: false,\n      webPreferences: { webSecurity: false, javascript: false }\n    })\n\n    printout.loadURL(\n      'data:text/html;charset=UTF-8,' +\n        formatHTML(props)(note, targetPath, exportTasks)\n    )\n\n    return new Promise((resolve, reject) => {\n      printout.webContents.on('did-finish-load', () => {\n        printout.webContents.printToPDF({}, (err, data) => {\n          if (err) reject(err)\n          else resolve(data)\n          printout.destroy()\n        })\n      })\n    })\n  }\n}\n",
    "browser/main/lib/dataApi/updateSnippet.js": "import fs from 'fs'\nimport consts from 'browser/lib/consts'\n\nfunction updateSnippet(snippet, snippetFile) {\n  return new Promise((resolve, reject) => {\n    const snippets = JSON.parse(\n      fs.readFileSync(snippetFile || consts.SNIPPET_FILE, 'utf-8')\n    )\n\n    for (let i = 0; i < snippets.length; i++) {\n      const currentSnippet = snippets[i]\n\n      if (currentSnippet.id === snippet.id) {\n        if (\n          currentSnippet.name === snippet.name &&\n          currentSnippet.prefix === snippet.prefix &&\n          currentSnippet.content === snippet.content &&\n          currentSnippet.linesHighlighted === snippet.linesHighlighted\n        ) {\n          // if everything is the same then don't write to disk\n          resolve(snippets)\n        } else {\n          currentSnippet.name = snippet.name\n          currentSnippet.prefix = snippet.prefix\n          currentSnippet.content = snippet.content\n          currentSnippet.linesHighlighted = snippet.linesHighlighted\n          fs.writeFile(\n            snippetFile || consts.SNIPPET_FILE,\n            JSON.stringify(snippets, null, 4),\n            err => {\n              if (err) reject(err)\n              resolve(snippets)\n            }\n          )\n        }\n      }\n    }\n  })\n}\n\nmodule.exports = updateSnippet\n",
    "dev-scripts/dev.js": "const webpack = require('webpack')\nconst WebpackDevServer = require('webpack-dev-server')\nconst config = require('../webpack.config')\nconst signale = require('signale')\nconst { spawn } = require('child_process')\nconst electron = require('electron')\nconst port = 8080\nlet server = null\nlet firstRun = true\n\nconst options = {\n  publicPath: config.output.publicPath,\n  hot: true,\n  inline: true,\n  quiet: true\n}\n\nfunction startServer() {\n  config.plugins.push(new webpack.HotModuleReplacementPlugin())\n  config.entry.main.unshift(\n    `webpack-dev-server/client?http://localhost:${port}/`,\n    'webpack/hot/dev-server'\n  )\n  const compiler = webpack(config)\n  server = new WebpackDevServer(compiler, options)\n\n  return new Promise((resolve, reject) => {\n    server.listen(port, 'localhost', function(err) {\n      if (err) {\n        reject(err)\n      }\n      signale.success(`Webpack Dev Server listening at localhost:${port}`)\n      signale.watch(`Waiting for webpack to bundle...`)\n      compiler.plugin('done', stats => {\n        if (!stats.hasErrors()) {\n          signale.success(`Bundle success !`)\n          resolve()\n        } else {\n          if (!firstRun) {\n            console.log(stats.compilation.errors[0])\n          } else {\n            firstRun = false\n            reject(stats.compilation.errors[0])\n          }\n        }\n      })\n    })\n  })\n}\n\nfunction startElectron() {\n  spawn(electron, ['--hot', './index.js'], { stdio: 'inherit' })\n    .on('close', () => {\n      server.close()\n    })\n    .on('error', err => {\n      signale.error(err)\n      server.close()\n    })\n    .on('disconnect', () => {\n      server.close()\n    })\n    .on('exit', () => {\n      server.close()\n    })\n}\n\nstartServer()\n  .then(() => {\n    startElectron()\n    signale.success('Electron started')\n  })\n  .catch(err => {\n    signale.error(err)\n    process.exit(1)\n  })\n",
    "browser/main/NoteList/index.js": "/* global electron */\nimport PropTypes from 'prop-types'\nimport React from 'react'\nimport CSSModules from 'browser/lib/CSSModules'\nimport styles from './NoteList.styl'\nimport moment from 'moment'\nimport _ from 'lodash'\nimport ee from 'browser/main/lib/eventEmitter'\nimport dataApi from 'browser/main/lib/dataApi'\nimport attachmentManagement from 'browser/main/lib/dataApi/attachmentManagement'\nimport ConfigManager from 'browser/main/lib/ConfigManager'\nimport NoteItem from 'browser/components/NoteItem'\nimport NoteItemSimple from 'browser/components/NoteItemSimple'\nimport searchFromNotes from 'browser/lib/search'\nimport fs from 'fs'\nimport path from 'path'\nimport { push, replace } from 'connected-react-router'\nimport copy from 'copy-to-clipboard'\nimport AwsMobileAnalyticsConfig from 'browser/main/lib/AwsMobileAnalyticsConfig'\nimport Markdown from '../../lib/markdown'\nimport i18n from 'browser/lib/i18n'\nimport { confirmDeleteNote } from 'browser/lib/confirmDeleteNote'\nimport context from 'browser/lib/context'\nimport filenamify from 'filenamify'\nimport queryString from 'query-string'\n\nconst { remote } = require('electron')\nconst { dialog } = remote\nconst WP_POST_PATH = '/wp/v2/posts'\n\nconst regexMatchStartingTitleNumber = new RegExp('^([0-9]*.?[0-9]+).*$')\n\nfunction sortByCreatedAt(a, b) {\n  return new Date(b.createdAt) - new Date(a.createdAt)\n}\n\nfunction sortByAlphabetical(a, b) {\n  const matchA = regexMatchStartingTitleNumber.exec(a.title)\n  const matchB = regexMatchStartingTitleNumber.exec(b.title)\n\n  if (matchA && matchA.length === 2 && matchB && matchB.length === 2) {\n    // Both note titles are starting with a float. We will compare it now.\n    const floatA = parseFloat(matchA[1])\n    const floatB = parseFloat(matchB[1])\n\n    const diff = floatA - floatB\n    if (diff !== 0) {\n      return diff\n    }\n\n    // The float values are equal. We will compare the full title.\n  }\n\n  return a.title.localeCompare(b.title)\n}\n\nfunction sortByUpdatedAt(a, b) {\n  return new Date(b.updatedAt) - new Date(a.updatedAt)\n}\n\nfunction findNoteByKey(notes, noteKey) {\n  return notes.find(note => note.key === noteKey)\n}\n\nfunction findNotesByKeys(notes, noteKeys) {\n  return notes.filter(note => noteKeys.includes(getNoteKey(note)))\n}\n\nfunction getNoteKey(note) {\n  return note.key\n}\n\nclass NoteList extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.selectNextNoteHandler = () => {\n      this.selectNextNote()\n    }\n    this.selectPriorNoteHandler = () => {\n      this.selectPriorNote()\n    }\n    this.focusHandler = () => {\n      this.refs.list.focus()\n    }\n    this.alertIfSnippetHandler = (event, msg) => {\n      this.alertIfSnippet(msg)\n    }\n    this.importFromFileHandler = this.importFromFile.bind(this)\n    this.jumpNoteByHash = this.jumpNoteByHashHandler.bind(this)\n    this.handleNoteListKeyUp = this.handleNoteListKeyUp.bind(this)\n    this.handleNoteListBlur = this.handleNoteListBlur.bind(this)\n    this.getNoteKeyFromTargetIndex = this.getNoteKeyFromTargetIndex.bind(this)\n    this.cloneNote = this.cloneNote.bind(this)\n    this.deleteNote = this.deleteNote.bind(this)\n    this.focusNote = this.focusNote.bind(this)\n    this.pinToTop = this.pinToTop.bind(this)\n    this.getNoteStorage = this.getNoteStorage.bind(this)\n    this.getNoteFolder = this.getNoteFolder.bind(this)\n    this.getViewType = this.getViewType.bind(this)\n    this.restoreNote = this.restoreNote.bind(this)\n    this.copyNoteLink = this.copyNoteLink.bind(this)\n    this.navigate = this.navigate.bind(this)\n\n    // TODO: not Selected noteKeys but SelectedNote(for reusing)\n    this.state = {\n      ctrlKeyDown: false,\n      shiftKeyDown: false,\n      prevShiftNoteIndex: -1,\n      selectedNoteKeys: []\n    }\n\n    this.contextNotes = []\n  }\n\n  componentDidMount() {\n    this.refreshTimer = setInterval(() => this.forceUpdate(), 60 * 1000)\n    ee.on('list:next', this.selectNextNoteHandler)\n    ee.on('list:prior', this.selectPriorNoteHandler)\n    ee.on('list:clone', this.cloneNote)\n    ee.on('list:focus', this.focusHandler)\n    ee.on('list:isMarkdownNote', this.alertIfSnippetHandler)\n    ee.on('import:file', this.importFromFileHandler)\n    ee.on('list:jump', this.jumpNoteByHash)\n    ee.on('list:navigate', this.navigate)\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.location.pathname !== this.props.location.pathname) {\n      this.resetScroll()\n    }\n  }\n\n  resetScroll() {\n    this.refs.list.scrollTop = 0\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.refreshTimer)\n\n    ee.off('list:next', this.selectNextNoteHandler)\n    ee.off('list:prior', this.selectPriorNoteHandler)\n    ee.off('list:clone', this.cloneNote)\n    ee.off('list:focus', this.focusHandler)\n    ee.off('list:isMarkdownNote', this.alertIfSnippetHandler)\n    ee.off('import:file', this.importFromFileHandler)\n    ee.off('list:jump', this.jumpNoteByHash)\n  }\n\n  componentDidUpdate(prevProps) {\n    const { dispatch, location } = this.props\n    const { selectedNoteKeys } = this.state\n    const visibleNoteKeys = this.notes && this.notes.map(note => note.key)\n    const note = this.notes && this.notes[0]\n    const key = location.search && queryString.parse(location.search).key\n    const prevKey =\n      prevProps.location.search &&\n      queryString.parse(prevProps.location.search).key\n    const noteKey = visibleNoteKeys.includes(prevKey)\n      ? prevKey\n      : note && note.key\n\n    if (note && location.search === '') {\n      if (!location.pathname.match(/\\/searched/))\n        this.contextNotes = this.getContextNotes()\n\n      // A visible note is an active note\n      if (!selectedNoteKeys.includes(noteKey)) {\n        if (selectedNoteKeys.length === 1) selectedNoteKeys.pop()\n        selectedNoteKeys.push(noteKey)\n        ee.emit('list:moved')\n      }\n\n      dispatch(\n        replace({\n          // was passed with context - we can use connected router here\n          pathname: location.pathname,\n          search: queryString.stringify({\n            key: noteKey\n          })\n        })\n      )\n      return\n    }\n\n    // Auto scroll\n    if (_.isString(key) && prevKey === key) {\n      const targetIndex = this.getTargetIndex()\n      if (targetIndex > -1) {\n        const list = this.refs.list\n        const item = list.childNodes[targetIndex]\n\n        if (item == null) return false\n\n        const overflowBelow =\n          item.offsetTop +\n            item.clientHeight -\n            list.clientHeight -\n            list.scrollTop >\n          0\n        if (overflowBelow) {\n          list.scrollTop =\n            item.offsetTop + item.clientHeight - list.clientHeight\n        }\n        const overflowAbove = list.scrollTop > item.offsetTop\n        if (overflowAbove) {\n          list.scrollTop = item.offsetTop\n        }\n      }\n    }\n  }\n\n  focusNote(selectedNoteKeys, noteKey, pathname) {\n    const { dispatch } = this.props\n\n    this.setState({\n      selectedNoteKeys\n    })\n\n    dispatch(\n      push({\n        pathname,\n        search: queryString.stringify({\n          key: noteKey\n        })\n      })\n    )\n  }\n\n  getNoteKeyFromTargetIndex(targetIndex) {\n    const note = Object.assign({}, this.notes[targetIndex])\n    const noteKey = getNoteKey(note)\n    return noteKey\n  }\n\n  selectPriorNote() {\n    if (this.notes == null || this.notes.length === 0) {\n      return\n    }\n    let { selectedNoteKeys } = this.state\n    const { shiftKeyDown } = this.state\n    const { location } = this.props\n\n    let targetIndex = this.getTargetIndex()\n\n    if (targetIndex === 0) {\n      return\n    }\n    targetIndex--\n\n    if (!shiftKeyDown) {\n      selectedNoteKeys = []\n    }\n    const priorNoteKey = this.getNoteKeyFromTargetIndex(targetIndex)\n    if (selectedNoteKeys.includes(priorNoteKey)) {\n      selectedNoteKeys.pop()\n    } else {\n      selectedNoteKeys.push(priorNoteKey)\n    }\n\n    this.focusNote(selectedNoteKeys, priorNoteKey, location.pathname)\n\n    ee.emit('list:moved')\n  }\n\n  selectNextNote() {\n    if (this.notes == null || this.notes.length === 0) {\n      return\n    }\n    let { selectedNoteKeys } = this.state\n    const { shiftKeyDown } = this.state\n    const { location } = this.props\n\n    let targetIndex = this.getTargetIndex()\n    const isTargetLastNote = targetIndex === this.notes.length - 1\n\n    if (isTargetLastNote && shiftKeyDown) {\n      return\n    } else if (isTargetLastNote) {\n      targetIndex = 0\n    } else {\n      targetIndex++\n      if (targetIndex < 0) targetIndex = 0\n      else if (targetIndex > this.notes.length - 1)\n        targetIndex = this.notes.length - 1\n    }\n\n    if (!shiftKeyDown) {\n      selectedNoteKeys = []\n    }\n    const nextNoteKey = this.getNoteKeyFromTargetIndex(targetIndex)\n    if (selectedNoteKeys.includes(nextNoteKey)) {\n      selectedNoteKeys.pop()\n    } else {\n      selectedNoteKeys.push(nextNoteKey)\n    }\n\n    this.focusNote(selectedNoteKeys, nextNoteKey, location.pathname)\n\n    ee.emit('list:moved')\n  }\n\n  jumpNoteByHashHandler(event, noteHash) {\n    const { data } = this.props\n\n    // first argument event isn't used.\n    if (this.notes === null || this.notes.length === 0) {\n      return\n    }\n\n    const selectedNoteKeys = [noteHash]\n\n    let locationToSelect = '/home'\n    const noteByHash = data.noteMap\n      .map(note => note)\n      .find(note => note.key === noteHash)\n    if (noteByHash !== undefined) {\n      locationToSelect =\n        '/storages/' + noteByHash.storage + '/folders/' + noteByHash.folder\n    }\n\n    this.focusNote(selectedNoteKeys, noteHash, locationToSelect)\n\n    ee.emit('list:moved')\n  }\n\n  handleNoteListKeyDown(e) {\n    if (e.metaKey) return true\n\n    // A key\n    if (e.keyCode === 65 && !e.shiftKey) {\n      e.preventDefault()\n      ee.emit('top:new-note')\n    }\n\n    // E key\n    if (e.keyCode === 69) {\n      e.preventDefault()\n      ee.emit('detail:focus')\n    }\n\n    // L or S key\n    if (e.keyCode === 76 || e.keyCode === 83) {\n      e.preventDefault()\n      ee.emit('top:focus-search')\n    }\n\n    // UP or K key\n    if (e.keyCode === 38 || e.keyCode === 75) {\n      e.preventDefault()\n      this.selectPriorNote()\n    }\n\n    // DOWN or J key\n    if (e.keyCode === 40 || e.keyCode === 74) {\n      e.preventDefault()\n      this.selectNextNote()\n    }\n\n    if (e.shiftKey) {\n      this.setState({ shiftKeyDown: true })\n    } else if (e.ctrlKey) {\n      this.setState({ ctrlKeyDown: true })\n    }\n  }\n\n  handleNoteListKeyUp(e) {\n    if (!e.shiftKey) {\n      this.setState({ shiftKeyDown: false })\n    }\n\n    if (!e.ctrlKey) {\n      this.setState({ ctrlKeyDown: false })\n    }\n  }\n\n  handleNoteListBlur() {\n    this.setState({\n      shiftKeyDown: false,\n      ctrlKeyDown: false\n    })\n  }\n\n  getNotes() {\n    const {\n      data,\n      match: { params },\n      location\n    } = this.props\n    if (\n      location.pathname.match(/\\/home/) ||\n      location.pathname.match(/alltags/)\n    ) {\n      const allNotes = data.noteMap.map(note => note)\n      this.contextNotes = allNotes\n      return allNotes\n    }\n\n    if (location.pathname.match(/\\/starred/)) {\n      const starredNotes = data.starredSet\n        .toJS()\n        .map(uniqueKey => data.noteMap.get(uniqueKey))\n      this.contextNotes = starredNotes\n      return starredNotes\n    }\n\n    if (location.pathname.match(/\\/searched/)) {\n      const searchInputText = params.searchword\n      const allNotes = data.noteMap.map(note => note)\n      this.contextNotes = allNotes\n      if (searchInputText === undefined || searchInputText === '') {\n        return this.sortByPin(this.contextNotes)\n      }\n      return searchFromNotes(this.contextNotes, searchInputText)\n    }\n\n    if (location.pathname.match(/\\/trashed/)) {\n      const trashedNotes = data.trashedSet\n        .toJS()\n        .map(uniqueKey => data.noteMap.get(uniqueKey))\n      this.contextNotes = trashedNotes\n      return trashedNotes\n    }\n\n    if (location.pathname.match(/\\/tags/)) {\n      const listOfTags = params.tagname.split(' ')\n      return data.noteMap\n        .map(note => {\n          return note\n        })\n        .filter(note => listOfTags.every(tag => note.tags.includes(tag)))\n    }\n\n    return this.getContextNotes()\n  }\n\n  // get notes in the current folder\n  getContextNotes() {\n    const {\n      data,\n      match: { params }\n    } = this.props\n    const storageKey = params.storageKey\n    const folderKey = params.folderKey\n    const storage = data.storageMap.get(storageKey)\n    if (storage === undefined) return []\n\n    const folder = _.find(storage.folders, { key: folderKey })\n    if (folder === undefined) {\n      const storageNoteSet = data.storageNoteMap.get(storage.key) || []\n      return storageNoteSet.map(uniqueKey => data.noteMap.get(uniqueKey))\n    }\n\n    const folderNoteKeyList =\n      data.folderNoteMap.get(`${storage.key}-${folder.key}`) || []\n    return folderNoteKeyList.map(uniqueKey => data.noteMap.get(uniqueKey))\n  }\n\n  sortByPin(unorderedNotes) {\n    const pinnedNotes = []\n    const unpinnedNotes = []\n\n    unorderedNotes.forEach(note => {\n      if (note.isPinned) {\n        pinnedNotes.push(note)\n      } else {\n        unpinnedNotes.push(note)\n      }\n    })\n\n    return pinnedNotes.concat(unpinnedNotes)\n  }\n\n  getNoteIndexByKey(noteKey) {\n    return this.notes.findIndex(note => {\n      if (!note) return -1\n\n      return note.key === noteKey\n    })\n  }\n\n  handleNoteClick(e, uniqueKey) {\n    const { dispatch, location } = this.props\n    let { selectedNoteKeys, prevShiftNoteIndex } = this.state\n    const { ctrlKeyDown, shiftKeyDown } = this.state\n    const hasSelectedNoteKey = selectedNoteKeys.length > 0\n\n    if (ctrlKeyDown && selectedNoteKeys.includes(uniqueKey)) {\n      const newSelectedNoteKeys = selectedNoteKeys.filter(\n        noteKey => noteKey !== uniqueKey\n      )\n      this.setState({\n        selectedNoteKeys: newSelectedNoteKeys\n      })\n      return\n    }\n    if (!ctrlKeyDown && !shiftKeyDown) {\n      selectedNoteKeys = []\n    }\n\n    if (!shiftKeyDown) {\n      prevShiftNoteIndex = -1\n    }\n\n    selectedNoteKeys.push(uniqueKey)\n\n    if (shiftKeyDown && hasSelectedNoteKey) {\n      let firstShiftNoteIndex = this.getNoteIndexByKey(selectedNoteKeys[0])\n      // Shift selection can either start from first note in the exisiting selectedNoteKeys\n      // or previous first shift note index\n      firstShiftNoteIndex =\n        firstShiftNoteIndex > prevShiftNoteIndex\n          ? firstShiftNoteIndex\n          : prevShiftNoteIndex\n\n      const lastShiftNoteIndex = this.getNoteIndexByKey(uniqueKey)\n\n      const startIndex =\n        firstShiftNoteIndex < lastShiftNoteIndex\n          ? firstShiftNoteIndex\n          : lastShiftNoteIndex\n      const endIndex =\n        firstShiftNoteIndex > lastShiftNoteIndex\n          ? firstShiftNoteIndex\n          : lastShiftNoteIndex\n\n      selectedNoteKeys = []\n      for (let i = startIndex; i <= endIndex; i++) {\n        selectedNoteKeys.push(this.notes[i].key)\n      }\n\n      if (prevShiftNoteIndex < 0) {\n        prevShiftNoteIndex = firstShiftNoteIndex\n      }\n    }\n\n    this.setState({\n      selectedNoteKeys,\n      prevShiftNoteIndex\n    })\n\n    dispatch(\n      push({\n        pathname: location.pathname,\n        search: queryString.stringify({\n          key: uniqueKey\n        })\n      })\n    )\n  }\n\n  handleSortByChange(e) {\n    const {\n      dispatch,\n      match: {\n        params: { folderKey }\n      }\n    } = this.props\n\n    const config = {\n      [folderKey]: { sortBy: e.target.value }\n    }\n\n    ConfigManager.set(config)\n    dispatch({\n      type: 'SET_CONFIG',\n      config\n    })\n  }\n\n  handleListStyleButtonClick(e, style) {\n    const { dispatch } = this.props\n\n    const config = {\n      listStyle: style\n    }\n\n    ConfigManager.set(config)\n    dispatch({\n      type: 'SET_CONFIG',\n      config\n    })\n  }\n\n  handleListDirectionButtonClick(e, direction) {\n    const { dispatch } = this.props\n\n    const config = {\n      listDirection: direction\n    }\n\n    ConfigManager.set(config)\n    dispatch({\n      type: 'SET_CONFIG',\n      config\n    })\n  }\n\n  alertIfSnippet(msg) {\n    const warningMessage = msg =>\n      ({\n        'export-txt': 'Text export',\n        'export-md': 'Markdown export',\n        'export-html': 'HTML export',\n        'export-pdf': 'PDF export',\n        print: 'Print'\n      }[msg])\n\n    const targetIndex = this.getTargetIndex()\n    if (this.notes[targetIndex].type === 'SNIPPET_NOTE') {\n      dialog.showMessageBox(remote.getCurrentWindow(), {\n        type: 'warning',\n        message: i18n.__('Sorry!'),\n        detail: i18n.__(\n          warningMessage(msg) + ' is available only in markdown notes.'\n        ),\n        buttons: [i18n.__('OK')]\n      })\n    }\n  }\n\n  handleDragStart(e, note) {\n    let { selectedNoteKeys } = this.state\n    const noteKey = getNoteKey(note)\n\n    if (!selectedNoteKeys.includes(noteKey)) {\n      selectedNoteKeys = []\n      selectedNoteKeys.push(noteKey)\n    }\n\n    const notes = this.notes.map(note => Object.assign({}, note))\n    const selectedNotes = findNotesByKeys(notes, selectedNoteKeys)\n    const noteData = JSON.stringify(selectedNotes)\n    e.dataTransfer.setData('note', noteData)\n    this.selectNextNote()\n  }\n\n  handleExportClick(e, note, fileType) {\n    const options = {\n      defaultPath: filenamify(note.title, {\n        replacement: '_'\n      }),\n      filters: [{ name: 'Documents', extensions: [fileType] }],\n      properties: ['openFile', 'createDirectory']\n    }\n\n    dialog.showSaveDialog(remote.getCurrentWindow(), options, filename => {\n      if (filename) {\n        const { config } = this.props\n\n        dataApi\n          .exportNoteAs(note, filename, fileType, config)\n          .then(res => {\n            dialog.showMessageBox(remote.getCurrentWindow(), {\n              type: 'info',\n              message: `Exported to ${filename}`\n            })\n          })\n          .catch(err => {\n            dialog.showErrorBox(\n              'Export error',\n              err ? err.message || err : 'Unexpected error during export'\n            )\n            throw err\n          })\n      }\n    })\n  }\n\n  handleNoteContextMenu(e, uniqueKey) {\n    const { location } = this.props\n    const { selectedNoteKeys } = this.state\n    const note = findNoteByKey(this.notes, uniqueKey)\n    const noteKey = getNoteKey(note)\n\n    if (selectedNoteKeys.length === 0 || !selectedNoteKeys.includes(noteKey)) {\n      this.handleNoteClick(e, uniqueKey)\n    }\n\n    const pinLabel = note.isPinned\n      ? i18n.__('Remove pin')\n      : i18n.__('Pin to Top')\n    const deleteLabel = i18n.__('Delete Note')\n    const cloneNote = i18n.__('Clone Note')\n    const restoreNote = i18n.__('Restore Note')\n    const copyNoteLink = i18n.__('Copy Note Link')\n    const publishLabel = i18n.__('Publish Blog')\n    const updateLabel = i18n.__('Update Blog')\n    const openBlogLabel = i18n.__('Open Blog')\n\n    const templates = []\n\n    if (location.pathname.match(/\\/trash/)) {\n      templates.push(\n        {\n          label: restoreNote,\n          click: this.restoreNote\n        },\n        {\n          label: deleteLabel,\n          click: this.deleteNote\n        }\n      )\n    } else {\n      if (!location.pathname.match(/\\/starred/)) {\n        templates.push({\n          label: pinLabel,\n          click: this.pinToTop\n        })\n      }\n      templates.push(\n        {\n          label: deleteLabel,\n          click: this.deleteNote\n        },\n        {\n          label: cloneNote,\n          click: this.cloneNote.bind(this)\n        },\n        {\n          label: copyNoteLink,\n          click: this.copyNoteLink.bind(this, note)\n        }\n      )\n\n      if (note.type === 'MARKDOWN_NOTE') {\n        templates.push(\n          {\n            type: 'separator'\n          },\n          {\n            label: i18n.__('Export Note'),\n            submenu: [\n              {\n                label: i18n.__('Export as Plain Text (.txt)'),\n                click: e => this.handleExportClick(e, note, 'txt')\n              },\n              {\n                label: i18n.__('Export as Markdown (.md)'),\n                click: e => this.handleExportClick(e, note, 'md')\n              },\n              {\n                label: i18n.__('Export as HTML (.html)'),\n                click: e => this.handleExportClick(e, note, 'html')\n              },\n              {\n                label: i18n.__('Export as PDF (.pdf)'),\n                click: e => this.handleExportClick(e, note, 'pdf')\n              }\n            ]\n          }\n        )\n\n        if (note.blog && note.blog.blogLink && note.blog.blogId) {\n          templates.push(\n            {\n              type: 'separator'\n            },\n            {\n              label: updateLabel,\n              click: this.publishMarkdown.bind(this)\n            },\n            {\n              label: openBlogLabel,\n              click: () => this.openBlog.bind(this)(note)\n            }\n          )\n        } else {\n          templates.push(\n            {\n              type: 'separator'\n            },\n            {\n              label: publishLabel,\n              click: this.publishMarkdown.bind(this)\n            }\n          )\n        }\n      }\n    }\n    context.popup(templates)\n  }\n\n  updateSelectedNotes(updateFunc, cleanSelection = true) {\n    const { selectedNoteKeys } = this.state\n    const { dispatch } = this.props\n    const notes = this.notes.map(note => Object.assign({}, note))\n    const selectedNotes = findNotesByKeys(notes, selectedNoteKeys)\n\n    if (!_.isFunction(updateFunc)) {\n      console.warn('Update function is not defined. No update will happen')\n      updateFunc = note => {\n        return note\n      }\n    }\n\n    Promise.all(\n      selectedNotes.map(note => {\n        note = updateFunc(note)\n        return dataApi.updateNote(note.storage, note.key, note)\n      })\n    ).then(updatedNotes => {\n      updatedNotes.forEach(note => {\n        dispatch({\n          type: 'UPDATE_NOTE',\n          note\n        })\n      })\n    })\n\n    if (cleanSelection) {\n      this.selectNextNote()\n    }\n  }\n\n  pinToTop() {\n    this.updateSelectedNotes(note => {\n      note.isPinned = !note.isPinned\n      return note\n    })\n  }\n\n  restoreNote() {\n    this.updateSelectedNotes(note => {\n      note.isTrashed = false\n      return note\n    })\n  }\n\n  deleteNote() {\n    const { dispatch } = this.props\n    const { selectedNoteKeys } = this.state\n    const notes = this.notes.map(note => Object.assign({}, note))\n    const selectedNotes = findNotesByKeys(notes, selectedNoteKeys)\n    const firstNote = selectedNotes[0]\n    const { confirmDeletion } = this.props.config.ui\n\n    if (firstNote.isTrashed) {\n      if (!confirmDeleteNote(confirmDeletion, true)) return\n\n      Promise.all(\n        selectedNotes.map(note => {\n          return dataApi.deleteNote(note.storage, note.key)\n        })\n      )\n        .then(data => {\n          const dispatchHandler = () => {\n            data.forEach(item => {\n              dispatch({\n                type: 'DELETE_NOTE',\n                storageKey: item.storageKey,\n                noteKey: item.noteKey\n              })\n            })\n          }\n          ee.once('list:next', dispatchHandler)\n        })\n        .then(() => ee.emit('list:next'))\n        .catch(err => {\n          console.error('Cannot Delete note: ' + err)\n        })\n    } else {\n      if (!confirmDeleteNote(confirmDeletion, false)) return\n\n      Promise.all(\n        selectedNotes.map(note => {\n          note.isTrashed = true\n\n          return dataApi.updateNote(note.storage, note.key, note)\n        })\n      )\n        .then(newNotes => {\n          newNotes.forEach(newNote => {\n            dispatch({\n              type: 'UPDATE_NOTE',\n              note: newNote\n            })\n          })\n          AwsMobileAnalyticsConfig.recordDynamicCustomEvent('EDIT_NOTE')\n        })\n        .then(() => ee.emit('list:next'))\n        .catch(err => {\n          console.error('Notes could not go to trash: ' + err)\n        })\n    }\n    this.setState({ selectedNoteKeys: [] })\n  }\n\n  cloneNote() {\n    const { selectedNoteKeys } = this.state\n    const { dispatch, location } = this.props\n    const { storage, folder } = this.resolveTargetFolder()\n    const notes = this.notes.map(note => Object.assign({}, note))\n    const selectedNotes = findNotesByKeys(notes, selectedNoteKeys)\n    const firstNote = selectedNotes[0]\n    const eventName =\n      firstNote.type === 'MARKDOWN_NOTE' ? 'ADD_MARKDOWN' : 'ADD_SNIPPET'\n\n    AwsMobileAnalyticsConfig.recordDynamicCustomEvent(eventName)\n    AwsMobileAnalyticsConfig.recordDynamicCustomEvent('ADD_ALLNOTE')\n    dataApi\n      .createNote(storage.key, {\n        type: firstNote.type,\n        folder: folder.key,\n        title: firstNote.title + ' ' + i18n.__('copy'),\n        content: firstNote.content,\n        linesHighlighted: firstNote.linesHighlighted,\n        description: firstNote.description,\n        snippets: firstNote.snippets,\n        tags: firstNote.tags,\n        isStarred: firstNote.isStarred\n      })\n      .then(note => {\n        attachmentManagement.cloneAttachments(firstNote, note)\n        return note\n      })\n      .then(note => {\n        dispatch({\n          type: 'UPDATE_NOTE',\n          note: note\n        })\n\n        this.setState({\n          selectedNoteKeys: [note.key]\n        })\n\n        dispatch(\n          push({\n            pathname: location.pathname,\n            search: queryString.stringify({ key: note.key })\n          })\n        )\n      })\n  }\n\n  copyNoteLink(note) {\n    const noteLink = `[${note.title}](:note:${note.key})`\n    return copy(noteLink)\n  }\n\n  navigate(sender, pathname) {\n    const { dispatch } = this.props\n    dispatch(\n      push({\n        pathname,\n        search: queryString.stringify({\n          // key: noteKey\n        })\n      })\n    )\n  }\n\n  save(note) {\n    const { dispatch } = this.props\n    dataApi.updateNote(note.storage, note.key, note).then(note => {\n      dispatch({\n        type: 'UPDATE_NOTE',\n        note: note\n      })\n    })\n  }\n\n  publishMarkdown() {\n    if (this.pendingPublish) {\n      clearTimeout(this.pendingPublish)\n    }\n    this.pendingPublish = setTimeout(() => {\n      this.publishMarkdownNow()\n    }, 1000)\n  }\n\n  publishMarkdownNow() {\n    const { selectedNoteKeys } = this.state\n    const notes = this.notes.map(note => Object.assign({}, note))\n    const selectedNotes = findNotesByKeys(notes, selectedNoteKeys)\n    const firstNote = selectedNotes[0]\n    const config = ConfigManager.get()\n    const { address, token, authMethod, username, password } = config.blog\n    let authToken = ''\n    if (authMethod === 'USER') {\n      authToken = `Basic ${window.btoa(`${username}:${password}`)}`\n    } else {\n      authToken = `Bearer ${token}`\n    }\n    const contentToRender = firstNote.content.replace(\n      `# ${firstNote.title}`,\n      ''\n    )\n    const markdown = new Markdown()\n    const data = {\n      title: firstNote.title,\n      content: markdown.render(contentToRender),\n      status: 'publish'\n    }\n\n    let url = ''\n    let method = ''\n    if (firstNote.blog && firstNote.blog.blogId) {\n      url = `${address}${WP_POST_PATH}/${firstNote.blog.blogId}`\n      method = 'PUT'\n    } else {\n      url = `${address}${WP_POST_PATH}`\n      method = 'POST'\n    }\n    // eslint-disable-next-line no-undef\n    fetch(url, {\n      method: method,\n      body: JSON.stringify(data),\n      headers: {\n        Authorization: authToken,\n        'Content-Type': 'application/json'\n      }\n    })\n      .then(res => res.json())\n      .then(response => {\n        if (_.isNil(response.link) || _.isNil(response.id)) {\n          return Promise.reject()\n        }\n        firstNote.blog = {\n          blogLink: response.link,\n          blogId: response.id\n        }\n        this.save(firstNote)\n        this.confirmPublish(firstNote)\n      })\n      .catch(error => {\n        console.error(error)\n        this.confirmPublishError()\n      })\n  }\n\n  confirmPublishError() {\n    const { remote } = electron\n    const { dialog } = remote\n    const alertError = {\n      type: 'warning',\n      message: i18n.__('Publish Failed'),\n      detail: i18n.__('Check and update your blog setting and try again.'),\n      buttons: [i18n.__('Confirm')]\n    }\n    dialog.showMessageBox(remote.getCurrentWindow(), alertError)\n  }\n\n  confirmPublish(note) {\n    const buttonIndex = dialog.showMessageBox(remote.getCurrentWindow(), {\n      type: 'warning',\n      message: i18n.__('Publish Succeeded'),\n      detail: `${note.title} is published at ${note.blog.blogLink}`,\n      buttons: [i18n.__('Confirm'), i18n.__('Open Blog')]\n    })\n\n    if (buttonIndex === 1) {\n      this.openBlog(note)\n    }\n  }\n\n  openBlog(note) {\n    const { shell } = electron\n    shell.openExternal(note.blog.blogLink)\n  }\n\n  importFromFile() {\n    const options = {\n      filters: [{ name: 'Documents', extensions: ['md', 'txt'] }],\n      properties: ['openFile', 'multiSelections']\n    }\n\n    dialog.showOpenDialog(remote.getCurrentWindow(), options, filepaths => {\n      this.addNotesFromFiles(filepaths)\n    })\n  }\n\n  handleDrop(e) {\n    e.preventDefault()\n    const { location } = this.props\n    const filepaths = Array.from(e.dataTransfer.files).map(file => {\n      return file.path\n    })\n    if (!location.pathname.match(/\\/trashed/)) this.addNotesFromFiles(filepaths)\n  }\n\n  // Add notes to the current folder\n  addNotesFromFiles(filepaths) {\n    const { dispatch, location } = this.props\n    const { storage, folder } = this.resolveTargetFolder()\n\n    if (filepaths === undefined) return\n    filepaths.forEach(filepath => {\n      fs.readFile(filepath, (err, data) => {\n        if (err) throw Error('File reading error: ', err)\n\n        fs.stat(filepath, (err, { mtime, birthtime }) => {\n          if (err) throw Error('File stat reading error: ', err)\n\n          const content = data.toString()\n          const newNote = {\n            content: content,\n            folder: folder.key,\n            title: path.basename(filepath, path.extname(filepath)),\n            type: 'MARKDOWN_NOTE',\n            createdAt: birthtime,\n            updatedAt: mtime\n          }\n          dataApi.createNote(storage.key, newNote).then(note => {\n            attachmentManagement\n              .importAttachments(note.content, filepath, storage.key, note.key)\n              .then(newcontent => {\n                note.content = newcontent\n\n                dataApi.updateNote(storage.key, note.key, note)\n\n                dispatch({\n                  type: 'UPDATE_NOTE',\n                  note: note\n                })\n                dispatch(\n                  push({\n                    pathname: location.pathname,\n                    search: queryString.stringify({ key: getNoteKey(note) })\n                  })\n                )\n              })\n          })\n        })\n      })\n    })\n  }\n\n  getTargetIndex() {\n    const { location } = this.props\n    const key = queryString.parse(location.search).key\n    const targetIndex = _.findIndex(this.notes, note => {\n      return getNoteKey(note) === key\n    })\n    return targetIndex\n  }\n\n  resolveTargetFolder() {\n    const {\n      data,\n      match: { params }\n    } = this.props\n    let storage = data.storageMap.get(params.storageKey)\n\n    // Find first storage\n    if (storage == null) {\n      for (const kv of data.storageMap) {\n        storage = kv[1]\n        break\n      }\n    }\n\n    if (storage == null) this.showMessageBox('No storage for importing note(s)')\n    const folder =\n      _.find(storage.folders, { key: params.folderKey }) || storage.folders[0]\n    if (folder == null) this.showMessageBox('No folder for importing note(s)')\n\n    return {\n      storage,\n      folder\n    }\n  }\n\n  showMessageBox(message) {\n    dialog.showMessageBox(remote.getCurrentWindow(), {\n      type: 'warning',\n      message: message,\n      buttons: [i18n.__('OK')]\n    })\n  }\n\n  getNoteStorage(note) {\n    // note.storage = storage key\n    return this.props.data.storageMap.toJS()[note.storage]\n  }\n\n  getNoteFolder(note) {\n    // note.folder = folder key\n    const storage = this.getNoteStorage(note)\n    return storage\n      ? _.find(storage.folders, ({ key }) => key === note.folder)\n      : []\n  }\n\n  getViewType() {\n    const { pathname } = this.props.location\n    const folder = /\\/folders\\/[a-zA-Z0-9]+/.test(pathname)\n    const storage = /\\/storages\\/[a-zA-Z0-9]+/.test(pathname) && !folder\n    const allNotes = pathname === '/home'\n    if (allNotes) return 'ALL'\n    if (folder) return 'FOLDER'\n    if (storage) return 'STORAGE'\n  }\n\n  render() {\n    const {\n      location,\n      config,\n      match: {\n        params: { folderKey }\n      }\n    } = this.props\n    let { notes } = this.props\n    const { selectedNoteKeys } = this.state\n    const sortBy = _.get(config, [folderKey, 'sortBy'], config.sortBy.default)\n    const sortDir = config.listDirection\n    const sortFunc =\n      sortBy === 'CREATED_AT'\n        ? sortByCreatedAt\n        : sortBy === 'ALPHABETICAL'\n        ? sortByAlphabetical\n        : sortByUpdatedAt\n    const sortedNotes = location.pathname.match(/\\/starred|\\/trash/)\n      ? this.getNotes().sort(sortFunc)\n      : this.sortByPin(this.getNotes().sort(sortFunc))\n    this.notes = notes = sortedNotes.filter(note => {\n      if (\n        // has matching storage\n        !!this.getNoteStorage(note) &&\n        // this is for the trash box\n        (note.isTrashed !== true || location.pathname === '/trashed')\n      ) {\n        return true\n      }\n    })\n    if (sortDir === 'DESCENDING') this.notes.reverse()\n\n    moment.updateLocale('en', {\n      relativeTime: {\n        future: 'in %s',\n        past: '%s ago',\n        s: '%ds',\n        ss: '%ss',\n        m: '1m',\n        mm: '%dm',\n        h: 'an hour',\n        hh: '%dh',\n        d: '1d',\n        dd: '%dd',\n        M: '1M',\n        MM: '%dM',\n        y: '1Y',\n        yy: '%dY'\n      }\n    })\n\n    const viewType = this.getViewType()\n\n    const autoSelectFirst =\n      notes.length === 1 ||\n      selectedNoteKeys.length === 0 ||\n      notes.every(note => !selectedNoteKeys.includes(note.key))\n\n    const noteList = notes.map((note, index) => {\n      if (note == null) {\n        return null\n      }\n\n      const isDefault = config.listStyle === 'DEFAULT'\n      const uniqueKey = getNoteKey(note)\n\n      const isActive =\n        selectedNoteKeys.includes(uniqueKey) ||\n        notes.length === 1 ||\n        (autoSelectFirst && index === 0)\n      const dateDisplay = moment(\n        sortBy === 'CREATED_AT' ? note.createdAt : note.updatedAt\n      ).fromNow('D')\n\n      const storage = this.getNoteStorage(note)\n\n      if (isDefault) {\n        return (\n          <NoteItem\n            isActive={isActive}\n            note={note}\n            dateDisplay={dateDisplay}\n            key={uniqueKey}\n            handleNoteContextMenu={this.handleNoteContextMenu.bind(this)}\n            handleNoteClick={this.handleNoteClick.bind(this)}\n            handleDragStart={this.handleDragStart.bind(this)}\n            pathname={location.pathname}\n            folderName={this.getNoteFolder(note).name}\n            storageName={storage.name}\n            viewType={viewType}\n            showTagsAlphabetically={config.ui.showTagsAlphabetically}\n            coloredTags={config.coloredTags}\n          />\n        )\n      }\n\n      return (\n        <NoteItemSimple\n          isActive={isActive}\n          note={note}\n          key={uniqueKey}\n          handleNoteContextMenu={this.handleNoteContextMenu.bind(this)}\n          handleNoteClick={this.handleNoteClick.bind(this)}\n          handleDragStart={this.handleDragStart.bind(this)}\n          pathname={location.pathname}\n          folderName={this.getNoteFolder(note).name}\n          storageName={storage.name}\n          viewType={viewType}\n        />\n      )\n    })\n\n    return (\n      <div\n        className='NoteList'\n        styleName='root'\n        style={this.props.style}\n        onDrop={e => this.handleDrop(e)}\n      >\n        <div styleName='control'>\n          <div styleName='control-sortBy'>\n            <i className='fa fa-angle-down' />\n            <select\n              styleName='control-sortBy-select'\n              title={i18n.__('Select filter mode')}\n              value={sortBy}\n              onChange={e => this.handleSortByChange(e)}\n            >\n              <option title='Sort by update time' value='UPDATED_AT'>\n                {i18n.__('Updated')}\n              </option>\n              <option title='Sort by create time' value='CREATED_AT'>\n                {i18n.__('Created')}\n              </option>\n              <option title='Sort alphabetically' value='ALPHABETICAL'>\n                {i18n.__('Alphabetically')}\n              </option>\n            </select>\n          </div>\n          <div styleName='control-button-area'>\n            <button\n              title={i18n.__('Ascending Order')}\n              styleName={\n                config.listDirection === 'ASCENDING'\n                  ? 'control-button--active'\n                  : 'control-button'\n              }\n              onClick={e => this.handleListDirectionButtonClick(e, 'ASCENDING')}\n            >\n              <img src='../resources/icon/icon-up.svg' />\n            </button>\n            <button\n              title={i18n.__('Descending Order')}\n              styleName={\n                config.listDirection === 'DESCENDING'\n                  ? 'control-button--active'\n                  : 'control-button'\n              }\n              onClick={e =>\n                this.handleListDirectionButtonClick(e, 'DESCENDING')\n              }\n            >\n              <img src='../resources/icon/icon-down.svg' />\n            </button>\n            <button\n              title={i18n.__('Default View')}\n              styleName={\n                config.listStyle === 'DEFAULT'\n                  ? 'control-button--active'\n                  : 'control-button'\n              }\n              onClick={e => this.handleListStyleButtonClick(e, 'DEFAULT')}\n            >\n              <img src='../resources/icon/icon-column.svg' />\n            </button>\n            <button\n              title={i18n.__('Compressed View')}\n              styleName={\n                config.listStyle === 'SMALL'\n                  ? 'control-button--active'\n                  : 'control-button'\n              }\n              onClick={e => this.handleListStyleButtonClick(e, 'SMALL')}\n            >\n              <img src='../resources/icon/icon-column-list.svg' />\n            </button>\n          </div>\n        </div>\n        <div\n          styleName='list'\n          ref='list'\n          tabIndex='-1'\n          onKeyDown={e => this.handleNoteListKeyDown(e)}\n          onKeyUp={this.handleNoteListKeyUp}\n          onBlur={this.handleNoteListBlur}\n        >\n          {noteList}\n        </div>\n      </div>\n    )\n  }\n}\nNoteList.contextTypes = {\n  router: PropTypes.shape([])\n}\n\nNoteList.propTypes = {\n  dispatch: PropTypes.func,\n  repositories: PropTypes.array,\n  style: PropTypes.shape({\n    width: PropTypes.number\n  })\n}\n\nexport default CSSModules(NoteList, styles)\n",
    "browser/main/lib/dataApi/deleteFolder.js": "const _ = require('lodash')\nconst path = require('path')\nconst resolveStorageData = require('./resolveStorageData')\nconst resolveStorageNotes = require('./resolveStorageNotes')\nconst CSON = require('@rokt33r/season')\nconst { findStorage } = require('browser/lib/findStorage')\nconst deleteSingleNote = require('./deleteNote')\n\n/**\n * @param {String} storageKey\n * @param {String} folderKey\n *\n * @return {Object}\n * ```\n * {\n *   storage: Object,\n *   folderKey: String\n * }\n * ```\n */\nfunction deleteFolder(storageKey, folderKey) {\n  let targetStorage\n  try {\n    targetStorage = findStorage(storageKey)\n  } catch (e) {\n    return Promise.reject(e)\n  }\n\n  return resolveStorageData(targetStorage)\n    .then(function assignNotes(storage) {\n      return resolveStorageNotes(storage).then(notes => {\n        return {\n          storage,\n          notes\n        }\n      })\n    })\n    .then(function deleteFolderAndNotes(data) {\n      const { storage, notes } = data\n      storage.folders = storage.folders.filter(function excludeTargetFolder(\n        folder\n      ) {\n        return folder.key !== folderKey\n      })\n\n      const targetNotes = notes.filter(function filterTargetNotes(note) {\n        return note.folder === folderKey\n      })\n\n      const deleteAllNotes = targetNotes.map(function deleteNote(note) {\n        return deleteSingleNote(storageKey, note.key)\n      })\n      return Promise.all(deleteAllNotes).then(() => storage)\n    })\n    .then(function(storage) {\n      CSON.writeFileSync(\n        path.join(storage.path, 'boostnote.json'),\n        _.pick(storage, ['folders', 'version'])\n      )\n\n      return {\n        storage,\n        folderKey\n      }\n    })\n}\n\nmodule.exports = deleteFolder\n",
    "browser/main/lib/dataApi/exportFolder.js": "import { findStorage } from 'browser/lib/findStorage'\nimport resolveStorageData from './resolveStorageData'\nimport resolveStorageNotes from './resolveStorageNotes'\nimport getFilename from './getFilename'\nimport exportNote from './exportNote'\nimport getContentFormatter from './getContentFormatter'\n\n/**\n * @param {String} storageKey\n * @param {String} folderKey\n * @param {String} fileType\n * @param {String} exportDir\n * @param {Object} config\n *\n * @return {Object}\n * ```\n * {\n *   storage: Object,\n *   folderKey: String,\n *   fileType: String,\n *   exportDir: String\n * }\n * ```\n */\n\nfunction exportFolder(storageKey, folderKey, fileType, exportDir, config) {\n  let targetStorage\n  try {\n    targetStorage = findStorage(storageKey)\n  } catch (e) {\n    return Promise.reject(e)\n  }\n\n  const deduplicator = {}\n\n  return resolveStorageData(targetStorage)\n    .then(storage => {\n      return resolveStorageNotes(storage).then(notes => ({\n        storage,\n        notes: notes.filter(\n          note =>\n            note.folder === folderKey &&\n            !note.isTrashed &&\n            note.type === 'MARKDOWN_NOTE'\n        )\n      }))\n    })\n    .then(({ storage, notes }) => {\n      const contentFormatter = getContentFormatter(storage, fileType, config)\n\n      return Promise.all(\n        notes.map(note => {\n          const targetPath = getFilename(\n            note,\n            fileType,\n            exportDir,\n            deduplicator\n          )\n\n          return exportNote(storage.key, note, targetPath, contentFormatter)\n        })\n      ).then(() => ({\n        storage,\n        folderKey,\n        fileType,\n        exportDir\n      }))\n    })\n}\n\nmodule.exports = exportFolder\n",
    "browser/main/lib/dataApi/exportStorage.js": "import { findStorage } from 'browser/lib/findStorage'\nimport resolveStorageData from './resolveStorageData'\nimport resolveStorageNotes from './resolveStorageNotes'\nimport filenamify from 'filenamify'\nimport path from 'path'\nimport fs from 'fs'\nimport exportNote from './exportNote'\nimport getContentFormatter from './getContentFormatter'\nimport getFilename from './getFilename'\n\n/**\n * @param {String} storageKey\n * @param {String} fileType\n * @param {String} exportDir\n * @param {Object} config\n *\n * @return {Object}\n * ```\n * {\n *   storage: Object,\n *   fileType: String,\n *   exportDir: String\n * }\n * ```\n */\n\nfunction exportStorage(storageKey, fileType, exportDir, config) {\n  let targetStorage\n  try {\n    targetStorage = findStorage(storageKey)\n  } catch (e) {\n    return Promise.reject(e)\n  }\n\n  return resolveStorageData(targetStorage)\n    .then(storage => {\n      return resolveStorageNotes(storage).then(notes => ({\n        storage,\n        notes: notes.filter(\n          note => !note.isTrashed && note.type === 'MARKDOWN_NOTE'\n        )\n      }))\n    })\n    .then(({ storage, notes }) => {\n      const contentFormatter = getContentFormatter(storage, fileType, config)\n\n      const folderNamesMapping = {}\n      const deduplicators = {}\n\n      storage.folders.forEach(folder => {\n        const folderExportedDir = path.join(\n          exportDir,\n          filenamify(folder.name, { replacement: '_' })\n        )\n\n        folderNamesMapping[folder.key] = folderExportedDir\n\n        // make sure directory exists\n        try {\n          fs.mkdirSync(folderExportedDir)\n        } catch (e) {}\n\n        deduplicators[folder.key] = {}\n      })\n\n      return Promise.all(\n        notes.map(note => {\n          const targetPath = getFilename(\n            note,\n            fileType,\n            folderNamesMapping[note.folder],\n            deduplicators[note.folder]\n          )\n\n          return exportNote(storage.key, note, targetPath, contentFormatter)\n        })\n      ).then(() => ({\n        storage,\n        fileType,\n        exportDir\n      }))\n    })\n}\n\nmodule.exports = exportStorage\n",
    "browser/main/modals/PreferencesModal/InfoTab.js": "import React from 'react'\nimport CSSModules from 'browser/lib/CSSModules'\nimport styles from './InfoTab.styl'\nimport ConfigManager from 'browser/main/lib/ConfigManager'\nimport { store } from 'browser/main/store'\nimport AwsMobileAnalyticsConfig from 'browser/main/lib/AwsMobileAnalyticsConfig'\nimport _ from 'lodash'\nimport i18n from 'browser/lib/i18n'\n\nconst electron = require('electron')\nconst { shell, remote } = electron\nconst appVersion = remote.app.getVersion()\n\nclass InfoTab extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      config: this.props.config,\n      subscriptionFormStatus: 'idle',\n      subscriptionFormErrorMessage: null,\n      subscriptionFormEmail: ''\n    }\n  }\n\n  componentDidMount() {\n    const { autoUpdateEnabled, amaEnabled } = ConfigManager.get()\n\n    this.setState({ config: { autoUpdateEnabled, amaEnabled } })\n  }\n\n  handleLinkClick(e) {\n    shell.openExternal(e.currentTarget.href)\n    e.preventDefault()\n  }\n\n  handleConfigChange(e) {\n    const newConfig = {\n      amaEnabled: this.refs.amaEnabled.checked,\n      autoUpdateEnabled: this.refs.autoUpdateEnabled.checked\n    }\n\n    this.setState({ config: newConfig })\n    return newConfig\n  }\n\n  handleSubscriptionFormSubmit(e) {\n    e.preventDefault()\n    this.setState({\n      subscriptionFormStatus: 'sending',\n      subscriptionFormErrorMessage: null\n    })\n\n    fetch(\n      'https://boostmails.boostio.co/api/public/lists/5f434dccd05f3160b41c0d49/subscriptions',\n      {\n        headers: {\n          Accept: 'application/json',\n          'Content-Type': 'application/json'\n        },\n        method: 'POST',\n        body: JSON.stringify({ email: this.state.subscriptionFormEmail })\n      }\n    )\n      .then(response => {\n        if (response.status >= 400) {\n          return response.text().then(text => {\n            throw new Error(text)\n          })\n        }\n        this.setState({\n          subscriptionFormStatus: 'done'\n        })\n      })\n      .catch(error => {\n        this.setState({\n          subscriptionFormStatus: 'idle',\n          subscriptionFormErrorMessage: error.message\n        })\n      })\n  }\n\n  handleSubscriptionFormEmailChange(e) {\n    this.setState({\n      subscriptionFormEmail: e.target.value\n    })\n  }\n\n  handleSaveButtonClick(e) {\n    const newConfig = this.state.config\n\n    if (!newConfig.amaEnabled) {\n      AwsMobileAnalyticsConfig.recordDynamicCustomEvent('DISABLE_AMA')\n      this.setState({\n        amaMessage: i18n.__('We hope we will gain your trust')\n      })\n    } else {\n      this.setState({\n        amaMessage: i18n.__(\"Thank's for trusting us\")\n      })\n    }\n\n    _.debounce(() => {\n      this.setState({\n        amaMessage: ''\n      })\n    }, 3000)()\n\n    ConfigManager.set(newConfig)\n\n    store.dispatch({\n      type: 'SET_CONFIG',\n      config: newConfig\n    })\n  }\n\n  infoMessage() {\n    const { amaMessage } = this.state\n    return amaMessage ? <p styleName='policy-confirm'>{amaMessage}</p> : null\n  }\n\n  handleAutoUpdateChange() {\n    const { autoUpdateEnabled } = this.handleConfigChange()\n\n    ConfigManager.set({ autoUpdateEnabled })\n  }\n\n  render() {\n    return (\n      <div styleName='root'>\n        <div styleName='group-header'>{i18n.__('Community')}</div>\n        <div styleName='top'>\n          <ul styleName='list'>\n            <li>\n              <a\n                href='https://issuehunt.io/repos/53266139'\n                onClick={e => this.handleLinkClick(e)}\n              >\n                {i18n.__('Bounty on IssueHunt')}\n              </a>\n            </li>\n            <li>\n              <a\n                href='https://boostnote.io/#subscribe'\n                onClick={e => this.handleLinkClick(e)}\n              >\n                {i18n.__('Subscribe to Newsletter')}\n              </a>\n            </li>\n            <li>\n              <a\n                href='https://github.com/BoostIO/Boostnote/issues'\n                onClick={e => this.handleLinkClick(e)}\n              >\n                {i18n.__('GitHub')}\n              </a>\n            </li>\n            <li>\n              <a\n                href='https://medium.com/boostnote'\n                onClick={e => this.handleLinkClick(e)}\n              >\n                {i18n.__('Blog')}\n              </a>\n            </li>\n            <li>\n              <a\n                href='https://www.facebook.com/groups/boostnote'\n                onClick={e => this.handleLinkClick(e)}\n              >\n                {i18n.__('Facebook Group')}\n              </a>\n            </li>\n            <li>\n              <a\n                href='https://twitter.com/boostnoteapp'\n                onClick={e => this.handleLinkClick(e)}\n              >\n                {i18n.__('Twitter')}\n              </a>\n            </li>\n          </ul>\n        </div>\n\n        <hr />\n\n        <div styleName='group-header--sub'>Subscribe Update Notes</div>\n        {this.state.subscriptionFormStatus === 'done' ? (\n          <div>\n            <blockquote color={{ color: 'green' }}>\n              Thanks for the subscription!\n            </blockquote>\n          </div>\n        ) : (\n          <div>\n            {this.state.subscriptionFormErrorMessage != null && (\n              <blockquote style={{ color: 'red' }}>\n                {this.state.subscriptionFormErrorMessage}\n              </blockquote>\n            )}\n            <form onSubmit={e => this.handleSubscriptionFormSubmit(e)}>\n              <input\n                styleName='subscription-email-input'\n                placeholder='E-mail'\n                type='email'\n                onChange={e => this.handleSubscriptionFormEmailChange(e)}\n                disabled={this.state.subscriptionFormStatus === 'sending'}\n              />\n              <button\n                styleName='subscription-submit-button'\n                type='submit'\n                disabled={this.state.subscriptionFormStatus === 'sending'}\n              >\n                Subscribe\n              </button>\n            </form>\n          </div>\n        )}\n        <hr />\n\n        <div styleName='group-header--sub'>{i18n.__('About')}</div>\n\n        <div styleName='top'>\n          <div styleName='icon-space'>\n            <img\n              styleName='icon'\n              src='../resources/app.png'\n              width='92'\n              height='92'\n            />\n            <div styleName='icon-right'>\n              <div styleName='appId'>Boostnote Legacy {appVersion}</div>\n              <div styleName='description'>\n                {i18n.__(\n                  'An open source note-taking app made for programmers just like you.'\n                )}\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <ul styleName='list'>\n          <li>\n            <a\n              href='https://boostnote.io'\n              onClick={e => this.handleLinkClick(e)}\n            >\n              {i18n.__('Website')}\n            </a>\n          </li>\n          <li>\n            <a\n              href='https://github.com/BoostIO/Boostnote/blob/master/docs/build.md'\n              onClick={e => this.handleLinkClick(e)}\n            >\n              {i18n.__('Development')}\n            </a>\n            {i18n.__(' : Development configurations for Boostnote.')}\n          </li>\n          <li styleName='cc'>{i18n.__('Copyright (C) 2017 - 2020 BoostIO')}</li>\n          <li styleName='cc'>{i18n.__('License: GPL v3')}</li>\n        </ul>\n\n        <div>\n          <label>\n            <input\n              type='checkbox'\n              ref='autoUpdateEnabled'\n              onChange={() => this.handleAutoUpdateChange()}\n              checked={this.state.config.autoUpdateEnabled}\n            />\n            {i18n.__('Enable Auto Update')}\n          </label>\n        </div>\n\n        <hr styleName='separate-line' />\n\n        <div styleName='group-header2--sub'>{i18n.__('Analytics')}</div>\n        <div>\n          {i18n.__(\n            'Boostnote collects anonymous data for the sole purpose of improving the application, and strictly does not collect any personal information such the contents of your notes.'\n          )}\n        </div>\n        <div>\n          {i18n.__('You can see how it works on ')}\n          <a\n            href='https://github.com/BoostIO/Boostnote'\n            onClick={e => this.handleLinkClick(e)}\n          >\n            GitHub\n          </a>\n          .\n        </div>\n        <br />\n        <div>{i18n.__('You can choose to enable or disable this option.')}</div>\n        <input\n          onChange={e => this.handleConfigChange(e)}\n          checked={this.state.config.amaEnabled}\n          ref='amaEnabled'\n          type='checkbox'\n        />\n        {i18n.__('Enable analytics to help improve Boostnote')}\n        <br />\n        <button\n          styleName='policy-submit'\n          onClick={e => this.handleSaveButtonClick(e)}\n        >\n          {i18n.__('Save')}\n        </button>\n        <br />\n        {this.infoMessage()}\n      </div>\n    )\n  }\n}\n\nInfoTab.propTypes = {}\n\nexport default CSSModules(InfoTab, styles)\n"
  }
}